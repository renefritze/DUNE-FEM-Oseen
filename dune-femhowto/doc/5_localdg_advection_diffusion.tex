\newcommand{\velo}{\mathbf{a}}
\newcommand{\timedomain}{\mathbf{T}}
This chapter is to introduce the \texttt{Pass} concept in \Fem\ and to explain
the steps that are necessary in order to implement a Local Discontinuous
Galerkin solver using the \texttt{LocalDGPass} class. In the end it is
shown how the solution can be analysed visually with help of the
\texttt{DataWriter} class.

\section{Advection-Diffusion Equation}

The example problem is a scalar advection-diffusion equation on $\Omega =
[0,1]^3$
\begin{equation}
  \label{eq:advectdiff}
  \begin{aligned}
    \partial_{t} u + \nabla \cdot (\velo u) - \varepsilon \Delta u 
    {}          &=  0            & \mbox{in}&\ \Omega \times \timedomain \\
    u           &=  g_{D}        & \mbox{on}&\ \partial\Omega \times \timedomain \\
    u(0,\cdot)  &=  u_{0}        & \mbox{in}&\ \Omega \times \{0\},
  \end{aligned}
\end{equation}
with $u$ living in a function space $V$ and $\velo:=(0.8,0.8,0)^t$. An exact
solution is specified by
% definitions for equation
\newcommand{\ccos}{\tilde{c}}
\newcommand{\csin}{\hat{c}}
\begin{equation}
  u(x,t) = \sum_{i=1}^{2} \exp(-\varepsilon t \pi^2 |{c^{i}|})
  \left(\prod_{j=1}^{3} \ccos_{j}^{i}\cos(c_{j}^{i}\pi(x_{j}-\velo_{j} t)) + 
  {}              \csin_{j}^{i}\sin(c_{j}^{i}\pi(x_{j}-\velo_{j} t)) \right),
  \label{eq:exactsolution}
\end{equation}
where
\begin{align}
  c^{1}    &:=(2,1,1.3)^{t}      & c^{2}&:=(0.7,0.5,0.1) \\
  \csin^{1}&:=(0.8,0.4,-0.4)^{t} & \csin^{2} &:= (0.2,0.1,0.2) \\
  \ccos^{1}&:=(0.6,1.2,0.1)^{t}  & \ccos^{2} &:= (0.9,0.3,-0.3).
  \label{eq:constants}
\end{align}
Therefore the initial and boundary functions are defined by
\begin{align}
  u_{0}(x) &= u(x,0) & g_{D}(x,t) = u|_{\partial\Omega}(x,t).
  \label{eq:initialboundary}
\end{align}
Note that the problem is also implemented for $2$ dimension by projecting
everything onto the first two coordinates. 
The discretization of the problem is done as described in
\cite[ch.4]{wissrechnen}.

The LDG Ansatz uses auxiliary functions $u_{0}, u_{2} \in V$ and $u_{1} \in V^{3}$
%
\begin{equation}
  \label{eq:ldgansatz}
  \begin{aligned}
    u_{0} &= u \\
    u_{1} &= - \sqrt{\varepsilon} \nabla u_{0}  \\
    u_{2} &= - \nabla \cdot (\velo u_{0} + \sqrt{\varepsilon} u_{1})  \\
    \partial_{t} u &= u_{2}.
  \end{aligned}
\end{equation}
%
Now $u_{0}$ and $u_{1}$ can be projected onto the Discontinous Galerkin
function spaces $V_{h} := \{\varphi_{1},\dots \varphi_{n}\}$ resp.
$[V_{h}]^{3}=\{\psi_{1},\dots\ \psi_{n^{3}}\}$ with discrete domain in space. The equations
in (\ref{eq:ldgansatz}) can then be rewritten as a variational formulation 
%
\newcommand{\ftilde}{\tilde{f}}
\begin{align}
  \label{eq:variational1}
  \int_{T}^{} u_{1} \psi &= \int_{T}^{}\underbrace{\sqrt{\varepsilon}u_{0}}_{f_{1}(u_{0})} \nabla \cdot \psi
  {}                       - \int_{\partial T}^{}\underbrace{\sqrt{\varepsilon}u_{0}}_{\ftilde_{1}(u_{0})} \psi \cdot n 
  {}                                   && \forall{\psi}\in [V_{h}]^{3}\\
  \label{eq:variational2}
  \int_{T}^{} u_{2} \varphi &= \int_{T}^{} \underbrace{\left(\velo u_{0} + \sqrt{\varepsilon} u_{1}\right)}_{
  {}                                                      f_{2}(u_{0},u_{1})} \cdot \nabla \varphi
  {}                         - \int_{\partial T}^{} \underbrace{\left(\velo u_{0} + \sqrt{\varepsilon} u_{1}\right)}_{
  {}                                                      \ftilde_{2}(u_{0},u_{1})} \varphi \cdot n
  {}                                         && \forall{\varphi} \in V_{h}
\end{align}
for every grid cell $T$. 
%
To complete the discretization in the space domain, the numerical fluxes
between the cell interfaces must be defined to approximate $\ftilde_{1}$ and
$\ftilde_{2}$ defined in (\ref{eq:variational1}) and (\ref{eq:variational2}).
In this example we choose
%
\begin{align}
  \label{eq:flux1}
  \ftilde_{1,h}(u_{0}) &= 
  \left\{
  \begin{array}{cl}
    \sqrt{\varepsilon} g_{D}(x)  & \mbox{on}\ \partial\Omega \\
    \sqrt{\varepsilon} \{u_{0}\} & \mbox{else}
  \end{array}
  \right.
\\
  \label{eq:flux2}
  \ftilde_{2,h}(u_{0},u_{1}) &=
  \left\{
  \begin{array}[]{cl}
    \velo\, g_{D}(x) + \sqrt{\varepsilon}u_{1}(x^{-}) & \mbox{on}\ \partial\Omega \\
    w(\velo, u_{0})  + \sqrt{\varepsilon}\{u_{1}\} & \mbox{else}
  \end{array}
  \right.
\end{align}
%
where
%
\begin{equation}
  \{u\} := \frac{1}{2}(u(x^{+}) + u(x^{-})) \quad\mbox{and}\quad
  w(\velo, u_{0}) := \left\{
  \begin{array}[]{cl}
    \velo u_{0}(x^{+}) & \mbox{if}\ \velo \cdot n \leq 0 \\
    \velo u_{0}(x^{-}) & \mbox{if}\ \velo \cdot n > 0
  \end{array}
  \right.
  \label{eq:meanupwind}
\end{equation}
%
define a mean respectively an upwind function over the cell interfaces.
%
Now an operator $L : V_{h} \to V_{h}$ can be defined as a concatenation
$L:=\Pi \circ L_{2}\circ L_{1}$ of the two operators 
%
\begin{equation}
  \label{eq:passes}
  \begin{aligned}
    L_{1}:& V_{h} \to V_{h} \times V_{h}^{3} && (u_{0}) \mapsto (u_{0}, u_{1}) \\
    L_{2}:& V_{h} \times V_{h}^{3} \to V_{h} \times V_{h}^{3} \times V_{h} && (u_{0}, u_{1}) \mapsto (u_{0}, u_{1}, u_{2})
  \end{aligned}
\end{equation}
%
and the projection operator $\Pi$ that projects to the last component. This allows to
shorten the problem formulation to
%
\begin{equation}
  \partial_{t} u + L[u] = 0.
  \label{eq:advectdiffshort}
\end{equation}
%
This is an ODE in the time domain and can be solved with standard ODE solvers
requiring evaluations of the discrete operator $L$ in each time step. The
so-called ``methods of lines'' is further examined in
\cite[ch.4.3]{wissrechnen}.  
%
\section{Implementation overview}\label{se:overview}

The source code of the implmentation described in this section is located in
the directory \lstinline!dune-femhowto/src\_localdg!. It consists of $7$ source
files:
%
\begin{itemize}
  \item \lstinline!problem.hh! contains the class \lstinline!U0! which defines
    the exact solution $u$ as defined in (\ref{eq:exactsolution}) and $g_D, u_0$
    as defined in (\ref{eq:initialboundary}). Those can be called through the
    following methods:
      \lstinputlisting[numbers=left,numberstyle=\tiny,numbersep=5pt,linerange={94-94,111-111}]{../src_localdg/problem.hh}
    
  \item \lstinline!models.hh! contains the class
    \lstinline!AdvectionDiffusionModel! that describes the model data given in
    equation (\ref{eq:ldgansatz}) and the class \lstinline!UpwindFlux! which is
    just a helper class for the upwind flux given in (\ref{eq:meanupwind}).

  \item \lstinline!discretemodels.hh! contains two classes
    \lstinline!AdvDiffDModel1! and \lstinline!AdvDiffDModel2! that describe the
    two passes of the LDG implementation, i.e. the terms and fluxes given by
    (\ref{eq:variational1}--\ref{eq:flux2}). For further details to these classes
    see section \ref{se:localdg}.

  \item \lstinline!advectdiff.hh! provides the LDG Operator
    \lstinline!DGAdvectionDiffusionOperator! that is constructed out of the
    models given in \lstinline!discretemodels.hh!. For further details, refer
    to section \ref{se:localdg}.

  \item \lstinline!dgtest.cc! is the source file for the main program and is
    explained in the next section.

  \item \lstinline!datadisp.cc! and \lstinline!stuff.cc! are functions with helper class
    for pretty printing of EOC Data respectively data visualisation. Further
    details on this topic can be found in section \ref{se:outputvisualisation}.
%
\end{itemize}

\section{Main Loop} \label{se:mainloop}
%
The major typedefs for problem and model definitions are included via the
\lstinline!models.hh! header file. If the program shall run with a different
ODE solver e.g., the definitions that can be seen in the header files excerpt
in listing \ref{lst:modelshh} need to be adapted.
%
\begin{lst}[End of ../src\_localdg/models.hh] \label{lst:modelshh}\mbox{}
  \lstinputlisting[numbers=left,numberstyle=\tiny,numbersep=5pt,linerange={325-348}]{../src_localdg/models.hh}
\end{lst}
%
The main loop can be found in the file \lstinline!dgtest.cc!. An explanation
of the most important lines in this file, follows after listing
\ref{lst:dgtestcc}.
%
\begin{lst}[../src\_localdg/dgtest.cc] \label{lst:dgtestcc}\mbox{}
  \lstinputlisting[numbers=left,numberstyle=\tiny,numbersep=5pt]{../src_localdg/dgtest.cc}
\end{lst}
%
In lines \ref{dg:param0}-\ref{dg:param1} runtime options specified in a
parameter file are read in with help of the \lstinline!Dune::Parameter! class.
The default name for the parameter file is ``parameter'' (as defined in line
\ref{dg:paramfile}) and can be changed through the command line.

Lines \ref{dg:cfl0}-\ref{dg:cfl1} set the CFL constant that is needed to
preserve strong stability of the ODE solver. This constant can also be
specified explicitly in the parameterfile. It is known by the TimeProvider
\lstinline!tp! that in turn is given together with the discrete operator for
the space domain \lstinline!dg!  to the ODE solver in lines \ref{dg:dgop} and
\ref{dg:timeprovider}. Each time the ODE solver calls one of its methods
\lstinline!initialize! or \lstinline!solve! (see lines \ref{dg:odeinit},
\ref{dg:odesolve}), it evaluates the operator \lstinline!dg! and afterwards
asks the operator for a new time step estimate by calling its method
\lstinline!provideTimeStepEstimate!. This estimate multiplied by the CFL
constant then turns out to be the next timestep length. Note that in lines
\ref{dg:maxtimestep1} and \ref{dg:maxtimestep2} the maximum for this timestep
length is bounded by the value in \lstinline!maxTimeStep!, which is controlled
via the parameterfile.

For visualisation of the found solution the program writes the time snapshots
to the harddisk. This snapshot data can then be postprocessed by programs like
GRAPE or Paraview.  The user hast the ability to change the output directory
for the snapshots, the interval at which the snapshots should be generated and
the output format in the parameterfile. The options are all handled by an
instance of the \Fem\ class \lstinline!DataWriter! that is created in lines
\ref{dg:datawriterdef0}-\ref{dg:datawriterdef1} and requested to write
snapshots on the harddisk in lines \ref{dg:datawrite1} and \ref{dg:datawrite2}. 

\section{Setting up an LDGPass} \label{se:localdg}

This section is to shed light on the construction of the operator
\lstinline!dg! that obviously is the heart of this LDG solver.

In order to set up the operator $L$ as it is defined in (\ref{eq:passes})
the \Fem\ Pass concept is used. 

The passes $L_{1}$ and $L_{2}$ are implemented as \texttt{LocalDGPass}
instances. A \texttt{LocalDGPass} solves an equation of the form
%
\begin{align} v + \text{div}(f(x,u)) + A(x,u)\nabla u &= S(x,u) &&\mbox{in}\
  \Omega.  \label{eq:LocalDGPass} \end{align}
%
with the argument $u$ and the computed solution $v$. Both required passes (see
(\ref{eq:ldgansatz})) are in this form. A look at the weak formulation of
equation (\ref{eq:LocalDGPass}) reveals what methods a model which is passed to
the constructor of a \texttt{LocalDGPass} instance needs to specify:
%
\begin{equation} \label{eq:fourmethods} \int_{T}^{} v \varphi = -
  \int_{\partial T}^{} \underbrace{\left( f(x,u) + A(x,u) \cdot n
  \right)}_{\substack{\mathtt{numericalFlux}\\\mathtt{boundaryFlux}}} \varphi +
  \int_{T}^{} \overbrace{f(x,u)}^{\mathclap{\mathtt{analyticalFlux}}} \cdot
  \nabla \varphi + \int_{T}^{} \underbrace{\left(S -
  A(x,u)\right)}_{\mathtt{source}} \nabla u \varphi.  \end{equation}
%
The header file \lstinline!advectdiff.hh! defines the two models that implement
these four methods \lstinline!analyticalFlux!, \lstinline!source!,
\lstinline!numericalFlux! and \lstinline!boundaryFlux!. Each of these methods
describes the discrete version of its corresponding term in the variational
formulation (\ref{eq:fourmethods}). The second pass of this implementation e.g.
has no \lstinline!source! term, the \lstinline!analyticalFlux! represents
$f_{2}(u_{0}, u_{1})$ (see (\ref{eq:variational2})) and the
\lstinline!numericalFlux! resp. the \lstinline!boundaryFlux! together represent
the flux function $f_{2,h}(u_{0},u_{1})$ (see (\ref{eq:flux2})), where the
first one implements the flux on interfaces between inner cells and the second
one on the boundary domain. Listing \ref{lst:advdiffd2} shows the actual
implementation of this model.
%
\begin{lst}[AdvDiffDModel2 in ../src\_localdg/discretemodels.hh]
  \label{lst:advdiffd2}\mbox{}
  \lstinputlisting[numbers=left,numberstyle=\tiny,numbersep=5pt,linerange={254-403}]{../src_localdg/discretemodels.hh}
\end{lst}
%
Note that in line \ref{dm:hasSource} the model notifies the
\lstinline!LocalDGPass! that there is no source term, and therefore the
\lstinline!source! method is never called and does not need to be implemented.
All the implemented fluxes have a parameter of type \lstinline!ArgumentTuple!.
This is the argument to the flux function which for the second pass lives in
the product of two function vector spaces. In order to access the correct
component of the argument, there is an elegant solution using the
\lstinline!Int2Type! helper class: Every Pass gets a unique id when it is
defined (see line \ref{ad:passids}) and the \lstinline!Int2Type! class can
convert this unique id to a unique type as done in lines \ref{dm:int2type0} and
\ref{dm:int2type1}. These types then allow \lstinline!ArgumentTuple!s to be
used like arrays, as in line \ref{dm:int2typeusage} e.g., where
\lstinline!uLeft[u0Var]! returns $u_{0}(x^{-})$ and \lstinline!uLeft[u1Var]!
returns $u_{1}(x^{-})$. Alternatively there is a \lstinline!Selector! class in
\Fem\ which also provides accessors to any component of a tuple but which is
more cumbersome.

With models defined for both passes the implementation of the LDG operator
becomes quite simple.
%
\begin{lst}[../src\_localdg/advectdiff.hh] \label{lst:advectdiffhh}\mbox{}
  \lstinputlisting[numbers=left,numberstyle=\tiny,numbersep=5pt]{../src_localdg/advectdiff.hh}
\end{lst}
%
Lines \ref{ad:typedefpass1} and \ref{ad:typedefpass2} contain the typedefs for
both passes specifying the underlying model and the pass id of the
\lstinline!LocalDG! pass. The initialisation of the passes in lines
\ref{ad:initialisepass1} and \ref{ad:initialisepass2} is equally
straightforward.  Line \ref{ad:callpass2} shows how a pass can be evaluated
like an \lstinline!Operator! calling all previous passes.
%
%If you are interested in writing your own Dune Pass you should refer to
%section \ref{se:pass_details} where the implementation of the \lstinline!Pass!
%and \lstinline!LocalDGPass! classes is explained in more detail.
%
%\section{Pass details} \label{se:pass_details}

\section{Visualisation and EOC Output} \label{se:outputvisualisation}

The source code shipped with this document contains a file called
\lstinline!datadisp.cc! which implements a GRAPE interface for the data
produced by the \lstinline!dgtest! program. It also provides a file
\lstinline!manager.replay! which preconfigures GRAPE for watching the snapshots
as an animation. Just click on the play button.
%
\begin{lstlisting} 
  ./datadisp paramfile:parameter 0 25 
\end{lstlisting}
%
starts the visualisation, where the last number must be less than or equal to
the number of snapshots produced by \lstinline!dgtest!.

Furthermore, \lstinline!dgtest! produces on every run, a \TeX file called
\lstinline!eoc.tex!, which comprises statistics about the numerical convergence
of the implemented LDG scheme.

% vim:set ft=tex:
