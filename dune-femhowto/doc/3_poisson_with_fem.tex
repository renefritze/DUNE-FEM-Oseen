%
% Written by K. Michel
%

In this chapter we want to show how to use \Fem\ for solving a simple test problem.
As a test problem, we choose the Poisson problem: \label{poissonproblem}

\begin{eqnarray}
  -\triangle u &=& f  \quad \mbox{in}\ \Omega\\
             u &=& g  \quad \mbox{on}\ \partial\Omega
\end{eqnarray}
We want to solve this problem with the finite element method using Lagrangian elements. The implementation of this method is done in the files in the directory \lstinline!dune-femhowto/src_poisson!.

The numerical treatment of this problem is described in chapter 1 of this skript (in german): \url{http://www.mathematik.uni-freiburg.de/IAM/Teaching/ubungen/sci_com_SS06/skriptum.pdf}.

In this example, we choose the following problem data:
\begin{eqnarray}
  \Omega &:=& ]0,1[^{dimworld}, \quad x = (x_1, ..., x_{dimworld}) \\
  f(x) &:=& 2 \sum_{i=1}^{dimworld} \prod_{j \neq i} (x_j-x_j^2)  \quad \forall x \in \Omega  \\
  u(x) &:=& \prod_{i=1}^{dimworld} (x_i - x_i^2)  \quad \forall x \in \Omega   \\
  g(x) &:=& u(x) \quad \forall x \in \partial\Omega
\end{eqnarray}
where $u$ is the exact solution. The boundary values are just the values of the exact solution on the boundary points.

Note: In the current implementation we implemented another right hand side $f$.
\begin{eqnarray}
  f(x,y) &:=& 8 \pi^2 \cos(2 \pi x) \cos(2 \pi y)  \quad \forall x \in \Omega  \\
  u(x,y) &:=&         \cos(2 \pi x) \cos(2 \pi y)  \quad \forall x \in \Omega   \\
  g(x,y) &:=& u(x,y) \quad \forall x \in \partial\Omega
\end{eqnarray}
The second problem data should better be used only with \texttt{dimworld=2}. For changing between these two versions, please modify \texttt{problem.hh}.



\section{Implementing the algorithm and the problem data}

\subsection{The algorithm in \texttt{lagrange.cc} }
\subsubsection{The function \texttt{main()} }
We want to skip all the \texttt{includes} at the beginning of the file and jump directly to the \texttt{main} routine.

\begin{itemize}
 \item Initialize grid and some more initialization stuff

 \item Call \texttt{Algorithm::calc()} twice for EOC calculation:
\begin{lstlisting}
for( int i=0; i<2; ++i )
{
	// calculate L2-projection
	projectionError[i] =
       Algorithm<GridType, L2ProjectionProblem, MassOperator>
          ::calc(grid,"l2-projection", false);

	// calculate poisson problem
	poissonError[i] =
       Algorithm<GridType, PoissonProblem, LaplaceOperator>
          ::calc(grid,"poisson",true);

	// make refinement for next step
	grid.globalRefine( DGFGridInfo<GridType>::refineStepsForHalf() );
}
\end{lstlisting}

 \item Calculate EOC:
\begin{lstlisting}
const double poissonEOC =
                log( poissonError[0] / poissonError[1] ) / M_LN2;
const double projectionEOC =
                log( projectionError[0] / projectionError[1] ) / M_LN2;
\end{lstlisting}

\end{itemize}
\texttt{L2ProjectionProblem} and \texttt{PoissonProblem} are defined in \texttt{problem.hh},
\texttt{MassOperator} and \texttt{LaplaceOperator} are defined in \texttt{massmatrix.hh} respective \texttt{laplace.hh}. These files will be explained in detail later.


\subsubsection{The struct \texttt{Algorithm} }
\begin{lstlisting}
template < class GridImp,
           template <class> class ProblemImp,
           template <class> class OperatorImp >
struct Algorithm
\end{lstlisting}
This struct contains some (important) typedefs and the method \texttt{calc()}, which holds the algorithm.
Explanation of the typedefs:

\begin{itemize}
 \item \lstinline!typedef GridImp GridType!\\
      New name for template parameter.

 \item \lstinline!typedef LeafGridPart<GridType> GridPartType!\\
      A \texttt{GridPart} is a subset of entities of the whole grid. Here our \texttt{GridPart} is build up by all leaf elements.

 \item \lstinline!FunctionSpace<double, double, GridType::dimension, 1>  FunctionSpaceType!\\
      The analytical functionspace we want to use: We use functions $f: \R^{dimension} \rightarrow \R $,
      where Elements from $\R$ are represented by \texttt{doubles}.

 \item \lstinline!typedef LagrangeDiscreteFunctionSpace<FunctionSpaceType, GridPartType, POLORDER>!\\
       \lstinline!    DiscreteFunctionSpaceType!\\
      The discrete function space we want to use, here the lagrange space.

 \item \lstinline!typedef AdaptiveDiscreteFunction<DiscreteFunctionSpaceType> DiscreteFunctionType!\\
      Build up discrete functions from the discrete function space.

 \item \lstinline!typedef ProblemImp<FunctionSpaceType> ProblemType!\\
       \lstinline!typedef typename ProblemType::RHSFunctionType RHSFunctionType!\\
       \lstinline!typedef typename ProblemType::ExactSolutionType ExactSolutionType!\\
      The problem data and data functions (as defined in problem.hh)

 \item \lstinline!typedef OperatorImp<DiscreteFunctionType> OperatorType!\\
      New name for template parameter (will be the laplace or the massmatrix operator).

 \item \lstinline!typedef OEMBICGSTABOp<DiscreteFunctionType,OperatorType> InverseOperatorType!\\
      Define the type of inverse operator we are using to solve the system. There are different inverse operators available.
\end{itemize}


\subsubsection*{ Explanation of the algorithm in the method \texttt{calc()} }
\begin{lstlisting}
static double calc (GridType& grid,
                    const std::string name,
                    bool verbose = false )
\end{lstlisting}

\begin{itemize}
 \item Create instances of the types defined above:
	\begin{itemize}
	  \item \texttt{discreteFunctionSpace} of type \texttt{DiscreteFunctionSpaceType} (and print also some information)
	  \item \texttt{solution} and \texttt{rhs} of type \texttt{DiscreteFunctionType} (discrete functions for solution and right hand side)
	  \item \texttt{f} of type \texttt{RHSFunctionType} (analytical right hand side)
	\end{itemize}

 \item Build right hand side (see boundary.hh):
\begin{lstlisting}
assembleRHS<2*DiscreteFunctionSpaceType::polynomialOrder> ( f , rhs );
\end{lstlisting}

 \item Set the dirichlet boundary points to the corresponding values of the exact solution $u$ by modifying \texttt{rhs}
       (see boundary.hh, problem.hh):
\begin{lstlisting}
ExactSolutionType u( discreteFunctionSpace );
// ...
for( IteratorType it = discreteFunctionSpace.begin(); it != endit; ++it )
{
  boundaryTreatment( *it, u, rhs );
}
\end{lstlisting}

 \item Create instance of our problem operator (here: Laplace or MassMatrix Operator),
       see \texttt{laplace.hh} and \texttt{massmatrix.hh}.
\begin{lstlisting}
OperatorType problemOperator( discreteFunctionSpace );
\end{lstlisting}

 \item Solve the linear system by using the inverse operator (defined above) of our \texttt{problemOperator}:
\begin{lstlisting}
InverseOperatorType cg( problemOperator, 1e-8, 1e-8, 20000, verbose );
cg( rhs, solution );
\end{lstlisting}
For more information see the doxygen documentation of \Fem\ (Operators - Linear solver)

 \item Error calculation and graphical output.
\end{itemize}




\subsection{The problem data in \texttt{problem.hh} }
First we implement the problem data: The right hand side $f$ and the exact solution $u$ of our Poisson problem (see page \pageref{poissonproblem}). The exact solution is needed for the EOC calculation and also for setting the boundary values.
\begin{lstlisting}
template <class FunctionSpaceType>
class myRHSFunction
    : public Function< FunctionSpaceType, myRHSFunction<FunctionSpaceType> >
{
  // Implementation...
};
\end{lstlisting}

\begin{lstlisting}
template <class FunctionSpaceType>
class myExactSolution
    : public Function< FunctionSpaceType, myExactSolution<FunctionSpaceType> >
{
  // Implementation...
};
\end{lstlisting}
Note: These classes are derived from the \texttt{Function} class by using the Barton-Nackman-Trick in the second template parameter.

Now we put all problem data together in two classes:
\begin{lstlisting}
// right hand side and exact solution for poisson problem
template <class FunctionSpaceType>
struct PoissonProblem
{
    // type of right hand side
    typedef myRHSFunction<FunctionSpaceType> RHSFunctionType;

    // type of exact solution
    typedef myExactSolution<FunctionSpaceType> ExactSolutionType;
};

// for the L2-Projection use the exact solution also for the right hand side
template <class FunctionSpaceType>
struct L2ProjectionProblem
{
    // type of right hand side, use exact solution(!)
    typedef myExactSolution<FunctionSpaceType> RHSFunctionType;

    // type of exact solution
    typedef myExactSolution<FunctionSpaceType> ExactSolutionType;
};
\end{lstlisting}





\subsection{Right hand side assembler and boundary treatment in \texttt{boundary.hh} }
You can find more details about this topic in chapter 1 of this skript (in german): \url{http://www.mathematik.uni-freiburg.de/IAM/Teaching/ubungen/sci_com_SS06/skriptum.pdf}.

\subsubsection*{The function \texttt{assembleRHS()} }
This function assembles the right hand side for a given \texttt{function} and returns the result in \texttt{discreteFunction}.
The (given) right hand side function $f$ itself is implemented in \texttt{problem.hh}.
\begin{lstlisting}
template< int polOrd,
          class FunctionType,
          class DiscreteFunctionType>
static void assembleRHS( const FunctionType &function,
                         DiscreteFunctionType &discreteFunction )
{
// Implementation...
}
\end{lstlisting}

\subsubsection*{The function \texttt{boundaryTreatment()} } \label{boundaryTreatment}
Sets the dirichlet points to the corresponding values of \texttt{boundaryValue}. \texttt{boundaryValue} can be arbitrary, but  \texttt{langrange.cc} uses the (given) exact solution $u$ for setting the boundary values.
The exact solution $u$ itself is implemented in \texttt{problem.hh}.
\begin{lstlisting}
template< class EntityType,
          class FunctionType,
          class DiscreteFunctionType >
static void boundaryTreatment( const EntityType &entity,
                               const FunctionType& boundaryValue,
                               DiscreteFunctionType &rhs )
{
// Implementation...
}
\end{lstlisting}




\section{Implementing Laplace- and MassOperator}
Remember the following lines of the algorithm in \texttt{lagrange.cc}:
\begin{lstlisting}
// type of inverse operator
typedef OEMBICGSTABOp<DiscreteFunctionType,OperatorType> InverseOperatorType;

// assemble right hand side and so on ...
// ...

// create problem operator (Laplace or MassMatrix Operator)
OperatorType problemOperator( discreteFunctionSpace );

// apply inverse operator (solve the linear system)
InverseOperatorType cg( problemOperator, 1e-8, 1e-8, 20000, verbose );
cg( rhs, solution );
\end{lstlisting}
This means, for solving our problem with the inverse operator \texttt{cg}, we first have to provide a suitable problem operator.
How this can be done for the Poisson Problem is shown in the following subsections.


\subsection{An abstract matrix operator in \texttt{matrixoperator.hh} }
In this file the class \texttt{MatrixOperator} is implemented. This class is the base class for the problem operator classes \texttt{LaplaceOperator} and \texttt{MassOperator}, which are described below. The derived classes have to implement at least the (protected) method \texttt{assembleLocalMatrix()}.

\subsubsection{Private member variables}
\begin{itemize}
 \item \lstinline!const DiscreteFunctionSpaceType &discreteFunctionSpace_!: reference to the used discrete function space.

 \item \lstinline!mutable MatrixObjectImp matrixObj_!: pointer to the system matrix.

 \item \lstinline!mutable bool matrix_assembled_!: flag indicating whether the system matrix has already been assembled.

 \item \lstinline!const bool boundaryCorrect_!: true if boundary correction should be done.
\end{itemize}


\subsubsection{The constructor \texttt{MatrixOperator::MatrixOperator()} }
The constructor of this class is protected, so you cannot create any instances of this class.
\begin{lstlisting}
MatrixOperator( const DiscreteFunctionSpaceType &discreteFunctionSpace, bool bnd )
    : discreteFunctionSpace_( discreteFunctionSpace ),
      matrixObj_( discreteFunctionSpace, discreteFunctionSpace , "" ),
      matrix_assembled_( false ),
      boundaryCorrect_(bnd)
{
}
\end{lstlisting}


\subsubsection{Public methods}
The public methods are all very easy.
\begin{itemize}
 \item \texttt{MatrixOperator::operator() ()}\\
       \texttt{MatrixOperator::multOEM()}\\
    Apply the operator: Multiplies a vector with the system matrix and returns the result.

 \item \texttt{MatrixOperator::systemMatrix()}\\
    Returns the system matrix \texttt{matrixObj\_}. Calls \texttt{MatrixOperator::assemble()} before, if needed.

 \item \texttt{MatrixOperator::preconditionMatrix()}\\
    Returns a reference to the preconditioning matrix.

 \item \texttt{MatrixOperator::print()}\\
    Prints the system matrix into a stream.

 \item \texttt{MatrixOperator::discreteFunctionSpace()}\\
    Returns the used discreteFunctionSpace.

 \item \texttt{MatrixOperator::assemble()}\\
    Allocates memory for the system matrix \texttt{matrixObj\_} and then
    calls the method \texttt{MatrixOperator::assembleOnGrid()}.
\end{itemize}


\subsubsection{Protected methods}
\begin{itemize}
 \item \texttt{MatrixOperator::assembleOnGrid()}\\
    Runs over all entities, calls on each entity \texttt{MatrixOperator::assembleOnEntity()} and calls,
    if needed, \texttt{MatrixOperator::boundaryCorrectOnEntity()}.
    Furthermore, prints out the time needed for the hole matrix to assemble.

 \item \texttt{MatrixOperator::assembleOnEntity()}\\
    Performs matrix assemble for one entity. Creates for that entity a local matrix and calls
    \texttt{MatrixOperator::assembleLocalMatrix()} on the entity.

 \item \texttt{MatrixOperator::assembleLocalMatrix()}\\
    Uses the Barton-Nackman Trick to avoid using virtual functions: Just calls the corresponding method
    \texttt{assembleLocalMatrix()} in the derived class. The derived class has to implement this method!

 \item \texttt{MatrixOperator::boundaryCorrectOnEntity()}\\
    Modifies the system matrix in order to implement the dirichlet boundary condition. Compare with the function
    \texttt{boundaryTreatment()} on page \pageref{boundaryTreatment}, where the corresponding thing was done
    for the right hand side.
\end{itemize}


\subsubsection{Private methods}
\begin{itemize}
 \item \texttt{MatrixOperatorType\& asImp()}\\
       \texttt{const MatrixOperatorType\& asImp() const}\\
    Performs the Barton-Nackman Trick to avoid virtual functions. Looks strange, but works, so don't worry about!
\end{itemize}




\subsection{The Laplace operator in \texttt{laplace.hh} }
The struct \texttt{LaplaceOperatorTraits} at the beginning of the file contains only some typedefs,
so let's start directly with the  class \texttt{LaplaceOperator}.
\begin{lstlisting}
template< class DiscreteFunctionImp >
class LaplaceOperator : public MatrixOperator< LaplaceOperatorTraits<DiscreteFunctionImp> >
\end{lstlisting}
This class is derived from the class \texttt{MatrixOperator} (see \texttt{matrixoperator.hh}) to implement the Laplace operator.
The typedefs at the beginning of the class are not so important.

Most of the work is already be done in the base class, here we have only to implement the method \texttt{LaplaceOperator::assembleLocalMatrix()}. For details about that method we refer again to
this skript: \url{http://www.mathematik.uni-freiburg.de/IAM/Teaching/ubungen/sci_com_SS06/skriptum.pdf}, chapter 1.3.2.



\subsection{The mass matrix operator in \texttt{massmatrix.hh} }

This file holds another class derived from \texttt{MatrixOperator}, but this time to implement the mass matrix operator.
The hole file is very similar with the file \texttt{laplace.hh}, only the method \texttt{MassOperator::assembleLocalMatrix()}
is (of course) different.















