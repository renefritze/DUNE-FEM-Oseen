<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN""http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>dune-istl: Block Recursive Iterative Kernels (dune-istl )</title>
  <link rel="stylesheet" type="text/css" href="./dune-doxy.css">
  <link rel="stylesheet" type="text/css" href="./tabs.css">
</head>
<div class="main">
<div class="doxygen">
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Block Recursive Iterative Kernels<br>
<small>
[<a class="el" href="a00194.html">Sparse Matrix and Vector classes</a>]</small>
</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Generic iterative kernels for the solvers which work on the block recursive structure of the matrices and vectors. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html">Dune::BL&lt; l &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compile-time parameter for block recursion depth  <a href="a00019.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g70a513d582bb02811c982b086e7bd01d"></a><!-- doxytag: member="ISTL_Kernel::bltsolve" ref="g70a513d582bb02811c982b086e7bd01d" args="(const M &amp;A, X &amp;v, const Y &amp;d)" -->
template&lt;class M, class X, class Y&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00202.html#g70a513d582bb02811c982b086e7bd01d">Dune::bltsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">block lower triangular solve <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g848984e8ba2f14b3adaaa12305b5bd94"></a><!-- doxytag: member="ISTL_Kernel::bltsolve" ref="g848984e8ba2f14b3adaaa12305b5bd94" args="(const M &amp;A, X &amp;v, const Y &amp;d, const K &amp;w)" -->
template&lt;class M, class X, class Y, class K&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00202.html#g848984e8ba2f14b3adaaa12305b5bd94">Dune::bltsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d, const K &amp;w)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">relaxed block lower triangular solve <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g62de7bf48e90dc286f0570bc75bc6de9"></a><!-- doxytag: member="ISTL_Kernel::ubltsolve" ref="g62de7bf48e90dc286f0570bc75bc6de9" args="(const M &amp;A, X &amp;v, const Y &amp;d)" -->
template&lt;class M, class X, class Y&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00202.html#g62de7bf48e90dc286f0570bc75bc6de9">Dune::ubltsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unit block lower triangular solve <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g986217f54ae31aea4df1f035e3d329ed"></a><!-- doxytag: member="ISTL_Kernel::ubltsolve" ref="g986217f54ae31aea4df1f035e3d329ed" args="(const M &amp;A, X &amp;v, const Y &amp;d, const K &amp;w)" -->
template&lt;class M, class X, class Y, class K&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00202.html#g986217f54ae31aea4df1f035e3d329ed">Dune::ubltsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d, const K &amp;w)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">relaxed unit block lower triangular solve <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g87856ef814a484d9ae2d13ddd2985a41"></a><!-- doxytag: member="ISTL_Kernel::butsolve" ref="g87856ef814a484d9ae2d13ddd2985a41" args="(const M &amp;A, X &amp;v, const Y &amp;d)" -->
template&lt;class M, class X, class Y&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00202.html#g87856ef814a484d9ae2d13ddd2985a41">Dune::butsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">block upper triangular solve <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g7f9f27206b246fc3adac8f3f7e14b480"></a><!-- doxytag: member="ISTL_Kernel::butsolve" ref="g7f9f27206b246fc3adac8f3f7e14b480" args="(const M &amp;A, X &amp;v, const Y &amp;d, const K &amp;w)" -->
template&lt;class M, class X, class Y, class K&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00202.html#g7f9f27206b246fc3adac8f3f7e14b480">Dune::butsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d, const K &amp;w)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">relaxed block upper triangular solve <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g452f157735b53482fa07e24e65d830ec"></a><!-- doxytag: member="ISTL_Kernel::ubutsolve" ref="g452f157735b53482fa07e24e65d830ec" args="(const M &amp;A, X &amp;v, const Y &amp;d)" -->
template&lt;class M, class X, class Y&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00202.html#g452f157735b53482fa07e24e65d830ec">Dune::ubutsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unit block upper triangular solve <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g9e76bc35f0fb88e4cc3f891a64d093ae"></a><!-- doxytag: member="ISTL_Kernel::ubutsolve" ref="g9e76bc35f0fb88e4cc3f891a64d093ae" args="(const M &amp;A, X &amp;v, const Y &amp;d, const K &amp;w)" -->
template&lt;class M, class X, class Y, class K&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00202.html#g9e76bc35f0fb88e4cc3f891a64d093ae">Dune::ubutsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d, const K &amp;w)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">relaxed unit block upper triangular solve <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gb5cccee4e4318c906ea21ce5b4065090"></a><!-- doxytag: member="ISTL_Kernel::bltsolve" ref="gb5cccee4e4318c906ea21ce5b4065090" args="(const M &amp;A, X &amp;v, const Y &amp;d, BL&lt; l &gt; bl)" -->
template&lt;class M, class X, class Y, int l&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00202.html#gb5cccee4e4318c906ea21ce5b4065090">Dune::bltsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d, BL&lt; l &gt; bl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">block lower triangular solve <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g06bf46bf36976036f35a394eccda7ca6"></a><!-- doxytag: member="ISTL_Kernel::bltsolve" ref="g06bf46bf36976036f35a394eccda7ca6" args="(const M &amp;A, X &amp;v, const Y &amp;d, const K &amp;w, BL&lt; l &gt; bl)" -->
template&lt;class M, class X, class Y, class K, int l&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00202.html#g06bf46bf36976036f35a394eccda7ca6">Dune::bltsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d, const K &amp;w, BL&lt; l &gt; bl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">relaxed block lower triangular solve <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g56b7728177fbed254756460a266c9247"></a><!-- doxytag: member="ISTL_Kernel::ubltsolve" ref="g56b7728177fbed254756460a266c9247" args="(const M &amp;A, X &amp;v, const Y &amp;d, BL&lt; l &gt; bl)" -->
template&lt;class M, class X, class Y, int l&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00202.html#g56b7728177fbed254756460a266c9247">Dune::ubltsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d, BL&lt; l &gt; bl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unit block lower triangular solve <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g6313e1351a239144936213c4e14f6b72"></a><!-- doxytag: member="ISTL_Kernel::ubltsolve" ref="g6313e1351a239144936213c4e14f6b72" args="(const M &amp;A, X &amp;v, const Y &amp;d, const K &amp;w, BL&lt; l &gt; bl)" -->
template&lt;class M, class X, class Y, class K, int l&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00202.html#g6313e1351a239144936213c4e14f6b72">Dune::ubltsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d, const K &amp;w, BL&lt; l &gt; bl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">relaxed unit block lower triangular solve <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gf24bebd83f7390a0685264d66d4edea8"></a><!-- doxytag: member="ISTL_Kernel::butsolve" ref="gf24bebd83f7390a0685264d66d4edea8" args="(const M &amp;A, X &amp;v, const Y &amp;d, BL&lt; l &gt; bl)" -->
template&lt;class M, class X, class Y, int l&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00202.html#gf24bebd83f7390a0685264d66d4edea8">Dune::butsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d, BL&lt; l &gt; bl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">block upper triangular solve <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gcb52fadfc7aebc01744e3b0270eebc18"></a><!-- doxytag: member="ISTL_Kernel::butsolve" ref="gcb52fadfc7aebc01744e3b0270eebc18" args="(const M &amp;A, X &amp;v, const Y &amp;d, const K &amp;w, BL&lt; l &gt; bl)" -->
template&lt;class M, class X, class Y, class K, int l&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00202.html#gcb52fadfc7aebc01744e3b0270eebc18">Dune::butsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d, const K &amp;w, BL&lt; l &gt; bl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">relaxed block upper triangular solve <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g349c0f1a2d5a69c7448daf6b7a12ec79"></a><!-- doxytag: member="ISTL_Kernel::ubutsolve" ref="g349c0f1a2d5a69c7448daf6b7a12ec79" args="(const M &amp;A, X &amp;v, const Y &amp;d, BL&lt; l &gt; bl)" -->
template&lt;class M, class X, class Y, int l&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00202.html#g349c0f1a2d5a69c7448daf6b7a12ec79">Dune::ubutsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d, BL&lt; l &gt; bl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">unit block upper triangular solve <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g09ae6dc9e21ca2677caff2afe7ea74ec"></a><!-- doxytag: member="ISTL_Kernel::ubutsolve" ref="g09ae6dc9e21ca2677caff2afe7ea74ec" args="(const M &amp;A, X &amp;v, const Y &amp;d, const K &amp;w, BL&lt; l &gt; bl)" -->
template&lt;class M, class X, class Y, class K, int l&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00202.html#g09ae6dc9e21ca2677caff2afe7ea74ec">Dune::ubutsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d, const K &amp;w, BL&lt; l &gt; bl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">relaxed unit block upper triangular solve <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gf6fd414b71fb40771cb4dcc95a62c791"></a><!-- doxytag: member="ISTL_Kernel::bdsolve" ref="gf6fd414b71fb40771cb4dcc95a62c791" args="(const M &amp;A, X &amp;v, const Y &amp;d)" -->
template&lt;class M, class X, class Y&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00202.html#gf6fd414b71fb40771cb4dcc95a62c791">Dune::bdsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">block diagonal solve, no relaxation <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g2dc20ad359c870a7e84faf8db8be30de"></a><!-- doxytag: member="ISTL_Kernel::bdsolve" ref="g2dc20ad359c870a7e84faf8db8be30de" args="(const M &amp;A, X &amp;v, const Y &amp;d, const K &amp;w)" -->
template&lt;class M, class X, class Y, class K&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00202.html#g2dc20ad359c870a7e84faf8db8be30de">Dune::bdsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d, const K &amp;w)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">block diagonal solve, with relaxation <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g020fa63a87ded39fd639648be8b62ba8"></a><!-- doxytag: member="ISTL_Kernel::bdsolve" ref="g020fa63a87ded39fd639648be8b62ba8" args="(const M &amp;A, X &amp;v, const Y &amp;d, BL&lt; l &gt; bl)" -->
template&lt;class M, class X, class Y, int l&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00202.html#g020fa63a87ded39fd639648be8b62ba8">Dune::bdsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d, BL&lt; l &gt; bl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">block diagonal solve, no relaxation <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g824de27539afb4eec577abed34df037f"></a><!-- doxytag: member="ISTL_Kernel::bdsolve" ref="g824de27539afb4eec577abed34df037f" args="(const M &amp;A, X &amp;v, const Y &amp;d, const K &amp;w, BL&lt; l &gt; bl)" -->
template&lt;class M, class X, class Y, class K, int l&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00202.html#g824de27539afb4eec577abed34df037f">Dune::bdsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d, const K &amp;w, BL&lt; l &gt; bl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">block diagonal solve, with relaxation <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g6ade8d7959e8801e7d2f7b201bcf3d7c"></a><!-- doxytag: member="ISTL_Kernel::dbgs" ref="g6ade8d7959e8801e7d2f7b201bcf3d7c" args="(const M &amp;A, X &amp;x, const Y &amp;b, const K &amp;w)" -->
template&lt;class M, class X, class Y, class K&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00202.html#g6ade8d7959e8801e7d2f7b201bcf3d7c">Dune::dbgs</a> (const M &amp;A, X &amp;x, const Y &amp;b, const K &amp;w)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GS step. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g3d0ad63f2b0d8d998f7731b01d34d430"></a><!-- doxytag: member="ISTL_Kernel::dbgs" ref="g3d0ad63f2b0d8d998f7731b01d34d430" args="(const M &amp;A, X &amp;x, const Y &amp;b, const K &amp;w, BL&lt; l &gt; bl)" -->
template&lt;class M, class X, class Y, class K, int l&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00202.html#g3d0ad63f2b0d8d998f7731b01d34d430">Dune::dbgs</a> (const M &amp;A, X &amp;x, const Y &amp;b, const K &amp;w, BL&lt; l &gt; bl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">GS step. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g2204a34cd46a8f061f0a2dccca4cd3e4"></a><!-- doxytag: member="ISTL_Kernel::bsorf" ref="g2204a34cd46a8f061f0a2dccca4cd3e4" args="(const M &amp;A, X &amp;x, const Y &amp;b, const K &amp;w)" -->
template&lt;class M, class X, class Y, class K&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00202.html#g2204a34cd46a8f061f0a2dccca4cd3e4">Dune::bsorf</a> (const M &amp;A, X &amp;x, const Y &amp;b, const K &amp;w)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SOR step. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g4c250fe4ba236b00884d4055a6c17450"></a><!-- doxytag: member="ISTL_Kernel::bsorf" ref="g4c250fe4ba236b00884d4055a6c17450" args="(const M &amp;A, X &amp;x, const Y &amp;b, const K &amp;w, BL&lt; l &gt; bl)" -->
template&lt;class M, class X, class Y, class K, int l&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00202.html#g4c250fe4ba236b00884d4055a6c17450">Dune::bsorf</a> (const M &amp;A, X &amp;x, const Y &amp;b, const K &amp;w, BL&lt; l &gt; bl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SOR step. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ge6c18af7f8c3249acaaa532970275f9c"></a><!-- doxytag: member="ISTL_Kernel::bsorb" ref="ge6c18af7f8c3249acaaa532970275f9c" args="(const M &amp;A, X &amp;x, const Y &amp;b, const K &amp;w)" -->
template&lt;class M, class X, class Y, class K&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00202.html#ge6c18af7f8c3249acaaa532970275f9c">Dune::bsorb</a> (const M &amp;A, X &amp;x, const Y &amp;b, const K &amp;w)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SSOR step. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g481cf6bb612fcb42577830118fdd7be5"></a><!-- doxytag: member="ISTL_Kernel::bsorb" ref="g481cf6bb612fcb42577830118fdd7be5" args="(const M &amp;A, X &amp;x, const Y &amp;b, const K &amp;w, BL&lt; l &gt; bl)" -->
template&lt;class M, class X, class Y, class K, int l&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00202.html#g481cf6bb612fcb42577830118fdd7be5">Dune::bsorb</a> (const M &amp;A, X &amp;x, const Y &amp;b, const K &amp;w, BL&lt; l &gt; bl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">SSOR step. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g092fc774da795e510eb72688df4e5067"></a><!-- doxytag: member="ISTL_Kernel::dbjac" ref="g092fc774da795e510eb72688df4e5067" args="(const M &amp;A, X &amp;x, const Y &amp;b, const K &amp;w)" -->
template&lt;class M, class X, class Y, class K&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00202.html#g092fc774da795e510eb72688df4e5067">Dune::dbjac</a> (const M &amp;A, X &amp;x, const Y &amp;b, const K &amp;w)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Jacobi step. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gd44b4d64785d69783e643ef605ba3424"></a><!-- doxytag: member="ISTL_Kernel::dbjac" ref="gd44b4d64785d69783e643ef605ba3424" args="(const M &amp;A, X &amp;x, const Y &amp;b, const K &amp;w, BL&lt; l &gt; bl)" -->
template&lt;class M, class X, class Y, class K, int l&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00202.html#gd44b4d64785d69783e643ef605ba3424">Dune::dbjac</a> (const M &amp;A, X &amp;x, const Y &amp;b, const K &amp;w, BL&lt; l &gt; bl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Jacobi step. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ge4e35df8b5a5d13bd2c3197414851a08"></a><!-- doxytag: member="ISTL_Kernel::bilu0_decomposition" ref="ge4e35df8b5a5d13bd2c3197414851a08" args="(M &amp;A)" -->
template&lt;class M&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00202.html#ge4e35df8b5a5d13bd2c3197414851a08">Dune::bilu0_decomposition</a> (M &amp;A)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute ILU decomposition of A. A is overwritten by its decomposition <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g3b5895ae8b7d2812e978bce9b9e85657"></a><!-- doxytag: member="ISTL_Kernel::bilu_backsolve" ref="g3b5895ae8b7d2812e978bce9b9e85657" args="(const M &amp;A, X &amp;v, const Y &amp;d)" -->
template&lt;class M, class X, class Y&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00202.html#g3b5895ae8b7d2812e978bce9b9e85657">Dune::bilu_backsolve</a> (const M &amp;A, X &amp;v, const Y &amp;d)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LU backsolve with stored inverse. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class M&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00202.html#gd888b736070e118d467ce5ef90298768">Dune::bilu_decomposition</a> (const M &amp;A, int n, M &amp;ILU)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="gd888b736070e118d467ce5ef90298768"></a><!-- doxytag: member="Dune::bilu_decomposition" ref="gd888b736070e118d467ce5ef90298768" args="(const M &amp;A, int n, M &amp;ILU)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Dune::bilu_decomposition           </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&nbsp;</td>
          <td class="paramname"> <em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&nbsp;</td>
          <td class="paramname"> <em>ILU</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
ILU decomposition of order n Computes ILU decomposition of order n. The matrix ILU should be an empty matrix in row_wise creation mode. This allows the user to either specify the number of nonzero elements or to determine it automatically at run-time. 
<p>References <a class="el" href="a00222.html#l00027">Dune::bilu0_decomposition()</a>.</p>

<p>Referenced by <a class="el" href="a00243.html#l00538">Dune::SeqILUn&lt; M, X, Y &gt;::SeqILUn()</a>.</p>

</div>
</div><p>
</div>
</div> <!-- end doxygen -->
</div> <!-- end main -->
<div class="foot">

<p class="foot">
  Generated on 6 Nov 2008 with <a
  href="http://www.doxygen.org/">Doxygen</a> (ver 1.5.6)  
  [<a href="doxygen.log">logfile</a>].
</p>

</div>

</body>
</html>
