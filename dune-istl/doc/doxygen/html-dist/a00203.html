<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN""http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>dune-istl: aggregates.hh Source File (dune-istl )</title>
  <link rel="stylesheet" type="text/css" href="./dune-doxy.css">
  <link rel="stylesheet" type="text/css" href="./tabs.css">
</head>
<div class="main">
<div class="doxygen">
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_39c25fa0261c9359275e2f8975608afb.html">istl</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_45c1d988590ecc4d2fccf216d56d012e.html">paamg</a>
  </div>
</div>
<div class="contents">
<h1>aggregates.hh</h1><a href="a00134.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// $Id: aggregates.hh 814 2007-09-21 18:17:51Z mblatt $ </span>
<a name="l00002"></a>00002 <span class="preprocessor">#ifndef DUNE_AMG_AGGREGATES_HH</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span><span class="preprocessor">#define DUNE_AMG_AGGREGATES_HH</span>
<a name="l00004"></a>00004 <span class="preprocessor"></span>
<a name="l00005"></a>00005 <span class="preprocessor">#include"<a class="code" href="a00148.html" title="Provides classes for building the matrix graph.">graph.hh</a>"</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include"<a class="code" href="a00174.html" title="Provides classes for handling internal properties in a graph.">properties.hh</a>"</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include"combinedfunctor.hh"</span>
<a name="l00008"></a>00008 
<a name="l00009"></a>00009 <span class="preprocessor">#include&lt;dune/common/timer.hh&gt;</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include&lt;dune/common/tuples.hh&gt;</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include&lt;dune/common/stdstreams.hh&gt;</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include&lt;dune/common/poolallocator.hh&gt;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include&lt;dune/common/sllist.hh&gt;</span>
<a name="l00014"></a>00014 
<a name="l00015"></a>00015 <span class="preprocessor">#include&lt;utility&gt;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include&lt;set&gt;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include&lt;algorithm&gt;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include&lt;limits&gt;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include&lt;ostream&gt;</span>
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 <span class="keyword">namespace </span>Dune
<a name="l00022"></a>00022 {
<a name="l00023"></a>00023   <span class="keyword">namespace </span>Amg
<a name="l00024"></a>00024   {
<a name="l00025"></a>00025     
<a name="l00039"></a>00039     <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00040"></a><a class="code" href="a00005.html">00040</a>     <span class="keyword">class </span><a class="code" href="a00005.html" title="Base class of all aggregation criterions.">AggregationCriterion</a> : <span class="keyword">public</span> T
<a name="l00041"></a>00041     {
<a name="l00042"></a>00042 
<a name="l00043"></a>00043     <span class="keyword">public</span>:
<a name="l00047"></a><a class="code" href="a00005.html#8110dd99b4f2ee974f3022b5cba4f5ed">00047</a>       <span class="keyword">typedef</span> T <a class="code" href="a00046.html">DependencyPolicy</a>;
<a name="l00048"></a>00048       
<a name="l00052"></a><a class="code" href="a00197.html#g0f63d04bf01bab42917249ec824b9319">00052</a>       <a class="code" href="a00197.html#g0f63d04bf01bab42917249ec824b9319" title="Constructor.">AggregationCriterion</a>()
<a name="l00053"></a>00053         : maxDistance_(2), minAggregateSize_(4), maxAggregateSize_(6), 
<a name="l00054"></a>00054           connectivity_(15), debugLevel_(3)
<a name="l00055"></a>00055       {}
<a name="l00056"></a>00056       
<a name="l00057"></a>00057       
<a name="l00065"></a><a class="code" href="a00197.html#ge4fef1b11ebb9e85ba520baf6d77c766">00065</a>       std::size_t <a class="code" href="a00197.html#ge4fef1b11ebb9e85ba520baf6d77c766" title="Get the maximal distance allowed between to nodes in a aggregate.">maxDistance</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> maxDistance_;}
<a name="l00066"></a>00066 
<a name="l00075"></a><a class="code" href="a00197.html#g58f530da670bfa93fba3e127be07f913">00075</a>       <span class="keywordtype">void</span> <a class="code" href="a00197.html#g58f530da670bfa93fba3e127be07f913" title="Set the maximal distance allowed between to nodes in a aggregate.">setMaxDistance</a>(std::size_t distance) { maxDistance_ = distance;}
<a name="l00076"></a>00076 
<a name="l00081"></a><a class="code" href="a00197.html#g5a9b3d45eb284edd36fbfb31779b780e">00081</a>       std::size_t <a class="code" href="a00197.html#g5a9b3d45eb284edd36fbfb31779b780e" title="Get the minimum number of nodes a aggregate has to consist of.">minAggregateSize</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> minAggregateSize_;}
<a name="l00082"></a>00082     
<a name="l00089"></a><a class="code" href="a00197.html#g0bba564dcd870e6aff3f9bc114d2a715">00089</a>       <span class="keywordtype">void</span> <a class="code" href="a00197.html#g0bba564dcd870e6aff3f9bc114d2a715" title="Set the minimum number of nodes a aggregate has to consist of.">setMinAggregateSize</a>(std::size_t size){ minAggregateSize_=size;}
<a name="l00090"></a>00090 
<a name="l00095"></a><a class="code" href="a00197.html#g4b7ef7cb7c048dab90204e7360004a41">00095</a>       std::size_t <a class="code" href="a00197.html#g4b7ef7cb7c048dab90204e7360004a41" title="Get the maximum number of nodes a aggregate is allowed to have.">maxAggregateSize</a>()<span class="keyword"> const</span>{ <span class="keywordflow">return</span> maxAggregateSize_;}
<a name="l00096"></a>00096 
<a name="l00103"></a><a class="code" href="a00197.html#g6ae3ed417f5b682d58d8486879193be2">00103</a>       <span class="keywordtype">void</span> <a class="code" href="a00197.html#g6ae3ed417f5b682d58d8486879193be2" title="Set the maximum number of nodes a aggregate is allowed to have.">setMaxAggregateSize</a>(std::size_t size){ maxAggregateSize_ = size;}
<a name="l00104"></a>00104 
<a name="l00112"></a><a class="code" href="a00197.html#g63591679ca51a29eb8b6db73d5c0c64b">00112</a>       std::size_t <a class="code" href="a00197.html#g63591679ca51a29eb8b6db73d5c0c64b" title="Get the maximum number of connections a aggregate is allowed to have.">maxConnectivity</a>()<span class="keyword"> const</span>{ <span class="keywordflow">return</span> connectivity_;}
<a name="l00113"></a>00113 
<a name="l00121"></a><a class="code" href="a00197.html#g0fd73bf448c50c0c2c9d733ca09b00b9">00121</a>       <span class="keywordtype">void</span> <a class="code" href="a00197.html#g0fd73bf448c50c0c2c9d733ca09b00b9" title="Set the maximum number of connections a aggregate is allowed to have.">setMaxConnectivity</a>(std::size_t connectivity){ connectivity_ = connectivity;}
<a name="l00122"></a>00122 
<a name="l00128"></a><a class="code" href="a00197.html#g112134619133e663798f050d995ee16e">00128</a>       <span class="keywordtype">void</span> <a class="code" href="a00197.html#g112134619133e663798f050d995ee16e" title="Set the debugging level.">setDebugLevel</a>(<span class="keywordtype">int</span> level)
<a name="l00129"></a>00129       {
<a name="l00130"></a>00130         debugLevel_ = level;
<a name="l00131"></a>00131       }
<a name="l00132"></a>00132       
<a name="l00138"></a><a class="code" href="a00197.html#gc0ecfafdcb23f24bfcebf68a6815ff46">00138</a>       <span class="keywordtype">int</span> <a class="code" href="a00197.html#gc0ecfafdcb23f24bfcebf68a6815ff46" title="Get the debugging Level.">debugLevel</a>()<span class="keyword"> const</span>
<a name="l00139"></a>00139 <span class="keyword">      </span>{
<a name="l00140"></a>00140         <span class="keywordflow">return</span> debugLevel_;
<a name="l00141"></a>00141       }
<a name="l00142"></a>00142       
<a name="l00143"></a>00143       
<a name="l00144"></a>00144     <span class="keyword">private</span>:
<a name="l00145"></a>00145       std::size_t maxDistance_, minAggregateSize_, maxAggregateSize_, connectivity_;
<a name="l00146"></a>00146       <span class="keywordtype">int</span> debugLevel_;
<a name="l00147"></a>00147     };
<a name="l00148"></a>00148     
<a name="l00149"></a>00149     <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00150"></a>00150     std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const AggregationCriterion&lt;T&gt;&amp; criterion)
<a name="l00151"></a>00151     {
<a name="l00152"></a>00152       os&lt;&lt;<span class="stringliteral">"{ maxdistance="</span>&lt;&lt;criterion.maxDistance()&lt;&lt;<span class="stringliteral">" minAggregateSize="</span>
<a name="l00153"></a>00153         &lt;&lt;criterion.minAggregateSize()&lt;&lt; <span class="stringliteral">" maxAggregateSize="</span>&lt;&lt;criterion.maxAggregateSize()
<a name="l00154"></a>00154         &lt;&lt;<span class="stringliteral">" connectivity="</span>&lt;&lt;criterion.connectivity()&lt;&lt;<span class="stringliteral">" debugLevel="</span>&lt;&lt;criterion.debugLevel()&lt;&lt;<span class="stringliteral">"}"</span>;
<a name="l00155"></a>00155       <span class="keywordflow">return</span> os;
<a name="l00156"></a>00156     }
<a name="l00157"></a>00157 
<a name="l00161"></a><a class="code" href="a00047.html">00161</a>     <span class="keyword">class </span><a class="code" href="a00047.html" title="Paramters needed to check whether a node depends on another.">DependencyParameters</a>
<a name="l00162"></a>00162     {
<a name="l00163"></a>00163     <span class="keyword">public</span>:
<a name="l00165"></a><a class="code" href="a00047.html#af07527f9c494debc36abbca053b2fc9">00165</a>       <a class="code" href="a00047.html#af07527f9c494debc36abbca053b2fc9" title="Constructor.">DependencyParameters</a>()
<a name="l00166"></a>00166         : alpha_(1.0/3.0), beta_(1.0E-5)
<a name="l00167"></a>00167       {}
<a name="l00168"></a>00168       
<a name="l00173"></a><a class="code" href="a00197.html#gd4cda39a27265d7281d0a24e7fd77cc2">00173</a>       <span class="keywordtype">void</span> <a class="code" href="a00197.html#gd4cda39a27265d7281d0a24e7fd77cc2" title="Set threshold for marking nodes as isolated. The default value is 1.0E-5.">setBeta</a>(<span class="keywordtype">double</span> b)
<a name="l00174"></a>00174       {
<a name="l00175"></a>00175         beta_ = b;
<a name="l00176"></a>00176       }
<a name="l00177"></a>00177       
<a name="l00183"></a><a class="code" href="a00197.html#gdc9d81c0f753b41fc3e66498bce9ab00">00183</a>       <span class="keywordtype">double</span> <a class="code" href="a00197.html#gdc9d81c0f753b41fc3e66498bce9ab00" title="Get the threshold for marking nodes as isolated. The default value is 1.0E-5.">beta</a>()<span class="keyword"> const</span>
<a name="l00184"></a>00184 <span class="keyword">      </span>{
<a name="l00185"></a>00185         <span class="keywordflow">return</span> beta_;
<a name="l00186"></a>00186       }
<a name="l00187"></a>00187       
<a name="l00192"></a><a class="code" href="a00197.html#g4a1e3ffba75a11bce0dca3054da77534">00192</a>       <span class="keywordtype">void</span> <a class="code" href="a00197.html#g4a1e3ffba75a11bce0dca3054da77534" title="Set the scaling value for marking connections as strong. Default value is 1/3.">setAlpha</a>(<span class="keywordtype">double</span> a)
<a name="l00193"></a>00193       {
<a name="l00194"></a>00194         alpha_ = a;
<a name="l00195"></a>00195       }
<a name="l00196"></a>00196 
<a name="l00201"></a><a class="code" href="a00197.html#g8a13c7f715bcc33c6209e04fd4c4f14a">00201</a>       <span class="keywordtype">double</span> <a class="code" href="a00197.html#g8a13c7f715bcc33c6209e04fd4c4f14a" title="Get the scaling value for marking connections as strong. Default value is 1/3.">alpha</a>()<span class="keyword"> const</span>
<a name="l00202"></a>00202 <span class="keyword">      </span>{
<a name="l00203"></a>00203         <span class="keywordflow">return</span> alpha_;
<a name="l00204"></a>00204       }
<a name="l00205"></a>00205       
<a name="l00206"></a>00206     <span class="keyword">private</span>:
<a name="l00207"></a>00207       <span class="keywordtype">double</span> alpha_, beta_;
<a name="l00208"></a>00208     };
<a name="l00209"></a>00209     
<a name="l00210"></a>00210     
<a name="l00214"></a>00214     <span class="keyword">template</span>&lt;<span class="keyword">class</span> M, <span class="keyword">class</span> N&gt;
<a name="l00215"></a><a class="code" href="a00046.html">00215</a>     <span class="keyword">class </span><a class="code" href="a00046.html" title="Dependency policy for symmetric matrices.">Dependency</a> : <span class="keyword">public</span> <a class="code" href="a00047.html" title="Paramters needed to check whether a node depends on another.">DependencyParameters</a>
<a name="l00216"></a>00216     {
<a name="l00217"></a>00217     <span class="keyword">public</span>:
<a name="l00221"></a><a class="code" href="a00046.html#1baaec66f4b574b2cef650c8faa3320f">00221</a>       <span class="keyword">typedef</span> M <a class="code" href="a00071.html" title="A generic dynamic matrix.">Matrix</a>;
<a name="l00222"></a>00222       
<a name="l00226"></a><a class="code" href="a00197.html#g321acf98b939f0b93a7410b189e4a2a5">00226</a>       <span class="keyword">typedef</span> N <a class="code" href="a00197.html#g321acf98b939f0b93a7410b189e4a2a5" title="The norm to use for examining the matrix entries.">Norm</a>;
<a name="l00227"></a>00227 
<a name="l00231"></a><a class="code" href="a00197.html#g62b0d02ee5cbaa9714dd453aa0db5567">00231</a>       <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="a00022.html" title="A vector of blocks with memory management.">Matrix::row_type</a> <a class="code" href="a00022.html" title="A vector of blocks with memory management.">Row</a>;
<a name="l00232"></a>00232 
<a name="l00236"></a><a class="code" href="a00197.html#g00c973edf4b506a16aea1fc25a14b897">00236</a>       <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="a00071.html#bd4dbd77caee12c3ebd5291f341c34a5" title="Const iterator for the entries of each row.">Matrix::ConstColIterator</a> <a class="code" href="a00197.html#g00c973edf4b506a16aea1fc25a14b897" title="Constant column iterator of the matrix.">ColIter</a>;
<a name="l00237"></a>00237       
<a name="l00238"></a>00238       <span class="keywordtype">void</span> init(<span class="keyword">const</span> <a class="code" href="a00071.html" title="A generic dynamic matrix.">Matrix</a>* matrix);
<a name="l00239"></a>00239       
<a name="l00240"></a>00240       <span class="keywordtype">void</span> initRow(<span class="keyword">const</span> <a class="code" href="a00022.html" title="A vector of blocks with memory management.">Row</a>&amp; row, <span class="keywordtype">int</span> index);
<a name="l00241"></a>00241 
<a name="l00242"></a>00242       <span class="keywordtype">void</span> examine(<span class="keyword">const</span> <a class="code" href="a00197.html#g00c973edf4b506a16aea1fc25a14b897" title="Constant column iterator of the matrix.">ColIter</a>&amp; col);
<a name="l00243"></a>00243       
<a name="l00244"></a>00244       <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l00245"></a>00245       <span class="keywordtype">void</span> examine(G&amp; graph, <span class="keyword">const</span> <span class="keyword">typename</span> G::EdgeIterator&amp; edge, <span class="keyword">const</span> <a class="code" href="a00197.html#g00c973edf4b506a16aea1fc25a14b897" title="Constant column iterator of the matrix.">ColIter</a>&amp; col);
<a name="l00246"></a>00246 
<a name="l00247"></a>00247       <span class="keywordtype">bool</span> isIsolated();
<a name="l00248"></a>00248     <span class="keyword">private</span>:
<a name="l00250"></a>00250       <span class="keyword">const</span> <a class="code" href="a00071.html" title="A generic dynamic matrix.">Matrix</a>* matrix_;
<a name="l00252"></a>00252       <span class="keyword">typename</span> <a class="code" href="a00071.html#421771888958d68e858f1af6a2b4ad9d" title="Export the type representing the underlying field.">Matrix::field_type</a> maxValue_;
<a name="l00254"></a>00254       <a class="code" href="a00197.html#g321acf98b939f0b93a7410b189e4a2a5" title="The norm to use for examining the matrix entries.">Norm</a> norm_;      
<a name="l00256"></a>00256       <span class="keywordtype">int</span> row_;
<a name="l00258"></a>00258       <span class="keyword">typename</span> <a class="code" href="a00071.html#421771888958d68e858f1af6a2b4ad9d" title="Export the type representing the underlying field.">Matrix::field_type</a> diagonal_;
<a name="l00259"></a>00259     };
<a name="l00260"></a>00260         
<a name="l00264"></a>00264     <span class="keyword">template</span>&lt;<span class="keyword">class</span> M, <span class="keyword">class</span> N&gt;
<a name="l00265"></a><a class="code" href="a00124.html">00265</a>     <span class="keyword">class </span><a class="code" href="a00124.html" title="Dependency policy for symmetric matrices.">SymmetricDependency</a> : <span class="keyword">public</span> <a class="code" href="a00047.html" title="Paramters needed to check whether a node depends on another.">DependencyParameters</a>
<a name="l00266"></a>00266     {
<a name="l00267"></a>00267     <span class="keyword">public</span>:
<a name="l00271"></a><a class="code" href="a00124.html#30338139b017b5a898350c3c5e368a80">00271</a>       <span class="keyword">typedef</span> M <a class="code" href="a00071.html" title="A generic dynamic matrix.">Matrix</a>;
<a name="l00272"></a>00272       
<a name="l00276"></a><a class="code" href="a00197.html#g65efb2e151489eb39de0b953bc205a81">00276</a>       <span class="keyword">typedef</span> N <a class="code" href="a00197.html#g65efb2e151489eb39de0b953bc205a81" title="The norm to use for examining the matrix entries.">Norm</a>;
<a name="l00277"></a>00277 
<a name="l00281"></a><a class="code" href="a00197.html#g4c9089eed18a881ea305ab6eb3a464c0">00281</a>       <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="a00022.html" title="A vector of blocks with memory management.">Matrix::row_type</a> <a class="code" href="a00022.html" title="A vector of blocks with memory management.">Row</a>;
<a name="l00282"></a>00282 
<a name="l00286"></a><a class="code" href="a00197.html#g5354f976f8656a31fb61761f3cfc594b">00286</a>       <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="a00071.html#bd4dbd77caee12c3ebd5291f341c34a5" title="Const iterator for the entries of each row.">Matrix::ConstColIterator</a> <a class="code" href="a00197.html#g5354f976f8656a31fb61761f3cfc594b" title="Constant column iterator of the matrix.">ColIter</a>;
<a name="l00287"></a>00287       
<a name="l00288"></a>00288       <span class="keywordtype">void</span> init(<span class="keyword">const</span> <a class="code" href="a00071.html" title="A generic dynamic matrix.">Matrix</a>* matrix);
<a name="l00289"></a>00289       
<a name="l00290"></a>00290       <span class="keywordtype">void</span> initRow(<span class="keyword">const</span> <a class="code" href="a00022.html" title="A vector of blocks with memory management.">Row</a>&amp; row, <span class="keywordtype">int</span> index);
<a name="l00291"></a>00291 
<a name="l00292"></a>00292       <span class="keywordtype">void</span> examine(<span class="keyword">const</span> <a class="code" href="a00197.html#g5354f976f8656a31fb61761f3cfc594b" title="Constant column iterator of the matrix.">ColIter</a>&amp; col);
<a name="l00293"></a>00293       
<a name="l00294"></a>00294       <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l00295"></a>00295       <span class="keywordtype">void</span> examine(G&amp; graph, <span class="keyword">const</span> <span class="keyword">typename</span> G::EdgeIterator&amp; edge, <span class="keyword">const</span> <a class="code" href="a00197.html#g5354f976f8656a31fb61761f3cfc594b" title="Constant column iterator of the matrix.">ColIter</a>&amp; col);
<a name="l00296"></a>00296 
<a name="l00297"></a>00297       <span class="keywordtype">bool</span> isIsolated();
<a name="l00298"></a>00298     <span class="keyword">private</span>:
<a name="l00300"></a>00300       <span class="keyword">const</span> <a class="code" href="a00071.html" title="A generic dynamic matrix.">Matrix</a>* matrix_;
<a name="l00302"></a>00302       <span class="keyword">typename</span> <a class="code" href="a00071.html#421771888958d68e858f1af6a2b4ad9d" title="Export the type representing the underlying field.">Matrix::field_type</a> maxValue_;
<a name="l00304"></a>00304       <a class="code" href="a00197.html#g65efb2e151489eb39de0b953bc205a81" title="The norm to use for examining the matrix entries.">Norm</a> norm_;      
<a name="l00306"></a>00306       <span class="keywordtype">int</span> row_;
<a name="l00308"></a>00308       <span class="keyword">typename</span> <a class="code" href="a00071.html#421771888958d68e858f1af6a2b4ad9d" title="Export the type representing the underlying field.">Matrix::field_type</a> diagonal_;
<a name="l00309"></a>00309     };
<a name="l00310"></a>00310 
<a name="l00315"></a><a class="code" href="a00049.html">00315</a>     <span class="keyword">class </span><a class="code" href="a00049.html" title="Norm that uses only the [0][0] entry of the block to determine couplings.">FirstDiagonal</a>
<a name="l00316"></a>00316     {
<a name="l00317"></a>00317     <span class="keyword">public</span>:
<a name="l00322"></a>00322       <span class="keyword">template</span>&lt;<span class="keyword">class</span> M&gt;
<a name="l00323"></a><a class="code" href="a00049.html#51a891f33ce0aaedb88b671038aeaa5d">00323</a>       <span class="keyword">typename</span> M::field_type <a class="code" href="a00049.html#51a891f33ce0aaedb88b671038aeaa5d" title="compute the norm of a matrix.">operator()</a>(<span class="keyword">const</span> M&amp; m)<span class="keyword"> const</span>
<a name="l00324"></a>00324 <span class="keyword">      </span>{
<a name="l00325"></a>00325         <span class="keywordflow">return</span> m[0][0];
<a name="l00326"></a>00326       }
<a name="l00327"></a>00327     };
<a name="l00328"></a>00328     
<a name="l00334"></a><a class="code" href="a00098.html">00334</a>     <span class="keyword">struct </span><a class="code" href="a00098.html" title="Functor using the row sum (infinity) norm to determine strong couplings.">RowSum</a>
<a name="l00335"></a>00335     {
<a name="l00340"></a>00340       <span class="keyword">template</span>&lt;<span class="keyword">class</span> M&gt;
<a name="l00341"></a><a class="code" href="a00098.html#d1d6ab449fbdb472f5d1adb1799e6300">00341</a>       <span class="keyword">typename</span> M::field_type <a class="code" href="a00098.html#d1d6ab449fbdb472f5d1adb1799e6300" title="compute the norm of a matrix.">operator()</a>(<span class="keyword">const</span> M&amp; m)<span class="keyword"> const</span>
<a name="l00342"></a>00342 <span class="keyword">      </span>{
<a name="l00343"></a>00343         <span class="keywordflow">return</span> m.infinity_norm();
<a name="l00344"></a>00344       }
<a name="l00345"></a>00345     };
<a name="l00346"></a>00346 
<a name="l00356"></a>00356     <span class="keyword">template</span>&lt;<span class="keyword">class</span> M, <span class="keyword">class</span> Norm&gt;
<a name="l00357"></a><a class="code" href="a00123.html">00357</a>     <span class="keyword">class </span><a class="code" href="a00123.html" title="Criterion taking advantage of symmetric matrices.">SymmetricCriterion</a> : <span class="keyword">public</span> <a class="code" href="a00005.html" title="Base class of all aggregation criterions.">AggregationCriterion</a>&lt;SymmetricDependency&lt;M,Norm&gt; &gt;
<a name="l00358"></a>00358     {};
<a name="l00359"></a>00359 
<a name="l00360"></a>00360     
<a name="l00372"></a>00372     <span class="keyword">template</span>&lt;<span class="keyword">class</span> M, <span class="keyword">class</span> Norm&gt;
<a name="l00373"></a><a class="code" href="a00125.html">00373</a>     <span class="keyword">class </span><a class="code" href="a00125.html" title="Criterion suited for unsymmetric matrices.">UnSymmetricCriterion</a> : <span class="keyword">public</span> <a class="code" href="a00005.html" title="Base class of all aggregation criterions.">AggregationCriterion</a>&lt;Dependency&lt;M,Norm&gt; &gt;
<a name="l00374"></a>00374     {};
<a name="l00375"></a>00375     <span class="comment">// forward declaration</span>
<a name="l00376"></a>00376     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt; <span class="keyword">class </span><a class="code" href="a00006.html" title="Class for building the aggregates.">Aggregator</a>;
<a name="l00377"></a>00377 
<a name="l00378"></a>00378     
<a name="l00386"></a>00386     <span class="keyword">template</span>&lt;<span class="keyword">class</span> V&gt;
<a name="l00387"></a><a class="code" href="a00003.html">00387</a>     <span class="keyword">class </span><a class="code" href="a00003.html" title="Class providing information about the mapping of the vertices onto aggregates.">AggregatesMap</a>
<a name="l00388"></a>00388     {
<a name="l00389"></a>00389     <span class="keyword">public</span>:
<a name="l00390"></a>00390 
<a name="l00394"></a><a class="code" href="a00197.html#gd35c6c9e3aa1ec18c07a97279f8d3f77">00394</a>       <span class="keyword">static</span> <span class="keyword">const</span> V <a class="code" href="a00197.html#gd35c6c9e3aa1ec18c07a97279f8d3f77" title="Identifier of not yet aggregated vertices.">UNAGGREGATED</a>;
<a name="l00395"></a>00395       
<a name="l00399"></a><a class="code" href="a00197.html#g9431f7b35947083f3d2a270a4b3b8bb5">00399</a>       <span class="keyword">static</span> <span class="keyword">const</span> V <a class="code" href="a00197.html#g9431f7b35947083f3d2a270a4b3b8bb5" title="Identifier of isolated vertices.">ISOLATED</a>;
<a name="l00403"></a><a class="code" href="a00197.html#gf657e8e9f35ddf9811f6ab7ea72ab9f5">00403</a>       <span class="keyword">typedef</span> V <a class="code" href="a00197.html#gf657e8e9f35ddf9811f6ab7ea72ab9f5" title="The vertex descriptor type.">VertexDescriptor</a>;
<a name="l00404"></a>00404       
<a name="l00408"></a><a class="code" href="a00197.html#g9258a3f0e9738c7c77d348cbb28b4b8d">00408</a>       <span class="keyword">typedef</span> V <a class="code" href="a00197.html#g9258a3f0e9738c7c77d348cbb28b4b8d" title="The aggregate descriptor type.">AggregateDescriptor</a>;
<a name="l00409"></a>00409 
<a name="l00414"></a><a class="code" href="a00197.html#gfc80ff0c5e84263f6917591bab360129">00414</a>       <span class="keyword">typedef</span> PoolAllocator&lt;VertexDescriptor,100*sizeof(int)&gt; <a class="code" href="a00197.html#gfc80ff0c5e84263f6917591bab360129" title="The allocator we use for our lists and the set.">Allocator</a>;
<a name="l00415"></a>00415       
<a name="l00420"></a><a class="code" href="a00197.html#gb0e20fc899e8046c7a5eb565cd8025f3">00420</a>       <span class="keyword">typedef</span> SLList&lt;VertexDescriptor,Allocator&gt; <a class="code" href="a00197.html#gb0e20fc899e8046c7a5eb565cd8025f3" title="The type of a single linked list of vertex descriptors.">VertexList</a>;
<a name="l00421"></a>00421 
<a name="l00425"></a><a class="code" href="a00004.html">00425</a>       <span class="keyword">class </span><a class="code" href="a00004.html" title="A Dummy visitor that does nothing for each visited edge.">DummyEdgeVisitor</a>
<a name="l00426"></a>00426       {
<a name="l00427"></a>00427       <span class="keyword">public</span>:
<a name="l00428"></a>00428         <span class="keyword">template</span>&lt;<span class="keyword">class</span> EdgeIterator&gt;
<a name="l00429"></a>00429         <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> EdgeIterator&amp; egde)<span class="keyword"> const</span>
<a name="l00430"></a>00430 <span class="keyword">        </span>{}
<a name="l00431"></a>00431       };
<a name="l00432"></a>00432       
<a name="l00433"></a>00433         
<a name="l00437"></a>00437       <a class="code" href="a00197.html#gaa86514f266a48b07787ab5c8440c9a2" title="Constructs without allocating memory.">AggregatesMap</a>();
<a name="l00438"></a>00438       
<a name="l00444"></a>00444       <a class="code" href="a00197.html#gaa86514f266a48b07787ab5c8440c9a2" title="Constructs without allocating memory.">AggregatesMap</a>(std::size_t <a class="code" href="a00197.html#gb4153cc79d23bc09e61b7a3a401cacfc" title="Get the number of vertices.">noVertices</a>);
<a name="l00445"></a>00445 
<a name="l00449"></a>00449       <a class="code" href="a00197.html#g556e4f96555dae9b025dc74b5c16467d" title="Destructor.">~AggregatesMap</a>();
<a name="l00450"></a>00450 
<a name="l00458"></a>00458       <span class="keyword">template</span>&lt;<span class="keyword">class</span> M, <span class="keyword">class</span> G, <span class="keyword">class</span> C&gt;
<a name="l00459"></a>00459       Tuple&lt;int,int,int&gt; <a class="code" href="a00197.html#g259ba5ab939f8b299c4d77129e8ef213" title="Build the aggregates.">buildAggregates</a>(<span class="keyword">const</span> M&amp; matrix, G&amp; graph, <span class="keyword">const</span> C&amp; criterion);
<a name="l00460"></a>00460       
<a name="l00480"></a>00480       <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> reset, <span class="keyword">class</span> G, <span class="keyword">class</span> F, <span class="keyword">class</span> VM&gt;
<a name="l00481"></a>00481       std::size_t <a class="code" href="a00197.html#g271b83cdc0415c6352b36881deac4515" title="Breadth first search within an aggregate.">breadthFirstSearch</a>(<span class="keyword">const</span> <a class="code" href="a00197.html#gf657e8e9f35ddf9811f6ab7ea72ab9f5" title="The vertex descriptor type.">VertexDescriptor</a>&amp; start,
<a name="l00482"></a>00482                              <span class="keyword">const</span> <a class="code" href="a00197.html#g9258a3f0e9738c7c77d348cbb28b4b8d" title="The aggregate descriptor type.">AggregateDescriptor</a>&amp; aggregate, 
<a name="l00483"></a>00483                              G&amp; graph,
<a name="l00484"></a>00484                              F&amp; aggregateVisitor,
<a name="l00485"></a>00485                              VM&amp; visitedMap) <span class="keyword">const</span>;
<a name="l00486"></a>00486       
<a name="l00510"></a>00510       <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> remove, <span class="keywordtype">bool</span> reset, <span class="keyword">class</span> G, <span class="keyword">class</span> L, <span class="keyword">class</span> F1, <span class="keyword">class</span> F2, <span class="keyword">class</span> VM&gt;
<a name="l00511"></a>00511       std::size_t <a class="code" href="a00197.html#g271b83cdc0415c6352b36881deac4515" title="Breadth first search within an aggregate.">breadthFirstSearch</a>(<span class="keyword">const</span> <a class="code" href="a00197.html#gf657e8e9f35ddf9811f6ab7ea72ab9f5" title="The vertex descriptor type.">VertexDescriptor</a>&amp; start, 
<a name="l00512"></a>00512                              <span class="keyword">const</span> <a class="code" href="a00197.html#g9258a3f0e9738c7c77d348cbb28b4b8d" title="The aggregate descriptor type.">AggregateDescriptor</a>&amp; aggregate, 
<a name="l00513"></a>00513                              G&amp; graph, L&amp; visited, F1&amp; aggregateVisitor,
<a name="l00514"></a>00514                              F2&amp; nonAggregateVisitor,
<a name="l00515"></a>00515                              VM&amp; visitedMap) <span class="keyword">const</span>;
<a name="l00516"></a>00516 
<a name="l00522"></a>00522       <span class="keywordtype">void</span> <a class="code" href="a00197.html#gdf10f6b77f88384bcbcd59cfe29a2002" title="Allocate memory for holding the information.">allocate</a>(std::size_t <a class="code" href="a00197.html#gb4153cc79d23bc09e61b7a3a401cacfc" title="Get the number of vertices.">noVertices</a>);
<a name="l00523"></a>00523       
<a name="l00527"></a>00527       std::size_t <a class="code" href="a00197.html#gb4153cc79d23bc09e61b7a3a401cacfc" title="Get the number of vertices.">noVertices</a>() <span class="keyword">const</span>;
<a name="l00528"></a>00528       
<a name="l00532"></a>00532       <span class="keywordtype">void</span> <a class="code" href="a00197.html#gf34f175c3ba3e120b84ca16c8c5df2b8" title="Free the allocated memory.">free</a>();
<a name="l00533"></a>00533             
<a name="l00539"></a>00539       <a class="code" href="a00197.html#g9258a3f0e9738c7c77d348cbb28b4b8d" title="The aggregate descriptor type.">AggregateDescriptor</a>&amp; <a class="code" href="a00197.html#g3e07dfd73a8a798f722c4a09a25bfbd1" title="Get the aggregate a vertex belongs to.">operator[]</a>(<span class="keyword">const</span> <a class="code" href="a00197.html#gf657e8e9f35ddf9811f6ab7ea72ab9f5" title="The vertex descriptor type.">VertexDescriptor</a>&amp; v);
<a name="l00540"></a>00540       
<a name="l00546"></a>00546       <span class="keyword">const</span> <a class="code" href="a00197.html#g9258a3f0e9738c7c77d348cbb28b4b8d" title="The aggregate descriptor type.">AggregateDescriptor</a>&amp; <a class="code" href="a00197.html#g3e07dfd73a8a798f722c4a09a25bfbd1" title="Get the aggregate a vertex belongs to.">operator[]</a>(<span class="keyword">const</span> <a class="code" href="a00197.html#gf657e8e9f35ddf9811f6ab7ea72ab9f5" title="The vertex descriptor type.">VertexDescriptor</a>&amp; v) <span class="keyword">const</span>;
<a name="l00547"></a>00547 
<a name="l00548"></a>00548     <span class="keyword">private</span>:
<a name="l00550"></a>00550       <a class="code" href="a00197.html#gaa86514f266a48b07787ab5c8440c9a2" title="Constructs without allocating memory.">AggregatesMap</a>(<span class="keyword">const</span> <a class="code" href="a00003.html" title="Class providing information about the mapping of the vertices onto aggregates.">AggregatesMap&lt;V&gt;</a>&amp; map)
<a name="l00551"></a>00551       {
<a name="l00552"></a>00552         <span class="keywordflow">throw</span> <span class="stringliteral">"Auch!"</span>;
<a name="l00553"></a>00553       }
<a name="l00554"></a>00554       
<a name="l00556"></a>00556       <a class="code" href="a00003.html" title="Class providing information about the mapping of the vertices onto aggregates.">AggregatesMap&lt;V&gt;</a>&amp; operator=(<span class="keyword">const</span> <a class="code" href="a00003.html" title="Class providing information about the mapping of the vertices onto aggregates.">AggregatesMap&lt;V&gt;</a>&amp; map)
<a name="l00557"></a>00557       {
<a name="l00558"></a>00558         <span class="keywordflow">throw</span> <span class="stringliteral">"Auch!"</span>;
<a name="l00559"></a>00559         <span class="keywordflow">return</span> <span class="keyword">this</span>;
<a name="l00560"></a>00560       }
<a name="l00561"></a>00561       
<a name="l00565"></a>00565       <a class="code" href="a00197.html#g9258a3f0e9738c7c77d348cbb28b4b8d" title="The aggregate descriptor type.">AggregateDescriptor</a>* aggregates_;
<a name="l00566"></a>00566 
<a name="l00570"></a>00570       std::size_t noVertices_;
<a name="l00571"></a>00571     };
<a name="l00572"></a>00572     
<a name="l00573"></a>00573     
<a name="l00578"></a>00578     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l00579"></a><a class="code" href="a00002.html">00579</a>     <span class="keyword">class </span><a class="code" href="a00002.html" title="A class for temporarily storing the vertices of an aggregate in.">Aggregate</a>
<a name="l00580"></a>00580     {
<a name="l00581"></a>00581       
<a name="l00582"></a>00582     <span class="keyword">public</span>:
<a name="l00583"></a>00583             
<a name="l00584"></a>00584       <span class="comment">/***</span>
<a name="l00585"></a>00585 <span class="comment">       * @brief The type of the matrix graph we work with.</span>
<a name="l00586"></a>00586 <span class="comment">       */</span>
<a name="l00587"></a>00587       <span class="keyword">typedef</span> G <a class="code" href="a00073.html" title="The (undirected) graph of a matrix.">MatrixGraph</a>;
<a name="l00591"></a><a class="code" href="a00197.html#gabd0e12ceada9a070a742ea7652852d0">00591</a>       <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="a00073.html#594cca89416b534b0b1a196c39684447" title="The vertex descriptor.">MatrixGraph::VertexDescriptor</a> <a class="code" href="a00197.html#gabd0e12ceada9a070a742ea7652852d0" title="The vertex descriptor type.">Vertex</a>;
<a name="l00592"></a>00592 
<a name="l00597"></a><a class="code" href="a00197.html#g96fded8e7b86869626d75352cf0e37a9">00597</a>       <span class="keyword">typedef</span> PoolAllocator&lt;Vertex,100*sizeof(int)&gt; <a class="code" href="a00197.html#g96fded8e7b86869626d75352cf0e37a9" title="The allocator we use for our lists and the set.">Allocator</a>;
<a name="l00598"></a>00598       
<a name="l00603"></a><a class="code" href="a00197.html#g6e330d1e9b83530c2bf8819a306ca0dd">00603</a>       <span class="keyword">typedef</span> SLList&lt;Vertex,Allocator&gt; <a class="code" href="a00197.html#g6e330d1e9b83530c2bf8819a306ca0dd" title="The type of a single linked list of vertex descriptors.">VertexList</a>;
<a name="l00604"></a>00604 
<a name="l00605"></a>00605       
<a name="l00610"></a><a class="code" href="a00197.html#g9c57586769fb10c7acf56903b5a6403c">00610</a>       <span class="keyword">typedef</span> std::set&lt;Vertex&gt; <a class="code" href="a00197.html#g9c57586769fb10c7acf56903b5a6403c" title="The type of a single linked list of vertex descriptors.">VertexSet</a>;
<a name="l00611"></a>00611 
<a name="l00613"></a><a class="code" href="a00197.html#gf63d25be188f0a6ebc681f857e103879">00613</a>       <span class="keyword">typedef</span> <span class="keyword">typename</span> VertexList::const_iterator <a class="code" href="a00197.html#gf63d25be188f0a6ebc681f857e103879" title="Const iterator over a vertex list.">const_iterator</a>;
<a name="l00614"></a>00614 
<a name="l00618"></a><a class="code" href="a00197.html#g48bdcd97f38278de05e399e0fe826892">00618</a>       <span class="keyword">typedef</span> std::size_t* <a class="code" href="a00197.html#g48bdcd97f38278de05e399e0fe826892" title="Type of the mapping of aggregate members onto distance spheres.">SphereMap</a>;
<a name="l00619"></a>00619       
<a name="l00627"></a>00627       <a class="code" href="a00197.html#gcfd89e6e64868331e0cc94523db3f9cd" title="Constructor.">Aggregate</a>(<span class="keyword">const</span> <a class="code" href="a00073.html" title="The (undirected) graph of a matrix.">MatrixGraph</a>&amp; graph, <a class="code" href="a00003.html" title="Class providing information about the mapping of the vertices onto aggregates.">AggregatesMap&lt;Vertex&gt;</a>&amp; aggregates, 
<a name="l00628"></a>00628                 <a class="code" href="a00197.html#g9c57586769fb10c7acf56903b5a6403c" title="The type of a single linked list of vertex descriptors.">VertexSet</a>&amp; connectivity);
<a name="l00629"></a>00629             
<a name="l00636"></a>00636       <span class="keywordtype">void</span> <a class="code" href="a00197.html#g3e3ec8317ac33f0484a3b68dbfacc883" title="Reconstruct the aggregat from an seed node.">reconstruct</a>(<span class="keyword">const</span> <a class="code" href="a00197.html#gabd0e12ceada9a070a742ea7652852d0" title="The vertex descriptor type.">Vertex</a>&amp; vertex);
<a name="l00637"></a>00637       
<a name="l00641"></a>00641       <span class="keywordtype">void</span> <a class="code" href="a00197.html#ge96703979cf9c2caa2cc3c1b7af2759c" title="Initialize the aggregate with one vertex.">seed</a>(<span class="keyword">const</span> <a class="code" href="a00197.html#gabd0e12ceada9a070a742ea7652852d0" title="The vertex descriptor type.">Vertex</a>&amp; vertex);
<a name="l00642"></a>00642       
<a name="l00646"></a>00646       <span class="keywordtype">void</span> <span class="keyword">add</span>(<span class="keyword">const</span> <a class="code" href="a00197.html#gabd0e12ceada9a070a742ea7652852d0" title="The vertex descriptor type.">Vertex</a>&amp; vertex);
<a name="l00647"></a>00647       
<a name="l00651"></a>00651       <span class="keywordtype">void</span> <a class="code" href="a00197.html#gd84ba771266c30d0fe726665c0978896" title="Clear the aggregate.">clear</a>();
<a name="l00652"></a>00652       
<a name="l00656"></a>00656       <span class="keyword">typename</span> VertexList::size_type <a class="code" href="a00197.html#g5ef0c406a4ca4655f909080b98515057" title="Get the size of the aggregate.">size</a>();
<a name="l00657"></a>00657       
<a name="l00661"></a>00661       <span class="keywordtype">int</span> <a class="code" href="a00197.html#gad837b91f8cb91f906d648fff8389cb4" title="Get the id identifying the aggregate.">id</a>();
<a name="l00662"></a>00662       
<a name="l00664"></a>00664       <a class="code" href="a00197.html#gf63d25be188f0a6ebc681f857e103879" title="Const iterator over a vertex list.">const_iterator</a> <a class="code" href="a00197.html#g941b0f155035fc3d918d48c88a3140fe" title="get an iterator over the vertices of the aggregate.">begin</a>() <span class="keyword">const</span>;
<a name="l00665"></a>00665       
<a name="l00667"></a>00667       <a class="code" href="a00197.html#gf63d25be188f0a6ebc681f857e103879" title="Const iterator over a vertex list.">const_iterator</a> <a class="code" href="a00197.html#g8d1e1147051aaa9cf3d9a21120f91462" title="get an iterator over the vertices of the aggregate.">end</a>() <span class="keyword">const</span>;
<a name="l00668"></a>00668       
<a name="l00669"></a>00669     <span class="keyword">private</span>:
<a name="l00673"></a>00673       <a class="code" href="a00197.html#g6e330d1e9b83530c2bf8819a306ca0dd" title="The type of a single linked list of vertex descriptors.">VertexList</a> vertices_;
<a name="l00674"></a>00674       
<a name="l00679"></a>00679       <span class="keywordtype">int</span> id_;
<a name="l00680"></a>00680 
<a name="l00684"></a>00684       <span class="keyword">const</span> <a class="code" href="a00073.html" title="The (undirected) graph of a matrix.">MatrixGraph</a>&amp; graph_;
<a name="l00685"></a>00685       
<a name="l00689"></a>00689       <a class="code" href="a00003.html" title="Class providing information about the mapping of the vertices onto aggregates.">AggregatesMap&lt;Vertex&gt;</a>&amp; aggregates_;
<a name="l00690"></a>00690 
<a name="l00694"></a>00694       <a class="code" href="a00197.html#g9c57586769fb10c7acf56903b5a6403c" title="The type of a single linked list of vertex descriptors.">VertexSet</a>&amp; connected_;
<a name="l00695"></a>00695     };
<a name="l00696"></a>00696     
<a name="l00700"></a>00700     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l00701"></a><a class="code" href="a00006.html">00701</a>     <span class="keyword">class </span><a class="code" href="a00006.html" title="Class for building the aggregates.">Aggregator</a>
<a name="l00702"></a>00702     {
<a name="l00703"></a>00703     <span class="keyword">public</span>:
<a name="l00704"></a>00704             
<a name="l00708"></a><a class="code" href="a00006.html#239664e57c4c996c7fbd3976267a26d9">00708</a>       <span class="keyword">typedef</span> G <a class="code" href="a00073.html" title="The (undirected) graph of a matrix.">MatrixGraph</a>;
<a name="l00709"></a>00709 
<a name="l00713"></a><a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678">00713</a>       <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="a00073.html#594cca89416b534b0b1a196c39684447" title="The vertex descriptor.">MatrixGraph::VertexDescriptor</a> <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a>;
<a name="l00714"></a>00714       
<a name="l00716"></a><a class="code" href="a00197.html#g753ac555d3d946b7cf76e5ab9b5824c2">00716</a>       <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="a00073.html#594cca89416b534b0b1a196c39684447" title="The vertex descriptor.">MatrixGraph::VertexDescriptor</a> <a class="code" href="a00197.html#g753ac555d3d946b7cf76e5ab9b5824c2" title="The type of the aggregate descriptor.">AggregateDescriptor</a>;
<a name="l00717"></a>00717 
<a name="l00721"></a>00721       <a class="code" href="a00197.html#g841366f64cc179802c21d4fd5a5ac684" title="Constructor.">Aggregator</a>();
<a name="l00722"></a>00722       
<a name="l00726"></a>00726       <a class="code" href="a00197.html#g7d14d8929ca6f47b57706e35c6f83c8b" title="Destructor.">~Aggregator</a>();
<a name="l00727"></a>00727       
<a name="l00740"></a>00740       <span class="keyword">template</span>&lt;<span class="keyword">class</span> M, <span class="keyword">class</span> C&gt;
<a name="l00741"></a>00741       Tuple&lt;int,int,int&gt; <a class="code" href="a00197.html#gecb7eccaaad0ed4c69e17003498d24b4" title="Build the aggregates.">build</a>(<span class="keyword">const</span> M&amp; m, G&amp; graph, 
<a name="l00742"></a>00742                                <a class="code" href="a00003.html" title="Class providing information about the mapping of the vertices onto aggregates.">AggregatesMap&lt;Vertex&gt;</a>&amp; aggregates, <span class="keyword">const</span> C&amp; c);
<a name="l00743"></a>00743     <span class="keyword">private</span>:
<a name="l00748"></a>00748       <span class="keyword">typedef</span> PoolAllocator&lt;Vertex,100*sizeof(int)&gt; Allocator;
<a name="l00749"></a>00749       
<a name="l00753"></a>00753       <span class="keyword">typedef</span> SLList&lt;Vertex,Allocator&gt; VertexList;
<a name="l00754"></a>00754 
<a name="l00758"></a>00758       <span class="keyword">typedef</span> std::set&lt;Vertex&gt; VertexSet;
<a name="l00759"></a>00759 
<a name="l00763"></a>00763       <span class="keyword">typedef</span> std::size_t* SphereMap;
<a name="l00764"></a>00764       
<a name="l00768"></a>00768       <a class="code" href="a00073.html" title="The (undirected) graph of a matrix.">MatrixGraph</a>* graph_;
<a name="l00769"></a>00769       
<a name="l00773"></a>00773       <a class="code" href="a00002.html" title="A class for temporarily storing the vertices of an aggregate in.">Aggregate&lt;MatrixGraph&gt;</a>* aggregate_;
<a name="l00774"></a>00774       
<a name="l00778"></a>00778       VertexList front_;
<a name="l00779"></a>00779 
<a name="l00783"></a>00783       VertexSet connected_;
<a name="l00784"></a>00784             
<a name="l00788"></a>00788       <span class="keywordtype">int</span> size_;
<a name="l00789"></a>00789       
<a name="l00793"></a>00793       <span class="keyword">class </span>Stack
<a name="l00794"></a>00794       {
<a name="l00795"></a>00795       <span class="keyword">public</span>:
<a name="l00796"></a>00796         <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a> NullEntry;
<a name="l00797"></a>00797         
<a name="l00798"></a>00798         Stack(<span class="keyword">const</span> <a class="code" href="a00073.html" title="The (undirected) graph of a matrix.">MatrixGraph</a>&amp; graph, 
<a name="l00799"></a>00799               <span class="keyword">const</span> <a class="code" href="a00006.html" title="Class for building the aggregates.">Aggregator&lt;G&gt;</a>&amp; aggregatesBuilder,
<a name="l00800"></a>00800               <span class="keyword">const</span> <a class="code" href="a00003.html" title="Class providing information about the mapping of the vertices onto aggregates.">AggregatesMap&lt;Vertex&gt;</a>&amp; aggregates);
<a name="l00801"></a>00801         ~Stack();
<a name="l00802"></a>00802         <span class="keywordtype">bool</span> push(<span class="keyword">const</span> <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a>&amp; v);
<a name="l00803"></a>00803         <span class="keywordtype">void</span> fill();
<a name="l00804"></a>00804         <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a> pop();
<a name="l00805"></a>00805       <span class="keyword">private</span>:
<a name="l00806"></a>00806         <span class="keyword">enum</span>{ N = 256000 };
<a name="l00807"></a>00807         
<a name="l00809"></a>00809         <span class="keyword">const</span> <a class="code" href="a00073.html" title="The (undirected) graph of a matrix.">MatrixGraph</a>&amp; graph_;
<a name="l00811"></a>00811         <span class="keyword">const</span> <a class="code" href="a00006.html" title="Class for building the aggregates.">Aggregator&lt;G&gt;</a>&amp; aggregatesBuilder_;
<a name="l00813"></a>00813         <span class="keyword">const</span> <a class="code" href="a00003.html" title="Class providing information about the mapping of the vertices onto aggregates.">AggregatesMap&lt;Vertex&gt;</a>&amp; aggregates_;
<a name="l00815"></a>00815         <span class="keywordtype">int</span> size_;
<a name="l00816"></a>00816         <span class="keywordtype">int</span> maxSize_;
<a name="l00818"></a>00818         <span class="keywordtype">int</span> head_;
<a name="l00819"></a>00819         <span class="keywordtype">int</span> filled_;
<a name="l00820"></a>00820         
<a name="l00822"></a>00822         <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a>* vals_;
<a name="l00823"></a>00823 
<a name="l00824"></a>00824         <span class="keywordtype">void</span> localPush(<span class="keyword">const</span> <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a>&amp; v);
<a name="l00825"></a>00825       };
<a name="l00826"></a>00826 
<a name="l00827"></a>00827       <span class="keyword">friend</span> <span class="keyword">class </span>Stack;
<a name="l00828"></a>00828       
<a name="l00832"></a>00832       <span class="keyword">template</span>&lt;<span class="keyword">class</span> C&gt;
<a name="l00833"></a>00833       <span class="keywordtype">void</span> buildDependency(<a class="code" href="a00006.html#239664e57c4c996c7fbd3976267a26d9" title="The matrix graph type used.">MatrixGraph</a>&amp; graph,
<a name="l00834"></a>00834                            <span class="keyword">const</span> <span class="keyword">typename</span> C::Matrix&amp; matrix,
<a name="l00835"></a>00835                            C criterion);
<a name="l00836"></a>00836 
<a name="l00847"></a>00847       <span class="keyword">template</span>&lt;<span class="keyword">class</span> V&gt;
<a name="l00848"></a>00848       <span class="keywordtype">void</span> visitAggregateNeighbours(<span class="keyword">const</span> <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a>&amp; vertex, <span class="keyword">const</span> <a class="code" href="a00197.html#g753ac555d3d946b7cf76e5ab9b5824c2" title="The type of the aggregate descriptor.">AggregateDescriptor</a>&amp; aggregate,  
<a name="l00849"></a>00849                                     <span class="keyword">const</span> AggregatesMap&lt;Vertex&gt;&amp; aggregates,
<a name="l00850"></a>00850                                     V&amp; visitor) <span class="keyword">const</span>;
<a name="l00851"></a>00851 
<a name="l00856"></a>00856       <span class="keyword">template</span>&lt;<span class="keyword">class</span> V&gt;
<a name="l00857"></a>00857       <span class="keyword">class </span>AggregateVisitor
<a name="l00858"></a>00858       {
<a name="l00859"></a>00859       <span class="keyword">public</span>:
<a name="l00863"></a>00863         <span class="keyword">typedef</span> V Visitor;
<a name="l00871"></a>00871         AggregateVisitor(<span class="keyword">const</span> AggregatesMap&lt;Vertex&gt;&amp; aggregates, <span class="keyword">const</span> <a class="code" href="a00197.html#g753ac555d3d946b7cf76e5ab9b5824c2" title="The type of the aggregate descriptor.">AggregateDescriptor</a>&amp; aggregate,
<a name="l00872"></a>00872                          Visitor&amp; visitor);
<a name="l00873"></a>00873         
<a name="l00880"></a>00880         <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="a00073.html#a09d463bdf24dcddac52b4a7cbbaacf8" title="The constant edge iterator type.">MatrixGraph::ConstEdgeIterator</a>&amp; edge);
<a name="l00881"></a>00881         
<a name="l00882"></a>00882       <span class="keyword">private</span>:
<a name="l00884"></a>00884         <span class="keyword">const</span> AggregatesMap&lt;Vertex&gt;&amp; aggregates_;
<a name="l00886"></a>00886         <a class="code" href="a00197.html#g753ac555d3d946b7cf76e5ab9b5824c2" title="The type of the aggregate descriptor.">AggregateDescriptor</a> aggregate_;
<a name="l00888"></a>00888         Visitor* visitor_;
<a name="l00889"></a>00889       };
<a name="l00890"></a>00890 
<a name="l00894"></a>00894       <span class="keyword">class </span>Counter
<a name="l00895"></a>00895       {
<a name="l00896"></a>00896       <span class="keyword">public</span>:
<a name="l00898"></a>00898         Counter();
<a name="l00900"></a>00900         <span class="keywordtype">int</span> value();
<a name="l00901"></a>00901         
<a name="l00902"></a>00902       <span class="keyword">protected</span>:
<a name="l00904"></a>00904         <span class="keywordtype">void</span> increment();
<a name="l00906"></a>00906         <span class="keywordtype">void</span> decrement();
<a name="l00907"></a>00907         
<a name="l00908"></a>00908       <span class="keyword">private</span>:
<a name="l00909"></a>00909         <span class="keywordtype">int</span> count_;
<a name="l00910"></a>00910       };
<a name="l00911"></a>00911 
<a name="l00912"></a>00912       
<a name="l00917"></a>00917       <span class="keyword">class </span>FrontNeighbourCounter : <span class="keyword">public</span> Counter
<a name="l00918"></a>00918       {
<a name="l00919"></a>00919       <span class="keyword">public</span>:
<a name="l00924"></a>00924         FrontNeighbourCounter(<span class="keyword">const</span> <a class="code" href="a00006.html#239664e57c4c996c7fbd3976267a26d9" title="The matrix graph type used.">MatrixGraph</a>&amp; front);
<a name="l00925"></a>00925         
<a name="l00926"></a>00926         <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="a00073.html#a09d463bdf24dcddac52b4a7cbbaacf8" title="The constant edge iterator type.">MatrixGraph::ConstEdgeIterator</a>&amp; edge);
<a name="l00927"></a>00927         
<a name="l00928"></a>00928       <span class="keyword">private</span>:
<a name="l00929"></a>00929         <span class="keyword">const</span> <a class="code" href="a00006.html#239664e57c4c996c7fbd3976267a26d9" title="The matrix graph type used.">MatrixGraph</a>&amp; graph_;
<a name="l00930"></a>00930       };
<a name="l00931"></a>00931       
<a name="l00936"></a>00936       <span class="keywordtype">int</span> noFrontNeighbours(<span class="keyword">const</span> <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a>&amp; vertex) <span class="keyword">const</span>;
<a name="l00937"></a>00937       
<a name="l00941"></a>00941       <span class="keyword">class </span>TwoWayCounter : <span class="keyword">public</span> Counter
<a name="l00942"></a>00942       {
<a name="l00943"></a>00943       <span class="keyword">public</span>:
<a name="l00944"></a>00944         <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="a00073.html#a09d463bdf24dcddac52b4a7cbbaacf8" title="The constant edge iterator type.">MatrixGraph::ConstEdgeIterator</a>&amp; edge);
<a name="l00945"></a>00945       };
<a name="l00946"></a>00946 
<a name="l00958"></a>00958       <span class="keywordtype">int</span> twoWayConnections(<span class="keyword">const</span> <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a>&amp;, <span class="keyword">const</span> <a class="code" href="a00197.html#g753ac555d3d946b7cf76e5ab9b5824c2" title="The type of the aggregate descriptor.">AggregateDescriptor</a>&amp; aggregate,  
<a name="l00959"></a>00959                              <span class="keyword">const</span> AggregatesMap&lt;Vertex&gt;&amp; aggregates) <span class="keyword">const</span>;
<a name="l00960"></a>00960 
<a name="l00964"></a>00964       <span class="keyword">class </span>OneWayCounter : <span class="keyword">public</span> Counter
<a name="l00965"></a>00965       {
<a name="l00966"></a>00966       <span class="keyword">public</span>:
<a name="l00967"></a>00967         <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="a00073.html#a09d463bdf24dcddac52b4a7cbbaacf8" title="The constant edge iterator type.">MatrixGraph::ConstEdgeIterator</a>&amp; edge);
<a name="l00968"></a>00968       };        
<a name="l00969"></a>00969 
<a name="l00981"></a>00981       <span class="keywordtype">int</span> oneWayConnections(<span class="keyword">const</span> <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a>&amp;, <span class="keyword">const</span> <a class="code" href="a00197.html#g753ac555d3d946b7cf76e5ab9b5824c2" title="The type of the aggregate descriptor.">AggregateDescriptor</a>&amp; aggregate,  
<a name="l00982"></a>00982                             <span class="keyword">const</span> AggregatesMap&lt;Vertex&gt;&amp; aggregates) <span class="keyword">const</span>;
<a name="l00983"></a>00983       
<a name="l00990"></a>00990       <span class="keyword">class </span>ConnectivityCounter : <span class="keyword">public</span> Counter
<a name="l00991"></a>00991       {
<a name="l00992"></a>00992       <span class="keyword">public</span>:
<a name="l00999"></a>00999         ConnectivityCounter(<span class="keyword">const</span> VertexSet&amp; connected, <span class="keyword">const</span> AggregatesMap&lt;Vertex&gt;&amp; aggregates);
<a name="l01000"></a>01000 
<a name="l01001"></a>01001         <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="a00073.html#a09d463bdf24dcddac52b4a7cbbaacf8" title="The constant edge iterator type.">MatrixGraph::ConstEdgeIterator</a>&amp; edge);
<a name="l01002"></a>01002 
<a name="l01003"></a>01003       <span class="keyword">private</span>:
<a name="l01005"></a>01005         <span class="keyword">const</span> VertexSet&amp; connected_;
<a name="l01007"></a>01007         <span class="keyword">const</span> AggregatesMap&lt;Vertex&gt;&amp; aggregates_;
<a name="l01008"></a>01008         
<a name="l01009"></a>01009       };
<a name="l01010"></a>01010 
<a name="l01022"></a>01022       <span class="keywordtype">double</span> connectivity(<span class="keyword">const</span> <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a>&amp; vertex, <span class="keyword">const</span> AggregatesMap&lt;Vertex&gt;&amp; aggregates) <span class="keyword">const</span>;
<a name="l01023"></a>01023       
<a name="l01031"></a>01031       <span class="keyword">class </span>DependencyCounter: <span class="keyword">public</span> Counter
<a name="l01032"></a>01032       {
<a name="l01033"></a>01033       <span class="keyword">public</span>:
<a name="l01037"></a>01037         DependencyCounter();
<a name="l01038"></a>01038         
<a name="l01039"></a>01039         <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="a00073.html#a09d463bdf24dcddac52b4a7cbbaacf8" title="The constant edge iterator type.">MatrixGraph::ConstEdgeIterator</a>&amp; edge);
<a name="l01040"></a>01040       };
<a name="l01041"></a>01041       
<a name="l01048"></a>01048       <span class="keyword">class </span>FrontMarker
<a name="l01049"></a>01049       {
<a name="l01050"></a>01050       <span class="keyword">public</span>:
<a name="l01057"></a>01057         FrontMarker(VertexList&amp; front, <a class="code" href="a00006.html#239664e57c4c996c7fbd3976267a26d9" title="The matrix graph type used.">MatrixGraph</a>&amp; graph);
<a name="l01058"></a>01058         
<a name="l01059"></a>01059         <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="a00073.html#a09d463bdf24dcddac52b4a7cbbaacf8" title="The constant edge iterator type.">MatrixGraph::ConstEdgeIterator</a>&amp; edge);
<a name="l01060"></a>01060         
<a name="l01061"></a>01061       <span class="keyword">private</span>:
<a name="l01063"></a>01063         VertexList&amp; front_;
<a name="l01065"></a>01065         <a class="code" href="a00006.html#239664e57c4c996c7fbd3976267a26d9" title="The matrix graph type used.">MatrixGraph</a>&amp; graph_;
<a name="l01066"></a>01066       };
<a name="l01067"></a>01067 
<a name="l01074"></a>01074       <span class="keywordtype">void</span> markFront(<span class="keyword">const</span> AggregatesMap&lt;Vertex&gt;&amp; aggregates);
<a name="l01075"></a>01075       
<a name="l01079"></a>01079       <span class="keywordtype">void</span> unmarkFront();
<a name="l01080"></a>01080       
<a name="l01095"></a>01095       <span class="keywordtype">int</span> unusedNeighbours(<span class="keyword">const</span> <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a>&amp; vertex, <span class="keyword">const</span> AggregatesMap&lt;Vertex&gt;&amp; aggregates) <span class="keyword">const</span>;
<a name="l01096"></a>01096 
<a name="l01110"></a>01110       std::pair&lt;int,int&gt; neighbours(<span class="keyword">const</span> <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a>&amp; vertex, 
<a name="l01111"></a>01111                                     <span class="keyword">const</span> <a class="code" href="a00197.html#g753ac555d3d946b7cf76e5ab9b5824c2" title="The type of the aggregate descriptor.">AggregateDescriptor</a>&amp; aggregate,
<a name="l01112"></a>01112                                     <span class="keyword">const</span> AggregatesMap&lt;Vertex&gt;&amp; aggregates) <span class="keyword">const</span>;
<a name="l01129"></a>01129       <span class="keywordtype">int</span> aggregateNeighbours(<span class="keyword">const</span> <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a>&amp; vertex, <span class="keyword">const</span> <a class="code" href="a00197.html#g753ac555d3d946b7cf76e5ab9b5824c2" title="The type of the aggregate descriptor.">AggregateDescriptor</a>&amp; aggregate, <span class="keyword">const</span> AggregatesMap&lt;Vertex&gt;&amp; aggregates) <span class="keyword">const</span>;
<a name="l01130"></a>01130       
<a name="l01138"></a>01138       <span class="keywordtype">bool</span> admissible(<span class="keyword">const</span> <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a>&amp; vertex, <span class="keyword">const</span> <a class="code" href="a00197.html#g753ac555d3d946b7cf76e5ab9b5824c2" title="The type of the aggregate descriptor.">AggregateDescriptor</a>&amp; aggregate, <span class="keyword">const</span> AggregatesMap&lt;Vertex&gt;&amp; aggregates) <span class="keyword">const</span>;
<a name="l01139"></a>01139       
<a name="l01146"></a>01146       <span class="keywordtype">void</span> seedFromFront(Stack&amp; stack,  <span class="keywordtype">bool</span> isolated);
<a name="l01147"></a>01147         
<a name="l01155"></a>01155       std::size_t distance(<span class="keyword">const</span> <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a>&amp; vertex, <span class="keyword">const</span> AggregatesMap&lt;Vertex&gt;&amp; aggregates);
<a name="l01156"></a>01156 
<a name="l01165"></a>01165       <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a> mergeNeighbour(<span class="keyword">const</span> <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a>&amp; vertex, <span class="keyword">const</span> AggregatesMap&lt;Vertex&gt;&amp; aggregates) <span class="keyword">const</span>;
<a name="l01166"></a>01166 
<a name="l01174"></a>01174       <span class="keyword">template</span>&lt;<span class="keyword">class</span> C&gt;
<a name="l01175"></a>01175       <span class="keywordtype">void</span> growAggregate(<span class="keyword">const</span> <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a>&amp; vertex, <span class="keyword">const</span> AggregatesMap&lt;Vertex&gt;&amp; aggregates, <span class="keyword">const</span> C&amp; c);
<a name="l01176"></a>01176     };
<a name="l01177"></a>01177 
<a name="l01178"></a>01178     <span class="keyword">template</span>&lt;<span class="keyword">class</span> M, <span class="keyword">class</span> N&gt;
<a name="l01179"></a>01179     <span class="keyword">inline</span> <span class="keywordtype">void</span> SymmetricDependency&lt;M,N&gt;::init(<span class="keyword">const</span> Matrix* matrix)
<a name="l01180"></a>01180     {
<a name="l01181"></a>01181       matrix_ = matrix;
<a name="l01182"></a>01182     }
<a name="l01183"></a>01183     
<a name="l01184"></a>01184     <span class="keyword">template</span>&lt;<span class="keyword">class</span> M, <span class="keyword">class</span> N&gt;
<a name="l01185"></a>01185     <span class="keyword">inline</span> <span class="keywordtype">void</span> SymmetricDependency&lt;M,N&gt;::initRow(<span class="keyword">const</span> Row&amp; row, <span class="keywordtype">int</span> index)
<a name="l01186"></a>01186     {
<a name="l01187"></a>01187       maxValue_ = std::min(- std::numeric_limits&lt;typename Matrix::field_type&gt;::max(), std::numeric_limits&lt;typename Matrix::field_type&gt;::min());
<a name="l01188"></a>01188       row_ = index;
<a name="l01189"></a>01189       diagonal_ = norm_(matrix_-&gt;operator[](row_)[row_]);
<a name="l01190"></a>01190     }
<a name="l01191"></a>01191 
<a name="l01192"></a>01192     <span class="keyword">template</span>&lt;<span class="keyword">class</span> M, <span class="keyword">class</span> N&gt;
<a name="l01193"></a>01193     <span class="keyword">inline</span> <span class="keywordtype">void</span> SymmetricDependency&lt;M,N&gt;::examine(<span class="keyword">const</span> ColIter&amp; col)
<a name="l01194"></a>01194     {
<a name="l01195"></a>01195       maxValue_ = std::max(maxValue_, 
<a name="l01196"></a>01196                            (norm_(*col) * norm_(matrix_-&gt;operator[](col.index())[row_]))/
<a name="l01197"></a>01197                            (norm_(matrix_-&gt;operator[](col.index())[col.index()]) * diagonal_));
<a name="l01198"></a>01198       <span class="comment">//(diagonal_*diagonal_));</span>
<a name="l01199"></a>01199     }
<a name="l01200"></a>01200     
<a name="l01201"></a>01201     <span class="keyword">template</span>&lt;<span class="keyword">class</span> M, <span class="keyword">class</span> N&gt;
<a name="l01202"></a>01202     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01203"></a>01203     <span class="keyword">inline</span> <span class="keywordtype">void</span> SymmetricDependency&lt;M,N&gt;::examine(G&amp; graph, <span class="keyword">const</span> <span class="keyword">typename</span> G::EdgeIterator&amp; edge, <span class="keyword">const</span> ColIter&amp; col)
<a name="l01204"></a>01204     {      
<a name="l01205"></a>01205       <span class="keywordflow">if</span>(norm_(matrix_-&gt;operator[](edge.target())[edge.source()]) * norm_(*col)/
<a name="l01206"></a>01206          (norm_(matrix_-&gt;operator[](edge.target())[edge.target()]) * diagonal_) &gt; alpha() * maxValue_){
<a name="l01207"></a>01207         <span class="comment">//(diagonal_ * diagonal_) &gt; alpha() * maxValue_){</span>
<a name="l01208"></a>01208         edge.properties().setDepends();
<a name="l01209"></a>01209         edge.properties().setInfluences();
<a name="l01210"></a>01210 
<a name="l01211"></a>01211         <span class="keyword">typename</span> G::EdgeProperties&amp; other = graph.getEdgeProperties(edge.target(), edge.source());
<a name="l01212"></a>01212         other.setInfluences();
<a name="l01213"></a>01213         other.setDepends();
<a name="l01214"></a>01214       }
<a name="l01215"></a>01215     }
<a name="l01216"></a>01216     
<a name="l01217"></a>01217     <span class="keyword">template</span>&lt;<span class="keyword">class</span> M, <span class="keyword">class</span> N&gt;
<a name="l01218"></a>01218     <span class="keyword">inline</span> <span class="keywordtype">bool</span> SymmetricDependency&lt;M,N&gt;::isIsolated()
<a name="l01219"></a>01219     {
<a name="l01220"></a>01220       <span class="keywordflow">return</span> maxValue_  &lt; beta();
<a name="l01221"></a>01221     }
<a name="l01222"></a>01222     
<a name="l01223"></a>01223     
<a name="l01224"></a>01224     <span class="keyword">template</span>&lt;<span class="keyword">class</span> M, <span class="keyword">class</span> N&gt;
<a name="l01225"></a>01225     <span class="keyword">inline</span> <span class="keywordtype">void</span> Dependency&lt;M,N&gt;::init(<span class="keyword">const</span> Matrix* matrix)
<a name="l01226"></a>01226     {
<a name="l01227"></a>01227       matrix_ = matrix;
<a name="l01228"></a>01228     }
<a name="l01229"></a>01229     
<a name="l01230"></a>01230     <span class="keyword">template</span>&lt;<span class="keyword">class</span> M, <span class="keyword">class</span> N&gt;
<a name="l01231"></a>01231     <span class="keyword">inline</span> <span class="keywordtype">void</span> Dependency&lt;M,N&gt;::initRow(<span class="keyword">const</span> Row&amp; row, <span class="keywordtype">int</span> index)
<a name="l01232"></a>01232     {
<a name="l01233"></a>01233       maxValue_ = std::min(- std::numeric_limits&lt;typename Matrix::field_type&gt;::max(), std::numeric_limits&lt;typename Matrix::field_type&gt;::min());
<a name="l01234"></a>01234       row_ = index;
<a name="l01235"></a>01235       diagonal_ = matrix_-&gt;operator[](row_)[row_];
<a name="l01236"></a>01236     }
<a name="l01237"></a>01237 
<a name="l01238"></a>01238     <span class="keyword">template</span>&lt;<span class="keyword">class</span> M, <span class="keyword">class</span> N&gt;
<a name="l01239"></a>01239     <span class="keyword">inline</span> <span class="keywordtype">void</span> Dependency&lt;M,N&gt;::examine(<span class="keyword">const</span> ColIter&amp; col)
<a name="l01240"></a>01240     {
<a name="l01241"></a>01241       maxValue_ = std::max(maxValue_, 
<a name="l01242"></a>01242                            -*col);
<a name="l01243"></a>01243     }
<a name="l01244"></a>01244     
<a name="l01245"></a>01245     <span class="keyword">template</span>&lt;<span class="keyword">class</span> M, <span class="keyword">class</span> N&gt;
<a name="l01246"></a>01246     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01247"></a>01247     <span class="keyword">inline</span> <span class="keywordtype">void</span> Dependency&lt;M,N&gt;::examine(G&amp; graph, <span class="keyword">const</span> <span class="keyword">typename</span> G::EdgeIterator&amp; edge, <span class="keyword">const</span> ColIter&amp; col)
<a name="l01248"></a>01248     {      
<a name="l01249"></a>01249       <span class="keywordflow">if</span>(-*col &gt;= maxValue_ * alpha()){
<a name="l01250"></a>01250         edge.properties().setDepends();
<a name="l01251"></a>01251         edge.properties().setInfluences();
<a name="l01252"></a>01252       }
<a name="l01253"></a>01253     }
<a name="l01254"></a>01254     
<a name="l01255"></a>01255     <span class="keyword">template</span>&lt;<span class="keyword">class</span> M, <span class="keyword">class</span> N&gt;
<a name="l01256"></a>01256     <span class="keyword">inline</span> <span class="keywordtype">bool</span> Dependency&lt;M,N&gt;::isIsolated()
<a name="l01257"></a>01257     {
<a name="l01258"></a>01258       <span class="keywordflow">return</span> maxValue_  &lt; beta() * diagonal_;
<a name="l01259"></a>01259     }
<a name="l01260"></a>01260     
<a name="l01261"></a>01261     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01262"></a><a class="code" href="a00197.html#gcfd89e6e64868331e0cc94523db3f9cd">01262</a>     <a class="code" href="a00002.html" title="A class for temporarily storing the vertices of an aggregate in.">Aggregate&lt;G&gt;::Aggregate</a>(<span class="keyword">const</span> <a class="code" href="a00073.html" title="The (undirected) graph of a matrix.">MatrixGraph</a>&amp; graph, <a class="code" href="a00003.html" title="Class providing information about the mapping of the vertices onto aggregates.">AggregatesMap&lt;Vertex&gt;</a>&amp; aggregates,
<a name="l01263"></a>01263                             <a class="code" href="a00197.html#g9c57586769fb10c7acf56903b5a6403c" title="The type of a single linked list of vertex descriptors.">VertexSet</a>&amp; connected)
<a name="l01264"></a>01264       : vertices_(), id_(-1), graph_(graph), aggregates_(aggregates),
<a name="l01265"></a>01265         connected_(connected)
<a name="l01266"></a>01266     {}
<a name="l01267"></a>01267     
<a name="l01268"></a>01268     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01269"></a><a class="code" href="a00197.html#g3e3ec8317ac33f0484a3b68dbfacc883">01269</a>     <span class="keywordtype">void</span> <a class="code" href="a00002.html" title="A class for temporarily storing the vertices of an aggregate in.">Aggregate&lt;G&gt;::reconstruct</a>(<span class="keyword">const</span> <a class="code" href="a00197.html#gabd0e12ceada9a070a742ea7652852d0" title="The vertex descriptor type.">Vertex</a>&amp; vertex)
<a name="l01270"></a>01270     {
<a name="l01271"></a>01271       vertices_.push_back(vertex);
<a name="l01272"></a>01272       <span class="keyword">typedef</span> <span class="keyword">typename</span> VertexList::const_iterator iterator;
<a name="l01273"></a>01273       iterator <a class="code" href="a00197.html#g941b0f155035fc3d918d48c88a3140fe" title="get an iterator over the vertices of the aggregate.">begin</a> = vertices_.begin();
<a name="l01274"></a>01274       iterator <a class="code" href="a00197.html#g8d1e1147051aaa9cf3d9a21120f91462" title="get an iterator over the vertices of the aggregate.">end</a>   = vertices_.end();
<a name="l01275"></a>01275       <span class="keywordflow">throw</span> <span class="stringliteral">"Not yet implemented"</span>;
<a name="l01276"></a>01276 
<a name="l01277"></a>01277       <span class="keywordflow">while</span>(begin!=end){
<a name="l01278"></a>01278         <span class="comment">//for();</span>
<a name="l01279"></a>01279       }
<a name="l01280"></a>01280       
<a name="l01281"></a>01281     }
<a name="l01282"></a>01282     
<a name="l01283"></a>01283     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01284"></a><a class="code" href="a00197.html#ge96703979cf9c2caa2cc3c1b7af2759c">01284</a>     <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="a00002.html" title="A class for temporarily storing the vertices of an aggregate in.">Aggregate&lt;G&gt;::seed</a>(<span class="keyword">const</span> <a class="code" href="a00197.html#gabd0e12ceada9a070a742ea7652852d0" title="The vertex descriptor type.">Vertex</a>&amp; vertex)
<a name="l01285"></a>01285     {
<a name="l01286"></a>01286       dvverb&lt;&lt;<span class="stringliteral">"Connected cleared"</span>&lt;&lt;std::endl;
<a name="l01287"></a>01287       connected_.clear();
<a name="l01288"></a>01288       vertices_.clear();
<a name="l01289"></a>01289       connected_.insert(vertex);
<a name="l01290"></a>01290       dvverb &lt;&lt; <span class="stringliteral">" Inserting "</span>&lt;&lt;vertex&lt;&lt;<span class="stringliteral">" size="</span>&lt;&lt;connected_.size();
<a name="l01291"></a>01291       id_ = vertex;
<a name="l01292"></a>01292       <span class="keyword">add</span>(vertex);
<a name="l01293"></a>01293     }
<a name="l01294"></a>01294     
<a name="l01295"></a>01295 
<a name="l01296"></a>01296     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01297"></a><a class="code" href="a00197.html#gfce9bc3b2241e2d61f1ea626ab2b48c6">01297</a>     <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="a00002.html" title="A class for temporarily storing the vertices of an aggregate in.">Aggregate&lt;G&gt;::add</a>(<span class="keyword">const</span> <a class="code" href="a00197.html#gabd0e12ceada9a070a742ea7652852d0" title="The vertex descriptor type.">Vertex</a>&amp; vertex)
<a name="l01298"></a>01298     {
<a name="l01299"></a>01299       vertices_.push_back(vertex);
<a name="l01300"></a>01300       aggregates_[vertex]=id_;
<a name="l01301"></a>01301 
<a name="l01302"></a>01302       <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="a00074.html" title="Iterator over all edges starting from a vertex.">MatrixGraph::ConstEdgeIterator</a> iterator;
<a name="l01303"></a>01303       <span class="keyword">const</span> iterator <a class="code" href="a00197.html#g8d1e1147051aaa9cf3d9a21120f91462" title="get an iterator over the vertices of the aggregate.">end</a> = graph_.<a class="code" href="a00197.html#g0c8a05b9dc5ae4644284f7d8bfcabc0d" title="Get an iterator over the edges starting at a vertex.">endEdges</a>(vertex);
<a name="l01304"></a>01304       <span class="keywordflow">for</span>(iterator edge = graph_.<a class="code" href="a00197.html#g998ea57efbb86e1bdb4c0c5db7b33bb4" title="Get an iterator over the edges starting at a vertex.">beginEdges</a>(vertex); edge != end; ++edge){
<a name="l01305"></a>01305         dvverb &lt;&lt; <span class="stringliteral">" Inserting "</span>&lt;&lt;aggregates_[edge.target()];
<a name="l01306"></a>01306         connected_.insert(aggregates_[edge.target()]);
<a name="l01307"></a>01307         dvverb &lt;&lt;<span class="stringliteral">" size="</span>&lt;&lt;connected_.size();
<a name="l01308"></a>01308       }
<a name="l01309"></a>01309       dvverb &lt;&lt;std::endl;
<a name="l01310"></a>01310     }
<a name="l01311"></a>01311     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01312"></a><a class="code" href="a00197.html#gd84ba771266c30d0fe726665c0978896">01312</a>     <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="a00002.html" title="A class for temporarily storing the vertices of an aggregate in.">Aggregate&lt;G&gt;::clear</a>()
<a name="l01313"></a>01313     {
<a name="l01314"></a>01314       vertices_.clear();
<a name="l01315"></a>01315       connected_.clear();
<a name="l01316"></a>01316       id_=-1;
<a name="l01317"></a>01317     }
<a name="l01318"></a>01318     
<a name="l01319"></a>01319     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01320"></a>01320     <span class="keyword">inline</span> <span class="keyword">typename</span> <a class="code" href="a00002.html" title="A class for temporarily storing the vertices of an aggregate in.">Aggregate&lt;G&gt;::VertexList::size_type</a> 
<a name="l01321"></a><a class="code" href="a00197.html#g5ef0c406a4ca4655f909080b98515057">01321</a>     <a class="code" href="a00002.html" title="A class for temporarily storing the vertices of an aggregate in.">Aggregate&lt;G&gt;::size</a>()
<a name="l01322"></a>01322     {
<a name="l01323"></a>01323       <span class="keywordflow">return</span> vertices_.size();
<a name="l01324"></a>01324     }
<a name="l01325"></a>01325     
<a name="l01326"></a>01326     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01327"></a><a class="code" href="a00197.html#gad837b91f8cb91f906d648fff8389cb4">01327</a>     <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="a00002.html" title="A class for temporarily storing the vertices of an aggregate in.">Aggregate&lt;G&gt;::id</a>()
<a name="l01328"></a>01328     {
<a name="l01329"></a>01329       <span class="keywordflow">return</span> id_;
<a name="l01330"></a>01330     }
<a name="l01331"></a>01331 
<a name="l01332"></a>01332     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01333"></a><a class="code" href="a00197.html#g941b0f155035fc3d918d48c88a3140fe">01333</a>     <span class="keyword">inline</span> <span class="keyword">typename</span> <a class="code" href="a00002.html" title="A class for temporarily storing the vertices of an aggregate in.">Aggregate&lt;G&gt;::const_iterator</a> <a class="code" href="a00002.html" title="A class for temporarily storing the vertices of an aggregate in.">Aggregate&lt;G&gt;::begin</a>()<span class="keyword"> const</span>
<a name="l01334"></a>01334 <span class="keyword">    </span>{
<a name="l01335"></a>01335       <span class="keywordflow">return</span> vertices_.begin();
<a name="l01336"></a>01336     }
<a name="l01337"></a>01337     
<a name="l01338"></a>01338     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01339"></a><a class="code" href="a00197.html#g8d1e1147051aaa9cf3d9a21120f91462">01339</a>     <span class="keyword">inline</span> <span class="keyword">typename</span> <a class="code" href="a00002.html" title="A class for temporarily storing the vertices of an aggregate in.">Aggregate&lt;G&gt;::const_iterator</a> <a class="code" href="a00002.html" title="A class for temporarily storing the vertices of an aggregate in.">Aggregate&lt;G&gt;::end</a>()<span class="keyword"> const</span>
<a name="l01340"></a>01340 <span class="keyword">    </span>{
<a name="l01341"></a>01341       <span class="keywordflow">return</span> vertices_.end();
<a name="l01342"></a>01342     }
<a name="l01343"></a>01343 
<a name="l01344"></a>01344     <span class="keyword">template</span>&lt;<span class="keyword">class</span> V&gt; 
<a name="l01345"></a>01345     <span class="keyword">const</span> V <a class="code" href="a00003.html" title="Class providing information about the mapping of the vertices onto aggregates.">AggregatesMap&lt;V&gt;::UNAGGREGATED</a> = std::numeric_limits&lt;V&gt;::max();
<a name="l01346"></a>01346     
<a name="l01347"></a>01347     <span class="keyword">template</span>&lt;<span class="keyword">class</span> V&gt; 
<a name="l01348"></a>01348     <span class="keyword">const</span> V <a class="code" href="a00003.html" title="Class providing information about the mapping of the vertices onto aggregates.">AggregatesMap&lt;V&gt;::ISOLATED</a> = std::numeric_limits&lt;V&gt;::max()-1;
<a name="l01349"></a>01349     
<a name="l01350"></a>01350     <span class="keyword">template</span>&lt;<span class="keyword">class</span> V&gt;
<a name="l01351"></a><a class="code" href="a00197.html#gaa86514f266a48b07787ab5c8440c9a2">01351</a>     <a class="code" href="a00003.html" title="Class providing information about the mapping of the vertices onto aggregates.">AggregatesMap&lt;V&gt;::AggregatesMap</a>()
<a name="l01352"></a>01352       : aggregates_(0)
<a name="l01353"></a>01353     {}
<a name="l01354"></a>01354 
<a name="l01355"></a>01355     <span class="keyword">template</span>&lt;<span class="keyword">class</span> V&gt;
<a name="l01356"></a><a class="code" href="a00197.html#g556e4f96555dae9b025dc74b5c16467d">01356</a>     <a class="code" href="a00003.html" title="Class providing information about the mapping of the vertices onto aggregates.">AggregatesMap&lt;V&gt;::~AggregatesMap</a>()
<a name="l01357"></a>01357     {
<a name="l01358"></a>01358       <span class="keywordflow">if</span>(aggregates_!=0)
<a name="l01359"></a>01359         <span class="keyword">delete</span>[] aggregates_;
<a name="l01360"></a>01360     }
<a name="l01361"></a>01361     
<a name="l01362"></a>01362 
<a name="l01363"></a>01363     <span class="keyword">template</span>&lt;<span class="keyword">class</span> V&gt;
<a name="l01364"></a><a class="code" href="a00197.html#ga57de3c523ca120b4deec855f5e4c124">01364</a>     <span class="keyword">inline</span> <a class="code" href="a00003.html" title="Class providing information about the mapping of the vertices onto aggregates.">AggregatesMap&lt;V&gt;::AggregatesMap</a>(std::size_t <a class="code" href="a00197.html#gb4153cc79d23bc09e61b7a3a401cacfc" title="Get the number of vertices.">noVertices</a>)
<a name="l01365"></a>01365     {
<a name="l01366"></a>01366       <a class="code" href="a00197.html#gdf10f6b77f88384bcbcd59cfe29a2002" title="Allocate memory for holding the information.">allocate</a>(noVertices);
<a name="l01367"></a>01367     }
<a name="l01368"></a>01368 
<a name="l01369"></a>01369     <span class="keyword">template</span>&lt;<span class="keyword">class</span> V&gt;
<a name="l01370"></a>01370     <span class="keyword">inline</span> std::size_t <a class="code" href="a00003.html" title="Class providing information about the mapping of the vertices onto aggregates.">AggregatesMap&lt;V&gt;::AggregatesMap::noVertices</a>()<span class="keyword"> const</span>
<a name="l01371"></a>01371 <span class="keyword">    </span>{
<a name="l01372"></a>01372       <span class="keywordflow">return</span> noVertices_;
<a name="l01373"></a>01373     }
<a name="l01374"></a>01374     
<a name="l01375"></a>01375     <span class="keyword">template</span>&lt;<span class="keyword">class</span> V&gt;
<a name="l01376"></a><a class="code" href="a00197.html#gdf10f6b77f88384bcbcd59cfe29a2002">01376</a>     <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="a00003.html" title="Class providing information about the mapping of the vertices onto aggregates.">AggregatesMap&lt;V&gt;::allocate</a>(std::size_t <a class="code" href="a00197.html#gb4153cc79d23bc09e61b7a3a401cacfc" title="Get the number of vertices.">noVertices</a>)
<a name="l01377"></a>01377     {
<a name="l01378"></a>01378       aggregates_ = <span class="keyword">new</span> <a class="code" href="a00197.html#g9258a3f0e9738c7c77d348cbb28b4b8d" title="The aggregate descriptor type.">AggregateDescriptor</a>[noVertices];
<a name="l01379"></a>01379       noVertices_ = noVertices;
<a name="l01380"></a>01380       
<a name="l01381"></a>01381       <span class="keywordflow">for</span>(std::size_t i=0; i &lt; noVertices; i++)
<a name="l01382"></a>01382         aggregates_[i]=<a class="code" href="a00197.html#gd35c6c9e3aa1ec18c07a97279f8d3f77" title="Identifier of not yet aggregated vertices.">UNAGGREGATED</a>;
<a name="l01383"></a>01383     }
<a name="l01384"></a>01384 
<a name="l01385"></a>01385     <span class="keyword">template</span>&lt;<span class="keyword">class</span> V&gt;
<a name="l01386"></a><a class="code" href="a00197.html#gf34f175c3ba3e120b84ca16c8c5df2b8">01386</a>     <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="a00003.html" title="Class providing information about the mapping of the vertices onto aggregates.">AggregatesMap&lt;V&gt;::free</a>()
<a name="l01387"></a>01387     {
<a name="l01388"></a>01388       assert(aggregates_ != 0);
<a name="l01389"></a>01389       <span class="keyword">delete</span>[] aggregates_;
<a name="l01390"></a>01390       aggregates_=0;
<a name="l01391"></a>01391     }
<a name="l01392"></a>01392     
<a name="l01393"></a>01393     <span class="keyword">template</span>&lt;<span class="keyword">class</span> V&gt;
<a name="l01394"></a>01394     <span class="keyword">inline</span> <span class="keyword">typename</span> <a class="code" href="a00003.html" title="Class providing information about the mapping of the vertices onto aggregates.">AggregatesMap&lt;V&gt;::AggregateDescriptor</a>&amp; 
<a name="l01395"></a><a class="code" href="a00197.html#g3e07dfd73a8a798f722c4a09a25bfbd1">01395</a>     <a class="code" href="a00003.html" title="Class providing information about the mapping of the vertices onto aggregates.">AggregatesMap&lt;V&gt;::operator[]</a>(<span class="keyword">const</span> <a class="code" href="a00197.html#gf657e8e9f35ddf9811f6ab7ea72ab9f5" title="The vertex descriptor type.">VertexDescriptor</a>&amp; v)
<a name="l01396"></a>01396     {
<a name="l01397"></a>01397       <span class="keywordflow">return</span> aggregates_[v];
<a name="l01398"></a>01398     }
<a name="l01399"></a>01399 
<a name="l01400"></a>01400     <span class="keyword">template</span>&lt;<span class="keyword">class</span> V&gt;
<a name="l01401"></a>01401     <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="a00003.html" title="Class providing information about the mapping of the vertices onto aggregates.">AggregatesMap&lt;V&gt;::AggregateDescriptor</a>&amp; 
<a name="l01402"></a><a class="code" href="a00197.html#g9fbeb9f55e40cb276c5286d3891e035c">01402</a>     <a class="code" href="a00003.html" title="Class providing information about the mapping of the vertices onto aggregates.">AggregatesMap&lt;V&gt;::operator[]</a>(<span class="keyword">const</span> <a class="code" href="a00197.html#gf657e8e9f35ddf9811f6ab7ea72ab9f5" title="The vertex descriptor type.">VertexDescriptor</a>&amp; v)<span class="keyword"> const</span>
<a name="l01403"></a>01403 <span class="keyword">    </span>{
<a name="l01404"></a>01404       <span class="keywordflow">return</span> aggregates_[v];
<a name="l01405"></a>01405     }
<a name="l01406"></a>01406 
<a name="l01407"></a>01407     <span class="keyword">template</span>&lt;<span class="keyword">class</span> V&gt;
<a name="l01408"></a>01408     <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> reset, <span class="keyword">class</span> G, <span class="keyword">class</span> F,<span class="keyword">class</span> VM&gt;
<a name="l01409"></a><a class="code" href="a00197.html#g271b83cdc0415c6352b36881deac4515">01409</a>     <span class="keyword">inline</span> std::size_t <a class="code" href="a00003.html" title="Class providing information about the mapping of the vertices onto aggregates.">AggregatesMap&lt;V&gt;::breadthFirstSearch</a>(<span class="keyword">const</span> V&amp; start,
<a name="l01410"></a>01410                                                     <span class="keyword">const</span> <a class="code" href="a00197.html#g9258a3f0e9738c7c77d348cbb28b4b8d" title="The aggregate descriptor type.">AggregateDescriptor</a>&amp; aggregate, 
<a name="l01411"></a>01411                                                     G&amp; graph, F&amp; aggregateVisitor,
<a name="l01412"></a>01412                                                     VM&amp; visitedMap)<span class="keyword"> const</span>
<a name="l01413"></a>01413 <span class="keyword">    </span>{
<a name="l01414"></a>01414       <a class="code" href="a00197.html#gb0e20fc899e8046c7a5eb565cd8025f3" title="The type of a single linked list of vertex descriptors.">VertexList</a> vlist;
<a name="l01415"></a>01415       <a class="code" href="a00004.html" title="A Dummy visitor that does nothing for each visited edge.">DummyEdgeVisitor</a> dummy;
<a name="l01416"></a>01416       <span class="keywordflow">return</span> breadthFirstSearch&lt;true,reset&gt;(start, aggregate, graph, vlist, aggregateVisitor, dummy, visitedMap);
<a name="l01417"></a>01417     }
<a name="l01418"></a>01418       
<a name="l01419"></a>01419     <span class="keyword">template</span>&lt;<span class="keyword">class</span> V&gt;
<a name="l01420"></a>01420     <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> remove, <span class="keywordtype">bool</span> reset, <span class="keyword">class</span> G, <span class="keyword">class</span> L, <span class="keyword">class</span> F1, <span class="keyword">class</span> F2, <span class="keyword">class</span> VM&gt;
<a name="l01421"></a><a class="code" href="a00197.html#ga827f5ef3d5034851ba6abddc8d373aa">01421</a>     std::size_t <a class="code" href="a00003.html" title="Class providing information about the mapping of the vertices onto aggregates.">AggregatesMap&lt;V&gt;::breadthFirstSearch</a>(<span class="keyword">const</span> V&amp; start,
<a name="l01422"></a>01422                                              <span class="keyword">const</span> <a class="code" href="a00197.html#g9258a3f0e9738c7c77d348cbb28b4b8d" title="The aggregate descriptor type.">AggregateDescriptor</a>&amp; aggregate, 
<a name="l01423"></a>01423                                              G&amp; graph,
<a name="l01424"></a>01424                                              L&amp; visited,
<a name="l01425"></a>01425                                              F1&amp; aggregateVisitor,
<a name="l01426"></a>01426                                              F2&amp; nonAggregateVisitor,
<a name="l01427"></a>01427                                              VM&amp; visitedMap)<span class="keyword"> const</span>
<a name="l01428"></a>01428 <span class="keyword">    </span>{
<a name="l01429"></a>01429       <span class="keyword">typedef</span> <span class="keyword">typename</span> L::const_iterator ListIterator;
<a name="l01430"></a>01430       <span class="keywordtype">int</span> visitedSpheres = 0;
<a name="l01431"></a>01431       
<a name="l01432"></a>01432       visited.push_back(start);
<a name="l01433"></a>01433       put(visitedMap, start, <span class="keyword">true</span>);
<a name="l01434"></a>01434       
<a name="l01435"></a>01435       ListIterator current = visited.begin();
<a name="l01436"></a>01436       ListIterator end = visited.end();
<a name="l01437"></a>01437       std::size_t i=0, size=visited.size();
<a name="l01438"></a>01438       
<a name="l01439"></a>01439       <span class="comment">// visit the neighbours of all vertices of the</span>
<a name="l01440"></a>01440       <span class="comment">// current sphere.</span>
<a name="l01441"></a>01441       <span class="keywordflow">while</span>(current != end){
<a name="l01442"></a>01442         
<a name="l01443"></a>01443         <span class="keywordflow">for</span>(;i&lt;size; ++current, ++i){
<a name="l01444"></a>01444           <span class="keyword">typedef</span> <span class="keyword">typename</span> G::ConstEdgeIterator EdgeIterator;
<a name="l01445"></a>01445           <span class="keyword">const</span> EdgeIterator endEdge = graph.endEdges(*current);
<a name="l01446"></a>01446           
<a name="l01447"></a>01447           <span class="keywordflow">for</span>(EdgeIterator edge = graph.beginEdges(*current);
<a name="l01448"></a>01448               edge != endEdge; ++edge){
<a name="l01449"></a>01449           
<a name="l01450"></a>01450             <span class="keywordflow">if</span>(aggregates_[edge.target()]==aggregate){
<a name="l01451"></a>01451               <span class="keywordflow">if</span>(!<span class="keyword">get</span>(visitedMap, edge.target())){
<a name="l01452"></a>01452                 put(visitedMap, edge.target(), <span class="keyword">true</span>);
<a name="l01453"></a>01453                 visited.push_back(edge.target());
<a name="l01454"></a>01454                 aggregateVisitor(edge);
<a name="l01455"></a>01455               }
<a name="l01456"></a>01456             }<span class="keywordflow">else</span>
<a name="l01457"></a>01457               nonAggregateVisitor(edge);
<a name="l01458"></a>01458           }
<a name="l01459"></a>01459         }       
<a name="l01460"></a>01460         end = visited.end();
<a name="l01461"></a>01461         size = visited.size();
<a name="l01462"></a>01462         <span class="keywordflow">if</span>(current != end)
<a name="l01463"></a>01463           visitedSpheres++;
<a name="l01464"></a>01464       }
<a name="l01465"></a>01465       
<a name="l01466"></a>01466       <span class="keywordflow">if</span>(reset)
<a name="l01467"></a>01467         <span class="keywordflow">for</span>(current = visited.begin(); current != end; ++current)
<a name="l01468"></a>01468           put(visitedMap, *current, <span class="keyword">false</span>);
<a name="l01469"></a>01469       
<a name="l01470"></a>01470         
<a name="l01471"></a>01471       <span class="keywordflow">if</span>(<span class="keyword">remove</span>)
<a name="l01472"></a>01472         visited.clear();
<a name="l01473"></a>01473       
<a name="l01474"></a>01474       <span class="keywordflow">return</span> visitedSpheres;
<a name="l01475"></a>01475     }
<a name="l01476"></a>01476     
<a name="l01477"></a>01477     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01478"></a><a class="code" href="a00197.html#g841366f64cc179802c21d4fd5a5ac684">01478</a>     <a class="code" href="a00006.html" title="Class for building the aggregates.">Aggregator&lt;G&gt;::Aggregator</a>()
<a name="l01479"></a>01479       : graph_(0), aggregate_(0), front_(), connected_(), size_(-1)
<a name="l01480"></a>01480     {}
<a name="l01481"></a>01481     
<a name="l01482"></a>01482     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01483"></a><a class="code" href="a00197.html#g7d14d8929ca6f47b57706e35c6f83c8b">01483</a>     <a class="code" href="a00006.html" title="Class for building the aggregates.">Aggregator&lt;G&gt;::~Aggregator</a>()
<a name="l01484"></a>01484     {
<a name="l01485"></a>01485       size_=-1;
<a name="l01486"></a>01486     }
<a name="l01487"></a>01487     
<a name="l01488"></a>01488     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01489"></a>01489     <span class="keyword">template</span>&lt;<span class="keyword">class</span> C&gt;
<a name="l01490"></a>01490     <span class="keywordtype">void</span> <a class="code" href="a00006.html" title="Class for building the aggregates.">Aggregator&lt;G&gt;::buildDependency</a>(<a class="code" href="a00073.html" title="The (undirected) graph of a matrix.">MatrixGraph</a>&amp; graph,
<a name="l01491"></a>01491                                         <span class="keyword">const</span> <span class="keyword">typename</span> C::Matrix&amp; matrix,
<a name="l01492"></a>01492                                         C criterion)
<a name="l01493"></a>01493     {
<a name="l01494"></a>01494       <span class="comment">// The Criterion we use for building the dependency.</span>
<a name="l01495"></a>01495       <span class="keyword">typedef</span> C Criterion;
<a name="l01496"></a>01496      
<a name="l01497"></a>01497       <span class="comment">//      assert(graph.isBuilt());</span>
<a name="l01498"></a>01498       <span class="keyword">typedef</span> <span class="keyword">typename</span> C::Matrix <a class="code" href="a00071.html" title="A generic dynamic matrix.">Matrix</a>;
<a name="l01499"></a>01499       <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="a00075.html" title="The vertex iterator type of the graph.">MatrixGraph::VertexIterator</a> VertexIterator;
<a name="l01500"></a>01500       
<a name="l01501"></a>01501       criterion.init(&amp;matrix);
<a name="l01502"></a>01502       
<a name="l01503"></a>01503       <span class="keywordflow">for</span>(VertexIterator vertex = graph.<a class="code" href="a00197.html#g596a7e2bca0d6ce04fea64cd240effd6" title="Get an iterator over the vertices.">begin</a>(); vertex != graph.<a class="code" href="a00197.html#gee23e1ecff955fa9fa37738250ec7b1a" title="Get an iterator over the vertices.">end</a>(); ++vertex){
<a name="l01504"></a>01504         <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="a00022.html" title="A vector of blocks with memory management.">Matrix::row_type</a> Row;
<a name="l01505"></a>01505         
<a name="l01506"></a>01506         Row row = matrix[*vertex];
<a name="l01507"></a>01507         
<a name="l01508"></a>01508         <span class="comment">// Tell the criterion what row we will examine now</span>
<a name="l01509"></a>01509         <span class="comment">// This might for example be used for calculating the</span>
<a name="l01510"></a>01510         <span class="comment">// maximum offdiagonal value</span>
<a name="l01511"></a>01511         criterion.initRow(row, *vertex);
<a name="l01512"></a>01512         
<a name="l01513"></a>01513         <span class="comment">// On a first path all columns are examined. After this </span>
<a name="l01514"></a>01514         <span class="comment">// the calculator should know whether the vertex is isolated.</span>
<a name="l01515"></a>01515         <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="a00071.html#bd4dbd77caee12c3ebd5291f341c34a5" title="Const iterator for the entries of each row.">Matrix::ConstColIterator</a> ColIterator;
<a name="l01516"></a>01516         ColIterator end = row.end();
<a name="l01517"></a>01517         <span class="keywordflow">for</span>(ColIterator col = row.begin(); col != end; ++col)
<a name="l01518"></a>01518           <span class="keywordflow">if</span>(col.index()!=*vertex)
<a name="l01519"></a>01519             criterion.examine(col);
<a name="l01520"></a>01520         
<a name="l01521"></a>01521         <span class="comment">// reset the vertex properties</span>
<a name="l01522"></a>01522         vertex.properties().reset();
<a name="l01523"></a>01523                 
<a name="l01524"></a>01524         <span class="comment">// Check whether the vertex is isolated.</span>
<a name="l01525"></a>01525         <span class="keywordflow">if</span>(criterion.isIsolated()){
<a name="l01526"></a>01526           <span class="comment">//std::cout&lt;&lt;"ISOLATED: "&lt;&lt;*vertex&lt;&lt;std::endl;</span>
<a name="l01527"></a>01527           vertex.properties().setIsolated();
<a name="l01528"></a>01528         }<span class="keywordflow">else</span>{
<a name="l01529"></a>01529           <span class="comment">// Examine all the edges beginning at this vertex.</span>
<a name="l01530"></a>01530           <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="a00073.html#c9f0e95986eee4720bb019d578f3aa28" title="The mutable edge iterator type.">MatrixGraph::EdgeIterator</a> EdgeIterator;
<a name="l01531"></a>01531           <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="a00071.html#bd4dbd77caee12c3ebd5291f341c34a5" title="Const iterator for the entries of each row.">Matrix::ConstColIterator</a> ColIterator;
<a name="l01532"></a>01532           EdgeIterator end = vertex.end();
<a name="l01533"></a>01533           ColIterator col = matrix[*vertex].begin();
<a name="l01534"></a>01534           
<a name="l01535"></a>01535           <span class="keywordflow">for</span>(EdgeIterator edge = vertex.begin(); edge!= end; ++edge, ++col){
<a name="l01536"></a>01536             <span class="comment">// Move to the right column.</span>
<a name="l01537"></a>01537             <span class="keywordflow">while</span>(col.index()!=edge.target())
<a name="l01538"></a>01538               ++col;
<a name="l01539"></a>01539             criterion.examine(graph, edge, col);
<a name="l01540"></a>01540           }
<a name="l01541"></a>01541         }
<a name="l01542"></a>01542         
<a name="l01543"></a>01543       }
<a name="l01544"></a>01544     }
<a name="l01545"></a>01545 
<a name="l01546"></a>01546     
<a name="l01547"></a>01547     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01548"></a>01548     <span class="keyword">template</span>&lt;<span class="keyword">class</span> V&gt;
<a name="l01549"></a><a class="code" href="a00197.html#g510b6c998062391f238820837f7dfe1d">01549</a>     <span class="keyword">inline</span> <a class="code" href="a00006.html" title="Class for building the aggregates.">Aggregator&lt;G&gt;::AggregateVisitor&lt;V&gt;::AggregateVisitor</a>(<span class="keyword">const</span> <a class="code" href="a00003.html" title="Class providing information about the mapping of the vertices onto aggregates.">AggregatesMap&lt;Vertex&gt;</a>&amp; aggregates, 
<a name="l01550"></a>01550                                                         <span class="keyword">const</span> <a class="code" href="a00197.html#g753ac555d3d946b7cf76e5ab9b5824c2" title="The type of the aggregate descriptor.">AggregateDescriptor</a>&amp; aggregate, V&amp; visitor)
<a name="l01551"></a>01551       : aggregates_(aggregates), aggregate_(aggregate), visitor_(&amp;visitor)
<a name="l01552"></a>01552     {}
<a name="l01553"></a>01553     
<a name="l01554"></a>01554     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01555"></a>01555     <span class="keyword">template</span>&lt;<span class="keyword">class</span> V&gt;
<a name="l01556"></a><a class="code" href="a00197.html#g857f6862a78c5497ae0e8f79d6ab61cf">01556</a>     <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="a00006.html" title="Class for building the aggregates.">Aggregator&lt;G&gt;::AggregateVisitor&lt;V&gt;::operator()</a>(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="a00074.html" title="Iterator over all edges starting from a vertex.">MatrixGraph::ConstEdgeIterator</a>&amp; edge)
<a name="l01557"></a>01557     {
<a name="l01558"></a>01558       <span class="keywordflow">if</span>(aggregates_[edge.<a class="code" href="a00197.html#g6acb7783d935fb7ee769e4bd311fea23" title="The index of the target vertex of the current edge.">target</a>()]==aggregate_)
<a name="l01559"></a>01559         visitor_-&gt;operator()(edge);
<a name="l01560"></a>01560     }
<a name="l01561"></a>01561     
<a name="l01562"></a>01562     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01563"></a>01563     <span class="keyword">template</span>&lt;<span class="keyword">class</span> V&gt;
<a name="l01564"></a>01564     <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="a00006.html" title="Class for building the aggregates.">Aggregator&lt;G&gt;::visitAggregateNeighbours</a>(<span class="keyword">const</span> <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a>&amp; vertex,
<a name="l01565"></a>01565                                                         <span class="keyword">const</span> <a class="code" href="a00197.html#g753ac555d3d946b7cf76e5ab9b5824c2" title="The type of the aggregate descriptor.">AggregateDescriptor</a>&amp; aggregate, 
<a name="l01566"></a>01566                                                         <span class="keyword">const</span> <a class="code" href="a00003.html" title="Class providing information about the mapping of the vertices onto aggregates.">AggregatesMap&lt;Vertex&gt;</a>&amp; aggregates,
<a name="l01567"></a>01567                                                         V&amp; visitor)<span class="keyword"> const</span>
<a name="l01568"></a>01568 <span class="keyword">    </span>{  
<a name="l01569"></a>01569       <span class="comment">// Only evaluates for edge pointing to the aggregate</span>
<a name="l01570"></a>01570       AggregateVisitor&lt;V&gt; v(aggregates, aggregate, visitor);
<a name="l01571"></a>01571       <a class="code" href="a00197.html#g647bb4cab2e448223bad5af1800a7dff" title="Visit all neighbour vertices of a vertex in a graph.">visitNeighbours</a>(*graph_, vertex, v);
<a name="l01572"></a>01572     }
<a name="l01573"></a>01573     
<a name="l01574"></a>01574     
<a name="l01575"></a>01575     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01576"></a><a class="code" href="a00197.html#g223f156eaaaf96a8f6840f2177ccc4fd">01576</a>     <span class="keyword">inline</span> <a class="code" href="a00006.html" title="Class for building the aggregates.">Aggregator&lt;G&gt;::Counter::Counter</a>()
<a name="l01577"></a>01577       : count_(0)
<a name="l01578"></a>01578     {}
<a name="l01579"></a>01579     
<a name="l01580"></a>01580     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01581"></a><a class="code" href="a00197.html#gf50b19a16af32bb05655d7139413b6b1">01581</a>     <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="a00006.html" title="Class for building the aggregates.">Aggregator&lt;G&gt;::Counter::increment</a>()
<a name="l01582"></a>01582     {
<a name="l01583"></a>01583       ++count_;
<a name="l01584"></a>01584     }
<a name="l01585"></a>01585 
<a name="l01586"></a>01586     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01587"></a><a class="code" href="a00197.html#g5852e16c0431720161d91dcd90be6fa5">01587</a>     <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="a00006.html" title="Class for building the aggregates.">Aggregator&lt;G&gt;::Counter::decrement</a>()
<a name="l01588"></a>01588     {
<a name="l01589"></a>01589       --count_;
<a name="l01590"></a>01590     }
<a name="l01591"></a>01591     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01592"></a><a class="code" href="a00197.html#gad63a76e83d64c9dafbaf87ac32d0fab">01592</a>     <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="a00006.html" title="Class for building the aggregates.">Aggregator&lt;G&gt;::Counter::value</a>()
<a name="l01593"></a>01593     {
<a name="l01594"></a>01594       <span class="keywordflow">return</span> count_;
<a name="l01595"></a>01595     }
<a name="l01596"></a>01596     
<a name="l01597"></a>01597     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01598"></a>01598     <span class="keyword">inline</span> <span class="keywordtype">void</span>  <a class="code" href="a00006.html" title="Class for building the aggregates.">Aggregator&lt;G&gt;::TwoWayCounter::operator()</a>(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="a00074.html" title="Iterator over all edges starting from a vertex.">MatrixGraph::ConstEdgeIterator</a>&amp; edge)
<a name="l01599"></a>01599     {
<a name="l01600"></a>01600       <span class="keywordflow">if</span>(edge.properties().isTwoWay())
<a name="l01601"></a>01601         Counter::increment();
<a name="l01602"></a>01602     }
<a name="l01603"></a>01603     
<a name="l01604"></a>01604     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01605"></a>01605     <span class="keywordtype">int</span> <a class="code" href="a00006.html" title="Class for building the aggregates.">Aggregator&lt;G&gt;::twoWayConnections</a>(<span class="keyword">const</span> <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a>&amp; vertex, <span class="keyword">const</span> <a class="code" href="a00197.html#g753ac555d3d946b7cf76e5ab9b5824c2" title="The type of the aggregate descriptor.">AggregateDescriptor</a>&amp; aggregate,
<a name="l01606"></a>01606                                          <span class="keyword">const</span> <a class="code" href="a00003.html" title="Class providing information about the mapping of the vertices onto aggregates.">AggregatesMap&lt;Vertex&gt;</a>&amp; aggregates)<span class="keyword"> const</span>
<a name="l01607"></a>01607 <span class="keyword">    </span>{
<a name="l01608"></a>01608       TwoWayCounter counter;
<a name="l01609"></a>01609       visitAggregateNeighbours(vertex, aggregate, aggregates, counter);
<a name="l01610"></a>01610       <span class="keywordflow">return</span> counter.value();
<a name="l01611"></a>01611     }
<a name="l01612"></a>01612     
<a name="l01613"></a>01613     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01614"></a>01614     <span class="keywordtype">int</span> Aggregator&lt;G&gt;::oneWayConnections(<span class="keyword">const</span> <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a>&amp; vertex, <span class="keyword">const</span> <a class="code" href="a00197.html#g753ac555d3d946b7cf76e5ab9b5824c2" title="The type of the aggregate descriptor.">AggregateDescriptor</a>&amp; aggregate,
<a name="l01615"></a>01615                                          <span class="keyword">const</span> AggregatesMap&lt;Vertex&gt;&amp; aggregates)<span class="keyword"> const</span>
<a name="l01616"></a>01616 <span class="keyword">    </span>{
<a name="l01617"></a>01617       OneWayCounter counter;
<a name="l01618"></a>01618       visitAggregateNeighbours(vertex, aggregate, aggregates, counter);
<a name="l01619"></a>01619       <span class="keywordflow">return</span> counter.value();
<a name="l01620"></a>01620     }
<a name="l01621"></a>01621     
<a name="l01622"></a>01622     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01623"></a>01623     <span class="keyword">inline</span> <span class="keywordtype">void</span> Aggregator&lt;G&gt;::OneWayCounter::operator()(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="a00073.html#a09d463bdf24dcddac52b4a7cbbaacf8" title="The constant edge iterator type.">MatrixGraph::ConstEdgeIterator</a>&amp; edge)
<a name="l01624"></a>01624     {
<a name="l01625"></a>01625       <span class="keywordflow">if</span>(edge.properties().isOneWay())
<a name="l01626"></a>01626         Counter::increment();
<a name="l01627"></a>01627     }
<a name="l01628"></a>01628     
<a name="l01629"></a>01629     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01630"></a><a class="code" href="a00197.html#gb2f81e0c007990646ae2d1a2cba03ee9">01630</a>     <span class="keyword">inline</span> <a class="code" href="a00006.html" title="Class for building the aggregates.">Aggregator&lt;G&gt;::ConnectivityCounter::ConnectivityCounter</a>(<span class="keyword">const</span> VertexSet&amp; connected,
<a name="l01631"></a>01631                                                                    <span class="keyword">const</span> <a class="code" href="a00003.html" title="Class providing information about the mapping of the vertices onto aggregates.">AggregatesMap&lt;Vertex&gt;</a>&amp; aggregates)
<a name="l01632"></a>01632       : Counter(), connected_(connected), aggregates_(aggregates)
<a name="l01633"></a>01633     {}
<a name="l01634"></a>01634     
<a name="l01635"></a>01635     
<a name="l01636"></a>01636     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01637"></a>01637     <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="a00006.html" title="Class for building the aggregates.">Aggregator&lt;G&gt;::ConnectivityCounter::operator()</a>(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="a00074.html" title="Iterator over all edges starting from a vertex.">MatrixGraph::ConstEdgeIterator</a>&amp; edge)
<a name="l01638"></a>01638     {
<a name="l01639"></a>01639       <span class="keywordflow">if</span>(connected_.find(aggregates_[edge.<a class="code" href="a00197.html#g6acb7783d935fb7ee769e4bd311fea23" title="The index of the target vertex of the current edge.">target</a>()]) == connected_.end() || aggregates_[edge.<a class="code" href="a00197.html#g6acb7783d935fb7ee769e4bd311fea23" title="The index of the target vertex of the current edge.">target</a>()]==<a class="code" href="a00003.html" title="Class providing information about the mapping of the vertices onto aggregates.">AggregatesMap&lt;Vertex&gt;::UNAGGREGATED</a>)
<a name="l01640"></a>01640         <span class="comment">// Would be a new connection</span>
<a name="l01641"></a>01641         Counter::increment();
<a name="l01642"></a>01642       <span class="keywordflow">else</span>{
<a name="l01643"></a>01643         Counter::increment();
<a name="l01644"></a>01644         Counter::increment();
<a name="l01645"></a>01645       }
<a name="l01646"></a>01646     }
<a name="l01647"></a>01647     
<a name="l01648"></a>01648     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01649"></a>01649     <span class="keyword">inline</span> <span class="keywordtype">double</span> Aggregator&lt;G&gt;::connectivity(<span class="keyword">const</span> <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a>&amp; vertex, <span class="keyword">const</span> AggregatesMap&lt;Vertex&gt;&amp; aggregates)<span class="keyword"> const</span>
<a name="l01650"></a>01650 <span class="keyword">    </span>{
<a name="l01651"></a>01651       ConnectivityCounter counter(connected_, aggregates);
<a name="l01652"></a>01652       <span class="keywordtype">double</span> noNeighbours=<a class="code" href="a00197.html#g647bb4cab2e448223bad5af1800a7dff" title="Visit all neighbour vertices of a vertex in a graph.">visitNeighbours</a>(*graph_, vertex, counter);
<a name="l01653"></a>01653       <span class="keywordflow">return</span> (<span class="keywordtype">double</span>)counter.value()/noNeighbours;
<a name="l01654"></a>01654     }
<a name="l01655"></a>01655     
<a name="l01656"></a>01656     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01657"></a><a class="code" href="a00197.html#g9a756b97f9143e5125497679c82c2e09">01657</a>     <span class="keyword">inline</span> <a class="code" href="a00006.html" title="Class for building the aggregates.">Aggregator&lt;G&gt;::DependencyCounter::DependencyCounter</a>()
<a name="l01658"></a>01658       : Counter()
<a name="l01659"></a>01659     {}
<a name="l01660"></a>01660     
<a name="l01661"></a>01661     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01662"></a>01662     <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="a00006.html" title="Class for building the aggregates.">Aggregator&lt;G&gt;::DependencyCounter::operator()</a>(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="a00074.html" title="Iterator over all edges starting from a vertex.">MatrixGraph::ConstEdgeIterator</a>&amp; edge)
<a name="l01663"></a>01663     {
<a name="l01664"></a>01664       <span class="keywordflow">if</span>(edge.properties().depends())
<a name="l01665"></a>01665         Counter::increment();
<a name="l01666"></a>01666       <span class="keywordflow">if</span>(edge.properties().influences())
<a name="l01667"></a>01667         Counter::increment();
<a name="l01668"></a>01668     }
<a name="l01669"></a>01669     
<a name="l01670"></a>01670     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01671"></a>01671     <span class="keywordtype">int</span> <a class="code" href="a00006.html" title="Class for building the aggregates.">Aggregator&lt;G&gt;::unusedNeighbours</a>(<span class="keyword">const</span> <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a>&amp; vertex, <span class="keyword">const</span> <a class="code" href="a00003.html" title="Class providing information about the mapping of the vertices onto aggregates.">AggregatesMap&lt;Vertex&gt;</a>&amp; aggregates)<span class="keyword"> const</span>
<a name="l01672"></a>01672 <span class="keyword">    </span>{
<a name="l01673"></a>01673       <span class="keywordflow">return</span> aggregateNeighbours(vertex, <a class="code" href="a00003.html" title="Class providing information about the mapping of the vertices onto aggregates.">AggregatesMap&lt;Vertex&gt;::UNAGGREGATED</a>, aggregates);
<a name="l01674"></a>01674     }
<a name="l01675"></a>01675     
<a name="l01676"></a>01676     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01677"></a>01677     std::pair&lt;int,int&gt; Aggregator&lt;G&gt;::neighbours(<span class="keyword">const</span> <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a>&amp; vertex,
<a name="l01678"></a>01678                                                  <span class="keyword">const</span> <a class="code" href="a00197.html#g753ac555d3d946b7cf76e5ab9b5824c2" title="The type of the aggregate descriptor.">AggregateDescriptor</a>&amp; aggregate,
<a name="l01679"></a>01679                                                  <span class="keyword">const</span> AggregatesMap&lt;Vertex&gt;&amp; aggregates)<span class="keyword"> const</span>
<a name="l01680"></a>01680 <span class="keyword">    </span>{
<a name="l01681"></a>01681       DependencyCounter unused, aggregated;
<a name="l01682"></a>01682       <span class="keyword">typedef</span> AggregateVisitor&lt;DependencyCounter&gt; Counter;
<a name="l01683"></a>01683       <span class="keyword">typedef</span> tuple&lt;Counter,Counter&gt; CounterTuple;
<a name="l01684"></a>01684       CombinedFunctor&lt;CounterTuple&gt; visitors(CounterTuple(Counter(aggregates, <a class="code" href="a00197.html#gd35c6c9e3aa1ec18c07a97279f8d3f77" title="Identifier of not yet aggregated vertices.">AggregatesMap&lt;Vertex&gt;::UNAGGREGATED</a>, unused), Counter(aggregates, aggregate, aggregated)));
<a name="l01685"></a>01685       <span class="keywordflow">return</span> std::make_pair(unused.value(), aggregated.value());
<a name="l01686"></a>01686 }
<a name="l01687"></a>01687       
<a name="l01688"></a>01688       
<a name="l01689"></a>01689     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01690"></a>01690     <span class="keywordtype">int</span> Aggregator&lt;G&gt;::aggregateNeighbours(<span class="keyword">const</span> <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a>&amp; vertex, <span class="keyword">const</span> <a class="code" href="a00197.html#g753ac555d3d946b7cf76e5ab9b5824c2" title="The type of the aggregate descriptor.">AggregateDescriptor</a>&amp; aggregate, <span class="keyword">const</span> AggregatesMap&lt;Vertex&gt;&amp; aggregates)<span class="keyword"> const</span>
<a name="l01691"></a>01691 <span class="keyword">    </span>{
<a name="l01692"></a>01692       DependencyCounter counter;
<a name="l01693"></a>01693       visitAggregateNeighbours(vertex, aggregate, aggregates, counter);
<a name="l01694"></a>01694       <span class="keywordflow">return</span> counter.value();
<a name="l01695"></a>01695     }
<a name="l01696"></a>01696     
<a name="l01697"></a>01697     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01698"></a>01698     std::size_t Aggregator&lt;G&gt;::distance(<span class="keyword">const</span> <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a>&amp; vertex, <span class="keyword">const</span> AggregatesMap&lt;Vertex&gt;&amp; aggregates)
<a name="l01699"></a>01699     {
<a name="l01700"></a>01700       <span class="keyword">typename</span> PropertyMapTypeSelector&lt;VertexVisitedTag,G&gt;::Type visitedMap = <span class="keyword">get</span>(VertexVisitedTag(), *graph_);
<a name="l01701"></a>01701       VertexList vlist;
<a name="l01702"></a>01702       <span class="keyword">typename</span> AggregatesMap&lt;Vertex&gt;::DummyEdgeVisitor dummy;
<a name="l01703"></a>01703       <span class="keywordflow">return</span> aggregates.template breadthFirstSearch&lt;true,true&gt;(vertex, 
<a name="l01704"></a>01704                                                       aggregate_-&gt;id(), *graph_, 
<a name="l01705"></a>01705                                            vlist, dummy, dummy, visitedMap);
<a name="l01706"></a>01706     }
<a name="l01707"></a>01707     
<a name="l01708"></a>01708     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01709"></a><a class="code" href="a00197.html#g7b98a5dcaabbf445e630246eb3984f58">01709</a>     <span class="keyword">inline</span> <a class="code" href="a00006.html" title="Class for building the aggregates.">Aggregator&lt;G&gt;::FrontMarker::FrontMarker</a>(VertexList&amp; front, <a class="code" href="a00073.html" title="The (undirected) graph of a matrix.">MatrixGraph</a>&amp; graph)
<a name="l01710"></a>01710       : front_(front), graph_(graph)
<a name="l01711"></a>01711     {}
<a name="l01712"></a>01712     
<a name="l01713"></a>01713     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01714"></a>01714     <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="a00006.html" title="Class for building the aggregates.">Aggregator&lt;G&gt;::FrontMarker::operator()</a>(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="a00074.html" title="Iterator over all edges starting from a vertex.">MatrixGraph::ConstEdgeIterator</a>&amp; edge)
<a name="l01715"></a>01715     {
<a name="l01716"></a>01716       <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a> target = edge.<a class="code" href="a00197.html#g6acb7783d935fb7ee769e4bd311fea23" title="The index of the target vertex of the current edge.">target</a>();
<a name="l01717"></a>01717       
<a name="l01718"></a>01718       <span class="keywordflow">if</span>(!graph_.getVertexProperties(target).front()){
<a name="l01719"></a>01719         front_.push_back(target);
<a name="l01720"></a>01720         graph_.getVertexProperties(target).setFront();
<a name="l01721"></a>01721       }
<a name="l01722"></a>01722     }
<a name="l01723"></a>01723         
<a name="l01724"></a>01724 
<a name="l01725"></a>01725     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01726"></a>01726     <span class="keywordtype">void</span> Aggregator&lt;G&gt;::markFront(<span class="keyword">const</span> AggregatesMap&lt;Vertex&gt;&amp; aggregates)
<a name="l01727"></a>01727     {
<a name="l01728"></a>01728       assert(front_.size()==0);
<a name="l01729"></a>01729       FrontMarker frontBuilder(front_, *graph_);
<a name="l01730"></a>01730       <span class="keyword">typedef</span> <span class="keyword">typename</span> Aggregate&lt;G&gt;::const_iterator Iterator;
<a name="l01731"></a>01731       
<a name="l01732"></a>01732       <span class="keywordflow">for</span>(Iterator vertex=aggregate_-&gt;begin(); vertex != aggregate_-&gt;end(); ++vertex)
<a name="l01733"></a>01733         visitAggregateNeighbours(*vertex, <a class="code" href="a00197.html#gd35c6c9e3aa1ec18c07a97279f8d3f77" title="Identifier of not yet aggregated vertices.">AggregatesMap&lt;Vertex&gt;::UNAGGREGATED</a>, aggregates, frontBuilder);
<a name="l01734"></a>01734       
<a name="l01735"></a>01735     }
<a name="l01736"></a>01736 
<a name="l01737"></a>01737     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01738"></a>01738     <span class="keyword">inline</span> <span class="keywordtype">bool</span> Aggregator&lt;G&gt;::admissible(<span class="keyword">const</span> <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a>&amp; vertex, <span class="keyword">const</span> <a class="code" href="a00197.html#g753ac555d3d946b7cf76e5ab9b5824c2" title="The type of the aggregate descriptor.">AggregateDescriptor</a>&amp; aggregate, <span class="keyword">const</span> AggregatesMap&lt;Vertex&gt;&amp; aggregates)<span class="keyword"> const</span>
<a name="l01739"></a>01739 <span class="keyword">    </span>{
<a name="l01740"></a>01740       <span class="comment">// Todo</span>
<a name="l01741"></a>01741       Dune::dvverb&lt;&lt;<span class="stringliteral">" Admissible not yet implemented!"</span>&lt;&lt;std::endl;
<a name="l01742"></a>01742       
<a name="l01743"></a>01743       <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01744"></a>01744     }
<a name="l01745"></a>01745     
<a name="l01746"></a>01746     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01747"></a>01747     <span class="keywordtype">void</span> Aggregator&lt;G&gt;::unmarkFront()
<a name="l01748"></a>01748     {      
<a name="l01749"></a>01749       <span class="keyword">typedef</span> <span class="keyword">typename</span> VertexList::const_iterator Iterator;
<a name="l01750"></a>01750       
<a name="l01751"></a>01751       <span class="keywordflow">for</span>(Iterator vertex=front_.begin(); vertex != front_.end(); ++vertex)
<a name="l01752"></a>01752         graph_-&gt;getVertexProperties(*vertex).resetFront();      
<a name="l01753"></a>01753       
<a name="l01754"></a>01754       front_.clear();
<a name="l01755"></a>01755     }
<a name="l01756"></a>01756 
<a name="l01757"></a>01757     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01758"></a>01758     <span class="keyword">inline</span> <span class="keyword">typename</span> G::VertexDescriptor Aggregator&lt;G&gt;::mergeNeighbour(<span class="keyword">const</span> <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a>&amp; vertex, <span class="keyword">const</span> AggregatesMap&lt;Vertex&gt;&amp; aggregates)<span class="keyword"> const</span>
<a name="l01759"></a>01759 <span class="keyword">    </span>{
<a name="l01760"></a>01760       <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="a00073.html#a09d463bdf24dcddac52b4a7cbbaacf8" title="The constant edge iterator type.">MatrixGraph::ConstEdgeIterator</a> Iterator;
<a name="l01761"></a>01761       
<a name="l01762"></a>01762       Iterator end = graph_-&gt;endEdges(vertex);
<a name="l01763"></a>01763       <span class="keywordflow">for</span>(Iterator edge = graph_-&gt;beginEdges(vertex); edge != end; ++edge){
<a name="l01764"></a>01764         <span class="keywordflow">if</span>(aggregates[edge.<a class="code" href="a00197.html#g6acb7783d935fb7ee769e4bd311fea23" title="The index of the target vertex of the current edge.">target</a>()] != <a class="code" href="a00197.html#gd35c6c9e3aa1ec18c07a97279f8d3f77" title="Identifier of not yet aggregated vertices.">AggregatesMap&lt;Vertex&gt;::UNAGGREGATED</a> &amp;&amp;
<a name="l01765"></a>01765            graph_-&gt;getVertexProperties(edge.<a class="code" href="a00197.html#g6acb7783d935fb7ee769e4bd311fea23" title="The index of the target vertex of the current edge.">target</a>()).isolated() == graph_-&gt;getVertexProperties(edge.<a class="code" href="a00197.html#g1f14c46b5842db0a2ceb6ab16008650a" title="The index of the source vertex of the current edge.">source</a>()).isolated()){
<a name="l01766"></a>01766           <span class="keywordflow">if</span>( graph_-&gt;getVertexProperties(vertex).isolated() || 
<a name="l01767"></a>01767               ((edge.properties().depends() || edge.properties().influences())
<a name="l01768"></a>01768                &amp;&amp; admissible(vertex, aggregates[edge.<a class="code" href="a00197.html#g6acb7783d935fb7ee769e4bd311fea23" title="The index of the target vertex of the current edge.">target</a>()], aggregates)))
<a name="l01769"></a>01769             <span class="keywordflow">return</span> edge.<a class="code" href="a00197.html#g6acb7783d935fb7ee769e4bd311fea23" title="The index of the target vertex of the current edge.">target</a>();
<a name="l01770"></a>01770         }
<a name="l01771"></a>01771       }
<a name="l01772"></a>01772       <span class="keywordflow">return</span> <a class="code" href="a00197.html#gd35c6c9e3aa1ec18c07a97279f8d3f77" title="Identifier of not yet aggregated vertices.">AggregatesMap&lt;Vertex&gt;::UNAGGREGATED</a>;
<a name="l01773"></a>01773     }
<a name="l01774"></a>01774     
<a name="l01775"></a>01775     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01776"></a><a class="code" href="a00197.html#g4a9c2f3b9ca3ad3ddb48388156b88703">01776</a>     <a class="code" href="a00006.html" title="Class for building the aggregates.">Aggregator&lt;G&gt;::FrontNeighbourCounter::FrontNeighbourCounter</a>(<span class="keyword">const</span> <a class="code" href="a00073.html" title="The (undirected) graph of a matrix.">MatrixGraph</a>&amp; graph)
<a name="l01777"></a>01777       : Counter(), graph_(graph)
<a name="l01778"></a>01778     {}
<a name="l01779"></a>01779 
<a name="l01780"></a>01780     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01781"></a>01781     <span class="keywordtype">void</span> <a class="code" href="a00006.html" title="Class for building the aggregates.">Aggregator&lt;G&gt;::FrontNeighbourCounter::operator()</a>(<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="a00074.html" title="Iterator over all edges starting from a vertex.">MatrixGraph::ConstEdgeIterator</a>&amp; edge)
<a name="l01782"></a>01782     {
<a name="l01783"></a>01783       <span class="keywordflow">if</span>(graph_.getVertexProperties(edge.<a class="code" href="a00197.html#g6acb7783d935fb7ee769e4bd311fea23" title="The index of the target vertex of the current edge.">target</a>()).front())
<a name="l01784"></a>01784         Counter::increment();
<a name="l01785"></a>01785     }
<a name="l01786"></a>01786     
<a name="l01787"></a>01787     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01788"></a>01788     <span class="keywordtype">int</span> <a class="code" href="a00006.html" title="Class for building the aggregates.">Aggregator&lt;G&gt;::noFrontNeighbours</a>(<span class="keyword">const</span> <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a>&amp; vertex)<span class="keyword"> const</span>
<a name="l01789"></a>01789 <span class="keyword">    </span>{
<a name="l01790"></a>01790       FrontNeighbourCounter counter(*graph_);
<a name="l01791"></a>01791       <a class="code" href="a00197.html#g647bb4cab2e448223bad5af1800a7dff" title="Visit all neighbour vertices of a vertex in a graph.">visitNeighbours</a>(*graph_, vertex, counter);
<a name="l01792"></a>01792       <span class="keywordflow">return</span> counter.value();
<a name="l01793"></a>01793     }
<a name="l01794"></a>01794     
<a name="l01795"></a>01795     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01796"></a>01796     <span class="keyword">template</span>&lt;<span class="keyword">class</span> C&gt;
<a name="l01797"></a>01797     <span class="keywordtype">void</span> Aggregator&lt;G&gt;::growAggregate(<span class="keyword">const</span> <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a>&amp; seed, <span class="keyword">const</span> AggregatesMap&lt;Vertex&gt;&amp; aggregates, <span class="keyword">const</span> C&amp; c)
<a name="l01798"></a>01798     {
<a name="l01799"></a>01799       <span class="keywordflow">while</span>(aggregate_-&gt;size() &lt; c.minAggregateSize()){
<a name="l01800"></a>01800         <span class="keywordtype">int</span> maxTwoCons=0, maxOneCons=0, maxNeighbours=-1;
<a name="l01801"></a>01801         <span class="keywordtype">double</span> maxCon=-1;
<a name="l01802"></a>01802                 
<a name="l01803"></a>01803         <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a> candidate = <a class="code" href="a00197.html#gd35c6c9e3aa1ec18c07a97279f8d3f77" title="Identifier of not yet aggregated vertices.">AggregatesMap&lt;Vertex&gt;::UNAGGREGATED</a>;
<a name="l01804"></a>01804         
<a name="l01805"></a>01805         unmarkFront();
<a name="l01806"></a>01806         markFront(aggregates);
<a name="l01807"></a>01807 
<a name="l01808"></a>01808         <span class="keyword">typedef</span> <span class="keyword">typename</span> VertexList::const_iterator Iterator;
<a name="l01809"></a>01809           
<a name="l01810"></a>01810         <span class="keywordflow">for</span>(Iterator vertex = front_.begin(); vertex != front_.end(); ++vertex){
<a name="l01811"></a>01811           <span class="comment">// Only nonisolated nodes are considered</span>
<a name="l01812"></a>01812           <span class="keywordflow">if</span>(graph_-&gt;getVertexProperties(*vertex).isolated())
<a name="l01813"></a>01813             <span class="keywordflow">continue</span>;
<a name="l01814"></a>01814           
<a name="l01815"></a>01815           <span class="keywordtype">int</span> twoWayCons = twoWayConnections(*vertex, aggregate_-&gt;id(), aggregates);
<a name="l01816"></a>01816           
<a name="l01817"></a>01817           <span class="comment">/* The case of two way connections. */</span>
<a name="l01818"></a>01818           <span class="keywordflow">if</span>( maxTwoCons == twoWayCons &amp;&amp; twoWayCons &gt; 0){
<a name="l01819"></a>01819             <span class="keywordtype">double</span> con = connectivity(*vertex, aggregates);
<a name="l01820"></a>01820 
<a name="l01821"></a>01821             <span class="keywordflow">if</span>(con == maxCon){
<a name="l01822"></a>01822               <span class="keywordtype">int</span> neighbours = noFrontNeighbours(*vertex);
<a name="l01823"></a>01823               
<a name="l01824"></a>01824               <span class="keywordflow">if</span>(neighbours &gt; maxNeighbours){
<a name="l01825"></a>01825                 maxNeighbours = neighbours;
<a name="l01826"></a>01826                 
<a name="l01827"></a>01827                 std::size_t distance_ = distance(*vertex, aggregates);
<a name="l01828"></a>01828 
<a name="l01829"></a>01829                 <span class="keywordflow">if</span>(c.maxDistance() &gt;= distance_){
<a name="l01830"></a>01830                   candidate = *vertex;
<a name="l01831"></a>01831                 }
<a name="l01832"></a>01832               }
<a name="l01833"></a>01833             }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( con &gt; maxCon){
<a name="l01834"></a>01834               maxCon = con;
<a name="l01835"></a>01835               maxNeighbours = noFrontNeighbours(*vertex);
<a name="l01836"></a>01836               std::size_t distance_ = distance(*vertex, aggregates);
<a name="l01837"></a>01837 
<a name="l01838"></a>01838               <span class="keywordflow">if</span>(c.maxDistance() &gt;= distance_){
<a name="l01839"></a>01839                 candidate = *vertex;
<a name="l01840"></a>01840               }
<a name="l01841"></a>01841             }
<a name="l01842"></a>01842           }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(twoWayCons &gt; maxTwoCons){
<a name="l01843"></a>01843             maxTwoCons = twoWayCons;
<a name="l01844"></a>01844             maxCon = connectivity(*vertex, aggregates);
<a name="l01845"></a>01845             maxNeighbours = noFrontNeighbours(*vertex);
<a name="l01846"></a>01846             std::size_t distance_ = distance(*vertex, aggregates);
<a name="l01847"></a>01847             
<a name="l01848"></a>01848             <span class="keywordflow">if</span>(c.maxDistance() &gt;= distance_){
<a name="l01849"></a>01849               candidate = *vertex;
<a name="l01850"></a>01850             }
<a name="l01851"></a>01851             
<a name="l01852"></a>01852             <span class="comment">// two way connections preceed</span>
<a name="l01853"></a>01853             maxOneCons = std::numeric_limits&lt;int&gt;::max();
<a name="l01854"></a>01854           }
<a name="l01855"></a>01855           
<a name="l01856"></a>01856           <span class="keywordflow">if</span>(twoWayCons &gt; 0)
<a name="l01857"></a>01857             <span class="keywordflow">continue</span>; <span class="comment">// THis is a two-way node, skip tests for one way nodes</span>
<a name="l01858"></a>01858 
<a name="l01859"></a>01859           <span class="comment">/* The one way case */</span>
<a name="l01860"></a>01860           <span class="keywordtype">int</span> oneWayCons = oneWayConnections(*vertex, aggregate_-&gt;id(), aggregates);
<a name="l01861"></a>01861           
<a name="l01862"></a>01862           <span class="keywordflow">if</span>(oneWayCons==0)
<a name="l01863"></a>01863             <span class="keywordflow">continue</span>; <span class="comment">// No strong connections, skip the tests.</span>
<a name="l01864"></a>01864 
<a name="l01865"></a>01865           <span class="keywordflow">if</span>(!admissible(*vertex, aggregate_-&gt;id(), aggregates))
<a name="l01866"></a>01866             <span class="keywordflow">continue</span>;
<a name="l01867"></a>01867           
<a name="l01868"></a>01868           <span class="keywordflow">if</span>( maxOneCons == oneWayCons &amp;&amp; oneWayCons &gt; 0){
<a name="l01869"></a>01869             <span class="keywordtype">double</span> con = connectivity(*vertex, aggregates);
<a name="l01870"></a>01870 
<a name="l01871"></a>01871             <span class="keywordflow">if</span>(con == maxCon){
<a name="l01872"></a>01872               <span class="keywordtype">int</span> neighbours = noFrontNeighbours(*vertex);
<a name="l01873"></a>01873               
<a name="l01874"></a>01874               <span class="keywordflow">if</span>(neighbours &gt; maxNeighbours){
<a name="l01875"></a>01875                 maxNeighbours = neighbours;
<a name="l01876"></a>01876                 std::size_t distance_ = distance(*vertex, aggregates);
<a name="l01877"></a>01877                 
<a name="l01878"></a>01878                 <span class="keywordflow">if</span>(c.maxDistance() &gt;= distance_){
<a name="l01879"></a>01879                   candidate = *vertex;
<a name="l01880"></a>01880                 }
<a name="l01881"></a>01881               }
<a name="l01882"></a>01882             }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( con &gt; maxCon){
<a name="l01883"></a>01883               maxCon = con;
<a name="l01884"></a>01884               maxNeighbours = noFrontNeighbours(*vertex);
<a name="l01885"></a>01885               std::size_t distance_ = distance(*vertex, aggregates);
<a name="l01886"></a>01886               <span class="keywordflow">if</span>(c.maxDistance() &gt;= distance_){
<a name="l01887"></a>01887                 candidate = *vertex;
<a name="l01888"></a>01888               }
<a name="l01889"></a>01889             }
<a name="l01890"></a>01890           }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(oneWayCons &gt; maxOneCons){
<a name="l01891"></a>01891             maxOneCons = oneWayCons;
<a name="l01892"></a>01892             maxCon = connectivity(*vertex, aggregates);
<a name="l01893"></a>01893             maxNeighbours = noFrontNeighbours(*vertex);
<a name="l01894"></a>01894             std::size_t distance_ = distance(*vertex, aggregates);
<a name="l01895"></a>01895                 
<a name="l01896"></a>01896             <span class="keywordflow">if</span>(c.maxDistance() &gt;= distance_){
<a name="l01897"></a>01897               candidate = *vertex;
<a name="l01898"></a>01898             }
<a name="l01899"></a>01899           }
<a name="l01900"></a>01900         }
<a name="l01901"></a>01901         
<a name="l01902"></a>01902         
<a name="l01903"></a>01903         <span class="keywordflow">if</span>(candidate == <a class="code" href="a00197.html#gd35c6c9e3aa1ec18c07a97279f8d3f77" title="Identifier of not yet aggregated vertices.">AggregatesMap&lt;Vertex&gt;::UNAGGREGATED</a>)
<a name="l01904"></a>01904           <span class="keywordflow">break</span>; <span class="comment">// No more candidates found</span>
<a name="l01905"></a>01905 
<a name="l01906"></a>01906         aggregate_-&gt;add(candidate);
<a name="l01907"></a>01907       }
<a name="l01908"></a>01908     }
<a name="l01909"></a>01909       
<a name="l01910"></a>01910     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> V&gt;
<a name="l01911"></a>01911     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> M, <span class="keyword">typename</span> G, <span class="keyword">typename</span> C&gt;
<a name="l01912"></a><a class="code" href="a00197.html#g259ba5ab939f8b299c4d77129e8ef213">01912</a>     Tuple&lt;int,int,int&gt; <a class="code" href="a00003.html" title="Class providing information about the mapping of the vertices onto aggregates.">AggregatesMap&lt;V&gt;::buildAggregates</a>(<span class="keyword">const</span> M&amp; matrix, G&amp; graph, <span class="keyword">const</span> C&amp; criterion)
<a name="l01913"></a>01913     {
<a name="l01914"></a>01914       <a class="code" href="a00006.html" title="Class for building the aggregates.">Aggregator&lt;G&gt;</a> aggregator;
<a name="l01915"></a>01915       <span class="keywordflow">return</span> aggregator.<a class="code" href="a00197.html#gecb7eccaaad0ed4c69e17003498d24b4" title="Build the aggregates.">build</a>(matrix, graph, *<span class="keyword">this</span>, criterion);
<a name="l01916"></a>01916     }
<a name="l01917"></a>01917     
<a name="l01918"></a>01918     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l01919"></a>01919     <span class="keyword">template</span>&lt;<span class="keyword">class</span> M, <span class="keyword">class</span> C&gt;
<a name="l01920"></a><a class="code" href="a00197.html#gecb7eccaaad0ed4c69e17003498d24b4">01920</a>     Tuple&lt;int,int,int&gt; <a class="code" href="a00006.html" title="Class for building the aggregates.">Aggregator&lt;G&gt;::build</a>(<span class="keyword">const</span> M&amp; m, G&amp; graph, <a class="code" href="a00003.html" title="Class providing information about the mapping of the vertices onto aggregates.">AggregatesMap&lt;Vertex&gt;</a>&amp; aggregates, <span class="keyword">const</span> C&amp; c)
<a name="l01921"></a>01921     {
<a name="l01922"></a>01922       <span class="comment">// Stack for fast vertex access</span>
<a name="l01923"></a>01923       Stack stack_(graph, *<span class="keyword">this</span>, aggregates);
<a name="l01924"></a>01924       
<a name="l01925"></a>01925       graph_ = &amp;graph;
<a name="l01926"></a>01926             
<a name="l01927"></a>01927       aggregate_ = <span class="keyword">new</span> <a class="code" href="a00002.html" title="A class for temporarily storing the vertices of an aggregate in.">Aggregate&lt;G&gt;</a>(graph, aggregates, connected_);
<a name="l01928"></a>01928       
<a name="l01929"></a>01929       <span class="comment">// Allocate the mapping to aggregate.</span>
<a name="l01930"></a>01930       size_ = graph.maxVertex();
<a name="l01931"></a>01931 
<a name="l01932"></a>01932       Timer watch;
<a name="l01933"></a>01933       watch.reset();
<a name="l01934"></a>01934 
<a name="l01935"></a>01935       buildDependency(graph, m, c);
<a name="l01936"></a>01936 
<a name="l01937"></a>01937       dverb&lt;&lt;<span class="stringliteral">"Build dependency took "</span>&lt;&lt; watch.elapsed()&lt;&lt;<span class="stringliteral">" seconds."</span>&lt;&lt;std::endl;
<a name="l01938"></a>01938       <span class="keywordtype">int</span> noAggregates, conAggregates, isoAggregates, oneAggregates;
<a name="l01939"></a>01939       noAggregates = conAggregates = isoAggregates = oneAggregates = 0;
<a name="l01940"></a>01940       
<a name="l01941"></a>01941       <span class="keywordflow">while</span>(<span class="keyword">true</span>){
<a name="l01942"></a>01942         <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a> seed = stack_.pop();
<a name="l01943"></a>01943         
<a name="l01944"></a>01944         <span class="keywordflow">if</span>(seed == Stack::NullEntry)
<a name="l01945"></a>01945           <span class="comment">// No more unaggregated vertices. We are finished!</span>
<a name="l01946"></a>01946           <span class="keywordflow">break</span>;
<a name="l01947"></a>01947         
<a name="l01948"></a>01948         <span class="comment">// Debugging output</span>
<a name="l01949"></a>01949         <span class="keywordflow">if</span>((noAggregates+1)%10000 == 0)
<a name="l01950"></a>01950           Dune::dverb&lt;&lt;<span class="stringliteral">"c"</span>;
<a name="l01951"></a>01951         
<a name="l01952"></a>01952         aggregate_-&gt;seed(seed);
<a name="l01953"></a>01953         
<a name="l01954"></a>01954         
<a name="l01955"></a>01955         <span class="keywordflow">if</span>(graph.getVertexProperties(seed).isolated()){
<a name="l01956"></a>01956           <span class="comment">// isolated vertices are not aggregated but skipped on the coarser levels.</span>
<a name="l01957"></a>01957           aggregates[seed]=<a class="code" href="a00003.html" title="Class providing information about the mapping of the vertices onto aggregates.">AggregatesMap&lt;Vertex&gt;::ISOLATED</a>;
<a name="l01958"></a>01958           ++isoAggregates;
<a name="l01959"></a>01959           <span class="comment">// skip rest as no agglomeration is done.</span>
<a name="l01960"></a>01960           <span class="keywordflow">continue</span>;
<a name="l01961"></a>01961         }<span class="keywordflow">else</span>
<a name="l01962"></a>01962           growAggregate(seed, aggregates, c);
<a name="l01963"></a>01963         
<a name="l01964"></a>01964         
<a name="l01965"></a>01965         <span class="comment">/* The rounding step. */</span>
<a name="l01966"></a>01966         <span class="keywordflow">while</span>(aggregate_-&gt;size() &lt; c.maxAggregateSize()){
<a name="l01967"></a>01967           
<a name="l01968"></a>01968           unmarkFront();
<a name="l01969"></a>01969           markFront(aggregates);
<a name="l01970"></a>01970           
<a name="l01971"></a>01971           <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a> candidate = <a class="code" href="a00003.html" title="Class providing information about the mapping of the vertices onto aggregates.">AggregatesMap&lt;Vertex&gt;::UNAGGREGATED</a>;
<a name="l01972"></a>01972           
<a name="l01973"></a>01973           <span class="keyword">typedef</span> <span class="keyword">typename</span> VertexList::const_iterator Iterator;
<a name="l01974"></a>01974           
<a name="l01975"></a>01975           <span class="keywordflow">for</span>(Iterator vertex = front_.begin(); vertex != front_.end(); ++vertex){
<a name="l01976"></a>01976 
<a name="l01977"></a>01977             <span class="keywordflow">if</span>(graph.getVertexProperties(*vertex).isolated())
<a name="l01978"></a>01978               <span class="keywordflow">continue</span>; <span class="comment">// No isolated nodes here</span>
<a name="l01979"></a>01979 
<a name="l01980"></a>01980             <span class="keywordflow">if</span>(twoWayConnections( *vertex, aggregate_-&gt;id(), aggregates) == 0 &amp;&amp; 
<a name="l01981"></a>01981                (oneWayConnections( *vertex, aggregate_-&gt;id(), aggregates) == 0 || 
<a name="l01982"></a>01982                 !admissible( *vertex, aggregate_-&gt;id(), aggregates) ))
<a name="l01983"></a>01983               <span class="keywordflow">continue</span>;
<a name="l01984"></a>01984           
<a name="l01985"></a>01985             std::pair&lt;int,int&gt; neighbourPair=neighbours(*vertex, aggregate_-&gt;id(),
<a name="l01986"></a>01986                                                      aggregates);
<a name="l01987"></a>01987             
<a name="l01988"></a>01988             <span class="comment">//if(aggregateNeighbours(*vertex, aggregate_-&gt;id(), aggregates) &lt;= unusedNeighbours(*vertex, aggregates))</span>
<a name="l01989"></a>01989             <span class="comment">// continue;</span>
<a name="l01990"></a>01990             
<a name="l01991"></a>01991             <span class="keywordflow">if</span>(neighbourPair.first &gt;= neighbourPair.second)
<a name="l01992"></a>01992               <span class="keywordflow">continue</span>;
<a name="l01993"></a>01993                     
<a name="l01994"></a>01994             <span class="keywordflow">if</span>(distance(*vertex, aggregates) &gt; c.maxDistance())
<a name="l01995"></a>01995               <span class="keywordflow">continue</span>; <span class="comment">// Distance too far</span>
<a name="l01996"></a>01996             candidate = *vertex;
<a name="l01997"></a>01997             <span class="keywordflow">break</span>;
<a name="l01998"></a>01998           }
<a name="l01999"></a>01999                   
<a name="l02000"></a>02000           <span class="keywordflow">if</span>(candidate == <a class="code" href="a00003.html" title="Class providing information about the mapping of the vertices onto aggregates.">AggregatesMap&lt;Vertex&gt;::UNAGGREGATED</a>) <span class="keywordflow">break</span>; <span class="comment">// no more candidates found.</span>
<a name="l02001"></a>02001           
<a name="l02002"></a>02002           aggregate_-&gt;add(candidate);
<a name="l02003"></a>02003           
<a name="l02004"></a>02004         }
<a name="l02005"></a>02005         
<a name="l02006"></a>02006         <span class="comment">// try to merge aggregates consisting of only one nonisolated vertex with other aggregates</span>
<a name="l02007"></a>02007         <span class="keywordflow">if</span>(aggregate_-&gt;size()==1)
<a name="l02008"></a>02008           <span class="keywordflow">if</span>(!graph.getVertexProperties(seed).isolated()){
<a name="l02009"></a>02009             <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a> mergedNeighbour = mergeNeighbour(seed, aggregates);
<a name="l02010"></a>02010 
<a name="l02011"></a>02011             <span class="keywordflow">if</span>(mergedNeighbour != <a class="code" href="a00003.html" title="Class providing information about the mapping of the vertices onto aggregates.">AggregatesMap&lt;Vertex&gt;::UNAGGREGATED</a>){
<a name="l02012"></a>02012               aggregates[seed] = aggregates[mergedNeighbour];
<a name="l02013"></a>02013               <span class="comment">/* // Reconstruct aggregate. Needed for markFront</span>
<a name="l02014"></a>02014 <span class="comment">              this-&gt;template breadthFirstSearch&lt;</span>
<a name="l02015"></a>02015 <span class="comment">              visitAggregateNeighbours(seed, aggregates[seed], aggregates,)</span>
<a name="l02016"></a>02016 <span class="comment">              if(aggregate_-&gt;size()==2)</span>
<a name="l02017"></a>02017 <span class="comment">                // Was a one node aggregate formerly</span>
<a name="l02018"></a>02018 <span class="comment">                --oneAggregates;</span>
<a name="l02019"></a>02019 <span class="comment">              */</span>
<a name="l02020"></a>02020             }<span class="keywordflow">else</span>{
<a name="l02021"></a>02021               ++oneAggregates;
<a name="l02022"></a>02022               ++conAggregates;
<a name="l02023"></a>02023             }
<a name="l02024"></a>02024             
<a name="l02025"></a>02025           }<span class="keywordflow">else</span>{
<a name="l02026"></a>02026             ++oneAggregates;
<a name="l02027"></a>02027             ++isoAggregates;
<a name="l02028"></a>02028           }
<a name="l02029"></a>02029         <span class="keywordflow">else</span>{
<a name="l02030"></a>02030           <span class="keywordflow">if</span>(graph.getVertexProperties(seed).isolated())
<a name="l02031"></a>02031             ++isoAggregates;
<a name="l02032"></a>02032           <span class="keywordflow">else</span>
<a name="l02033"></a>02033             ++conAggregates;
<a name="l02034"></a>02034         }
<a name="l02035"></a>02035         unmarkFront();
<a name="l02036"></a>02036         markFront(aggregates);
<a name="l02037"></a>02037         seedFromFront(stack_, graph.getVertexProperties(seed).isolated());
<a name="l02038"></a>02038         unmarkFront();
<a name="l02039"></a>02039       }
<a name="l02040"></a>02040       
<a name="l02041"></a>02041       Dune::dinfo&lt;&lt;<span class="stringliteral">"connected aggregates: "</span>&lt;&lt;conAggregates;
<a name="l02042"></a>02042       Dune::dinfo&lt;&lt;<span class="stringliteral">" isolated aggregates: "</span>&lt;&lt;isoAggregates;
<a name="l02043"></a>02043       Dune::dinfo&lt;&lt;<span class="stringliteral">" one node aggregates: "</span>&lt;&lt;oneAggregates&lt;&lt;std::endl;
<a name="l02044"></a>02044       
<a name="l02045"></a>02045       <span class="keyword">delete</span> aggregate_;
<a name="l02046"></a>02046       <span class="keywordflow">return</span> Tuple&lt;int,int,int&gt;(conAggregates,isoAggregates,oneAggregates);
<a name="l02047"></a>02047     }
<a name="l02048"></a>02048     
<a name="l02049"></a>02049     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l02050"></a>02050     <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="a00006.html" title="Class for building the aggregates.">Aggregator&lt;G&gt;::seedFromFront</a>(Stack&amp; stack_, <span class="keywordtype">bool</span> isolated)
<a name="l02051"></a>02051     {
<a name="l02052"></a>02052       <span class="keyword">typedef</span> <span class="keyword">typename</span> VertexList::const_iterator Iterator;
<a name="l02053"></a>02053       
<a name="l02054"></a>02054       Iterator end= front_.end();
<a name="l02055"></a>02055       <span class="keywordtype">int</span> count=0;
<a name="l02056"></a>02056       <span class="keywordflow">for</span>(Iterator vertex=front_.begin(); vertex != end; ++vertex,++count)
<a name="l02057"></a>02057         stack_.push(*vertex);
<a name="l02058"></a>02058       <span class="comment">/*</span>
<a name="l02059"></a>02059 <span class="comment">      if(MINIMAL_DEBUG_LEVEL&lt;=2 &amp;&amp; count==0 &amp;&amp; !isolated)</span>
<a name="l02060"></a>02060 <span class="comment">        Dune::dverb&lt;&lt; " no vertices pushed for nonisolated aggregate!"&lt;&lt;std::endl;</span>
<a name="l02061"></a>02061 <span class="comment">      */</span>
<a name="l02062"></a>02062     }
<a name="l02063"></a>02063 
<a name="l02064"></a>02064     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l02065"></a>02065     Aggregator&lt;G&gt;::Stack::Stack(<span class="keyword">const</span> <a class="code" href="a00006.html#239664e57c4c996c7fbd3976267a26d9" title="The matrix graph type used.">MatrixGraph</a>&amp; graph, <span class="keyword">const</span> Aggregator&lt;G&gt;&amp; aggregatesBuilder,
<a name="l02066"></a>02066                                 <span class="keyword">const</span> AggregatesMap&lt;Vertex&gt;&amp; aggregates)
<a name="l02067"></a>02067       : graph_(graph), aggregatesBuilder_(aggregatesBuilder), aggregates_(aggregates), size_(0), maxSize_(0), head_(0), filled_(0)
<a name="l02068"></a>02068     {
<a name="l02069"></a>02069       vals_ = <span class="keyword">new</span>  <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a>[N];
<a name="l02070"></a>02070     }
<a name="l02071"></a>02071     
<a name="l02072"></a>02072     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l02073"></a>02073     Aggregator&lt;G&gt;::Stack::~Stack()
<a name="l02074"></a>02074     {
<a name="l02075"></a>02075       Dune::dverb &lt;&lt; <span class="stringliteral">"Max stack size was "</span>&lt;&lt;maxSize_&lt;&lt;<span class="stringliteral">" filled="</span>&lt;&lt;filled_&lt;&lt;std::endl;
<a name="l02076"></a>02076       <span class="keyword">delete</span>[] vals_;
<a name="l02077"></a>02077     }
<a name="l02078"></a>02078     
<a name="l02079"></a>02079     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt; 
<a name="l02080"></a>02080     <span class="keyword">const</span> <span class="keyword">typename</span> Aggregator&lt;G&gt;::Vertex Aggregator&lt;G&gt;::Stack::NullEntry 
<a name="l02081"></a>02081     = std::numeric_limits&lt;typename G::VertexDescriptor&gt;::max();
<a name="l02082"></a>02082 
<a name="l02083"></a>02083     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l02084"></a>02084     <span class="keyword">inline</span> <span class="keywordtype">bool</span> Aggregator&lt;G&gt;::Stack::push(<span class="keyword">const</span> <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a>&amp; v)
<a name="l02085"></a>02085     {
<a name="l02086"></a>02086       <span class="keywordflow">if</span>(aggregates_[v] == <a class="code" href="a00197.html#gd35c6c9e3aa1ec18c07a97279f8d3f77" title="Identifier of not yet aggregated vertices.">AggregatesMap&lt;Vertex&gt;::UNAGGREGATED</a>){
<a name="l02087"></a>02087         localPush(v);
<a name="l02088"></a>02088         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02089"></a>02089       }<span class="keywordflow">else</span>
<a name="l02090"></a>02090         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02091"></a>02091     }
<a name="l02092"></a>02092     
<a name="l02093"></a>02093     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l02094"></a>02094     <span class="keyword">inline</span> <span class="keywordtype">void</span> Aggregator&lt;G&gt;::Stack::localPush(<span class="keyword">const</span> <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a>&amp; v)
<a name="l02095"></a>02095     {
<a name="l02096"></a>02096       vals_[head_] = v;
<a name="l02097"></a>02097       size_ = std::min&lt;int&gt;(size_+1, N);
<a name="l02098"></a>02098       head_ = (head_+N+1)%N;
<a name="l02099"></a>02099     }
<a name="l02100"></a>02100     
<a name="l02101"></a>02101     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l02102"></a>02102     <span class="keywordtype">void</span> Aggregator&lt;G&gt;::Stack::fill()
<a name="l02103"></a>02103     {
<a name="l02104"></a>02104       <span class="keywordtype">int</span> isolated = 0, connected=0;
<a name="l02105"></a>02105       <span class="keywordtype">int</span> isoumin, umin;
<a name="l02106"></a>02106       filled_++;
<a name="l02107"></a>02107       
<a name="l02108"></a>02108       head_ = size_ = 0;
<a name="l02109"></a>02109       isoumin = umin = std::numeric_limits&lt;int&gt;::max();
<a name="l02110"></a>02110       
<a name="l02111"></a>02111       <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="a00073.html#4f7d6424fd8ccc9b6275f08b06c59c18" title="The constant vertex iterator type.">MatrixGraph::ConstVertexIterator</a> Iterator;
<a name="l02112"></a>02112       
<a name="l02113"></a>02113       <span class="keyword">const</span> Iterator end = graph_.end();
<a name="l02114"></a>02114       
<a name="l02115"></a>02115       <span class="keywordflow">for</span>(Iterator vertex = graph_.begin(); vertex != end; ++vertex){
<a name="l02116"></a>02116         <span class="comment">// Skip already aggregated vertices</span>
<a name="l02117"></a>02117         <span class="keywordflow">if</span>(aggregates_[*vertex] != <a class="code" href="a00197.html#gd35c6c9e3aa1ec18c07a97279f8d3f77" title="Identifier of not yet aggregated vertices.">AggregatesMap&lt;Vertex&gt;::UNAGGREGATED</a>)
<a name="l02118"></a>02118           <span class="keywordflow">continue</span>;
<a name="l02119"></a>02119         
<a name="l02120"></a>02120         <span class="keywordflow">if</span>(vertex.properties().isolated()){
<a name="l02121"></a>02121           isoumin = std::min(isoumin, aggregatesBuilder_.unusedNeighbours(*vertex, aggregates_));
<a name="l02122"></a>02122           isolated++;
<a name="l02123"></a>02123         }<span class="keywordflow">else</span>{
<a name="l02124"></a>02124           umin = std::min(umin, aggregatesBuilder_.unusedNeighbours(*vertex, aggregates_));
<a name="l02125"></a>02125           connected++;
<a name="l02126"></a>02126         }
<a name="l02127"></a>02127       }
<a name="l02128"></a>02128       
<a name="l02129"></a>02129       <span class="keywordflow">if</span>(connected + isolated == 0)
<a name="l02130"></a>02130         <span class="comment">// No unaggregated vertices.</span>
<a name="l02131"></a>02131         <span class="keywordflow">return</span>;
<a name="l02132"></a>02132         
<a name="l02133"></a>02133       <span class="keywordflow">if</span>(connected &gt; 0){
<a name="l02134"></a>02134         <span class="comment">// Connected vertices have higher priority.</span>
<a name="l02135"></a>02135          <span class="keywordflow">for</span>(Iterator vertex = graph_.begin(); vertex != end; ++vertex)
<a name="l02136"></a>02136            <span class="keywordflow">if</span>(aggregates_[*vertex] == <a class="code" href="a00197.html#gd35c6c9e3aa1ec18c07a97279f8d3f77" title="Identifier of not yet aggregated vertices.">AggregatesMap&lt;Vertex&gt;::UNAGGREGATED</a> &amp;&amp; !vertex.properties().isolated() 
<a name="l02137"></a>02137               &amp;&amp; aggregatesBuilder_.unusedNeighbours(*vertex, aggregates_) == umin)
<a name="l02138"></a>02138              localPush(*vertex);
<a name="l02139"></a>02139       }<span class="keywordflow">else</span>{
<a name="l02140"></a>02140         <span class="keywordflow">for</span>(Iterator vertex = graph_.begin(); vertex != end; ++vertex)
<a name="l02141"></a>02141            <span class="keywordflow">if</span>(aggregates_[*vertex] == <a class="code" href="a00197.html#gd35c6c9e3aa1ec18c07a97279f8d3f77" title="Identifier of not yet aggregated vertices.">AggregatesMap&lt;Vertex&gt;::UNAGGREGATED</a> &amp;&amp; vertex.properties().isolated() 
<a name="l02142"></a>02142               &amp;&amp; aggregatesBuilder_.unusedNeighbours(*vertex, aggregates_) == isoumin)
<a name="l02143"></a>02143              localPush(*vertex);
<a name="l02144"></a>02144       }
<a name="l02145"></a>02145       maxSize_ = std::max(size_, maxSize_);
<a name="l02146"></a>02146     }
<a name="l02147"></a>02147 
<a name="l02148"></a>02148     <span class="keyword">template</span>&lt;<span class="keyword">class</span> G&gt;
<a name="l02149"></a>02149     <span class="keyword">inline</span> <span class="keyword">typename</span> G::VertexDescriptor Aggregator&lt;G&gt;::Stack::pop()
<a name="l02150"></a>02150     {
<a name="l02151"></a>02151       <span class="keywordflow">while</span>(size_&gt;0){
<a name="l02152"></a>02152         head_ = (head_ + N -1) % N;
<a name="l02153"></a>02153         size_--;
<a name="l02154"></a>02154         <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a> v = vals_[head_];
<a name="l02155"></a>02155         <span class="keywordflow">if</span>(aggregates_[v]==<a class="code" href="a00197.html#gd35c6c9e3aa1ec18c07a97279f8d3f77" title="Identifier of not yet aggregated vertices.">AggregatesMap&lt;Vertex&gt;::UNAGGREGATED</a>)
<a name="l02156"></a>02156           <span class="keywordflow">return</span> v;
<a name="l02157"></a>02157       }
<a name="l02158"></a>02158       <span class="comment">// Stack is empty try to fill it</span>
<a name="l02159"></a>02159       fill();
<a name="l02160"></a>02160       
<a name="l02161"></a>02161       <span class="comment">// try again</span>
<a name="l02162"></a>02162       <span class="keywordflow">while</span>(size_&gt;0){
<a name="l02163"></a>02163         head_ = (head_ + N -1) % N;
<a name="l02164"></a>02164         size_--;
<a name="l02165"></a>02165         <a class="code" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678" title="The vertex identifier.">Vertex</a> v = vals_[head_];
<a name="l02166"></a>02166         <span class="keywordflow">if</span>(aggregates_[v]==<a class="code" href="a00197.html#gd35c6c9e3aa1ec18c07a97279f8d3f77" title="Identifier of not yet aggregated vertices.">AggregatesMap&lt;Vertex&gt;::UNAGGREGATED</a>)
<a name="l02167"></a>02167           <span class="keywordflow">return</span> v;
<a name="l02168"></a>02168       }
<a name="l02169"></a>02169       <span class="keywordflow">return</span> NullEntry;
<a name="l02170"></a>02170     }
<a name="l02171"></a>02171 
<a name="l02172"></a>02172     <span class="keyword">template</span>&lt;<span class="keyword">class</span> V&gt;
<a name="l02173"></a>02173     <span class="keywordtype">void</span> printAggregates2d(<span class="keyword">const</span> AggregatesMap&lt;V&gt;&amp; aggregates, <span class="keywordtype">int</span> n, <span class="keywordtype">int</span> m,  std::ostream&amp; os)
<a name="l02174"></a>02174     {
<a name="l02175"></a>02175       std::ios_base::fmtflags oldOpts=os.flags();
<a name="l02176"></a>02176       
<a name="l02177"></a>02177       os.setf(std::ios_base::right, std::ios_base::adjustfield);
<a name="l02178"></a>02178       
<a name="l02179"></a>02179       V max=0;
<a name="l02180"></a>02180       <span class="keywordtype">int</span> width=1;
<a name="l02181"></a>02181 
<a name="l02182"></a>02182       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt; n*m; i++)
<a name="l02183"></a>02183         max=std::max(max, aggregates[i]);
<a name="l02184"></a>02184       
<a name="l02185"></a>02185       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=10; i &lt; 1000000; i*=10)
<a name="l02186"></a>02186         <span class="keywordflow">if</span>(max/i&gt;0)
<a name="l02187"></a>02187           width++;
<a name="l02188"></a>02188         <span class="keywordflow">else</span>
<a name="l02189"></a>02189           <span class="keywordflow">break</span>;
<a name="l02190"></a>02190       
<a name="l02191"></a>02191       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0, entry=0; j &lt; m; j++){
<a name="l02192"></a>02192         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;n; i++, entry++){
<a name="l02193"></a>02193           os.width(width);
<a name="l02194"></a>02194           os&lt;&lt;aggregates[entry]&lt;&lt;<span class="stringliteral">" "</span>;
<a name="l02195"></a>02195         }
<a name="l02196"></a>02196         
<a name="l02197"></a>02197         os&lt;&lt;std::endl;
<a name="l02198"></a>02198       }
<a name="l02199"></a>02199       os&lt;&lt;std::endl;
<a name="l02200"></a>02200       os.flags(oldOpts);
<a name="l02201"></a>02201     }
<a name="l02202"></a>02202     
<a name="l02203"></a>02203     
<a name="l02204"></a>02204   }<span class="comment">// namespace Amg</span>
<a name="l02205"></a>02205   
<a name="l02206"></a>02206 }<span class="comment">// namespace Dune</span>
<a name="l02207"></a>02207 
<a name="l02208"></a>02208 
<a name="l02209"></a>02209 <span class="preprocessor">#endif</span>
</pre></div></div>
</div> <!-- end doxygen -->
</div> <!-- end main -->
<div class="foot">

<p class="foot">
  Generated on 6 Nov 2008 with <a
  href="http://www.doxygen.org/">Doxygen</a> (ver 1.5.6)  
  [<a href="doxygen.log">logfile</a>].
</p>

</div>

</body>
</html>
