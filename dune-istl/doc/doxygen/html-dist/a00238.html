<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN""http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>dune-istl: owneroverlapcopy.hh Source File (dune-istl )</title>
  <link rel="stylesheet" type="text/css" href="./dune-doxy.css">
  <link rel="stylesheet" type="text/css" href="./tabs.css">
</head>
<div class="main">
<div class="doxygen">
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_39c25fa0261c9359275e2f8975608afb.html">istl</a>
  </div>
</div>
<div class="contents">
<h1>owneroverlapcopy.hh</h1><a href="a00168.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// $Id: owneroverlapcopy.hh 783 2007-08-03 08:17:56Z sander $</span>
<a name="l00002"></a>00002 <span class="preprocessor">#ifndef DUNE_OWNEROVERLAPCOPY_HH</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span><span class="preprocessor">#define DUNE_OWNEROVERLAPCOPY_HH</span>
<a name="l00004"></a>00004 <span class="preprocessor"></span>
<a name="l00005"></a>00005 <span class="preprocessor">#include&lt;new&gt;</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include&lt;iostream&gt;</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include&lt;vector&gt;</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include&lt;list&gt;</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include&lt;map&gt;</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include&lt;set&gt;</span>
<a name="l00011"></a>00011 
<a name="l00012"></a>00012 <span class="preprocessor">#include"cmath"</span>
<a name="l00013"></a>00013 
<a name="l00014"></a>00014 <span class="comment">// MPI header</span>
<a name="l00015"></a>00015 <span class="preprocessor">#if HAVE_MPI</span>
<a name="l00016"></a>00016 <span class="preprocessor"></span><span class="preprocessor">#include&lt;mpi.h&gt;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#endif</span>
<a name="l00018"></a>00018 <span class="preprocessor"></span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="preprocessor">#include&lt;dune/common/tuples.hh&gt;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include&lt;dune/common/enumset.hh&gt;</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="preprocessor">#if HAVE_MPI</span>
<a name="l00024"></a>00024 <span class="preprocessor"></span><span class="preprocessor">#include"<a class="code" href="a00153.html" title="Provides a map between global and local indices.">indexset.hh</a>"</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include"<a class="code" href="a00142.html" title="Provides utility classes for syncing distributed data via MPI communication.">communicator.hh</a>"</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include"<a class="code" href="a00175.html" title="Classes discribing a distributed indexset.">remoteindices.hh</a>"</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include&lt;dune/common/mpicollectivecommunication.hh&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#endif</span>
<a name="l00029"></a>00029 <span class="preprocessor"></span>
<a name="l00030"></a>00030 <span class="preprocessor">#include"solvercategory.hh"</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include"istlexception.hh"</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include&lt;dune/common/collectivecommunication.hh&gt;</span>
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 <span class="keyword">namespace </span>Dune {
<a name="l00035"></a>00035    
<a name="l00051"></a><a class="code" href="a00085.html">00051</a>   <span class="keyword">struct </span><a class="code" href="a00085.html" title="Attribute set for overlapping schwarz.">OwnerOverlapCopyAttributeSet</a>
<a name="l00052"></a>00052   {
<a name="l00053"></a>00053         <span class="keyword">enum</span> AttributeSet { 
<a name="l00054"></a>00054           owner=1, overlap=2, copy=0 };
<a name="l00055"></a>00055   };
<a name="l00056"></a>00056 
<a name="l00068"></a>00068   <span class="keyword">template</span> &lt;<span class="keyword">class</span> G, <span class="keyword">class</span> L&gt;
<a name="l00069"></a><a class="code" href="a00056.html">00069</a>   <span class="keyword">class </span><a class="code" href="a00056.html" title="Information about the index distribution.">IndexInfoFromGrid</a>
<a name="l00070"></a>00070   {
<a name="l00071"></a>00071   <span class="keyword">public</span>:
<a name="l00073"></a><a class="code" href="a00056.html#1f3b5adf7b577dfbab3874f1aa1ee6bc">00073</a>     <span class="keyword">typedef</span> G <a class="code" href="a00056.html#1f3b5adf7b577dfbab3874f1aa1ee6bc" title="The type of the global index.">GlobalIdType</a>;
<a name="l00074"></a>00074 
<a name="l00076"></a><a class="code" href="a00056.html#6aed54da56489b41890db40b94659d8c">00076</a>     <span class="keyword">typedef</span> L <a class="code" href="a00056.html#6aed54da56489b41890db40b94659d8c" title="The type of the local index.">LocalIdType</a>;
<a name="l00077"></a>00077     
<a name="l00084"></a><a class="code" href="a00056.html#36842faac3dcbe1b6d8f1682060347a2">00084</a>         <span class="keyword">typedef</span> Tuple&lt;GlobalIdType,LocalIdType,int&gt; <a class="code" href="a00056.html#36842faac3dcbe1b6d8f1682060347a2" title="A triple describing a local index.">IndexTripel</a>;
<a name="l00091"></a><a class="code" href="a00056.html#ac7ba4d17b15a3900e2d2935f25047c7">00091</a>         <span class="keyword">typedef</span> Tuple&lt;int,GlobalIdType,int&gt; <a class="code" href="a00056.html#ac7ba4d17b15a3900e2d2935f25047c7" title="A triple describing a remote index.">RemoteIndexTripel</a>;
<a name="l00092"></a>00092 
<a name="l00098"></a><a class="code" href="a00056.html#be68ec246c9997a684109912da7f21f8">00098</a>         <span class="keywordtype">void</span> <a class="code" href="a00056.html#be68ec246c9997a684109912da7f21f8" title="Add a new index triple to the set of local indices.">addLocalIndex</a> (<span class="keyword">const</span> <a class="code" href="a00056.html#36842faac3dcbe1b6d8f1682060347a2" title="A triple describing a local index.">IndexTripel</a>&amp; x)
<a name="l00099"></a>00099         {
<a name="l00100"></a>00100           <span class="keywordflow">if</span> (Element&lt;2&gt;::get(x)!=OwnerOverlapCopyAttributeSet::owner &amp;&amp; 
<a name="l00101"></a>00101                   Element&lt;2&gt;::get(x)!=OwnerOverlapCopyAttributeSet::overlap &amp;&amp; 
<a name="l00102"></a>00102                   Element&lt;2&gt;::get(x)!=OwnerOverlapCopyAttributeSet::copy)
<a name="l00103"></a>00103                 DUNE_THROW(<a class="code" href="a00067.html" title="derive error class from the base class in common">ISTLError</a>,<span class="stringliteral">"OwnerOverlapCopyCommunication: global index not in index set"</span>);
<a name="l00104"></a>00104           localindices.insert(x);
<a name="l00105"></a>00105         }
<a name="l00106"></a>00106 
<a name="l00112"></a><a class="code" href="a00056.html#19a502ca3b5f6947013be3195e206dd0">00112</a>         <span class="keywordtype">void</span> <a class="code" href="a00056.html#19a502ca3b5f6947013be3195e206dd0" title="Add a new remote index triple to the set of remote indices.">addRemoteIndex</a> (<span class="keyword">const</span> <a class="code" href="a00056.html#ac7ba4d17b15a3900e2d2935f25047c7" title="A triple describing a remote index.">RemoteIndexTripel</a>&amp; x)
<a name="l00113"></a>00113         {
<a name="l00114"></a>00114           <span class="keywordflow">if</span> (Element&lt;2&gt;::get(x)!=OwnerOverlapCopyAttributeSet::owner &amp;&amp; 
<a name="l00115"></a>00115                   Element&lt;2&gt;::get(x)!=OwnerOverlapCopyAttributeSet::overlap &amp;&amp; 
<a name="l00116"></a>00116                   Element&lt;2&gt;::get(x)!=OwnerOverlapCopyAttributeSet::copy)
<a name="l00117"></a>00117                 DUNE_THROW(<a class="code" href="a00067.html" title="derive error class from the base class in common">ISTLError</a>,<span class="stringliteral">"OwnerOverlapCopyCommunication: global index not in index set"</span>);
<a name="l00118"></a>00118           remoteindices.insert(x);
<a name="l00119"></a>00119         }
<a name="l00120"></a>00120 
<a name="l00125"></a><a class="code" href="a00056.html#7439a54bb21dcb4225307627d0968aa5">00125</a>         <span class="keyword">const</span> std::set&lt;IndexTripel&gt;&amp; <a class="code" href="a00056.html#7439a54bb21dcb4225307627d0968aa5" title="Get the set of indices local to the process.">localIndices</a> ()<span class="keyword"> const</span>
<a name="l00126"></a>00126 <span class="keyword">        </span>{
<a name="l00127"></a>00127           <span class="keywordflow">return</span> localindices;
<a name="l00128"></a>00128         }
<a name="l00129"></a>00129 
<a name="l00134"></a><a class="code" href="a00056.html#5916365c0a566bd287df6c8051d841da">00134</a>         <span class="keyword">const</span> std::set&lt;RemoteIndexTripel&gt;&amp; <a class="code" href="a00056.html#5916365c0a566bd287df6c8051d841da" title="Get the set of remote indices.">remoteIndices</a> ()<span class="keyword"> const</span>
<a name="l00135"></a>00135 <span class="keyword">        </span>{
<a name="l00136"></a>00136           <span class="keywordflow">return</span> remoteindices;
<a name="l00137"></a>00137         }
<a name="l00138"></a>00138 
<a name="l00142"></a><a class="code" href="a00056.html#99513b4177ba3bf5634701c0be9c140e">00142</a>         <span class="keywordtype">void</span> <a class="code" href="a00056.html#99513b4177ba3bf5634701c0be9c140e" title="Remove all indices from the sets.">clear</a> ()
<a name="l00143"></a>00143         {
<a name="l00144"></a>00144           localindices.clear();
<a name="l00145"></a>00145           remoteindices.clear();
<a name="l00146"></a>00146         }
<a name="l00147"></a>00147 
<a name="l00148"></a>00148   <span class="keyword">private</span>:
<a name="l00150"></a>00150         std::set&lt;IndexTripel&gt; localindices;
<a name="l00152"></a>00152         std::set&lt;RemoteIndexTripel&gt; remoteindices;
<a name="l00153"></a>00153   };
<a name="l00154"></a>00154 
<a name="l00155"></a>00155 
<a name="l00156"></a>00156 <span class="preprocessor">#if HAVE_MPI</span>
<a name="l00157"></a>00157 <span class="preprocessor"></span>
<a name="l00164"></a>00164   <span class="keyword">template</span> &lt;<span class="keyword">class</span> GlobalIdType, <span class="keyword">class</span> LocalIdType&gt;
<a name="l00165"></a><a class="code" href="a00086.html">00165</a>   <span class="keyword">class </span><a class="code" href="a00086.html" title="A class setting up standard communication for a two-valued attribute set with owner/overlap/copy...">OwnerOverlapCopyCommunication</a>
<a name="l00166"></a>00166   {
<a name="l00167"></a>00167         <span class="comment">// used types</span>
<a name="l00168"></a>00168         <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="a00056.html" title="Information about the index distribution.">IndexInfoFromGrid&lt;GlobalIdType,LocalIdType&gt;::IndexTripel</a> IndexTripel;
<a name="l00169"></a>00169         <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="a00056.html" title="Information about the index distribution.">IndexInfoFromGrid&lt;GlobalIdType,LocalIdType&gt;::RemoteIndexTripel</a> RemoteIndexTripel;
<a name="l00170"></a>00170         <span class="keyword">typedef</span> <span class="keyword">typename</span> std::set&lt;IndexTripel&gt;::const_iterator localindex_iterator;
<a name="l00171"></a>00171         <span class="keyword">typedef</span> <span class="keyword">typename</span> std::set&lt;RemoteIndexTripel&gt;::const_iterator remoteindex_iterator;
<a name="l00172"></a>00172     <span class="keyword">typedef</span> <span class="keyword">typename</span> OwnerOverlapCopyAttributeSet::AttributeSet AttributeSet;
<a name="l00173"></a>00173         <span class="keyword">typedef</span> <a class="code" href="a00089.html" title="An index present on the local process with an additional attribute flag.">ParallelLocalIndex&lt;AttributeSet&gt;</a> <a class="code" href="a00089.html" title="An index present on the local process with an additional attribute flag.">LI</a>;
<a name="l00174"></a>00174         <span class="keyword">typedef</span> <a class="code" href="a00087.html" title="Manager class for the mapping between local indices and globally unique indices.">ParallelIndexSet&lt;GlobalIdType,LI,512&gt;</a> <a class="code" href="a00087.html" title="Manager class for the mapping between local indices and globally unique indices.">PIS</a>;
<a name="l00175"></a>00175         <span class="keyword">typedef</span> <a class="code" href="a00097.html" title="The indices present on remote processes.">RemoteIndices&lt;PIS&gt;</a> <a class="code" href="a00097.html" title="The indices present on remote processes.">RI</a>;
<a name="l00176"></a>00176         <span class="keyword">typedef</span> <a class="code" href="a00096.html" title="Modifier for adding and/or deleting remote indices from the remote index list.">RemoteIndexListModifier&lt;PIS,false&gt;</a> <a class="code" href="a00096.html" title="Modifier for adding and/or deleting remote indices from the remote index list.">RILM</a>;
<a name="l00177"></a>00177         <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="a00095.html" title="Information about an index residing on another processor.">RI::RemoteIndex</a> <a class="code" href="a00095.html" title="Information about an index residing on another processor.">RX</a>;
<a name="l00178"></a>00178         <span class="keyword">typedef</span> <a class="code" href="a00024.html" title="A communicator that uses buffers to gather and scatter the data to be send or received...">BufferedCommunicator&lt;PIS&gt;</a> <a class="code" href="a00024.html" title="A communicator that uses buffers to gather and scatter the data to be send or received...">BC</a>;
<a name="l00179"></a>00179         <span class="keyword">typedef</span> <a class="code" href="a00060.html" title="Communication interface between remote and local indices.">Interface&lt;PIS&gt;</a> <a class="code" href="a00060.html" title="Communication interface between remote and local indices.">IF</a>;
<a name="l00180"></a>00180 
<a name="l00181"></a>00181     
<a name="l00183"></a>00183         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00184"></a>00184         <span class="keyword">struct </span>CopyGatherScatter
<a name="l00185"></a>00185         {
<a name="l00186"></a>00186           <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="a00030.html" title="Default policy used for communicating an indexed type.">CommPolicy&lt;T&gt;::IndexedType</a> V;
<a name="l00187"></a>00187 
<a name="l00188"></a>00188           <span class="keyword">static</span> V gather(<span class="keyword">const</span> T&amp; a, <span class="keywordtype">int</span> i)
<a name="l00189"></a>00189           {
<a name="l00190"></a>00190                 <span class="keywordflow">return</span> a[i];
<a name="l00191"></a>00191           }
<a name="l00192"></a>00192           
<a name="l00193"></a>00193           <span class="keyword">static</span> <span class="keywordtype">void</span> scatter(T&amp; a, V v, <span class="keywordtype">int</span> i)
<a name="l00194"></a>00194           {
<a name="l00195"></a>00195                 a[i] = v;
<a name="l00196"></a>00196           }
<a name="l00197"></a>00197         };
<a name="l00198"></a>00198         <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00199"></a>00199         <span class="keyword">struct </span>AddGatherScatter
<a name="l00200"></a>00200         {
<a name="l00201"></a>00201           <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="a00030.html" title="Default policy used for communicating an indexed type.">CommPolicy&lt;T&gt;::IndexedType</a> V;
<a name="l00202"></a>00202 
<a name="l00203"></a>00203           <span class="keyword">static</span> V gather(<span class="keyword">const</span> T&amp; a, <span class="keywordtype">int</span> i)
<a name="l00204"></a>00204           {
<a name="l00205"></a>00205                 <span class="keywordflow">return</span> a[i];
<a name="l00206"></a>00206           }
<a name="l00207"></a>00207           
<a name="l00208"></a>00208           <span class="keyword">static</span> <span class="keywordtype">void</span> scatter(T&amp; a, V v, <span class="keywordtype">int</span> i)
<a name="l00209"></a>00209           {
<a name="l00210"></a>00210                 a[i] += v;
<a name="l00211"></a>00211           }
<a name="l00212"></a>00212         };
<a name="l00213"></a>00213 
<a name="l00214"></a>00214         <span class="keywordtype">void</span> buildOwnerOverlapToAllInterface ()<span class="keyword"> const</span>
<a name="l00215"></a>00215 <span class="keyword">        </span>{
<a name="l00216"></a>00216           <span class="keywordflow">if</span> (OwnerOverlapToAllInterfaceBuilt)
<a name="l00217"></a>00217                 OwnerOverlapToAllInterface.<a class="code" href="a00195.html#g7998a5cc771852a49c8833b52e82a0ba" title="Frees memory allocated during the build.">free</a>();
<a name="l00218"></a>00218           <span class="keyword">typedef</span> Combine&lt;EnumItem&lt;AttributeSet,OwnerOverlapCopyAttributeSet::owner&gt;,EnumItem&lt;AttributeSet,OwnerOverlapCopyAttributeSet::overlap&gt;,AttributeSet&gt; OwnerOverlapSet;
<a name="l00219"></a>00219           <span class="keyword">typedef</span> Combine&lt;OwnerOverlapSet,EnumItem&lt;AttributeSet,OwnerOverlapCopyAttributeSet::copy&gt;,AttributeSet&gt; AllSet;
<a name="l00220"></a>00220           OwnerOverlapSet sourceFlags;
<a name="l00221"></a>00221           AllSet destFlags;
<a name="l00222"></a>00222           OwnerOverlapToAllInterface.<a class="code" href="a00195.html#g5d3351c8857ba5cfdd74d28bb5725a30" title="Builds the interface.">build</a>(ri,sourceFlags,destFlags);
<a name="l00223"></a>00223           OwnerOverlapToAllInterfaceBuilt = <span class="keyword">true</span>;
<a name="l00224"></a>00224         }
<a name="l00225"></a>00225 
<a name="l00226"></a>00226         <span class="keywordtype">void</span> buildOwnerToAllInterface ()<span class="keyword"> const</span>
<a name="l00227"></a>00227 <span class="keyword">        </span>{
<a name="l00228"></a>00228           <span class="keywordflow">if</span> (OwnerToAllInterfaceBuilt)
<a name="l00229"></a>00229                 OwnerToAllInterface.<a class="code" href="a00195.html#g7998a5cc771852a49c8833b52e82a0ba" title="Frees memory allocated during the build.">free</a>();
<a name="l00230"></a>00230           <span class="keyword">typedef</span> EnumItem&lt;AttributeSet,OwnerOverlapCopyAttributeSet::owner&gt; OwnerSet;
<a name="l00231"></a>00231           <span class="keyword">typedef</span> Combine&lt;EnumItem&lt;AttributeSet,OwnerOverlapCopyAttributeSet::owner&gt;,EnumItem&lt;AttributeSet,OwnerOverlapCopyAttributeSet::overlap&gt;,AttributeSet&gt; OwnerOverlapSet;
<a name="l00232"></a>00232           <span class="keyword">typedef</span> Combine&lt;OwnerOverlapSet,EnumItem&lt;AttributeSet,OwnerOverlapCopyAttributeSet::copy&gt;,AttributeSet&gt; AllSet;
<a name="l00233"></a>00233           OwnerOverlapSet sourceFlags;
<a name="l00234"></a>00234           AllSet destFlags;
<a name="l00235"></a>00235           OwnerToAllInterface.<a class="code" href="a00195.html#g5d3351c8857ba5cfdd74d28bb5725a30" title="Builds the interface.">build</a>(ri,sourceFlags,destFlags);
<a name="l00236"></a>00236           OwnerToAllInterfaceBuilt = <span class="keyword">true</span>;
<a name="l00237"></a>00237         }
<a name="l00238"></a>00238 
<a name="l00239"></a>00239   <span class="keyword">public</span>:
<a name="l00240"></a>00240       <span class="keyword">enum</span>{
<a name="l00241"></a>00241         category = <a class="code" href="a00114.html#c8ffad5e3e40145669da6089b16c9574fa10e78074c8114bcbcd6dfae4dc0888" title="Category for ovelapping solvers.">SolverCategory::overlapping</a>
<a name="l00242"></a>00242           };
<a name="l00243"></a>00243 
<a name="l00244"></a>00244     <span class="keyword">const</span> CollectiveCommunication&lt;MPI_Comm&gt;&amp; communicator()<span class="keyword"> const</span>
<a name="l00245"></a>00245 <span class="keyword">    </span>{
<a name="l00246"></a>00246       <span class="keywordflow">return</span> cc;
<a name="l00247"></a>00247     }
<a name="l00248"></a>00248     
<a name="l00255"></a>00255         <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00256"></a><a class="code" href="a00086.html#82f28eef2a3a99b898d35e98c610f378">00256</a>         <span class="keywordtype">void</span> <a class="code" href="a00086.html#82f28eef2a3a99b898d35e98c610f378" title="Communicate values from owner data points to all other data points.">copyOwnerToAll</a> (<span class="keyword">const</span> T&amp; source, T&amp; dest)<span class="keyword"> const</span>
<a name="l00257"></a>00257 <span class="keyword">        </span>{
<a name="l00258"></a>00258           <span class="keywordflow">if</span> (!OwnerToAllInterfaceBuilt)
<a name="l00259"></a>00259                 buildOwnerToAllInterface ();
<a name="l00260"></a>00260           <a class="code" href="a00024.html" title="A communicator that uses buffers to gather and scatter the data to be send or received...">BC</a> communicator;
<a name="l00261"></a>00261           communicator.template build&lt;T&gt;(OwnerToAllInterface);
<a name="l00262"></a>00262           communicator.template forward&lt;CopyGatherScatter&lt;T&gt; &gt;(source,dest);
<a name="l00263"></a>00263           communicator.<a class="code" href="a00195.html#g91148e43446c9a8efe0e93615ce9e825" title="Free the allocated memory (i.e. buffers and message information.">free</a>();
<a name="l00264"></a>00264         }
<a name="l00265"></a>00265 
<a name="l00266"></a>00266     
<a name="l00273"></a>00273         <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;
<a name="l00274"></a><a class="code" href="a00086.html#6bdcc4e86dd9ba8a4fffeb58e1b85f74">00274</a>         <span class="keywordtype">void</span> <a class="code" href="a00086.html#6bdcc4e86dd9ba8a4fffeb58e1b85f74" title="Communicate values from owner data points to all other data points and add them to...">addOwnerOverlapToAll</a> (<span class="keyword">const</span> T&amp; source, T&amp; dest)<span class="keyword"> const</span>
<a name="l00275"></a>00275 <span class="keyword">        </span>{
<a name="l00276"></a>00276           <span class="keywordflow">if</span> (!OwnerOverlapToAllInterfaceBuilt)
<a name="l00277"></a>00277                 buildOwnerOverlapToAllInterface ();
<a name="l00278"></a>00278           <a class="code" href="a00024.html" title="A communicator that uses buffers to gather and scatter the data to be send or received...">BC</a> communicator;
<a name="l00279"></a>00279           communicator.template build&lt;T&gt;(OwnerOverlapToAllInterface);
<a name="l00280"></a>00280           communicator.template forward&lt;AddGatherScatter&lt;T&gt; &gt;(source,dest);
<a name="l00281"></a>00281           communicator.<a class="code" href="a00195.html#g91148e43446c9a8efe0e93615ce9e825" title="Free the allocated memory (i.e. buffers and message information.">free</a>();
<a name="l00282"></a>00282         }
<a name="l00283"></a>00283 
<a name="l00291"></a>00291         <span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;
<a name="l00292"></a><a class="code" href="a00086.html#8cf5af772109512771de2d5bbbacb85c">00292</a>         <span class="keywordtype">void</span> <a class="code" href="a00086.html#8cf5af772109512771de2d5bbbacb85c" title="Compute a global dot product of two vectors.">dot</a> (<span class="keyword">const</span> T1&amp; x, <span class="keyword">const</span> T1&amp; y, T2&amp; result)<span class="keyword"> const</span>
<a name="l00293"></a>00293 <span class="keyword">        </span>{
<a name="l00294"></a>00294           <span class="comment">// set up mask vector</span>
<a name="l00295"></a>00295           <span class="keywordflow">if</span> (mask.size()!=<span class="keyword">static_cast&lt;</span>typename std::vector&lt;double&gt;::size_type<span class="keyword">&gt;</span>(x.size()))
<a name="l00296"></a>00296                 {
<a name="l00297"></a>00297                   mask.resize(x.size());
<a name="l00298"></a>00298                   <span class="keywordflow">for</span> (<span class="keyword">typename</span> std::vector&lt;double&gt;::size_type i=0; i&lt;mask.size(); i++) 
<a name="l00299"></a>00299                     mask[i] = 1;
<a name="l00300"></a>00300                   <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="a00195.html#g2d339136484321658ecf88e2e4dfa28b" title="The constant iterator over the pairs.">PIS::const_iterator</a> i=pis.<a class="code" href="a00195.html#g1f7489201417827fc547818553c1d57b" title="Get an iterator over the indices positioned at the first index.">begin</a>(); i!=pis.<a class="code" href="a00195.html#g76c8b73b6353cde82b8877ac982a17ae" title="Get an iterator over the indices positioned after the last index.">end</a>(); ++i)
<a name="l00301"></a>00301                         <span class="keywordflow">if</span> (i-&gt;local().attribute()!=OwnerOverlapCopyAttributeSet::owner)
<a name="l00302"></a>00302                           mask[i-&gt;local().local()] = 0;
<a name="l00303"></a>00303                 }
<a name="l00304"></a>00304           result = 0;
<a name="l00305"></a>00305           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;x.size(); i++)
<a name="l00306"></a>00306                 result += x[i]*(y[i])*mask[i];
<a name="l00307"></a>00307           result = cc.sum(result);
<a name="l00308"></a>00308           <span class="keywordflow">return</span>;
<a name="l00309"></a>00309         }
<a name="l00310"></a>00310 
<a name="l00317"></a>00317         <span class="keyword">template</span>&lt;<span class="keyword">class</span> T1&gt;
<a name="l00318"></a><a class="code" href="a00086.html#23f365e1c778f8af687cafcc42de13db">00318</a>         <span class="keywordtype">double</span> <a class="code" href="a00086.html#23f365e1c778f8af687cafcc42de13db" title="Compute the global euclidian norm of a vector.">norm</a> (<span class="keyword">const</span> T1&amp; x)<span class="keyword"> const</span>
<a name="l00319"></a>00319 <span class="keyword">        </span>{
<a name="l00320"></a>00320           <span class="comment">// set up mask vector</span>
<a name="l00321"></a>00321           <span class="keywordflow">if</span> (mask.size()!=<span class="keyword">static_cast&lt;</span>typename std::vector&lt;double&gt;::size_type<span class="keyword">&gt;</span>(x.size()))
<a name="l00322"></a>00322                 {
<a name="l00323"></a>00323                   mask.resize(x.size());
<a name="l00324"></a>00324                   <span class="keywordflow">for</span> (<span class="keyword">typename</span> std::vector&lt;double&gt;::size_type i=0; i&lt;mask.size(); i++) 
<a name="l00325"></a>00325                     mask[i] = 1;
<a name="l00326"></a>00326                   <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="a00195.html#g2d339136484321658ecf88e2e4dfa28b" title="The constant iterator over the pairs.">PIS::const_iterator</a> i=pis.<a class="code" href="a00195.html#g1f7489201417827fc547818553c1d57b" title="Get an iterator over the indices positioned at the first index.">begin</a>(); i!=pis.<a class="code" href="a00195.html#g76c8b73b6353cde82b8877ac982a17ae" title="Get an iterator over the indices positioned after the last index.">end</a>(); ++i)
<a name="l00327"></a>00327                         <span class="keywordflow">if</span> (i-&gt;local().attribute()!=OwnerOverlapCopyAttributeSet::owner)
<a name="l00328"></a>00328                           mask[i-&gt;local().local()] = 0;
<a name="l00329"></a>00329                 }
<a name="l00330"></a>00330           <span class="keywordtype">double</span> result = 0;
<a name="l00331"></a>00331           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;x.size(); i++)
<a name="l00332"></a>00332                 result += x[i].two_norm2()*mask[i];
<a name="l00333"></a>00333           <span class="keywordflow">return</span> sqrt(cc.sum(result));
<a name="l00334"></a>00334         }
<a name="l00335"></a>00335 
<a name="l00336"></a>00336         <span class="keyword">typedef</span> EnumItem&lt;AttributeSet,OwnerOverlapCopyAttributeSet::copy&gt; CopyFlags;
<a name="l00337"></a>00337     
<a name="l00339"></a><a class="code" href="a00086.html#007905d3c582d62a0518a264d6712fbb">00339</a>     <span class="keyword">typedef</span> <a class="code" href="a00087.html" title="Manager class for the mapping between local indices and globally unique indices.">ParallelIndexSet&lt;GlobalIdType,LI,512&gt;</a> <a class="code" href="a00087.html" title="Manager class for the mapping between local indices and globally unique indices.">ParallelIndexSet</a>;
<a name="l00340"></a>00340 
<a name="l00342"></a><a class="code" href="a00086.html#652fa06bc40c2b853bada4ceae3c413c">00342</a>     <span class="keyword">typedef</span> <a class="code" href="a00097.html" title="The indices present on remote processes.">RemoteIndices&lt;PIS&gt;</a> <a class="code" href="a00097.html" title="The indices present on remote processes.">RemoteIndices</a>;
<a name="l00343"></a>00343 
<a name="l00346"></a><a class="code" href="a00086.html#4d18c28c70bcbf749e8b37f8335c8389">00346</a>     <span class="keyword">typedef</span> <a class="code" href="a00050.html" title="Decorates an index set with the possibility to find a global index that is mapped...">GlobalLookupIndexSet&lt;ParallelIndexSet&gt;</a> <a class="code" href="a00050.html" title="Decorates an index set with the possibility to find a global index that is mapped...">GlobalLookupIndexSet</a>;
<a name="l00347"></a>00347 
<a name="l00352"></a><a class="code" href="a00086.html#d0879971da9f61ed37b1717e8c24222d">00352</a>     <span class="keyword">const</span> <a class="code" href="a00087.html" title="Manager class for the mapping between local indices and globally unique indices.">ParallelIndexSet</a>&amp; <a class="code" href="a00086.html#d0879971da9f61ed37b1717e8c24222d" title="Get the underlying parallel index set.">indexSet</a>()<span class="keyword"> const</span>
<a name="l00353"></a>00353 <span class="keyword">    </span>{
<a name="l00354"></a>00354       <span class="keywordflow">return</span> pis;
<a name="l00355"></a>00355     }
<a name="l00356"></a>00356     
<a name="l00361"></a><a class="code" href="a00086.html#3493d50c48eca40162df19e85154d540">00361</a>     <span class="keyword">const</span> <a class="code" href="a00097.html" title="The indices present on remote processes.">RemoteIndices</a>&amp; <a class="code" href="a00086.html#3493d50c48eca40162df19e85154d540" title="Get the underlying remote indices.">remoteIndices</a>()<span class="keyword"> const</span>
<a name="l00362"></a>00362 <span class="keyword">    </span>{
<a name="l00363"></a>00363       <span class="keywordflow">return</span> ri;
<a name="l00364"></a>00364     }
<a name="l00365"></a>00365     
<a name="l00370"></a><a class="code" href="a00086.html#22627a41708de0f89d33c583766d33ff">00370</a>     <a class="code" href="a00087.html" title="Manager class for the mapping between local indices and globally unique indices.">ParallelIndexSet</a>&amp; <a class="code" href="a00086.html#d0879971da9f61ed37b1717e8c24222d" title="Get the underlying parallel index set.">indexSet</a>()
<a name="l00371"></a>00371     {
<a name="l00372"></a>00372       <span class="keywordflow">return</span> pis;
<a name="l00373"></a>00373     }
<a name="l00374"></a>00374     
<a name="l00375"></a>00375 
<a name="l00380"></a><a class="code" href="a00086.html#154f59498d59c46b838ebc961f8c8133">00380</a>     <a class="code" href="a00097.html" title="The indices present on remote processes.">RemoteIndices</a>&amp; <a class="code" href="a00086.html#3493d50c48eca40162df19e85154d540" title="Get the underlying remote indices.">remoteIndices</a>()
<a name="l00381"></a>00381     {
<a name="l00382"></a>00382       <span class="keywordflow">return</span> ri;
<a name="l00383"></a>00383     }
<a name="l00384"></a>00384 
<a name="l00385"></a>00385     <span class="keywordtype">void</span> buildGlobalLookup(std::size_t size)
<a name="l00386"></a>00386     {
<a name="l00387"></a>00387       assert(!globalLookup_);
<a name="l00388"></a>00388       globalLookup_ = <span class="keyword">new</span> <a class="code" href="a00086.html#4d18c28c70bcbf749e8b37f8335c8389" title="The type of the reverse lookup of indices.">GlobalLookupIndexSet</a>(pis, size);
<a name="l00389"></a>00389     }
<a name="l00390"></a>00390 
<a name="l00391"></a>00391     <span class="keywordtype">void</span> freeGlobalLookup()
<a name="l00392"></a>00392     {
<a name="l00393"></a>00393       <span class="keyword">delete</span> globalLookup_;
<a name="l00394"></a>00394       globalLookup_=0;
<a name="l00395"></a>00395     }    
<a name="l00396"></a>00396 
<a name="l00397"></a>00397     <span class="keyword">const</span> <a class="code" href="a00086.html#4d18c28c70bcbf749e8b37f8335c8389" title="The type of the reverse lookup of indices.">GlobalLookupIndexSet</a>&amp; globalLookup()<span class="keyword"> const</span>
<a name="l00398"></a>00398 <span class="keyword">    </span>{
<a name="l00399"></a>00399       assert(globalLookup_ != 0);
<a name="l00400"></a>00400       <span class="keywordflow">return</span> *globalLookup_;
<a name="l00401"></a>00401     }
<a name="l00402"></a>00402     
<a name="l00408"></a>00408         <span class="keyword">template</span>&lt;<span class="keyword">class</span> T1&gt;
<a name="l00409"></a><a class="code" href="a00086.html#fe6282db199f41a18c33febfeb7ce6fb">00409</a>         <span class="keywordtype">void</span> <a class="code" href="a00086.html#fe6282db199f41a18c33febfeb7ce6fb" title="Set vector to zero at copy dofs.">project</a> (T1&amp; x)<span class="keyword"> const</span>
<a name="l00410"></a>00410 <span class="keyword">        </span>{
<a name="l00411"></a>00411           <span class="keywordflow">for</span> (<span class="keyword">typename</span> <a class="code" href="a00195.html#g2d339136484321658ecf88e2e4dfa28b" title="The constant iterator over the pairs.">PIS::const_iterator</a> i=pis.<a class="code" href="a00195.html#g1f7489201417827fc547818553c1d57b" title="Get an iterator over the indices positioned at the first index.">begin</a>(); i!=pis.<a class="code" href="a00195.html#g76c8b73b6353cde82b8877ac982a17ae" title="Get an iterator over the indices positioned after the last index.">end</a>(); ++i)
<a name="l00412"></a>00412                 <span class="keywordflow">if</span> (i-&gt;local().attribute()==OwnerOverlapCopyAttributeSet::copy)
<a name="l00413"></a>00413                   x[i-&gt;local().local()] = 0;
<a name="l00414"></a>00414         }
<a name="l00415"></a>00415 
<a name="l00416"></a>00416 
<a name="l00424"></a><a class="code" href="a00086.html#d076f7151f5c8986681910a4c9665eac">00424</a>     <a class="code" href="a00086.html#d076f7151f5c8986681910a4c9665eac" title="Construct the communication without any indices.">OwnerOverlapCopyCommunication</a> (MPI_Comm comm_)
<a name="l00425"></a>00425       : cc(comm_), pis(), ri(pis,pis,comm_), 
<a name="l00426"></a>00426         OwnerToAllInterfaceBuilt(false), OwnerOverlapToAllInterfaceBuilt(false), globalLookup_(0)
<a name="l00427"></a>00427     {}
<a name="l00428"></a>00428     
<a name="l00434"></a><a class="code" href="a00086.html#52bd6f2fa5c51ea9f8638f50547031e9">00434</a>         <a class="code" href="a00086.html#d076f7151f5c8986681910a4c9665eac" title="Construct the communication without any indices.">OwnerOverlapCopyCommunication</a> (<span class="keyword">const</span> <a class="code" href="a00056.html" title="Information about the index distribution.">IndexInfoFromGrid&lt;GlobalIdType,LocalIdType&gt;</a>&amp; indexinfo, MPI_Comm comm_)
<a name="l00435"></a>00435           : cc(comm_),OwnerToAllInterfaceBuilt(false),OwnerOverlapToAllInterfaceBuilt(false), globalLookup_(0)
<a name="l00436"></a>00436         {
<a name="l00437"></a>00437           <span class="comment">// set up an ISTL index set</span>
<a name="l00438"></a>00438           pis.<a class="code" href="a00195.html#g10a18b0bbba6cbda15a58d7a2ede111f" title="Indicate that the index set is to be resized. If index set was not in ParallelIndexSetState::GROUND...">beginResize</a>();
<a name="l00439"></a>00439           <span class="keywordflow">for</span> (localindex_iterator i=indexinfo.<a class="code" href="a00056.html#7439a54bb21dcb4225307627d0968aa5" title="Get the set of indices local to the process.">localIndices</a>().begin(); i!=indexinfo.<a class="code" href="a00056.html#7439a54bb21dcb4225307627d0968aa5" title="Get the set of indices local to the process.">localIndices</a>().end(); ++i)
<a name="l00440"></a>00440                 {
<a name="l00441"></a>00441                   <span class="keywordflow">if</span> (Element&lt;2&gt;::get(*i)==OwnerOverlapCopyAttributeSet::owner)
<a name="l00442"></a>00442                         pis.<a class="code" href="a00195.html#g314b28a2ac2171f330979eb82c7d48fc" title="Add an new index to the set.">add</a>(Element&lt;0&gt;::get(*i),<a class="code" href="a00089.html" title="An index present on the local process with an additional attribute flag.">LI</a>(Element&lt;1&gt;::get(*i),OwnerOverlapCopyAttributeSet::owner,<span class="keyword">true</span>));
<a name="l00443"></a>00443                   <span class="keywordflow">if</span> (Element&lt;2&gt;::get(*i)==OwnerOverlapCopyAttributeSet::overlap)
<a name="l00444"></a>00444                         pis.<a class="code" href="a00195.html#g314b28a2ac2171f330979eb82c7d48fc" title="Add an new index to the set.">add</a>(Element&lt;0&gt;::get(*i),<a class="code" href="a00089.html" title="An index present on the local process with an additional attribute flag.">LI</a>(Element&lt;1&gt;::get(*i),OwnerOverlapCopyAttributeSet::overlap,<span class="keyword">true</span>));
<a name="l00445"></a>00445                   <span class="keywordflow">if</span> (Element&lt;2&gt;::get(*i)==OwnerOverlapCopyAttributeSet::copy)
<a name="l00446"></a>00446                         pis.<a class="code" href="a00195.html#g314b28a2ac2171f330979eb82c7d48fc" title="Add an new index to the set.">add</a>(Element&lt;0&gt;::get(*i),<a class="code" href="a00089.html" title="An index present on the local process with an additional attribute flag.">LI</a>(Element&lt;1&gt;::get(*i),OwnerOverlapCopyAttributeSet::copy,<span class="keyword">true</span>));
<a name="l00447"></a>00447 <span class="comment">//                std::cout &lt;&lt; cc.rank() &lt;&lt; ": adding index " &lt;&lt; Element&lt;0&gt;::get(*i) &lt;&lt; " " &lt;&lt; Element&lt;1&gt;::get(*i) &lt;&lt; " " &lt;&lt; Element&lt;2&gt;::get(*i) &lt;&lt; std::endl;</span>
<a name="l00448"></a>00448                 }
<a name="l00449"></a>00449           pis.<a class="code" href="a00195.html#gadfad947098175e885aa7fd6c5b490a5" title="Indicate that the resizing finishes.">endResize</a>();
<a name="l00450"></a>00450 
<a name="l00451"></a>00451           <span class="comment">// build remote indices WITHOUT communication</span>
<a name="l00452"></a>00452 <span class="comment">//        std::cout &lt;&lt; cc.rank() &lt;&lt; ": build remote indices" &lt;&lt; std::endl;</span>
<a name="l00453"></a>00453           ri.<a class="code" href="a00097.html#cf8c9eb42950f1c8f99c0dc816a5ee13" title="Set the the index sets and communicator we work with.">setIndexSets</a>(pis,pis,cc);
<a name="l00454"></a>00454           <span class="keywordflow">if</span> (indexinfo.<a class="code" href="a00056.html#5916365c0a566bd287df6c8051d841da" title="Get the set of remote indices.">remoteIndices</a>().size()&gt;0)
<a name="l00455"></a>00455                 {
<a name="l00456"></a>00456                   remoteindex_iterator i=indexinfo.<a class="code" href="a00056.html#5916365c0a566bd287df6c8051d841da" title="Get the set of remote indices.">remoteIndices</a>().begin();
<a name="l00457"></a>00457                   <span class="keywordtype">int</span> p = Element&lt;0&gt;::get(*i);
<a name="l00458"></a>00458                   <a class="code" href="a00096.html" title="Modifier for adding and/or deleting remote indices from the remote index list.">RILM</a> modifier = ri.template getModifier&lt;false,true&gt;(p);
<a name="l00459"></a>00459                   <span class="keyword">typename</span> <a class="code" href="a00195.html#g2d339136484321658ecf88e2e4dfa28b" title="The constant iterator over the pairs.">PIS::const_iterator</a> pi=pis.<a class="code" href="a00195.html#g1f7489201417827fc547818553c1d57b" title="Get an iterator over the indices positioned at the first index.">begin</a>();
<a name="l00460"></a>00460                   <span class="keywordflow">for</span> ( ; i!=indexinfo.<a class="code" href="a00056.html#5916365c0a566bd287df6c8051d841da" title="Get the set of remote indices.">remoteIndices</a>().end(); ++i)
<a name="l00461"></a>00461                         {
<a name="l00462"></a>00462                           <span class="comment">// handle processor change</span>
<a name="l00463"></a>00463                           <span class="keywordflow">if</span> (p!=Element&lt;0&gt;::get(*i))
<a name="l00464"></a>00464                                 {
<a name="l00465"></a>00465                                   p = Element&lt;0&gt;::get(*i);
<a name="l00466"></a>00466                                   modifier = ri.template getModifier&lt;false,true&gt;(p);
<a name="l00467"></a>00467                                   pi=pis.<a class="code" href="a00195.html#g1f7489201417827fc547818553c1d57b" title="Get an iterator over the indices positioned at the first index.">begin</a>();
<a name="l00468"></a>00468                                 }
<a name="l00469"></a>00469                           
<a name="l00470"></a>00470                           <span class="comment">// position to correct entry in parallel index set</span>
<a name="l00471"></a>00471                           <span class="keywordflow">while</span> (pi-&gt;global()!=Element&lt;1&gt;::get(*i) &amp;&amp; pi!=pis.<a class="code" href="a00195.html#g76c8b73b6353cde82b8877ac982a17ae" title="Get an iterator over the indices positioned after the last index.">end</a>())
<a name="l00472"></a>00472                                 ++pi;
<a name="l00473"></a>00473                           <span class="keywordflow">if</span> (pi==pis.<a class="code" href="a00195.html#g76c8b73b6353cde82b8877ac982a17ae" title="Get an iterator over the indices positioned after the last index.">end</a>())
<a name="l00474"></a>00474                                 DUNE_THROW(<a class="code" href="a00067.html" title="derive error class from the base class in common">ISTLError</a>,<span class="stringliteral">"OwnerOverlapCopyCommunication: global index not in index set"</span>);
<a name="l00475"></a>00475                           
<a name="l00476"></a>00476                           <span class="comment">// insert entry</span>
<a name="l00477"></a>00477 <span class="comment">//                        std::cout &lt;&lt; cc.rank() &lt;&lt; ": adding remote index " &lt;&lt; Element&lt;0&gt;::get(*i) &lt;&lt; " " &lt;&lt; Element&lt;1&gt;::get(*i) &lt;&lt; " " &lt;&lt; Element&lt;2&gt;::get(*i) &lt;&lt; std::endl;</span>
<a name="l00478"></a>00478                           <span class="keywordflow">if</span> (Element&lt;2&gt;::get(*i)==OwnerOverlapCopyAttributeSet::owner)
<a name="l00479"></a>00479                                 modifier.<a class="code" href="a00096.html#7bfa3c8ff95debe17b0c2b6afa0b1228" title="Insert an index to the list.">insert</a>(<a class="code" href="a00095.html" title="Information about an index residing on another processor.">RX</a>(OwnerOverlapCopyAttributeSet::owner,&amp;(*pi)));
<a name="l00480"></a>00480                           <span class="keywordflow">if</span> (Element&lt;2&gt;::get(*i)==OwnerOverlapCopyAttributeSet::overlap)
<a name="l00481"></a>00481                                 modifier.<a class="code" href="a00096.html#7bfa3c8ff95debe17b0c2b6afa0b1228" title="Insert an index to the list.">insert</a>(<a class="code" href="a00095.html" title="Information about an index residing on another processor.">RX</a>(OwnerOverlapCopyAttributeSet::overlap,&amp;(*pi)));
<a name="l00482"></a>00482                           <span class="keywordflow">if</span> (Element&lt;2&gt;::get(*i)==OwnerOverlapCopyAttributeSet::copy)
<a name="l00483"></a>00483                                 modifier.<a class="code" href="a00096.html#7bfa3c8ff95debe17b0c2b6afa0b1228" title="Insert an index to the list.">insert</a>(<a class="code" href="a00095.html" title="Information about an index residing on another processor.">RX</a>(OwnerOverlapCopyAttributeSet::copy,&amp;(*pi)));
<a name="l00484"></a>00484                         }
<a name="l00485"></a>00485                 }
<a name="l00486"></a>00486         }
<a name="l00487"></a>00487 
<a name="l00488"></a>00488         <span class="comment">// destructor: free memory in some objects</span>
<a name="l00489"></a>00489         ~<a class="code" href="a00086.html" title="A class setting up standard communication for a two-valued attribute set with owner/overlap/copy...">OwnerOverlapCopyCommunication</a> ()
<a name="l00490"></a>00490         {
<a name="l00491"></a>00491           ri.<a class="code" href="a00097.html#b79f78b61bca1262c30305e32f8aa809" title="Free the index lists.">free</a>();
<a name="l00492"></a>00492           <span class="keywordflow">if</span> (OwnerToAllInterfaceBuilt) OwnerToAllInterface.<a class="code" href="a00195.html#g7998a5cc771852a49c8833b52e82a0ba" title="Frees memory allocated during the build.">free</a>();
<a name="l00493"></a>00493           <span class="keywordflow">if</span> (OwnerOverlapToAllInterfaceBuilt) OwnerOverlapToAllInterface.<a class="code" href="a00195.html#g7998a5cc771852a49c8833b52e82a0ba" title="Frees memory allocated during the build.">free</a>();
<a name="l00494"></a>00494         }
<a name="l00495"></a>00495 
<a name="l00496"></a>00496   <span class="keyword">private</span>:
<a name="l00497"></a>00497     <a class="code" href="a00086.html#d076f7151f5c8986681910a4c9665eac" title="Construct the communication without any indices.">OwnerOverlapCopyCommunication</a> (<span class="keyword">const</span> <a class="code" href="a00086.html#d076f7151f5c8986681910a4c9665eac" title="Construct the communication without any indices.">OwnerOverlapCopyCommunication</a>&amp;)
<a name="l00498"></a>00498     {}
<a name="l00499"></a>00499         CollectiveCommunication&lt;MPI_Comm&gt; cc;
<a name="l00500"></a>00500         PIS pis;
<a name="l00501"></a>00501         RI ri;
<a name="l00502"></a>00502         <span class="keyword">mutable</span> IF OwnerToAllInterface;
<a name="l00503"></a>00503         <span class="keyword">mutable</span> <span class="keywordtype">bool</span> OwnerToAllInterfaceBuilt;
<a name="l00504"></a>00504         <span class="keyword">mutable</span> IF OwnerOverlapToAllInterface;
<a name="l00505"></a>00505         <span class="keyword">mutable</span> <span class="keywordtype">bool</span> OwnerOverlapToAllInterfaceBuilt;
<a name="l00506"></a>00506         <span class="keyword">mutable</span> std::vector&lt;double&gt; mask;
<a name="l00507"></a>00507     <a class="code" href="a00086.html#4d18c28c70bcbf749e8b37f8335c8389" title="The type of the reverse lookup of indices.">GlobalLookupIndexSet</a>* globalLookup_;
<a name="l00508"></a>00508   };
<a name="l00509"></a>00509 
<a name="l00510"></a>00510 <span class="preprocessor">#endif</span>
<a name="l00511"></a>00511 <span class="preprocessor"></span>
<a name="l00512"></a>00512  
<a name="l00515"></a>00515 } <span class="comment">// end namespace</span>
<a name="l00516"></a>00516 
<a name="l00517"></a>00517 <span class="preprocessor">#endif</span>
</pre></div></div>
</div> <!-- end doxygen -->
</div> <!-- end main -->
<div class="foot">

<p class="foot">
  Generated on 6 Nov 2008 with <a
  href="http://www.doxygen.org/">Doxygen</a> (ver 1.5.6)  
  [<a href="doxygen.log">logfile</a>].
</p>

</div>

</body>
</html>
