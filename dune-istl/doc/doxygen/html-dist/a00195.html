<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN""http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>dune-istl: ISTL Communication (dune-istl )</title>
  <link rel="stylesheet" type="text/css" href="./dune-doxy.css">
  <link rel="stylesheet" type="text/css" href="./tabs.css">
</head>
<div class="main">
<div class="doxygen">
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>ISTL Communication<br>
<small>
[<a class="el" href="a00193.html">ISTL</a>]</small>
</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Provides classes for syncing distributed indexed data structures. 
<p>
In a parallel representation a container <img class="formulaInl" alt="$x$" src="form_15.png">, e.g. a plain C-array, cannot be stored with all entries on each process because of limited memory and efficiency reasons. Therefore it is represented by individual pieces <img class="formulaInl" alt="$x_p$" src="form_16.png">, <img class="formulaInl" alt="$p=0, \ldots, P-1$" src="form_17.png">, where <img class="formulaInl" alt="$x_p$" src="form_16.png"> is the piece stored on process <img class="formulaInl" alt="$p$" src="form_18.png"> of the <img class="formulaInl" alt="$P$" src="form_19.png"> processes participating in the calculation. Although the global representation of the container is not available on any process, a process <img class="formulaInl" alt="$p$" src="form_18.png"> needs to know how the entries of it's local piece <img class="formulaInl" alt="$x_p$" src="form_16.png"> correspond to the entries of the global container <img class="formulaInl" alt="$x$" src="form_15.png">, which would be used in a sequential program. In this module we present classes describing the mapping of the local pieces to the global view and the communication interfaces.<h2><a class="anchor" name="IndexSet">
Parallel Index Sets</a></h2>
Form an abstract point of view a random access container <img class="formulaInl" alt="$x: I \rightarrow K$" src="form_20.png"> provides a mapping from an index set <img class="formulaInl" alt="$I \subset N_0$" src="form_21.png"> onto a set of objects <img class="formulaInl" alt="$K$" src="form_1.png">. Note that we do not require <img class="formulaInl" alt="$I$" src="form_22.png"> to be consecutive. The piece <img class="formulaInl" alt="$x_p$" src="form_16.png"> of the container <img class="formulaInl" alt="$x$" src="form_15.png"> stored on process <img class="formulaInl" alt="$p$" src="form_18.png"> is a mapping <img class="formulaInl" alt="$x_p:I_p \rightarrow K$" src="form_23.png">, where <img class="formulaInl" alt="$I_p \subset I$" src="form_24.png">. Due to efficiency the entries of <img class="formulaInl" alt="$x_p$" src="form_16.png"> should be stored in consecutive memory.<p>
This means that for the local computation the data must be addressable by a consecutive index starting from <img class="formulaInl" alt="$0$" src="form_25.png">. When using adaptive discretisation methods there might be the need to reorder the indices after adding and/or deleting some of the discretisation points. Therefore this index does not have to be persistent. Further on we will call this index <em>local index</em>.<p>
For the communication phases of our algorithms these locally stored entries must also be addressable by a global identifier to be able to store the received values tagged with the global identifiers at the correct local index in the consecutive local memory chunk. To ease the addition and removal of discretisation points this global identifier has to be persistent. Further on we will call this global identifier <em>global index</em>.<p>
Classes to build the mapping are <a class="el" href="a00087.html" title="Manager class for the mapping between local indices and globally unique indices.">ParallelIndexSet</a> and <a class="el" href="a00089.html" title="An index present on the local process with an additional attribute flag.">ParallelLocalIndex</a>. As these just provide a mapping from the global index to the local index, the wrapper class <a class="el" href="a00050.html" title="Decorates an index set with the possibility to find a global index that is mapped...">GlobalLookupIndexSet</a> facilitates the reverse lookup.<h2><a class="anchor" name="remote">
Remote Index Information</a></h2>
To setup communication between the processes every process needs to know what indices are also known to other processes and what attributes are attached to them on the remote side. This information is calculated and encapsulated in class <a class="el" href="a00097.html" title="The indices present on remote processes.">RemoteIndices</a>.<h2><a class="anchor" name="comm">
Communication</a></h2>
Based on the information about the distributed index sets, data independent interfaces between different sets of the index sets can be setup using the class <a class="el" href="a00060.html" title="Communication interface between remote and local indices.">Interface</a>. For the actual communication it data dependant communicators can be setup using <a class="el" href="a00024.html" title="A communicator that uses buffers to gather and scatter the data to be send or received...">BufferedCommunicator</a> or DatatypeCommunicator. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00142.html">communicator.hh</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides utility classes for syncing distributed data via MPI communication. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00153.html">indexset.hh</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides a map between global and local indices. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html">indicessyncer.hh</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for adding missing indices of a distributed index set in a local communication. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html">interface.hh</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides classes for building the communication interface between remote inidices. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00159.html">localindex.hh</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides classes for use as the local index in ParallelIndexSet. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html">owneroverlapcopy.hh</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Classes providing communication interfaces for overlapping Schwarz methods. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00171.html">plocalindex.hh</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides classes for use as the local index in ParallelIndexSet for distributed computing. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00175.html">remoteindices.hh</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Classes discribing a distributed indexset. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00111.html">Dune::SizeOne</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flag for marking indexed data structures where data at each index is of the same size.  <a href="a00111.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00130.html">Dune::VariableSize</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flag for marking indexed data structures where the data at each index may be a variable multiple of another type.  <a href="a00130.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00030.html">Dune::CommPolicy&lt; V &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default policy used for communicating an indexed type.  <a href="a00030.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00024.html">Dune::BufferedCommunicator&lt; T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A communicator that uses buffers to gather and scatter the data to be send or received.  <a href="a00024.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html">Dune::IndexPair&lt; TG, TL &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A pair consisting of a global and local index.  <a href="a00057.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html">Dune::InvalidIndexSetState</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception indicating that the index set is not in the expected state.  <a href="a00063.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00087.html">Dune::ParallelIndexSet&lt; TG, TL, N &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Manager class for the mapping between local indices and globally unique indices.  <a href="a00087.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html">Dune::ParallelIndexSet&lt; TG, TL, N &gt;::iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="a00088.html" title="The iterator over the pairs.">iterator</a> over the pairs.  <a href="a00088.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html">Dune::GlobalLookupIndexSet&lt; I &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decorates an index set with the possibility to find a global index that is mapped to a specific local.  <a href="a00050.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00059.html">Dune::IndicesSyncer&lt; T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for recomputing missing indices of a distributed index set.  <a href="a00059.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00060.html">Dune::Interface&lt; T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Communication interface between remote and local indices.  <a href="a00060.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html">Dune::LocalIndex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An index present on the local process.  <a href="a00069.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00078.html">Dune::MPITraits&lt; T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A traits class describing the mapping of types onto MPI_Datatypes.  <a href="a00078.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html">Dune::OwnerOverlapCopyAttributeSet</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attribute set for overlapping schwarz.  <a href="a00085.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00056.html">Dune::IndexInfoFromGrid&lt; G, L &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Information about the index distribution.  <a href="a00056.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00086.html">Dune::OwnerOverlapCopyCommunication&lt; GlobalIdType, LocalIdType &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A class setting up standard communication for a two-valued attribute set with owner/overlap/copy semantics.  <a href="a00086.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00089.html">Dune::ParallelLocalIndex&lt; T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An index present on the local process with an additional attribute flag.  <a href="a00089.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html">Dune::MPITraits&lt; ParallelLocalIndex&lt; T &gt; &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00079.html">Dune::MPITraits&lt; IndexPair&lt; TG, ParallelLocalIndex&lt; TA &gt; &gt; &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00095.html">Dune::RemoteIndex&lt; T1, T2 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Information about an index residing on another processor.  <a href="a00095.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00097.html">Dune::RemoteIndices&lt; T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The indices present on remote processes.  <a href="a00097.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef TG&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#gc7ba161114dcda480ec1e03fade5d887">Dune::IndexPair::GlobalIndex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the type of the global index.  <a href="#gc7ba161114dcda480ec1e03fade5d887"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef TL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g43eed1b88f2bc2e0b683465638df39fb">Dune::IndexPair::LocalIndex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the type of the local index.  <a href="#g43eed1b88f2bc2e0b683465638df39fb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gc025d93d84144d1ab5bcddfbc1760d53"></a><!-- doxytag: member="ISTL_Comm::GlobalIndex" ref="gc025d93d84144d1ab5bcddfbc1760d53" args="" -->
typedef TG&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#gc025d93d84144d1ab5bcddfbc1760d53">Dune::ParallelIndexSet::GlobalIndex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the type of the global index. This type has to provide at least a operator&lt; for sorting. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef TL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g80f93e9c02b5f29b011140b3a87d39af">Dune::ParallelIndexSet::LocalIndex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the local index, e.g. <a class="el" href="a00089.html" title="An index present on the local process with an additional attribute flag.">ParallelLocalIndex</a>.  <a href="#g80f93e9c02b5f29b011140b3a87d39af"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gfa0d2c4698da918525f35e3f5b74f1d8"></a><!-- doxytag: member="ISTL_Comm::IndexPair" ref="gfa0d2c4698da918525f35e3f5b74f1d8" args="" -->
typedef <a class="el" href="a00057.html">Dune::IndexPair</a><br>
&lt; GlobalIndex, LocalIndex &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#gfa0d2c4698da918525f35e3f5b74f1d8">Dune::ParallelIndexSet::IndexPair</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the pair stored. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g2d339136484321658ecf88e2e4dfa28b"></a><!-- doxytag: member="ISTL_Comm::const_iterator" ref="g2d339136484321658ecf88e2e4dfa28b" args="" -->
typedef ArrayList&lt; IndexPair, <br>
N &gt;::const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g2d339136484321658ecf88e2e4dfa28b">Dune::ParallelIndexSet::const_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The constant <a class="el" href="a00088.html" title="The iterator over the pairs.">iterator</a> over the pairs. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g8b7de52f424abbff8027cd528e1f0c58"></a><!-- doxytag: member="ISTL_Comm::LocalIndex" ref="g8b7de52f424abbff8027cd528e1f0c58" args="" -->
typedef <br>
ParallelIndexSet::LocalIndex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g8b7de52f424abbff8027cd528e1f0c58">Dune::GlobalLookupIndexSet::LocalIndex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the local index. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gf66c2a53e3745f2eb80a457f3358e484"></a><!-- doxytag: member="ISTL_Comm::GlobalIndex" ref="gf66c2a53e3745f2eb80a457f3358e484" args="" -->
typedef <br>
ParallelIndexSet::GlobalIndex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#gf66c2a53e3745f2eb80a457f3358e484">Dune::GlobalLookupIndexSet::GlobalIndex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the global index. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g581c7a4200df70547189e64988a72e4f"></a><!-- doxytag: member="ISTL_Comm::const_iterator" ref="g581c7a4200df70547189e64988a72e4f" args="" -->
typedef <br>
ParallelIndexSet::const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g581c7a4200df70547189e64988a72e4f">Dune::GlobalLookupIndexSet::const_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The iterator over the index pairs. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ge01c9c9d98e213ba18897c0fc69dba78"></a><!-- doxytag: member="ISTL_Comm::IndexPair" ref="ge01c9c9d98e213ba18897c0fc69dba78" args="" -->
typedef ParallelIndexSet::IndexPair&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#ge01c9c9d98e213ba18897c0fc69dba78">Dune::IndicesSyncer::IndexPair</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the index pair. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g44992bb99b3f3f3d7c9badb9c7ff74c2"></a><!-- doxytag: member="ISTL_Comm::GlobalIndex" ref="g44992bb99b3f3f3d7c9badb9c7ff74c2" args="" -->
typedef <br>
ParallelIndexSet::GlobalIndex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g44992bb99b3f3f3d7c9badb9c7ff74c2">Dune::IndicesSyncer::GlobalIndex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of the global index used in the index set. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g6087c4c3aa666ff87aa4ea4b9876646a"></a><!-- doxytag: member="ISTL_Comm::Attribute" ref="g6087c4c3aa666ff87aa4ea4b9876646a" args="" -->
typedef <br>
ParallelIndexSet::LocalIndex::Attribute&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g6087c4c3aa666ff87aa4ea4b9876646a">Dune::IndicesSyncer::Attribute</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of the attribute used in the index set. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gca7ec68a02c0f8a370406c1506cbd594"></a><!-- doxytag: member="ISTL_Comm::RemoteIndices" ref="gca7ec68a02c0f8a370406c1506cbd594" args="" -->
typedef <a class="el" href="a00097.html">Dune::RemoteIndices</a><br>
&lt; ParallelIndexSet &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#gca7ec68a02c0f8a370406c1506cbd594">Dune::IndicesSyncer::RemoteIndices</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of the remote indices. <br></td></tr>
<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g1b1dd66b80964351e68f44bddb32593e">Dune::ParallelIndexSetState</a> { <a class="el" href="a00195.html#gg1b1dd66b80964351e68f44bddb32593e30f779eddf23499c322b692257ae7116">Dune::GROUND</a>, 
<a class="el" href="a00195.html#gg1b1dd66b80964351e68f44bddb32593e2fbc0ce9b92442e69a405a452f2ef416">Dune::RESIZE</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The states the index set can be in.  <a href="a00195.html#g1b1dd66b80964351e68f44bddb32593e">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="a00195.html#gge56f8c8166be1be9e15f9665b68c7e3b7f95f052a4180cbaae53571e19da4d02">Dune::ParallelIndexSet::arraySize</a> =  (N&gt;0)?N:1
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g4f24bf6f596bf963429e084ecf3a0835">Dune::LocalIndexState</a> </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The states avaiable for the local indices.  <a href="a00195.html#g4f24bf6f596bf963429e084ecf3a0835">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class TG, class TL&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00195.html#gf3fe52ba966ff2b732b5a9216ad7e69f">Dune::operator&lt;&lt;</a> (std::ostream &amp;os, const IndexPair&lt; TG, TL &gt; &amp;pair)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print an index pair.  <a href="#gf3fe52ba966ff2b732b5a9216ad7e69f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g8e4caa12b6c34752c7bc2f01361d3a63">Dune::IndexPair::IndexPair</a> (const GlobalIndex &amp;global, const LocalIndex &amp;local)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a new Pair.  <a href="#g8e4caa12b6c34752c7bc2f01361d3a63"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g73eb42aaa0a54d593d6f537960446d7a"></a><!-- doxytag: member="ISTL_Comm::IndexPair" ref="g73eb42aaa0a54d593d6f537960446d7a" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g73eb42aaa0a54d593d6f537960446d7a">Dune::IndexPair::IndexPair</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a new Pair. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#gbc5975873aa790a0f3caf5b8c185a1d1">Dune::IndexPair::IndexPair</a> (const GlobalIndex &amp;global)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a new Pair.  <a href="#gbc5975873aa790a0f3caf5b8c185a1d1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const GlobalIndex &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#gcfce50e1fba13d1fe62b7193e738c00c">Dune::IndexPair::global</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the global index.  <a href="#gcfce50e1fba13d1fe62b7193e738c00c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LocalIndex &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#ga7f66e7dbce2d04bda01b154f8103894">Dune::IndexPair::local</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the local index.  <a href="#ga7f66e7dbce2d04bda01b154f8103894"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const LocalIndex &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g3347abaf05298b85ac2fcce6b87b7375">Dune::IndexPair::local</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the local index.  <a href="#g3347abaf05298b85ac2fcce6b87b7375"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g98503056ecd6fa927cd9189fa41f91a2">Dune::IndexPair::setLocal</a> (int index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the local index.  <a href="#g98503056ecd6fa927cd9189fa41f91a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gab9080b900ad0b31e35b9c0654a763b2"></a><!-- doxytag: member="ISTL_Comm::ParallelIndexSet" ref="gab9080b900ad0b31e35b9c0654a763b2" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#gab9080b900ad0b31e35b9c0654a763b2">Dune::ParallelIndexSet::ParallelIndexSet</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const ParallelIndexSetState &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#gd7fbeef92f1ee69893d2efcb908e133b">Dune::ParallelIndexSet::state</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the state the index set is in.  <a href="#gd7fbeef92f1ee69893d2efcb908e133b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g10a18b0bbba6cbda15a58d7a2ede111f"></a><!-- doxytag: member="ISTL_Comm::beginResize" ref="g10a18b0bbba6cbda15a58d7a2ede111f" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g10a18b0bbba6cbda15a58d7a2ede111f">Dune::ParallelIndexSet::beginResize</a> ()  throw (InvalidIndexSetState)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicate that the index set is to be resized. <dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InvalidState</em>&nbsp;</td><td>If index set was not in ParallelIndexSetState::GROUND mode. </td></tr>
  </table>
</dl>
<br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g314b28a2ac2171f330979eb82c7d48fc">Dune::ParallelIndexSet::add</a> (const GlobalIndex &amp;global)  throw (InvalidIndexSetState)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an new index to the set.  <a href="#g314b28a2ac2171f330979eb82c7d48fc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#ga0be4f42ade95057bcb960cafc5e0503">Dune::ParallelIndexSet::add</a> (const GlobalIndex &amp;global, const LocalIndex &amp;local)  throw (InvalidIndexSetState)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an new index to the set.  <a href="#ga0be4f42ade95057bcb960cafc5e0503"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g8967dfc42b1855566b7f9a3557f89005">Dune::ParallelIndexSet::markAsDeleted</a> (const iterator &amp;position)  throw (InvalidIndexSetState)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mark an index as deleted.  <a href="#g8967dfc42b1855566b7f9a3557f89005"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#gadfad947098175e885aa7fd6c5b490a5">Dune::ParallelIndexSet::endResize</a> ()  throw (InvalidIndexSetState)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Indicate that the resizing finishes.  <a href="#gadfad947098175e885aa7fd6c5b490a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">IndexPair &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#gcbf0d00a471f84ee916369f8b267d2f0">Dune::ParallelIndexSet::operator[]</a> (const GlobalIndex &amp;global)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the index pair with a specific global id.  <a href="#gcbf0d00a471f84ee916369f8b267d2f0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const IndexPair &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g1b6da9c28c3609e5b85ec76d2b3be8fe">Dune::ParallelIndexSet::operator[]</a> (const GlobalIndex &amp;global) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the index pair with a specific global id.  <a href="#g1b6da9c28c3609e5b85ec76d2b3be8fe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g1f7489201417827fc547818553c1d57b">Dune::ParallelIndexSet::begin</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an <a class="el" href="a00088.html" title="The iterator over the pairs.">iterator</a> over the indices positioned at the first index.  <a href="#g1f7489201417827fc547818553c1d57b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g76c8b73b6353cde82b8877ac982a17ae">Dune::ParallelIndexSet::end</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an <a class="el" href="a00088.html" title="The iterator over the pairs.">iterator</a> over the indices positioned after the last index.  <a href="#g76c8b73b6353cde82b8877ac982a17ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#gf79f7deb60a9b3849481627d326a366c">Dune::ParallelIndexSet::begin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an <a class="el" href="a00088.html" title="The iterator over the pairs.">iterator</a> over the indices positioned at the first index.  <a href="#gf79f7deb60a9b3849481627d326a366c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#gab5fe2f4f30c085204176111624d6f83">Dune::ParallelIndexSet::end</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an <a class="el" href="a00088.html" title="The iterator over the pairs.">iterator</a> over the indices positioned after the last index.  <a href="#gab5fe2f4f30c085204176111624d6f83"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g1d85acf860530070eb101872811f1fc4">Dune::ParallelIndexSet::renumberLocal</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Renumbers the local index numbers.  <a href="#g1d85acf860530070eb101872811f1fc4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#ga48178e14a3a34666d1f5fc6938eb814">Dune::ParallelIndexSet::seqNo</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the internal sequence number.  <a href="#ga48178e14a3a34666d1f5fc6938eb814"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g3d746bd954f7cbd7ca306c86b1ae7055">Dune::ParallelIndexSet::size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the total number (public and nonpublic) indices.  <a href="#g3d746bd954f7cbd7ca306c86b1ae7055"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class TG, class TL, int N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00195.html#gf387ba134daa8a9ebde34086f5957894">Dune::operator&lt;&lt;</a> (std::ostream &amp;os, const ParallelIndexSet&lt; TG, TL, N &gt; &amp;indexSet)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print an index set.  <a href="#gf387ba134daa8a9ebde34086f5957894"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#gf0a14b66fc635c8a66f4346aa1828a88">Dune::GlobalLookupIndexSet::GlobalLookupIndexSet</a> (const ParallelIndexSet &amp;indexset, std::size_t size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#gf0a14b66fc635c8a66f4346aa1828a88"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gb501ff12c926340ba45b83cdd7b03d4e"></a><!-- doxytag: member="ISTL_Comm::~GlobalLookupIndexSet" ref="gb501ff12c926340ba45b83cdd7b03d4e" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#gb501ff12c926340ba45b83cdd7b03d4e">Dune::GlobalLookupIndexSet::~GlobalLookupIndexSet</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const IndexPair &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#gf5a1c0458de148e051ab68fe7f104af2">Dune::GlobalLookupIndexSet::operator[]</a> (const GlobalIndex &amp;global) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the index pair with a specific global id.  <a href="#gf5a1c0458de148e051ab68fe7f104af2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ge232c43f4540b790dfc93684c5db89d6"></a><!-- doxytag: member="ISTL_Comm::pair" ref="ge232c43f4540b790dfc93684c5db89d6" args="(const std::size_t &amp;local) const " -->
const IndexPair *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#ge232c43f4540b790dfc93684c5db89d6">Dune::GlobalLookupIndexSet::pair</a> (const std::size_t &amp;local) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the index pair corresponding to a local index. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g5aeeb87374c2ca2d89030b39fbe68dc6">Dune::GlobalLookupIndexSet::begin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator over the indices positioned at the first index.  <a href="#g5aeeb87374c2ca2d89030b39fbe68dc6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g70df556d4be8a30ec2201508ac51e930">Dune::GlobalLookupIndexSet::end</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator over the indices positioned after the last index.  <a href="#g70df556d4be8a30ec2201508ac51e930"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g2525c0db5f67ecafb1c5b002585290ba">Dune::GlobalLookupIndexSet::seqNo</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the internal sequence number.  <a href="#g2525c0db5f67ecafb1c5b002585290ba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g4cb1ab45cfccdf8b9a2c0d8804c1743f">Dune::GlobalLookupIndexSet::size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the total number (public and nonpublic) indices.  <a href="#g4cb1ab45cfccdf8b9a2c0d8804c1743f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g8b032138e767af75563f7eab24eae18c">Dune::IndicesSyncer::IndicesSyncer</a> (ParallelIndexSet &amp;indexSet, RemoteIndices &amp;remoteIndices)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#g8b032138e767af75563f7eab24eae18c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#gc6edb7facf4c4407f74982989e5f9980">Dune::IndicesSyncer::sync</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sync the index set.  <a href="#gc6edb7facf4c4407f74982989e5f9980"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00195.html#g5e83acb6ddba86eff1451747a796615f">Dune::IndicesSyncer::sync</a> (T1 &amp;numberer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Synce the index set and assign local numbers to new indices.  <a href="#g5e83acb6ddba86eff1451747a796615f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g00b953618afeea2b679aa8e98e941c04">Dune::IndicesSyncer::Iterators::Iterators</a> (RemoteIndexList &amp;remoteIndices, GlobalIndexList &amp;globalIndices, BoolList &amp;booleans)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#g00b953618afeea2b679aa8e98e941c04"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g067105d3d09142a3273fea7f895b3ebc"></a><!-- doxytag: member="ISTL_Comm::Iterators" ref="g067105d3d09142a3273fea7f895b3ebc" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g067105d3d09142a3273fea7f895b3ebc">Dune::IndicesSyncer::Iterators::Iterators</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g5db541e35522db17c6177279d1d3895c"></a><!-- doxytag: member="ISTL_Comm::operator++" ref="g5db541e35522db17c6177279d1d3895c" args="()" -->
Iterators &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g5db541e35522db17c6177279d1d3895c">Dune::IndicesSyncer::Iterators::operator++</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increment all iteraors. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g12e2db408a39d33659a1047edce477b0">Dune::IndicesSyncer::Iterators::insert</a> (const RemoteIndex &amp;index, const GlobalIndex &amp;global)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert a new remote index to the underlying remote index list.  <a href="#g12e2db408a39d33659a1047edce477b0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">RemoteIndex &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#ge95be71d25167448c338eb204475bbfa">Dune::IndicesSyncer::Iterators::remoteIndex</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the remote index at current position.  <a href="#ge95be71d25167448c338eb204475bbfa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">GlobalIndex &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#gb9043928187ed9d370c5f37c51bab29a">Dune::IndicesSyncer::Iterators::globalIndex</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the global index of the remote index at current position.  <a href="#gb9043928187ed9d370c5f37c51bab29a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#gab940aa97ba194f2a6607ddf6175ce71">Dune::IndicesSyncer::Iterators::isOld</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Was this entry already in the remote index list before the sync process?  <a href="#gab940aa97ba194f2a6607ddf6175ce71"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g8eecdeb0c362c0ab465367fb5ccdc6f5">Dune::IndicesSyncer::Iterators::reset</a> (RemoteIndexList &amp;remoteIndices, GlobalIndexList &amp;globalIndices, BoolList &amp;booleans)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset all the underlying iterators.  <a href="#g8eecdeb0c362c0ab465367fb5ccdc6f5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#gb0429f093debb806dac575cc7390e215">Dune::IndicesSyncer::Iterators::isNotAtEnd</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Are we not at the end of the list?  <a href="#gb0429f093debb806dac575cc7390e215"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g1eaacfdfe68b9467ab2f56817b8c3350">Dune::IndicesSyncer::Iterators::isAtEnd</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Are we at the end of the list?  <a href="#g1eaacfdfe68b9467ab2f56817b8c3350"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, typename A&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00195.html#g4326d84fb55197953dde912e582dcd94">Dune::repairLocalIndexPointers</a> (std::map&lt; int, SLList&lt; typename T::GlobalIndex, A &gt; &gt; &amp;globalMap, RemoteIndices&lt; T &gt; &amp;remoteIndices, const T &amp;indexSet)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Repair the pointers to the local indices in the remote indices.  <a href="#g4326d84fb55197953dde912e582dcd94"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00195.html#gceea68b8eafc4ebca4945ddbf0bd5470">Dune::operator&lt;&lt;</a> (std::ostream &amp;os, const ParallelLocalIndex&lt; T &gt; &amp;index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print the local index to a stream.  <a href="#gceea68b8eafc4ebca4945ddbf0bd5470"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#gd6083d1fa31e7b48671381b8f47458f6">Dune::CommPolicy::getAddress</a> (const V &amp;v, int index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the address of entry at an index.  <a href="#gd6083d1fa31e7b48671381b8f47458f6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g6a6fe68e69566d81ea0b130ea628ada7">Dune::CommPolicy::getSize</a> (const V &amp;, int index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of primitve elements at that index.  <a href="#g6a6fe68e69566d81ea0b130ea628ada7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gb19fc03c7827e47801aedc4b43f6bd06"></a><!-- doxytag: member="ISTL_Comm::BufferedCommunicator" ref="gb19fc03c7827e47801aedc4b43f6bd06" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#gb19fc03c7827e47801aedc4b43f6bd06">Dune::BufferedCommunicator::BufferedCommunicator</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Data&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">EnableIf&lt; is_same&lt; SizeOne, <br>
typename CommPolicy&lt; Data &gt;<br>
::IndexedTypeFlag &gt;::value, <br>
void &gt;::Type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00195.html#g368c5043742c278be288f9e6d976de1b">Dune::BufferedCommunicator::build</a> (const Interface &amp;interface)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build the buffers and information for the communication process.  <a href="#g368c5043742c278be288f9e6d976de1b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class Data&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00195.html#g61de6ebaf57fccbafbf7fe0b48bdfe45">Dune::BufferedCommunicator::build</a> (const Data &amp;source, const Data &amp;target, const Interface &amp;interface)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build the buffers and information for the communication process.  <a href="#g61de6ebaf57fccbafbf7fe0b48bdfe45"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g91148e43446c9a8efe0e93615ce9e825"></a><!-- doxytag: member="ISTL_Comm::free" ref="g91148e43446c9a8efe0e93615ce9e825" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g91148e43446c9a8efe0e93615ce9e825">Dune::BufferedCommunicator::free</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free the allocated memory (i.e. buffers and message information. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g6df622f74b3e7218f07b705b03806ea9"></a><!-- doxytag: member="ISTL_Comm::~BufferedCommunicator" ref="g6df622f74b3e7218f07b705b03806ea9" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g6df622f74b3e7218f07b705b03806ea9">Dune::BufferedCommunicator::~BufferedCommunicator</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#gad081958b0e7015bba10821119f2b4ef">Dune::BufferedCommunicator::MessageSizeCalculator&lt; Data, SizeOne &gt;::operator()</a> (const InterfaceInformation &amp;info) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the number of values in message.  <a href="#gad081958b0e7015bba10821119f2b4ef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#gbb7894e6112bdba6ac7394e9d22ae10a">Dune::BufferedCommunicator::MessageSizeCalculator&lt; Data, SizeOne &gt;::operator()</a> (const Data &amp;data, const InterfaceInformation &amp;info) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the number of values in message.  <a href="#gbb7894e6112bdba6ac7394e9d22ae10a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g58851219a7013c680bf3f210dd51c7b7">Dune::BufferedCommunicator::MessageSizeCalculator&lt; Data, VariableSize &gt;::operator()</a> (const Data &amp;data, const InterfaceInformation &amp;info) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the number of values in message.  <a href="#g58851219a7013c680bf3f210dd51c7b7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class GatherScatter, class Data&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00195.html#ge291e9cc1569b51f4a8ee392c8d89af4">Dune::BufferedCommunicator::forward</a> (Data &amp;data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Forward send where target and source are the same.  <a href="#ge291e9cc1569b51f4a8ee392c8d89af4"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class GatherScatter, class Data&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00195.html#gb0af777cd63595c0298ff75be6a24a5d">Dune::BufferedCommunicator::backward</a> (Data &amp;data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Backward send where target and source are the same.  <a href="#gb0af777cd63595c0298ff75be6a24a5d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class GatherScatter, class Data&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00195.html#ge50622460292c69a2851476ad41417b2">Dune::BufferedCommunicator::forward</a> (const Data &amp;source, Data &amp;dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Send from source to target.  <a href="#ge50622460292c69a2851476ad41417b2"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class GatherScatter, class Data&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00195.html#gbe001b7f354d80d38f9e92a353dcb340">Dune::BufferedCommunicator::backward</a> (Data &amp;source, const Data &amp;dest)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Communicate in the reverse direction, i.e. send from target to source.  <a href="#gbe001b7f354d80d38f9e92a353dcb340"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T1, class T2, class Op, bool send&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00195.html#g2ec46f5af09aa30f8884dbc284d25a3a">Dune::InterfaceBuilder::buildInterface</a> (const RemoteIndices &amp;remoteIndices, const T1 &amp;sourceFlags, const T2 &amp;destFlags, Op &amp;functor) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds the interface between remote processes.  <a href="#g2ec46f5af09aa30f8884dbc284d25a3a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g34977a3d4cd57e1357c8829b0babad6a"></a><!-- doxytag: member="ISTL_Comm::communicator" ref="g34977a3d4cd57e1357c8829b0babad6a" args="() const " -->
MPI_Comm&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g34977a3d4cd57e1357c8829b0babad6a">Dune::Interface::communicator</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the MPI Communicator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const InformationMap &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#gb090953b7eb31e5c8be6e9667ba13c76">Dune::Interface::interfaces</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get information about the interfaces.  <a href="#gb090953b7eb31e5c8be6e9667ba13c76"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g1645b178ff6cf59d9013f4029327eb9f"></a><!-- doxytag: member="ISTL_Comm::print" ref="g1645b178ff6cf59d9013f4029327eb9f" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g1645b178ff6cf59d9013f4029327eb9f">Dune::Interface::print</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print the interface to std::out for debugging. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename T2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00195.html#g5d3351c8857ba5cfdd74d28bb5725a30">Dune::Interface::build</a> (const RemoteIndices &amp;remoteIndices, const T1 &amp;sourceFlags, const T2 &amp;destFlags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Builds the interface.  <a href="#g5d3351c8857ba5cfdd74d28bb5725a30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g7998a5cc771852a49c8833b52e82a0ba"></a><!-- doxytag: member="ISTL_Comm::free" ref="g7998a5cc771852a49c8833b52e82a0ba" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g7998a5cc771852a49c8833b52e82a0ba">Dune::Interface::free</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees memory allocated during the build. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gb19c7dee343bf007f23da5eb62d97436"></a><!-- doxytag: member="ISTL_Comm::~Interface" ref="gb19c7dee343bf007f23da5eb62d97436" args="()" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#gb19c7dee343bf007f23da5eb62d97436">Dune::Interface::~Interface</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const std::ptrdiff_t &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g5cdd1490a7a652c35e5a437bcff26db3">Dune::LocalIndex::local</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get the local index.  <a href="#g5cdd1490a7a652c35e5a437bcff26db3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g1c6f84a871b1e2650d242d9c69b14d65"></a><!-- doxytag: member="ISTL_Comm::operator std::ptrdiff_t" ref="g1c6f84a871b1e2650d242d9c69b14d65" args="() const " -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g1c6f84a871b1e2650d242d9c69b14d65">Dune::LocalIndex::operator std::ptrdiff_t</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert to the local index represented by an int. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LocalIndex &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#gd258dc23ac723e8e307f9a38ce5a2882">Dune::LocalIndex::operator=</a> (std::ptrdiff_t index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign a new local index.  <a href="#gd258dc23ac723e8e307f9a38ce5a2882"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LocalIndexState&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g414be0f59f74f2653e01e1e388acec02">Dune::LocalIndex::state</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the state.  <a href="#g414be0f59f74f2653e01e1e388acec02"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#ge134fe3358bd66ec666029d570bdb5c1">Dune::LocalIndex::setState</a> (LocalIndexState state)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the state.  <a href="#ge134fe3358bd66ec666029d570bdb5c1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#gc704d4292815f9acba45ee00a37fc77b">Dune::ParallelLocalIndex::ParallelLocalIndex</a> (const Attribute &amp;attribute, bool isPublic)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#gc704d4292815f9acba45ee00a37fc77b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g4f93f6b7d572e483621b096d51a17447">Dune::ParallelLocalIndex::ParallelLocalIndex</a> (size_t localIndex, const Attribute &amp;attribute, bool isPublic)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#g4f93f6b7d572e483621b096d51a17447"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#ge17e1ae024e8ef0dc1532125ae0296e9">Dune::ParallelLocalIndex::ParallelLocalIndex</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parameterless constructor.  <a href="#ge17e1ae024e8ef0dc1532125ae0296e9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const Attribute&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#gf9470d7c9de162b08e503031bfe619f5">Dune::ParallelLocalIndex::attribute</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#gf9470d7c9de162b08e503031bfe619f5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g33792062116e47a94116e36fb9d54ca4">Dune::ParallelLocalIndex::setAttribute</a> (const Attribute &amp;attribute)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the attribute of the index.  <a href="#g33792062116e47a94116e36fb9d54ca4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#ge984fd680c3e946c1f505e5a734ab60a">Dune::ParallelLocalIndex::local</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get the local index.  <a href="#ge984fd680c3e946c1f505e5a734ab60a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g608558d903a4917eabb4e6a4aa2a62e6"></a><!-- doxytag: member="ISTL_Comm::operator size_t" ref="g608558d903a4917eabb4e6a4aa2a62e6" args="() const " -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g608558d903a4917eabb4e6a4aa2a62e6">Dune::ParallelLocalIndex::operator size_t</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert to the local index represented by an int. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ParallelLocalIndex&lt; Attribute &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g8f021b0913f65c10de19b9d9084800ef">Dune::ParallelLocalIndex::operator=</a> (size_t index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign a new local index.  <a href="#g8f021b0913f65c10de19b9d9084800ef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g4e835b62fa0b645342080389e5e359d3">Dune::ParallelLocalIndex::isPublic</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check whether the index might also be known other processes.  <a href="#g4e835b62fa0b645342080389e5e359d3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">LocalIndexState&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g08d8d6b042214084cb0430db59639856">Dune::ParallelLocalIndex::state</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the state.  <a href="#g08d8d6b042214084cb0430db59639856"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g803d70f66ccc5cc004e30f734bbd3cc8">Dune::ParallelLocalIndex::setState</a> (const LocalIndexState &amp;state)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the state.  <a href="#g803d70f66ccc5cc004e30f734bbd3cc8"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g33a819e22b0d3a4540505de7694bfa01"></a><!-- doxytag: member="ISTL_Comm::publish" ref="g33a819e22b0d3a4540505de7694bfa01" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g33a819e22b0d3a4540505de7694bfa01">Dune::IndicesSyncer::MessageInformation::publish</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of indices we publish for each process. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g54eb54f050784a2edf79b2d54527af7a"></a><!-- doxytag: member="ISTL_Comm::pairs" ref="g54eb54f050784a2edf79b2d54527af7a" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html#g54eb54f050784a2edf79b2d54527af7a">Dune::IndicesSyncer::MessageInformation::pairs</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of pairs (attribute and process number) we publish to each neighbour process. <br></td></tr>
</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="gc7ba161114dcda480ec1e03fade5d887"></a><!-- doxytag: member="Dune::IndexPair::GlobalIndex" ref="gc7ba161114dcda480ec1e03fade5d887" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TG, class TL&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef TG <a class="el" href="a00057.html">Dune::IndexPair</a>&lt; TG, TL &gt;::GlobalIndex<code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
the type of the global index. 
<p>
This type has to provide at least a operator&lt; for sorting. 
</div>
</div><p>
<a class="anchor" name="g80f93e9c02b5f29b011140b3a87d39af"></a><!-- doxytag: member="Dune::ParallelIndexSet::LocalIndex" ref="g80f93e9c02b5f29b011140b3a87d39af" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TG, typename TL, int N = 100&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef TL <a class="el" href="a00087.html">Dune::ParallelIndexSet</a>&lt; TG, TL, N &gt;::LocalIndex<code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The type of the local index, e.g. <a class="el" href="a00089.html" title="An index present on the local process with an additional attribute flag.">ParallelLocalIndex</a>. 
<p>
This class to provide the following functions: <div class="fragment"><pre class="fragment"> <a class="code" href="a00195.html#g80f93e9c02b5f29b011140b3a87d39af" title="The type of the local index, e.g. ParallelLocalIndex.">LocalIndex</a> operator=(<span class="keywordtype">int</span>);
 operator int() <span class="keyword">const</span>;
 <a class="code" href="a00195.html#g4f24bf6f596bf963429e084ecf3a0835" title="The states avaiable for the local indices.">LocalIndexState</a> <a class="code" href="a00195.html#gd7fbeef92f1ee69893d2efcb908e133b" title="Get the state the index set is in.">state</a>() <span class="keyword">const</span>;
 <span class="keywordtype">void</span> setState(<a class="code" href="a00195.html#g4f24bf6f596bf963429e084ecf3a0835" title="The states avaiable for the local indices.">LocalIndexState</a>);
</pre></div> 
</div>
</div><p>
<a class="anchor" name="g43eed1b88f2bc2e0b683465638df39fb"></a><!-- doxytag: member="Dune::IndexPair::LocalIndex" ref="g43eed1b88f2bc2e0b683465638df39fb" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TG, class TL&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef TL <a class="el" href="a00057.html">Dune::IndexPair</a>&lt; TG, TL &gt;::LocalIndex<code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
the type of the local index. 
<p>
This class to provide the following functions: <div class="fragment"><pre class="fragment"> <a class="code" href="a00195.html#g43eed1b88f2bc2e0b683465638df39fb" title="the type of the local index.">LocalIndex</a> operator=(<span class="keywordtype">int</span>);
 operator int() <span class="keyword">const</span>;
 <a class="code" href="a00195.html#g4f24bf6f596bf963429e084ecf3a0835" title="The states avaiable for the local indices.">LocalIndexState</a> state() <span class="keyword">const</span>;
 <span class="keywordtype">void</span> setState(<a class="code" href="a00195.html#g4f24bf6f596bf963429e084ecf3a0835" title="The states avaiable for the local indices.">LocalIndexState</a>);
</pre></div> 
</div>
</div><p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="ge56f8c8166be1be9e15f9665b68c7e3b"></a><!-- doxytag: member="Dune::ParallelIndexSet::@11" ref="ge56f8c8166be1be9e15f9665b68c7e3b" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TG, typename TL, int N = 100&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum<code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gge56f8c8166be1be9e15f9665b68c7e3b7f95f052a4180cbaae53571e19da4d02"></a><!-- doxytag: member="arraySize" ref="gge56f8c8166be1be9e15f9665b68c7e3b7f95f052a4180cbaae53571e19da4d02" args="" -->arraySize</em>&nbsp;</td><td>
The size of the individual arrays in the underlying ArrayList. 
<p>
The default value is 100. <dl class="see" compact><dt><b>See also:</b></dt><dd>ArrayList::size </dd></dl>
</td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="g4f24bf6f596bf963429e084ecf3a0835"></a><!-- doxytag: member="Dune::LocalIndexState" ref="g4f24bf6f596bf963429e084ecf3a0835" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00195.html#g4f24bf6f596bf963429e084ecf3a0835">Dune::LocalIndexState</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The states avaiable for the local indices. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="a00195.html#g414be0f59f74f2653e01e1e388acec02" title="Get the state.">LocalIndex::state()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="g1b1dd66b80964351e68f44bddb32593e"></a><!-- doxytag: member="Dune::ParallelIndexSetState" ref="g1b1dd66b80964351e68f44bddb32593e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00195.html#g1b1dd66b80964351e68f44bddb32593e">Dune::ParallelIndexSetState</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The states the index set can be in. 
<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd>ParallelIndexSet::state_ </dd></dl>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gg1b1dd66b80964351e68f44bddb32593e30f779eddf23499c322b692257ae7116"></a><!-- doxytag: member="GROUND" ref="gg1b1dd66b80964351e68f44bddb32593e30f779eddf23499c322b692257ae7116" args="" -->GROUND</em>&nbsp;</td><td>
The default mode. Indicates that the index set is ready to be used. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg1b1dd66b80964351e68f44bddb32593e2fbc0ce9b92442e69a405a452f2ef416"></a><!-- doxytag: member="RESIZE" ref="gg1b1dd66b80964351e68f44bddb32593e2fbc0ce9b92442e69a405a452f2ef416" args="" -->RESIZE</em>&nbsp;</td><td>
Indicates that the index set is currently being resized. 
<p>
Indicates that all previously deleted indices are now deleted. CLEAN,<p>
Indicates that the index set is currently being reordered. REORDER </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga0be4f42ade95057bcb960cafc5e0503"></a><!-- doxytag: member="Dune::ParallelIndexSet::add" ref="ga0be4f42ade95057bcb960cafc5e0503" args="(const GlobalIndex &amp;global, const LocalIndex &amp;local)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TG, typename TL, int N = 100&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00087.html">Dune::ParallelIndexSet</a>&lt; TG, TL, N &gt;::add           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00195.html#gc025d93d84144d1ab5bcddfbc1760d53">GlobalIndex</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00069.html">LocalIndex</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>local</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throw (InvalidIndexSetState)<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add an new index to the set. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>global</em>&nbsp;</td><td>The globally unique id of the index. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>local</em>&nbsp;</td><td>The local index. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InvalidState</em>&nbsp;</td><td>If index set is not in ParallelIndexSetState::RESIZE mode. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g314b28a2ac2171f330979eb82c7d48fc"></a><!-- doxytag: member="Dune::ParallelIndexSet::add" ref="g314b28a2ac2171f330979eb82c7d48fc" args="(const GlobalIndex &amp;global)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TG, class TL, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00087.html">Dune::ParallelIndexSet</a>&lt; TG, TL, N &gt;::add           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00195.html#gc025d93d84144d1ab5bcddfbc1760d53">GlobalIndex</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>global</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (InvalidIndexSetState)<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add an new index to the set. 
<p>
The local index is created by the default constructor. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>global</em>&nbsp;</td><td>The globally unique id of the index. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InvalidState</em>&nbsp;</td><td>If index set is not in ParallelIndexSetState::RESIZE mode. </td></tr>
  </table>
</dl>

<p>References <a class="el" href="a00223.html#l00187">Dune::RESIZE</a>.</p>

<p>Referenced by <a class="el" href="a00238.html#l00434">Dune::OwnerOverlapCopyCommunication&lt; GlobalIdType, LocalIdType &gt;::OwnerOverlapCopyCommunication()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gf9470d7c9de162b08e503031bfe619f5"></a><!-- doxytag: member="Dune::ParallelLocalIndex::attribute" ref="gf9470d7c9de162b08e503031bfe619f5" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T <a class="el" href="a00089.html">Dune::ParallelLocalIndex</a>&lt; T &gt;::attribute           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>globalIndex</em>&nbsp;</td><td>The global index. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>attribute</em>&nbsp;</td><td>The attribute of the index. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>local</em>&nbsp;</td><td>The local index. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>isPublic</em>&nbsp;</td><td>True if the index might also be known to other processes.</td></tr>
  </table>
</dl>
<a class="el" href="a00089.html" title="An index present on the local process with an additional attribute flag.">ParallelLocalIndex</a>(const Attribute&amp; attribute, size_t local, bool isPublic); Get the attribute of the index. <dl class="return" compact><dt><b>Returns:</b></dt><dd>The associated attribute. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gbe001b7f354d80d38f9e92a353dcb340"></a><!-- doxytag: member="Dune::BufferedCommunicator::backward" ref="gbe001b7f354d80d38f9e92a353dcb340" args="(Data &amp;source, const Data &amp;dest)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class GatherScatter, class Data&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00024.html">Dune::BufferedCommunicator</a>&lt; T &gt;::backward           </td>
          <td>(</td>
          <td class="paramtype">Data &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Data &amp;&nbsp;</td>
          <td class="paramname"> <em>dest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Communicate in the reverse direction, i.e. send from target to source. 
<p>
The template parameter GatherScatter (e.g. CopyGatherScatter) has to have a static method <div class="fragment"><pre class="fragment"> <span class="comment">// Gather the data at index index of data</span>
 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">typename</span> CommPolicy&lt;Data&gt;::IndexedType&gt;&amp; gather(Data&amp; data, <span class="keywordtype">int</span> index);

 <span class="comment">// Scatter the value at a index of data</span>
 <span class="keyword">static</span> <span class="keywordtype">void</span> scatter(Data&amp; data, <span class="keyword">typename</span> CommPolicy&lt;Data&gt;::IndexedType&gt; value,
                     <span class="keywordtype">int</span> index);
</pre></div> in the case where <a class="el" href="a00030.html#82711a42e162a721414c8d9737a8ee0c" title="Whether the indexed type has variable size or there is always one value at each index...">CommPolicy&lt;Data&gt;::IndexedTypeFlag</a> is <a class="el" href="a00111.html" title="Flag for marking indexed data structures where data at each index is of the same...">SizeOne</a> and<p>
<div class="fragment"><pre class="fragment"> <span class="keyword">static</span> onst <span class="keyword">typename</span> CommPolicy&lt;Data&gt;::IndexedType&gt; gather(Data&amp; data, <span class="keywordtype">int</span> index, <span class="keywordtype">int</span> subindex);

 <span class="keyword">static</span> <span class="keywordtype">void</span> scatter(Data&amp; data, <span class="keyword">typename</span> CommPolicy&lt;Data&gt;::IndexedType&gt; value,
                     <span class="keywordtype">int</span> index, <span class="keywordtype">int</span> subindex);
</pre></div> in the case where <a class="el" href="a00030.html#82711a42e162a721414c8d9737a8ee0c" title="Whether the indexed type has variable size or there is always one value at each index...">CommPolicy&lt;Data&gt;::IndexedTypeFlag</a> is <a class="el" href="a00130.html" title="Flag for marking indexed data structures where the data at each index may be a variable...">VariableSize</a>. Here subindex is the subindex of the block at index. <dl class="warning" compact><dt><b>Warning:</b></dt><dd>The source and target data have to have the same layout as the ones given to the build function in case of variable size values at the indices. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The values will be copied from here to the send buffers. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The received values will be copied to here. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gb0af777cd63595c0298ff75be6a24a5d"></a><!-- doxytag: member="Dune::BufferedCommunicator::backward" ref="gb0af777cd63595c0298ff75be6a24a5d" args="(Data &amp;data)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class GatherScatter, class Data&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00024.html">Dune::BufferedCommunicator</a>&lt; T &gt;::backward           </td>
          <td>(</td>
          <td class="paramtype">Data &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Backward send where target and source are the same. 
<p>
The template parameter GatherScatter has to have a static method <div class="fragment"><pre class="fragment"> <span class="comment">// Gather the data at index index of data</span>
 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">typename</span> CommPolicy&lt;Data&gt;::IndexedType&gt;&amp; gather(Data&amp; data, <span class="keywordtype">int</span> index);

 <span class="comment">// Scatter the value at a index of data</span>
 <span class="keyword">static</span> <span class="keywordtype">void</span> scatter(Data&amp; data, <span class="keyword">typename</span> CommPolicy&lt;Data&gt;::IndexedType&gt; value,
                     <span class="keywordtype">int</span> index);
</pre></div> in the case where <a class="el" href="a00030.html#82711a42e162a721414c8d9737a8ee0c" title="Whether the indexed type has variable size or there is always one value at each index...">CommPolicy&lt;Data&gt;::IndexedTypeFlag</a> is <a class="el" href="a00111.html" title="Flag for marking indexed data structures where data at each index is of the same...">SizeOne</a> and<p>
<div class="fragment"><pre class="fragment"> <span class="keyword">static</span> onst <span class="keyword">typename</span> CommPolicy&lt;Data&gt;::IndexedType&gt; gather(Data&amp; data, <span class="keywordtype">int</span> index, <span class="keywordtype">int</span> subindex);

 <span class="keyword">static</span> <span class="keywordtype">void</span> scatter(Data&amp; data, <span class="keyword">typename</span> CommPolicy&lt;Data&gt;::IndexedType&gt; value,
                     <span class="keywordtype">int</span> index, <span class="keywordtype">int</span> subindex);
</pre></div> in the case where <a class="el" href="a00030.html#82711a42e162a721414c8d9737a8ee0c" title="Whether the indexed type has variable size or there is always one value at each index...">CommPolicy&lt;Data&gt;::IndexedTypeFlag</a> is <a class="el" href="a00130.html" title="Flag for marking indexed data structures where the data at each index may be a variable...">VariableSize</a>. Here subindex is the subindex of the block at index. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Source and target of the communication. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g5aeeb87374c2ca2d89030b39fbe68dc6"></a><!-- doxytag: member="Dune::GlobalLookupIndexSet::begin" ref="g5aeeb87374c2ca2d89030b39fbe68dc6" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I::const_iterator <a class="el" href="a00050.html">Dune::GlobalLookupIndexSet</a>&lt; I &gt;::begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator over the indices positioned at the first index. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Iterator over the local indices. </dd></dl>

<p>References <a class="el" href="a00223.html#l00889">Dune::ParallelIndexSet&lt; TG, TL, N &gt;::begin()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gf79f7deb60a9b3849481627d326a366c"></a><!-- doxytag: member="Dune::ParallelIndexSet::begin" ref="gf79f7deb60a9b3849481627d326a366c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TG, class TL, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ParallelIndexSet&lt; TG, TL, N &gt;::const_iterator <a class="el" href="a00087.html">Dune::ParallelIndexSet</a>&lt; TG, TL, N &gt;::begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an <a class="el" href="a00088.html" title="The iterator over the pairs.">iterator</a> over the indices positioned at the first index. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Iterator over the local indices. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g1f7489201417827fc547818553c1d57b"></a><!-- doxytag: member="Dune::ParallelIndexSet::begin" ref="g1f7489201417827fc547818553c1d57b" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TG, class TL, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ParallelIndexSet&lt; TG, TL, N &gt;::iterator <a class="el" href="a00087.html">Dune::ParallelIndexSet</a>&lt; TG, TL, N &gt;::begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an <a class="el" href="a00088.html" title="The iterator over the pairs.">iterator</a> over the indices positioned at the first index. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Iterator over the local indices. </dd></dl>

<p>Referenced by <a class="el" href="a00223.html#l00980">Dune::GlobalLookupIndexSet&lt; I &gt;::begin()</a>, <a class="el" href="a00226.html#l00341">Dune::InterfaceBuilder&lt; T &gt;::buildInterface()</a>, <a class="el" href="a00238.html#l00292">Dune::OwnerOverlapCopyCommunication&lt; GlobalIdType, LocalIdType &gt;::dot()</a>, <a class="el" href="a00238.html#l00318">Dune::OwnerOverlapCopyCommunication&lt; GlobalIdType, LocalIdType &gt;::norm()</a>, <a class="el" href="a00238.html#l00434">Dune::OwnerOverlapCopyCommunication&lt; GlobalIdType, LocalIdType &gt;::OwnerOverlapCopyCommunication()</a>, <a class="el" href="a00238.html#l00409">Dune::OwnerOverlapCopyCommunication&lt; GlobalIdType, LocalIdType &gt;::project()</a>, <a class="el" href="a00223.html#l00918">Dune::ParallelIndexSet&lt; TG, TL, N &gt;::renumberLocal()</a>, and <a class="el" href="a00245.html#l01272">Dune::RemoteIndexListModifier&lt; T, mode &gt;::repairLocalIndexPointers()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g5d3351c8857ba5cfdd74d28bb5725a30"></a><!-- doxytag: member="Dune::Interface::build" ref="g5d3351c8857ba5cfdd74d28bb5725a30" args="(const RemoteIndices &amp;remoteIndices, const T1 &amp;sourceFlags, const T2 &amp;destFlags)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00060.html">Dune::Interface</a>&lt; T &gt;::build           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00097.html">RemoteIndices</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>remoteIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&nbsp;</td>
          <td class="paramname"> <em>sourceFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&nbsp;</td>
          <td class="paramname"> <em>destFlags</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds the interface. 
<p>
The types T1 and T2 are classes representing a set of enumeration values of type <a class="el" href="a00060.html#8c14b4bdcf597b003b00c7d460e24343" title="The type of the attribute.">Interface::Attribute</a>. They have to provide a (static) method <div class="fragment"><pre class="fragment"> <span class="keywordtype">bool</span> contains(<a class="code" href="a00060.html#8c14b4bdcf597b003b00c7d460e24343" title="The type of the attribute.">Attribute</a> flag) <span class="keyword">const</span>;
</pre></div> for checking whether the set contains a specfic flag. This functionality is for example provided the classes EnumItem, EnumRange and Combine. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>remoteIndices</em>&nbsp;</td><td>The indices known to remote processes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sourceFlags</em>&nbsp;</td><td>The set of flags marking indices we send from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destFlags</em>&nbsp;</td><td>The set of flags marking indices we receive for. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g61de6ebaf57fccbafbf7fe0b48bdfe45"></a><!-- doxytag: member="Dune::BufferedCommunicator::build" ref="g61de6ebaf57fccbafbf7fe0b48bdfe45" args="(const Data &amp;source, const Data &amp;target, const Interface &amp;interface)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Data&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00024.html">Dune::BufferedCommunicator</a>&lt; T &gt;::build           </td>
          <td>(</td>
          <td class="paramtype">const Data &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Data &amp;&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00060.html">Interface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>interface</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Build the buffers and information for the communication process. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source in a forward send. The values will be copied from here to the send buffers. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>The target in a forward send. The received values will be copied to here. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>interface</em>&nbsp;</td><td>The interface that defines what indices are to be communicated. </td></tr>
  </table>
</dl>

<p>References <a class="el" href="a00226.html#l00422">Dune::Interface&lt; T &gt;::interfaces()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g368c5043742c278be288f9e6d976de1b"></a><!-- doxytag: member="Dune::BufferedCommunicator::build" ref="g368c5043742c278be288f9e6d976de1b" args="(const Interface &amp;interface)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Data&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EnableIf&lt; is_same&lt; SizeOne, typename CommPolicy&lt; Data &gt;::IndexedTypeFlag &gt;::value, void &gt;::Type <a class="el" href="a00024.html">Dune::BufferedCommunicator</a>&lt; T &gt;::build           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00060.html">Interface</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>interface</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Build the buffers and information for the communication process. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>interface</em>&nbsp;</td><td>The interface that defines what indices are to be communicated. </td></tr>
  </table>
</dl>

<p>References <a class="el" href="a00226.html#l00415">Dune::Interface&lt; T &gt;::communicator()</a>, and <a class="el" href="a00226.html#l00422">Dune::Interface&lt; T &gt;::interfaces()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g2ec46f5af09aa30f8884dbc284d25a3a"></a><!-- doxytag: member="Dune::InterfaceBuilder::buildInterface" ref="g2ec46f5af09aa30f8884dbc284d25a3a" args="(const RemoteIndices &amp;remoteIndices, const T1 &amp;sourceFlags, const T2 &amp;destFlags, Op &amp;functor) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class T1, class T2, class Op, bool send&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00061.html">Dune::InterfaceBuilder</a>&lt; T &gt;::buildInterface           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00097.html">RemoteIndices</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>remoteIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T1 &amp;&nbsp;</td>
          <td class="paramname"> <em>sourceFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&nbsp;</td>
          <td class="paramname"> <em>destFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Op &amp;&nbsp;</td>
          <td class="paramname"> <em>functor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds the interface between remote processes. 
<p>
The types T1 and T2 are classes representing a set of enumeration values of type <a class="el" href="a00061.html#e1cb3d9539a0f90e1d389ccad803d9b8" title="The type of the attribute.">InterfaceBuilder::Attribute</a>. They have to provide a (static) method <div class="fragment"><pre class="fragment"> <span class="keywordtype">bool</span> contains(<a class="code" href="a00061.html#e1cb3d9539a0f90e1d389ccad803d9b8" title="The type of the attribute.">Attribute</a> flag) <span class="keyword">const</span>;
</pre></div> for checking whether the set contains a specfic flag. This functionality is for example provided the classes EnumItem, EnumRange and Combine.<p>
If the template parameter send is true the sending side of the interface will be built, otherwise the information for receiving will be built.<p>
If the template parameter send is true we create interface for sending in a forward communication.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>remoteIndices</em>&nbsp;</td><td>The indices known to remote processes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sourceFlags</em>&nbsp;</td><td>The set of flags marking source indices. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destFlags</em>&nbsp;</td><td>The setof flags markig destination indices. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>functor</em>&nbsp;</td><td>A functor for callbacks. It should provide the following methods: <div class="fragment"><pre class="fragment"> <span class="comment">// Reserve memory for the interface to processor proc. The interface</span>
 <span class="comment">// has to hold size entries</span>
 <span class="keywordtype">void</span> reserve(<span class="keywordtype">int</span> proc, <span class="keywordtype">int</span> size);
 
 <span class="comment">// Add an entry to the interface</span>
 <span class="comment">// We will send/receive size entries at index local to process proc</span>
 <span class="keywordtype">void</span> <span class="keyword">add</span>(<span class="keywordtype">int</span> proc, <span class="keywordtype">int</span> local);
</pre></div> </td></tr>
  </table>
</dl>

<p>References <a class="el" href="a00245.html#l01416">Dune::CollectiveIterator&lt; T &gt;::advance()</a>, <a class="el" href="a00245.html#l01451">Dune::CollectiveIterator&lt; T &gt;::begin()</a>, <a class="el" href="a00223.html#l00889">Dune::ParallelIndexSet&lt; TG, TL, N &gt;::begin()</a>, <a class="el" href="a00245.html#l01236">Dune::RemoteIndices&lt; T &gt;::begin()</a>, <a class="el" href="a00245.html#l01394">Dune::RemoteIndices&lt; T &gt;::communicator()</a>, <a class="el" href="a00245.html#l01444">Dune::CollectiveIterator&lt; T &gt;::empty()</a>, <a class="el" href="a00245.html#l01458">Dune::CollectiveIterator&lt; T &gt;::end()</a>, <a class="el" href="a00223.html#l00897">Dune::ParallelIndexSet&lt; TG, TL, N &gt;::end()</a>, <a class="el" href="a00245.html#l01246">Dune::RemoteIndices&lt; T &gt;::end()</a>, <a class="el" href="a00245.html#l00312">Dune::RemoteIndices&lt; T &gt;::source_</a>, and <a class="el" href="a00245.html#l00315">Dune::RemoteIndices&lt; T &gt;::target_</a>.</p>

</div>
</div><p>
<a class="anchor" name="g70df556d4be8a30ec2201508ac51e930"></a><!-- doxytag: member="Dune::GlobalLookupIndexSet::end" ref="g70df556d4be8a30ec2201508ac51e930" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">I::const_iterator <a class="el" href="a00050.html">Dune::GlobalLookupIndexSet</a>&lt; I &gt;::end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator over the indices positioned after the last index. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Iterator over the local indices. </dd></dl>

<p>References <a class="el" href="a00223.html#l00897">Dune::ParallelIndexSet&lt; TG, TL, N &gt;::end()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gab5fe2f4f30c085204176111624d6f83"></a><!-- doxytag: member="Dune::ParallelIndexSet::end" ref="gab5fe2f4f30c085204176111624d6f83" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TG, class TL, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ParallelIndexSet&lt; TG, TL, N &gt;::const_iterator <a class="el" href="a00087.html">Dune::ParallelIndexSet</a>&lt; TG, TL, N &gt;::end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an <a class="el" href="a00088.html" title="The iterator over the pairs.">iterator</a> over the indices positioned after the last index. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Iterator over the local indices. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g76c8b73b6353cde82b8877ac982a17ae"></a><!-- doxytag: member="Dune::ParallelIndexSet::end" ref="g76c8b73b6353cde82b8877ac982a17ae" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TG, class TL, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ParallelIndexSet&lt; TG, TL, N &gt;::iterator <a class="el" href="a00087.html">Dune::ParallelIndexSet</a>&lt; TG, TL, N &gt;::end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an <a class="el" href="a00088.html" title="The iterator over the pairs.">iterator</a> over the indices positioned after the last index. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Iterator over the local indices. </dd></dl>

<p>Referenced by <a class="el" href="a00226.html#l00341">Dune::InterfaceBuilder&lt; T &gt;::buildInterface()</a>, <a class="el" href="a00238.html#l00292">Dune::OwnerOverlapCopyCommunication&lt; GlobalIdType, LocalIdType &gt;::dot()</a>, <a class="el" href="a00223.html#l00986">Dune::GlobalLookupIndexSet&lt; I &gt;::end()</a>, <a class="el" href="a00238.html#l00318">Dune::OwnerOverlapCopyCommunication&lt; GlobalIdType, LocalIdType &gt;::norm()</a>, <a class="el" href="a00223.html#l00582">Dune::operator&lt;&lt;()</a>, <a class="el" href="a00238.html#l00434">Dune::OwnerOverlapCopyCommunication&lt; GlobalIdType, LocalIdType &gt;::OwnerOverlapCopyCommunication()</a>, <a class="el" href="a00238.html#l00409">Dune::OwnerOverlapCopyCommunication&lt; GlobalIdType, LocalIdType &gt;::project()</a>, <a class="el" href="a00223.html#l00918">Dune::ParallelIndexSet&lt; TG, TL, N &gt;::renumberLocal()</a>, and <a class="el" href="a00245.html#l01272">Dune::RemoteIndexListModifier&lt; T, mode &gt;::repairLocalIndexPointers()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gadfad947098175e885aa7fd6c5b490a5"></a><!-- doxytag: member="Dune::ParallelIndexSet::endResize" ref="gadfad947098175e885aa7fd6c5b490a5" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TG, class TL, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00087.html">Dune::ParallelIndexSet</a>&lt; TG, TL, N &gt;::endResize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (InvalidIndexSetState)<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Indicate that the resizing finishes. 
<p>
Now every index will get its local id. The local indices will be ordered according to the global indices: Let <img class="formulaInl" alt="$(g_i,l_i)_{i=0}^N $" src="form_26.png"> be the set of all indices then <img class="formulaInl" alt="$l_i < l_j$" src="form_27.png"> if and only if <img class="formulaInl" alt="$g_i < g_j$" src="form_28.png"> for arbitrary <img class="formulaInl" alt="$i \neq j$" src="form_29.png">. <dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InvalidState</em>&nbsp;</td><td>If index set was not in ParallelIndexSetState::RESIZE mode. </td></tr>
  </table>
</dl>

<p>References <a class="el" href="a00223.html#l00183">Dune::GROUND</a>, and <a class="el" href="a00223.html#l00187">Dune::RESIZE</a>.</p>

<p>Referenced by <a class="el" href="a00238.html#l00434">Dune::OwnerOverlapCopyCommunication&lt; GlobalIdType, LocalIdType &gt;::OwnerOverlapCopyCommunication()</a>, and <a class="el" href="a00225.html#l00669">Dune::IndicesSyncer&lt; T &gt;::sync()</a>.</p>

</div>
</div><p>
<a class="anchor" name="ge50622460292c69a2851476ad41417b2"></a><!-- doxytag: member="Dune::BufferedCommunicator::forward" ref="ge50622460292c69a2851476ad41417b2" args="(const Data &amp;source, Data &amp;dest)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class GatherScatter, class Data&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00024.html">Dune::BufferedCommunicator</a>&lt; T &gt;::forward           </td>
          <td>(</td>
          <td class="paramtype">const Data &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Data &amp;&nbsp;</td>
          <td class="paramname"> <em>dest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send from source to target. 
<p>
The template parameter GatherScatter (e.g. CopyGatherScatter) has to have a static method <div class="fragment"><pre class="fragment"> <span class="comment">// Gather the data at index index of data</span>
 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">typename</span> CommPolicy&lt;Data&gt;::IndexedType&gt;&amp; gather(Data&amp; data, <span class="keywordtype">int</span> index);

 <span class="comment">// Scatter the value at a index of data</span>
 <span class="keyword">static</span> <span class="keywordtype">void</span> scatter(Data&amp; data, <span class="keyword">typename</span> CommPolicy&lt;Data&gt;::IndexedType&gt; value,
                     <span class="keywordtype">int</span> index);
</pre></div> in the case where <a class="el" href="a00030.html#82711a42e162a721414c8d9737a8ee0c" title="Whether the indexed type has variable size or there is always one value at each index...">CommPolicy&lt;Data&gt;::IndexedTypeFlag</a> is <a class="el" href="a00111.html" title="Flag for marking indexed data structures where data at each index is of the same...">SizeOne</a> and<p>
<div class="fragment"><pre class="fragment"> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">typename</span> CommPolicy&lt;Data&gt;::IndexedType&gt; gather(Data&amp; data, <span class="keywordtype">int</span> index, <span class="keywordtype">int</span> subindex);

 <span class="keyword">static</span> <span class="keywordtype">void</span> scatter(Data&amp; data, <span class="keyword">typename</span> CommPolicy&lt;Data&gt;::IndexedType&gt; value,
                     <span class="keywordtype">int</span> index, <span class="keywordtype">int</span> subindex);
</pre></div> in the case where <a class="el" href="a00030.html#82711a42e162a721414c8d9737a8ee0c" title="Whether the indexed type has variable size or there is always one value at each index...">CommPolicy&lt;Data&gt;::IndexedTypeFlag</a> is <a class="el" href="a00130.html" title="Flag for marking indexed data structures where the data at each index may be a variable...">VariableSize</a>. Here subindex is the subindex of the block at index. <dl class="warning" compact><dt><b>Warning:</b></dt><dd>The source and target data have to have the same layout as the ones given to the build function in case of variable size values at the indices. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The values will be copied from here to the send buffers. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>The received values will be copied to here. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ge291e9cc1569b51f4a8ee392c8d89af4"></a><!-- doxytag: member="Dune::BufferedCommunicator::forward" ref="ge291e9cc1569b51f4a8ee392c8d89af4" args="(Data &amp;data)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class GatherScatter, class Data&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00024.html">Dune::BufferedCommunicator</a>&lt; T &gt;::forward           </td>
          <td>(</td>
          <td class="paramtype">Data &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Forward send where target and source are the same. 
<p>
The template parameter GatherScatter has to have a static method <div class="fragment"><pre class="fragment"> <span class="comment">// Gather the data at index index of data</span>
 <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">typename</span> CommPolicy&lt;Data&gt;::IndexedType&gt;&amp; gather(Data&amp; data, <span class="keywordtype">int</span> index);

 <span class="comment">// Scatter the value at a index of data</span>
 <span class="keyword">static</span> <span class="keywordtype">void</span> scatter(Data&amp; data, <span class="keyword">typename</span> CommPolicy&lt;Data&gt;::IndexedType&gt; value,
                     <span class="keywordtype">int</span> index);
</pre></div> in the case where <a class="el" href="a00030.html#82711a42e162a721414c8d9737a8ee0c" title="Whether the indexed type has variable size or there is always one value at each index...">CommPolicy&lt;Data&gt;::IndexedTypeFlag</a> is <a class="el" href="a00111.html" title="Flag for marking indexed data structures where data at each index is of the same...">SizeOne</a> and<p>
<div class="fragment"><pre class="fragment"> <span class="keyword">static</span> onst <span class="keyword">typename</span> CommPolicy&lt;Data&gt;::IndexedType&gt; gather(Data&amp; data, <span class="keywordtype">int</span> index, <span class="keywordtype">int</span> subindex);

 <span class="keyword">static</span> <span class="keywordtype">void</span> scatter(Data&amp; data, <span class="keyword">typename</span> CommPolicy&lt;Data&gt;::IndexedType&gt; value,
                     <span class="keywordtype">int</span> index, <span class="keywordtype">int</span> subindex);
</pre></div> in the case where <a class="el" href="a00030.html#82711a42e162a721414c8d9737a8ee0c" title="Whether the indexed type has variable size or there is always one value at each index...">CommPolicy&lt;Data&gt;::IndexedTypeFlag</a> is <a class="el" href="a00130.html" title="Flag for marking indexed data structures where the data at each index may be a variable...">VariableSize</a>. Here subindex is the subindex of the block at index. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>Source and target of the communication. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gd6083d1fa31e7b48671381b8f47458f6"></a><!-- doxytag: member="Dune::CommPolicy::getAddress" ref="gd6083d1fa31e7b48671381b8f47458f6" args="(const V &amp;v, int index)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const void * <a class="el" href="a00030.html">Dune::CommPolicy</a>&lt; V &gt;::getAddress           </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the address of entry at an index. 
<p>
The default implementation uses operator[] to get the address. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>An existing representation of the type that has more elements than index. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>The index of the entry. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g6a6fe68e69566d81ea0b130ea628ada7"></a><!-- doxytag: member="Dune::CommPolicy::getSize" ref="g6a6fe68e69566d81ea0b130ea628ada7" args="(const V &amp;, int index)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="a00030.html">Dune::CommPolicy</a>&lt; V &gt;::getSize           </td>
          <td>(</td>
          <td class="paramtype">const V &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the number of primitve elements at that index. 
<p>
The default always returns 1. 
</div>
</div><p>
<a class="anchor" name="gcfce50e1fba13d1fe62b7193e738c00c"></a><!-- doxytag: member="Dune::IndexPair::global" ref="gcfce50e1fba13d1fe62b7193e738c00c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TG, class TL&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const TG &amp; <a class="el" href="a00057.html">Dune::IndexPair</a>&lt; TG, TL &gt;::global           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the global index. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The global index. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb9043928187ed9d370c5f37c51bab29a"></a><!-- doxytag: member="Dune::IndicesSyncer::Iterators::globalIndex" ref="gb9043928187ed9d370c5f37c51bab29a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IndicesSyncer&lt; T &gt;::GlobalIndex &amp; <a class="el" href="a00059.html">Dune::IndicesSyncer</a>&lt; T &gt;::Iterators::globalIndex           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the global index of the remote index at current position. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The current global index. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf0a14b66fc635c8a66f4346aa1828a88"></a><!-- doxytag: member="Dune::GlobalLookupIndexSet::GlobalLookupIndexSet" ref="gf0a14b66fc635c8a66f4346aa1828a88" args="(const ParallelIndexSet &amp;indexset, std::size_t size)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00050.html">Dune::GlobalLookupIndexSet</a>&lt; I &gt;::GlobalLookupIndexSet           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00087.html">ParallelIndexSet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>indexset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>indexset</em>&nbsp;</td><td>The index set we want to be able to lookup the corresponding global index of a local index. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The number of indices present. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gbc5975873aa790a0f3caf5b8c185a1d1"></a><!-- doxytag: member="Dune::IndexPair::IndexPair" ref="gbc5975873aa790a0f3caf5b8c185a1d1" args="(const GlobalIndex &amp;global)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TG, class TL&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00057.html">Dune::IndexPair</a>&lt; TG, TL &gt;::IndexPair           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00195.html#gc7ba161114dcda480ec1e03fade5d887">GlobalIndex</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>global</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a new Pair. 
<p>
The local index will be 0. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>global</em>&nbsp;</td><td>The global index. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g8e4caa12b6c34752c7bc2f01361d3a63"></a><!-- doxytag: member="Dune::IndexPair::IndexPair" ref="g8e4caa12b6c34752c7bc2f01361d3a63" args="(const GlobalIndex &amp;global, const LocalIndex &amp;local)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TG, class TL&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00057.html">Dune::IndexPair</a>&lt; TG, TL &gt;::IndexPair           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00195.html#gc7ba161114dcda480ec1e03fade5d887">GlobalIndex</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00069.html">LocalIndex</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>local</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs a new Pair. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>global</em>&nbsp;</td><td>The global index. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>local</em>&nbsp;</td><td>The local index. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g8b032138e767af75563f7eab24eae18c"></a><!-- doxytag: member="Dune::IndicesSyncer::IndicesSyncer" ref="g8b032138e767af75563f7eab24eae18c" args="(ParallelIndexSet &amp;indexSet, RemoteIndices &amp;remoteIndices)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00059.html">Dune::IndicesSyncer</a>&lt; T &gt;::IndicesSyncer           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00087.html">ParallelIndexSet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>indexSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00097.html">RemoteIndices</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>remoteIndices</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>
The source as well as the target index set of the remote indices have to be the same as the provided index set. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>indexSet</em>&nbsp;</td><td>The index set with the information of the locally present indices. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>remoteIndices</em>&nbsp;</td><td>The remoteIndices. </td></tr>
  </table>
</dl>

<p>References <a class="el" href="a00245.html#l01394">Dune::RemoteIndices&lt; T &gt;::communicator()</a>, <a class="el" href="a00245.html#l00312">Dune::RemoteIndices&lt; T &gt;::source_</a>, and <a class="el" href="a00245.html#l00315">Dune::RemoteIndices&lt; T &gt;::target_</a>.</p>

</div>
</div><p>
<a class="anchor" name="g12e2db408a39d33659a1047edce477b0"></a><!-- doxytag: member="Dune::IndicesSyncer::Iterators::insert" ref="g12e2db408a39d33659a1047edce477b0" args="(const RemoteIndex &amp;index, const GlobalIndex &amp;global)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00059.html">Dune::IndicesSyncer</a>&lt; T &gt;::Iterators::insert           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00095.html">RemoteIndex</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00195.html#g44992bb99b3f3f3d7c9badb9c7ff74c2">GlobalIndex</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>global</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert a new remote index to the underlying remote index list. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>The remote index. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>global</em>&nbsp;</td><td>The global index corresponding to the remote index. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gb090953b7eb31e5c8be6e9667ba13c76"></a><!-- doxytag: member="Dune::Interface::interfaces" ref="gb090953b7eb31e5c8be6e9667ba13c76" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt; int, std::pair&lt; InterfaceInformation, InterfaceInformation &gt; &gt; &amp; <a class="el" href="a00060.html">Dune::Interface</a>&lt; T &gt;::interfaces           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get information about the interfaces. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Map of the interfaces. The key of the map is the process number and the value is the information pair (first the send and then the receive information). </dd></dl>

<p>Referenced by <a class="el" href="a00212.html#l01136">Dune::BufferedCommunicator&lt; T &gt;::build()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g1eaacfdfe68b9467ab2f56817b8c3350"></a><!-- doxytag: member="Dune::IndicesSyncer::Iterators::isAtEnd" ref="g1eaacfdfe68b9467ab2f56817b8c3350" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00059.html">Dune::IndicesSyncer</a>&lt; T &gt;::Iterators::isAtEnd           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Are we at the end of the list? 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if the iterators are positioned at the end of the list and the tail of the list respectively. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb0429f093debb806dac575cc7390e215"></a><!-- doxytag: member="Dune::IndicesSyncer::Iterators::isNotAtEnd" ref="gb0429f093debb806dac575cc7390e215" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00059.html">Dune::IndicesSyncer</a>&lt; T &gt;::Iterators::isNotAtEnd           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Are we not at the end of the list? 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if the iterators are not positioned at the end of the list and the tail of the list respectively. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gab940aa97ba194f2a6607ddf6175ce71"></a><!-- doxytag: member="Dune::IndicesSyncer::Iterators::isOld" ref="gab940aa97ba194f2a6607ddf6175ce71" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00059.html">Dune::IndicesSyncer</a>&lt; T &gt;::Iterators::isOld           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Was this entry already in the remote index list before the sync process? 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if the current index wasalready in the remote index list before the sync process. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g4e835b62fa0b645342080389e5e359d3"></a><!-- doxytag: member="Dune::ParallelLocalIndex::isPublic" ref="g4e835b62fa0b645342080389e5e359d3" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00089.html">Dune::ParallelLocalIndex</a>&lt; T &gt;::isPublic           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check whether the index might also be known other processes. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if the index might be known to other processors. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g00b953618afeea2b679aa8e98e941c04"></a><!-- doxytag: member="Dune::IndicesSyncer::Iterators::Iterators" ref="g00b953618afeea2b679aa8e98e941c04" args="(RemoteIndexList &amp;remoteIndices, GlobalIndexList &amp;globalIndices, BoolList &amp;booleans)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00059.html">Dune::IndicesSyncer</a>&lt; T &gt;::Iterators::Iterators           </td>
          <td>(</td>
          <td class="paramtype">RemoteIndexList &amp;&nbsp;</td>
          <td class="paramname"> <em>remoteIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GlobalIndexList &amp;&nbsp;</td>
          <td class="paramname"> <em>globalIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BoolList &amp;&nbsp;</td>
          <td class="paramname"> <em>booleans</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>
Initializes all iterator to first entry and the one before the first entry, respectively. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>remoteIndices</em>&nbsp;</td><td>The list of the remote indices. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>globalIndices</em>&nbsp;</td><td>The list of the coresponding global indices. This is needed because the the pointers to the local index will become invalid due to the merging of the index sets. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>booleans</em>&nbsp;</td><td>Whether the remote index was there before the sync process started. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ge984fd680c3e946c1f505e5a734ab60a"></a><!-- doxytag: member="Dune::ParallelLocalIndex::local" ref="ge984fd680c3e946c1f505e5a734ab60a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="a00089.html">Dune::ParallelLocalIndex</a>&lt; T &gt;::local           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
get the local index. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The local index. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g5cdd1490a7a652c35e5a437bcff26db3"></a><!-- doxytag: member="Dune::LocalIndex::local" ref="g5cdd1490a7a652c35e5a437bcff26db3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::ptrdiff_t &amp; Dune::LocalIndex::local           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
get the local index. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The local index. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g3347abaf05298b85ac2fcce6b87b7375"></a><!-- doxytag: member="Dune::IndexPair::local" ref="g3347abaf05298b85ac2fcce6b87b7375" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TG, class TL&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const TL &amp; <a class="el" href="a00057.html">Dune::IndexPair</a>&lt; TG, TL &gt;::local           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the local index. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The local index. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ga7f66e7dbce2d04bda01b154f8103894"></a><!-- doxytag: member="Dune::IndexPair::local" ref="ga7f66e7dbce2d04bda01b154f8103894" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TG, class TL&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TL &amp; <a class="el" href="a00057.html">Dune::IndexPair</a>&lt; TG, TL &gt;::local           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the local index. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The local index. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g8967dfc42b1855566b7f9a3557f89005"></a><!-- doxytag: member="Dune::ParallelIndexSet::markAsDeleted" ref="g8967dfc42b1855566b7f9a3557f89005" args="(const iterator &amp;position)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TG, class TL, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00087.html">Dune::ParallelIndexSet</a>&lt; TG, TL, N &gt;::markAsDeleted           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00088.html">iterator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>position</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throw (InvalidIndexSetState)<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Mark an index as deleted. 
<p>
The index will be deleted during <a class="el" href="a00195.html#gadfad947098175e885aa7fd6c5b490a5" title="Indicate that the resizing finishes.">endResize()</a>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>An <a class="el" href="a00088.html" title="The iterator over the pairs.">iterator</a> at the position we want to delete. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InvalidState</em>&nbsp;</td><td>If index set is not in ParallelIndexSetState::RESIZE mode. </td></tr>
  </table>
</dl>

<p>References <a class="el" href="a00223.html#l00187">Dune::RESIZE</a>.</p>

</div>
</div><p>
<a class="anchor" name="g58851219a7013c680bf3f210dd51c7b7"></a><!-- doxytag: member="Dune::BufferedCommunicator::MessageSizeCalculator&lt; Data, VariableSize &gt;::operator()" ref="g58851219a7013c680bf3f210dd51c7b7" args="(const Data &amp;data, const InterfaceInformation &amp;info) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Data&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="a00024.html">Dune::BufferedCommunicator</a>&lt; T &gt;::MessageSizeCalculator&lt; Data, VariableSize &gt;::operator()           </td>
          <td>(</td>
          <td class="paramtype">const Data &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00062.html">InterfaceInformation</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate the number of values in message. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>The information about the interface corresponding to the message. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>A representative of the data we send. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of values in th message. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gbb7894e6112bdba6ac7394e9d22ae10a"></a><!-- doxytag: member="Dune::BufferedCommunicator::MessageSizeCalculator&lt; Data, SizeOne &gt;::operator()" ref="gbb7894e6112bdba6ac7394e9d22ae10a" args="(const Data &amp;data, const InterfaceInformation &amp;info) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Data&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="a00024.html">Dune::BufferedCommunicator</a>&lt; T &gt;::MessageSizeCalculator&lt; Data, SizeOne &gt;::operator()           </td>
          <td>(</td>
          <td class="paramtype">const Data &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00062.html">InterfaceInformation</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>info</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate the number of values in message. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>The information about the interface corresponding to the message. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>ignored. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of values in th message. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gad081958b0e7015bba10821119f2b4ef"></a><!-- doxytag: member="Dune::BufferedCommunicator::MessageSizeCalculator&lt; Data, SizeOne &gt;::operator()" ref="gad081958b0e7015bba10821119f2b4ef" args="(const InterfaceInformation &amp;info) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;class Data&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="a00024.html">Dune::BufferedCommunicator</a>&lt; T &gt;::MessageSizeCalculator&lt; Data, SizeOne &gt;::operator()           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00062.html">InterfaceInformation</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>info</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate the number of values in message. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>info</em>&nbsp;</td><td>The information about the interface corresponding to the message. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of values in th message. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gceea68b8eafc4ebca4945ddbf0bd5470"></a><!-- doxytag: member="Dune::operator&lt;&lt;" ref="gceea68b8eafc4ebca4945ddbf0bd5470" args="(std::ostream &amp;os, const ParallelLocalIndex&lt; T &gt; &amp;index)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; Dune::operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ParallelLocalIndex&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print the local index to a stream. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>os</em>&nbsp;</td><td>The output stream to print to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>The index to print. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gf387ba134daa8a9ebde34086f5957894"></a><!-- doxytag: member="Dune::operator&lt;&lt;" ref="gf387ba134daa8a9ebde34086f5957894" args="(std::ostream &amp;os, const ParallelIndexSet&lt; TG, TL, N &gt; &amp;indexSet)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TG, class TL, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Dune::operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ParallelIndexSet&lt; TG, TL, N &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>indexSet</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print an index set. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>os</em>&nbsp;</td><td>The outputstream to print to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>indexSet</em>&nbsp;</td><td>The index set to print. </td></tr>
  </table>
</dl>

<p>References <a class="el" href="a00223.html#l00897">Dune::ParallelIndexSet&lt; TG, TL, N &gt;::end()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gf3fe52ba966ff2b732b5a9216ad7e69f"></a><!-- doxytag: member="Dune::operator&lt;&lt;" ref="gf3fe52ba966ff2b732b5a9216ad7e69f" args="(std::ostream &amp;os, const IndexPair&lt; TG, TL &gt; &amp;pair)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TG, class TL&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Dune::operator&lt;&lt;           </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndexPair&lt; TG, TL &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>pair</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Print an index pair. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>os</em>&nbsp;</td><td>The outputstream to print to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pair</em>&nbsp;</td><td>The index pair to print. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g8f021b0913f65c10de19b9d9084800ef"></a><!-- doxytag: member="Dune::ParallelLocalIndex::operator=" ref="g8f021b0913f65c10de19b9d9084800ef" args="(size_t index)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ParallelLocalIndex&lt; T &gt; &amp; <a class="el" href="a00089.html">Dune::ParallelLocalIndex</a>&lt; T &gt;::operator=           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assign a new local index. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>The new local index. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gd258dc23ac723e8e307f9a38ce5a2882"></a><!-- doxytag: member="Dune::LocalIndex::operator=" ref="gd258dc23ac723e8e307f9a38ce5a2882" args="(std::ptrdiff_t index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LocalIndex &amp; Dune::LocalIndex::operator=           </td>
          <td>(</td>
          <td class="paramtype">std::ptrdiff_t&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assign a new local index. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>The new local index. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gf5a1c0458de148e051ab68fe7f104af2"></a><!-- doxytag: member="Dune::GlobalLookupIndexSet::operator[]" ref="gf5a1c0458de148e051ab68fe7f104af2" args="(const GlobalIndex &amp;global) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const IndexPair&lt; typename I::GlobalIndex, typename I::LocalIndex &gt; &amp; <a class="el" href="a00050.html">Dune::GlobalLookupIndexSet</a>&lt; I &gt;::operator[]           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00195.html#gf66c2a53e3745f2eb80a457f3358e484">GlobalIndex</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>global</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the index pair with a specific global id. 
<p>
This starts a binary search for the entry and therefor has complexity N log(N). This method is forwarded to the underlying index set. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>global</em>&nbsp;</td><td>The globally unique id of the pair. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The pair of indices for the id. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NoSuchEntry</em>&nbsp;</td><td>Thrown if the global id is not known. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g1b6da9c28c3609e5b85ec76d2b3be8fe"></a><!-- doxytag: member="Dune::ParallelIndexSet::operator[]" ref="g1b6da9c28c3609e5b85ec76d2b3be8fe" args="(const GlobalIndex &amp;global) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TG, class TL, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const IndexPair&lt; TG, TL &gt; &amp; <a class="el" href="a00087.html">Dune::ParallelIndexSet</a>&lt; TG, TL, N &gt;::operator[]           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00195.html#gc025d93d84144d1ab5bcddfbc1760d53">GlobalIndex</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>global</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the index pair with a specific global id. 
<p>
This starts a binary search for the entry and therefor has complexity N log(N). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>global</em>&nbsp;</td><td>The globally unique id of the pair. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The pair of indices for the id. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NoSuchEntry</em>&nbsp;</td><td>Thrown if the global id is not known. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gcbf0d00a471f84ee916369f8b267d2f0"></a><!-- doxytag: member="Dune::ParallelIndexSet::operator[]" ref="gcbf0d00a471f84ee916369f8b267d2f0" args="(const GlobalIndex &amp;global)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TG, class TL, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IndexPair&lt; TG, TL &gt; &amp; <a class="el" href="a00087.html">Dune::ParallelIndexSet</a>&lt; TG, TL, N &gt;::operator[]           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00195.html#gc025d93d84144d1ab5bcddfbc1760d53">GlobalIndex</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>global</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the index pair with a specific global id. 
<p>
This starts a binary search for the entry and therefor has complexity N log(N). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>global</em>&nbsp;</td><td>The globally unique id of the pair. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The pair of indices for the id. </dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NoSuchEntry</em>&nbsp;</td><td>Thrown if the global id is not known. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ge17e1ae024e8ef0dc1532125ae0296e9"></a><!-- doxytag: member="Dune::ParallelLocalIndex::ParallelLocalIndex" ref="ge17e1ae024e8ef0dc1532125ae0296e9" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00089.html">Dune::ParallelLocalIndex</a>&lt; T &gt;::ParallelLocalIndex           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parameterless constructor. 
<p>
Needed for use in container classes. 
</div>
</div><p>
<a class="anchor" name="g4f93f6b7d572e483621b096d51a17447"></a><!-- doxytag: member="Dune::ParallelLocalIndex::ParallelLocalIndex" ref="g4f93f6b7d572e483621b096d51a17447" args="(size_t localIndex, const Attribute &amp;attribute, bool isPublic)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00089.html">Dune::ParallelLocalIndex</a>&lt; T &gt;::ParallelLocalIndex           </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>localIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00089.html#7e473eb41ada9a29dd9b18b59d27cab4">Attribute</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isPublic</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>localIndex</em>&nbsp;</td><td>The local index. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>attribute</em>&nbsp;</td><td>The attribute of the index. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>isPublic</em>&nbsp;</td><td>True if the index might also be known to other processes. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gc704d4292815f9acba45ee00a37fc77b"></a><!-- doxytag: member="Dune::ParallelLocalIndex::ParallelLocalIndex" ref="gc704d4292815f9acba45ee00a37fc77b" args="(const Attribute &amp;attribute, bool isPublic)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00089.html">Dune::ParallelLocalIndex</a>&lt; T &gt;::ParallelLocalIndex           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00089.html#7e473eb41ada9a29dd9b18b59d27cab4">Attribute</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>isPublic</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>
The local index will be initialized to 0. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attribute</em>&nbsp;</td><td>The attribute of the index. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>isPublic</em>&nbsp;</td><td>True if the index might also be known to other processes. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ge95be71d25167448c338eb204475bbfa"></a><!-- doxytag: member="Dune::IndicesSyncer::Iterators::remoteIndex" ref="ge95be71d25167448c338eb204475bbfa" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">IndicesSyncer&lt; T &gt;::RemoteIndex &amp; <a class="el" href="a00059.html">Dune::IndicesSyncer</a>&lt; T &gt;::Iterators::remoteIndex           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the remote index at current position. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The current remote index. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g1d85acf860530070eb101872811f1fc4"></a><!-- doxytag: member="Dune::ParallelIndexSet::renumberLocal" ref="g1d85acf860530070eb101872811f1fc4" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TG, class TL, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00087.html">Dune::ParallelIndexSet</a>&lt; TG, TL, N &gt;::renumberLocal           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Renumbers the local index numbers. 
<p>
After this function returns the indices are consecutively numbered beginning from 0. Let $(g_i,l_i)$, $(g_j,l_j)$ be two arbituary index pairs with $g_i&lt;g_j$ then after renumbering $l_i&lt;l_j$ will hold. 
<p>References <a class="el" href="a00223.html#l00889">Dune::ParallelIndexSet&lt; TG, TL, N &gt;::begin()</a>, <a class="el" href="a00223.html#l00897">Dune::ParallelIndexSet&lt; TG, TL, N &gt;::end()</a>, and <a class="el" href="a00223.html#l00187">Dune::RESIZE</a>.</p>

</div>
</div><p>
<a class="anchor" name="g4326d84fb55197953dde912e582dcd94"></a><!-- doxytag: member="Dune::repairLocalIndexPointers" ref="g4326d84fb55197953dde912e582dcd94" args="(std::map&lt; int, SLList&lt; typename T::GlobalIndex, A &gt; &gt; &amp;globalMap, RemoteIndices&lt; T &gt; &amp;remoteIndices, const T &amp;indexSet)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Dune::repairLocalIndexPointers           </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; int, SLList&lt; typename T::GlobalIndex, A &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>globalMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RemoteIndices&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>remoteIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>indexSet</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Repair the pointers to the local indices in the remote indices. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>globalMap</em>&nbsp;</td><td>The map of the process number to the list of global indices corresponding to the remote index list of the process. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>remoteIndices</em>&nbsp;</td><td>The known remote indices. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>indexSet</em>&nbsp;</td><td>The set of local indices of the current process. </td></tr>
  </table>
</dl>

<p>References <a class="el" href="a00245.html#l00355">Dune::RemoteIndices&lt; T &gt;::remoteIndices_</a>.</p>

</div>
</div><p>
<a class="anchor" name="g8eecdeb0c362c0ab465367fb5ccdc6f5"></a><!-- doxytag: member="Dune::IndicesSyncer::Iterators::reset" ref="g8eecdeb0c362c0ab465367fb5ccdc6f5" args="(RemoteIndexList &amp;remoteIndices, GlobalIndexList &amp;globalIndices, BoolList &amp;booleans)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00059.html">Dune::IndicesSyncer</a>&lt; T &gt;::Iterators::reset           </td>
          <td>(</td>
          <td class="paramtype">RemoteIndexList &amp;&nbsp;</td>
          <td class="paramname"> <em>remoteIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GlobalIndexList &amp;&nbsp;</td>
          <td class="paramname"> <em>globalIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BoolList &amp;&nbsp;</td>
          <td class="paramname"> <em>booleans</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reset all the underlying iterators. 
<p>
Position them to first list entry and the entry before the first entry respectively. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>remoteIndices</em>&nbsp;</td><td>The list of the remote indices. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>globalIndices</em>&nbsp;</td><td>The list of the coresponding global indices. This is needed because the the pointers to the local index will become invalid due to the merging of the index sets. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>booleans</em>&nbsp;</td><td>Whether the remote index was there before the sync process started. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g2525c0db5f67ecafb1c5b002585290ba"></a><!-- doxytag: member="Dune::GlobalLookupIndexSet::seqNo" ref="g2525c0db5f67ecafb1c5b002585290ba" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="a00050.html">Dune::GlobalLookupIndexSet</a>&lt; I &gt;::seqNo           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the internal sequence number. 
<p>
Is initially 0 is incremented for each resize. <dl class="return" compact><dt><b>Returns:</b></dt><dd>The sequence number. </dd></dl>

<p>References <a class="el" href="a00223.html#l00934">Dune::ParallelIndexSet&lt; TG, TL, N &gt;::seqNo()</a>.</p>

</div>
</div><p>
<a class="anchor" name="ga48178e14a3a34666d1f5fc6938eb814"></a><!-- doxytag: member="Dune::ParallelIndexSet::seqNo" ref="ga48178e14a3a34666d1f5fc6938eb814" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TG, class TL, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="a00087.html">Dune::ParallelIndexSet</a>&lt; TG, TL, N &gt;::seqNo           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the internal sequence number. 
<p>
Is initially 0 is incremented for each resize. <dl class="return" compact><dt><b>Returns:</b></dt><dd>The sequence number. </dd></dl>

<p>Referenced by <a class="el" href="a00245.html#l01199">Dune::RemoteIndices&lt; T &gt;::isSynced()</a>, <a class="el" href="a00245.html#l01179">Dune::RemoteIndices&lt; T &gt;::rebuild()</a>, <a class="el" href="a00223.html#l00998">Dune::GlobalLookupIndexSet&lt; I &gt;::seqNo()</a>, and <a class="el" href="a00225.html#l00669">Dune::IndicesSyncer&lt; T &gt;::sync()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g33792062116e47a94116e36fb9d54ca4"></a><!-- doxytag: member="Dune::ParallelLocalIndex::setAttribute" ref="g33792062116e47a94116e36fb9d54ca4" args="(const Attribute &amp;attribute)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00089.html">Dune::ParallelLocalIndex</a>&lt; T &gt;::setAttribute           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00089.html#7e473eb41ada9a29dd9b18b59d27cab4">Attribute</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>attribute</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the attribute of the index. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>attribute</em>&nbsp;</td><td>The associated attribute. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g98503056ecd6fa927cd9189fa41f91a2"></a><!-- doxytag: member="Dune::IndexPair::setLocal" ref="g98503056ecd6fa927cd9189fa41f91a2" args="(int index)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TG, class TL&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00057.html">Dune::IndexPair</a>&lt; TG, TL &gt;::setLocal           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the local index. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index</em>&nbsp;</td><td>The index to set it to. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g803d70f66ccc5cc004e30f734bbd3cc8"></a><!-- doxytag: member="Dune::ParallelLocalIndex::setState" ref="g803d70f66ccc5cc004e30f734bbd3cc8" args="(const LocalIndexState &amp;state)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00089.html">Dune::ParallelLocalIndex</a>&lt; T &gt;::setState           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00195.html#g4f24bf6f596bf963429e084ecf3a0835">LocalIndexState</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>state</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the state. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>The state to set. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ge134fe3358bd66ec666029d570bdb5c1"></a><!-- doxytag: member="Dune::LocalIndex::setState" ref="ge134fe3358bd66ec666029d570bdb5c1" args="(LocalIndexState state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Dune::LocalIndex::setState           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00195.html#g4f24bf6f596bf963429e084ecf3a0835">LocalIndexState</a>&nbsp;</td>
          <td class="paramname"> <em>state</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the state. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>The state to set. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g4cb1ab45cfccdf8b9a2c0d8804c1743f"></a><!-- doxytag: member="Dune::GlobalLookupIndexSet::size" ref="g4cb1ab45cfccdf8b9a2c0d8804c1743f" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="a00050.html">Dune::GlobalLookupIndexSet</a>&lt; I &gt;::size           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the total number (public and nonpublic) indices. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The total number (public and nonpublic) indices. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g3d746bd954f7cbd7ca306c86b1ae7055"></a><!-- doxytag: member="Dune::ParallelIndexSet::size" ref="g3d746bd954f7cbd7ca306c86b1ae7055" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TG, class TL, int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="a00087.html">Dune::ParallelIndexSet</a>&lt; TG, TL, N &gt;::size           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the total number (public and nonpublic) indices. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The total number (public and nonpublic) indices. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g08d8d6b042214084cb0430db59639856"></a><!-- doxytag: member="Dune::ParallelLocalIndex::state" ref="g08d8d6b042214084cb0430db59639856" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">LocalIndexState <a class="el" href="a00089.html">Dune::ParallelLocalIndex</a>&lt; T &gt;::state           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the state. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The state. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g414be0f59f74f2653e01e1e388acec02"></a><!-- doxytag: member="Dune::LocalIndex::state" ref="g414be0f59f74f2653e01e1e388acec02" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LocalIndexState Dune::LocalIndex::state           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the state. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The state. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gd7fbeef92f1ee69893d2efcb908e133b"></a><!-- doxytag: member="Dune::ParallelIndexSet::state" ref="gd7fbeef92f1ee69893d2efcb908e133b" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TG, typename TL, int N = 100&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const ParallelIndexSetState&amp; <a class="el" href="a00087.html">Dune::ParallelIndexSet</a>&lt; TG, TL, N &gt;::state           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the state the index set is in. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The state of the index set. </dd></dl>

<p>Referenced by <a class="el" href="a00245.html#l01272">Dune::RemoteIndexListModifier&lt; T, mode &gt;::repairLocalIndexPointers()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g5e83acb6ddba86eff1451747a796615f"></a><!-- doxytag: member="Dune::IndicesSyncer::sync" ref="g5e83acb6ddba86eff1451747a796615f" args="(T1 &amp;numberer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename T1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00059.html">Dune::IndicesSyncer</a>&lt; T &gt;::sync           </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&nbsp;</td>
          <td class="paramname"> <em>numberer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Synce the index set and assign local numbers to new indices. 
<p>
Computes the missing indices in the local and the remote index list and adds them. No global communication is necessary! <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>numberer</em>&nbsp;</td><td>Functor providing the local indices for the added global indices. has to provide a function size_t operator()(const TG&amp; global) that provides the local index to a global one. It will be called for ascending global indices. </td></tr>
  </table>
</dl>

<p>References <a class="el" href="a00245.html#l01236">Dune::RemoteIndices&lt; T &gt;::begin()</a>, <a class="el" href="a00223.html#l00704">Dune::ParallelIndexSet&lt; TG, TL, N &gt;::beginResize()</a>, <a class="el" href="a00245.html#l01246">Dune::RemoteIndices&lt; T &gt;::end()</a>, <a class="el" href="a00223.html#l00760">Dune::ParallelIndexSet&lt; TG, TL, N &gt;::endResize()</a>, <a class="el" href="a00245.html#l01172">Dune::RemoteIndices&lt; T &gt;::neighbours()</a>, and <a class="el" href="a00223.html#l00934">Dune::ParallelIndexSet&lt; TG, TL, N &gt;::seqNo()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gc6edb7facf4c4407f74982989e5f9980"></a><!-- doxytag: member="Dune::IndicesSyncer::sync" ref="gc6edb7facf4c4407f74982989e5f9980" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00059.html">Dune::IndicesSyncer</a>&lt; T &gt;::sync           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sync the index set. 
<p>
Computes the missing indices in the local and the remote index list and adds them. No global communication is necessary! All indices added to the index will become the local index std::numeric_limits&lt;size_t&gt;::max() 
</div>
</div><p>
</div>
</div> <!-- end doxygen -->
</div> <!-- end main -->
<div class="foot">

<p class="foot">
  Generated on 6 Nov 2008 with <a
  href="http://www.doxygen.org/">Doxygen</a> (ver 1.5.6)  
  [<a href="doxygen.log">logfile</a>].
</p>

</div>

</body>
</html>
