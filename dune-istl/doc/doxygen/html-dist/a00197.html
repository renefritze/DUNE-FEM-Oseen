<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN""http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>dune-istl: Parallel Algebraic Multigrid (dune-istl )</title>
  <link rel="stylesheet" type="text/css" href="./dune-doxy.css">
  <link rel="stylesheet" type="text/css" href="./tabs.css">
</head>
<div class="main">
<div class="doxygen">
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Parallel Algebraic Multigrid<br>
<small>
[<a class="el" href="a00198.html">Preconditioners</a>]</small>
</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
A Parallel Algebraic Multigrid based on Agglomeration. 
<p>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html">aggregates.hh</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides classes for the Coloring process of AMG. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00136.html">amg.hh</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The AMG preconditioner. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00143.html">construction.hh</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper classes for the construction of classes without empty constructor. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html">dependency.hh</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides classes for initializing the link attributes of a matrix graph. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00146.html">galerkin.hh</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides a class for building the galerkin product based on a aggregation scheme. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html">graph.hh</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides classes for building the matrix graph. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00151.html">hierarchy.hh</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides a classes representing the hierarchies in AMG. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00154.html">indicescoarsener.hh</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides a class for building the index set and remote indices on the coarse level. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html">properties.hh</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides classes for handling internal properties in a graph. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00180.html">smoother.hh</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Classes for the generic construction and application of the smoothers. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html">transfer.hh</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prolongation and restriction for amg. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html">Dune::Amg::AggregationCriterion&lt; T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class of all aggregation criterions.  <a href="a00005.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html">Dune::Amg::DependencyParameters</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Paramters needed to check whether a node depends on another.  <a href="a00047.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00046.html">Dune::Amg::Dependency&lt; M, N &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="a00046.html" title="Dependency policy for symmetric matrices.">Dependency</a> policy for symmetric matrices.  <a href="a00046.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00124.html">Dune::Amg::SymmetricDependency&lt; M, N &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="a00046.html" title="Dependency policy for symmetric matrices.">Dependency</a> policy for symmetric matrices.  <a href="a00124.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00049.html">Dune::Amg::FirstDiagonal</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Norm that uses only the [0][0] entry of the block to determine couplings.  <a href="a00049.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00098.html">Dune::Amg::RowSum</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Functor using the row sum (infinity) norm to determine strong couplings.  <a href="a00098.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00123.html">Dune::Amg::SymmetricCriterion&lt; M, Norm &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Criterion taking advantage of symmetric matrices.  <a href="a00123.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00125.html">Dune::Amg::UnSymmetricCriterion&lt; M, Norm &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Criterion suited for unsymmetric matrices.  <a href="a00125.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html">Dune::Amg::AggregatesMap&lt; V &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class providing information about the mapping of the vertices onto aggregates.  <a href="a00003.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html">Dune::Amg::AggregatesMap&lt; V &gt;::DummyEdgeVisitor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A Dummy visitor that does nothing for each visited edge.  <a href="a00004.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html">Dune::Amg::Aggregate&lt; G &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A class for temporarily storing the vertices of an aggregate in.  <a href="a00002.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html">Dune::Amg::Aggregator&lt; G &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for building the aggregates.  <a href="a00006.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html">Dune::Amg::AMG&lt; M, X, S, PI, A &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parallel algebraic multigrid based on agglomeration.  <a href="a00007.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html">Dune::Amg::ConstructionTraits&lt; T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Traits class for generically constructing non default constructable types.  <a href="a00037.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00048.html">Dune::Amg::EdgeProperties</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class representing the properties of an ede in the matrix graph.  <a href="a00048.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00131.html">Dune::Amg::VertexProperties</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class representing a node in the matrix graph.  <a href="a00131.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html">Dune::Amg::SparsityBuilder&lt; M, V &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Functor for building the sparsity pattern of the matrix using examineConnectivity.  <a href="a00115.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html">Dune::Amg::BaseConnectivityConstructor::ConnectedBuilder&lt; G, S, V &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visitor for identifying connected aggregates during a breadthFirstSearch.  <a href="a00013.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00073.html">Dune::Amg::MatrixGraph&lt; M &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The (undirected) graph of a matrix.  <a href="a00073.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html">Dune::Amg::SubGraph&lt; G, T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A subgraph of a graph.  <a href="a00116.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00132.html">Dune::Amg::VertexPropertiesGraph&lt; G, VP, VM &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attaches properties to the vertices of a graph.  <a href="a00132.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00093.html">Dune::Amg::PropertiesGraph&lt; G, VP, EP, VM, EM &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attaches properties to the edges and vertices of a graph.  <a href="a00093.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html">Dune::Amg::GraphVertexPropertiesSelector&lt; G &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper to access the internal edge properties of a graph via <a class="el" href="a00053.html#284519a4d7bdac73f26407e744a1e88e" title="Get the properties associated to a vertex.">operator[]()</a>.  <a href="a00053.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html">Dune::Amg::GraphEdgePropertiesSelector&lt; G &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper to access the internal vertex properties of a graph via <a class="el" href="a00052.html#f9f8710842abac2fc96c2a48b86e8970" title="Get the properties associated to a vertex.">operator[]()</a>.  <a href="a00052.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00054.html">Dune::Amg::Hierarchy&lt; T, A &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A hierarchy of coantainers (e.g. matrices or vectors).  <a href="a00054.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00076.html">Dune::Amg::MatrixHierarchy&lt; M, PI, A &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The hierarchies build by the coarsening process.  <a href="a00076.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00027.html">Dune::Amg::CoarsenCriterion&lt; T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The criterion describing the stop criteria for the coarsening Process.  <a href="a00027.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00058.html">Dune::Amg::IndicesCoarsener&lt; SequentialInformation, E &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Coarsen Indices in the sequential case.  <a href="a00058.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html">Dune::Amg::VertexVisitedTag</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tag idnetifying the visited property of a vertex.  <a href="a00133.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00094.html">Dune::Amg::RandomAccessBundledPropertyMap&lt; C, K, i, T, R &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A property map that extracts one property out of a bundle using <a class="el" href="a00197.html#g12ef2c1377e445577a0a1f967272ccdb" title="Get the property for a key.">operator[]()</a>.  <a href="a00094.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html">Dune::Amg::DefaultSmootherArgs&lt; T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The default class for the smoother arguments.  <a href="a00045.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00113.html">Dune::Amg::SmootherTraits&lt; T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Traits class for getting the attribute class of a smoother.  <a href="a00113.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html">Dune::Amg::DefaultConstructionArgs&lt; T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construction Arguments for the default smoothers.  <a href="a00044.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00043.html">Dune::Amg::ConstructionTraits&lt; SeqSSOR&lt; M, X, Y, l &gt; &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Policy for the construction of the <a class="el" href="a00110.html" title="Sequential SSOR preconditioner.">SeqSSOR</a> smoother.  <a href="a00043.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00042.html">Dune::Amg::ConstructionTraits&lt; SeqSOR&lt; M, X, Y, l &gt; &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Policy for the construction of the <a class="el" href="a00109.html" title="Sequential SOR preconditioner.">SeqSOR</a> smoother.  <a href="a00042.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html">Dune::Amg::ConstructionTraits&lt; SeqJac&lt; M, X, Y, l &gt; &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Policy for the construction of the <a class="el" href="a00104.html" title="The sequential jacobian preconditioner.">SeqJac</a> smoother.  <a href="a00041.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00039.html">Dune::Amg::ConstructionTraits&lt; SeqILU0&lt; M, X, Y &gt; &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Policy for the construction of the <a class="el" href="a00103.html" title="Sequential ILU(n) preconditioner.">SeqILUn</a> smoother.  <a href="a00039.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00040.html">Dune::Amg::ConstructionTraits&lt; SeqILUn&lt; M, X, Y &gt; &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Policy for the construction of the <a class="el" href="a00104.html" title="The sequential jacobian preconditioner.">SeqJac</a> smoother.  <a href="a00040.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00038.html">Dune::Amg::ConstructionTraits&lt; ParSSOR&lt; M, X, Y, C &gt; &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Policy for the construction of the <a class="el" href="a00091.html" title="A parallel SSOR preconditioner.">ParSSOR</a> smoother.  <a href="a00038.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html">Dune::Amg::SmootherApplier&lt; T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper class for applying the smoothers.  <a href="a00112.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g321acf98b939f0b93a7410b189e4a2a5"></a><!-- doxytag: member="ISTL_PAAMG::Norm" ref="g321acf98b939f0b93a7410b189e4a2a5" args="" -->
typedef N&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g321acf98b939f0b93a7410b189e4a2a5">Dune::Amg::Dependency::Norm</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The norm to use for examining the matrix entries. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g62b0d02ee5cbaa9714dd453aa0db5567"></a><!-- doxytag: member="ISTL_PAAMG::Row" ref="g62b0d02ee5cbaa9714dd453aa0db5567" args="" -->
typedef Matrix::row_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g62b0d02ee5cbaa9714dd453aa0db5567">Dune::Amg::Dependency::Row</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constant Row iterator of the matrix. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g00c973edf4b506a16aea1fc25a14b897"></a><!-- doxytag: member="ISTL_PAAMG::ColIter" ref="g00c973edf4b506a16aea1fc25a14b897" args="" -->
typedef Matrix::ConstColIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g00c973edf4b506a16aea1fc25a14b897">Dune::Amg::Dependency::ColIter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constant column iterator of the matrix. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g65efb2e151489eb39de0b953bc205a81"></a><!-- doxytag: member="ISTL_PAAMG::Norm" ref="g65efb2e151489eb39de0b953bc205a81" args="" -->
typedef N&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g65efb2e151489eb39de0b953bc205a81">Dune::Amg::SymmetricDependency::Norm</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The norm to use for examining the matrix entries. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g4c9089eed18a881ea305ab6eb3a464c0"></a><!-- doxytag: member="ISTL_PAAMG::Row" ref="g4c9089eed18a881ea305ab6eb3a464c0" args="" -->
typedef Matrix::row_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g4c9089eed18a881ea305ab6eb3a464c0">Dune::Amg::SymmetricDependency::Row</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constant Row iterator of the matrix. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g5354f976f8656a31fb61761f3cfc594b"></a><!-- doxytag: member="ISTL_PAAMG::ColIter" ref="g5354f976f8656a31fb61761f3cfc594b" args="" -->
typedef Matrix::ConstColIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g5354f976f8656a31fb61761f3cfc594b">Dune::Amg::SymmetricDependency::ColIter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constant column iterator of the matrix. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gf657e8e9f35ddf9811f6ab7ea72ab9f5"></a><!-- doxytag: member="ISTL_PAAMG::VertexDescriptor" ref="gf657e8e9f35ddf9811f6ab7ea72ab9f5" args="" -->
typedef V&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gf657e8e9f35ddf9811f6ab7ea72ab9f5">Dune::Amg::AggregatesMap::VertexDescriptor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The vertex descriptor type. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g9258a3f0e9738c7c77d348cbb28b4b8d"></a><!-- doxytag: member="ISTL_PAAMG::AggregateDescriptor" ref="g9258a3f0e9738c7c77d348cbb28b4b8d" args="" -->
typedef V&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g9258a3f0e9738c7c77d348cbb28b4b8d">Dune::Amg::AggregatesMap::AggregateDescriptor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The aggregate descriptor type. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gfc80ff0c5e84263f6917591bab360129"></a><!-- doxytag: member="ISTL_PAAMG::Allocator" ref="gfc80ff0c5e84263f6917591bab360129" args="" -->
typedef PoolAllocator<br>
&lt; VertexDescriptor, <br>
100 *sizeof(int)&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gfc80ff0c5e84263f6917591bab360129">Dune::Amg::AggregatesMap::Allocator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The allocator we use for our lists and the set. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gb0e20fc899e8046c7a5eb565cd8025f3"></a><!-- doxytag: member="ISTL_PAAMG::VertexList" ref="gb0e20fc899e8046c7a5eb565cd8025f3" args="" -->
typedef SLList<br>
&lt; VertexDescriptor, Allocator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gb0e20fc899e8046c7a5eb565cd8025f3">Dune::Amg::AggregatesMap::VertexList</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of a single linked list of vertex descriptors. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gabd0e12ceada9a070a742ea7652852d0"></a><!-- doxytag: member="ISTL_PAAMG::Vertex" ref="gabd0e12ceada9a070a742ea7652852d0" args="" -->
typedef <br>
MatrixGraph::VertexDescriptor&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gabd0e12ceada9a070a742ea7652852d0">Dune::Amg::Aggregate::Vertex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The vertex descriptor type. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g96fded8e7b86869626d75352cf0e37a9"></a><!-- doxytag: member="ISTL_PAAMG::Allocator" ref="g96fded8e7b86869626d75352cf0e37a9" args="" -->
typedef PoolAllocator&lt; Vertex, <br>
100 *sizeof(int)&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g96fded8e7b86869626d75352cf0e37a9">Dune::Amg::Aggregate::Allocator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The allocator we use for our lists and the set. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g6e330d1e9b83530c2bf8819a306ca0dd"></a><!-- doxytag: member="ISTL_PAAMG::VertexList" ref="g6e330d1e9b83530c2bf8819a306ca0dd" args="" -->
typedef SLList&lt; Vertex, Allocator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g6e330d1e9b83530c2bf8819a306ca0dd">Dune::Amg::Aggregate::VertexList</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of a single linked list of vertex descriptors. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g9c57586769fb10c7acf56903b5a6403c"></a><!-- doxytag: member="ISTL_PAAMG::VertexSet" ref="g9c57586769fb10c7acf56903b5a6403c" args="" -->
typedef std::set&lt; Vertex &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g9c57586769fb10c7acf56903b5a6403c">Dune::Amg::Aggregate::VertexSet</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of a single linked list of vertex descriptors. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gf63d25be188f0a6ebc681f857e103879"></a><!-- doxytag: member="ISTL_PAAMG::const_iterator" ref="gf63d25be188f0a6ebc681f857e103879" args="" -->
typedef VertexList::const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gf63d25be188f0a6ebc681f857e103879">Dune::Amg::Aggregate::const_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Const iterator over a vertex list. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g48bdcd97f38278de05e399e0fe826892"></a><!-- doxytag: member="ISTL_PAAMG::SphereMap" ref="g48bdcd97f38278de05e399e0fe826892" args="" -->
typedef std::size_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g48bdcd97f38278de05e399e0fe826892">Dune::Amg::Aggregate::SphereMap</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of the mapping of aggregate members onto distance spheres. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g0f4859e7d55855bace8c873cfdafa678"></a><!-- doxytag: member="ISTL_PAAMG::Vertex" ref="g0f4859e7d55855bace8c873cfdafa678" args="" -->
typedef <br>
MatrixGraph::VertexDescriptor&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678">Dune::Amg::Aggregator::Vertex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The vertex identifier. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g753ac555d3d946b7cf76e5ab9b5824c2"></a><!-- doxytag: member="ISTL_PAAMG::AggregateDescriptor" ref="g753ac555d3d946b7cf76e5ab9b5824c2" args="" -->
typedef <br>
MatrixGraph::VertexDescriptor&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g753ac555d3d946b7cf76e5ab9b5824c2">Dune::Amg::Aggregator::AggregateDescriptor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the aggregate descriptor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gfc3d32c625bd4cabd2481107019b2fb2"></a><!-- doxytag: member="ISTL_PAAMG::ParallelInformation" ref="gfc3d32c625bd4cabd2481107019b2fb2" args="" -->
typedef PI&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gfc3d32c625bd4cabd2481107019b2fb2">Dune::Amg::AMG::ParallelInformation</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the parallel information. Either OwnerOverlapCommunication or another type discribing the parallel data distribution and prvoiding communication methods. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gef37f955d0f91544f873eb26177a9978"></a><!-- doxytag: member="ISTL_PAAMG::OperatorHierarchy" ref="gef37f955d0f91544f873eb26177a9978" args="" -->
typedef MatrixHierarchy&lt; M, <br>
ParallelInformation, A &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gef37f955d0f91544f873eb26177a9978">Dune::Amg::AMG::OperatorHierarchy</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The operator hierarchy type. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gafe146a3971a12af39b849c10e71e26d"></a><!-- doxytag: member="ISTL_PAAMG::ParallelInformationHierarchy" ref="gafe146a3971a12af39b849c10e71e26d" args="" -->
typedef <br>
OperatorHierarchy::ParallelInformationHierarchy&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gafe146a3971a12af39b849c10e71e26d">Dune::Amg::AMG::ParallelInformationHierarchy</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The parallal data distribution hierarchy type. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g2baddcf013a5166a162950672bd21a03"></a><!-- doxytag: member="ISTL_PAAMG::Domain" ref="g2baddcf013a5166a162950672bd21a03" args="" -->
typedef X&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g2baddcf013a5166a162950672bd21a03">Dune::Amg::AMG::Domain</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The domain type. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g7c0496b0f7de49193c227a8c93c045d1"></a><!-- doxytag: member="ISTL_PAAMG::Range" ref="g7c0496b0f7de49193c227a8c93c045d1" args="" -->
typedef X&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g7c0496b0f7de49193c227a8c93c045d1">Dune::Amg::AMG::Range</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The range type. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gb775b7ff79213774ad098fdf1c4c65cf"></a><!-- doxytag: member="ISTL_PAAMG::CoarseSolver" ref="gb775b7ff79213774ad098fdf1c4c65cf" args="" -->
typedef InverseOperator&lt; X, X &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gb775b7ff79213774ad098fdf1c4c65cf">Dune::Amg::AMG::CoarseSolver</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the type of the coarse solver. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef S&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g60efd923eab7d4f2e8e66755c1d86843">Dune::Amg::AMG::Smoother</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the smoother.  <a href="#g60efd923eab7d4f2e8e66755c1d86843"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g4b093095df84e9990eff5581cfe4bfa9"></a><!-- doxytag: member="ISTL_PAAMG::SmootherArgs" ref="g4b093095df84e9990eff5581cfe4bfa9" args="" -->
typedef SmootherTraits<br>
&lt; Smoother &gt;::Arguments&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g4b093095df84e9990eff5581cfe4bfa9">Dune::Amg::AMG::SmootherArgs</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The argument type for the construction of the smoother. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g74c4b7c1a6265b3b6de13322394100b0"></a><!-- doxytag: member="ISTL_PAAMG::Graph" ref="g74c4b7c1a6265b3b6de13322394100b0" args="" -->
typedef G&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g74c4b7c1a6265b3b6de13322394100b0">Dune::Amg::PropertyGraphVertexPropertyMap::Graph</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the graph with internal properties. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g07cb592df02f93c85a1557e8c5bd2725"></a><!-- doxytag: member="ISTL_PAAMG::BitSet" ref="g07cb592df02f93c85a1557e8c5bd2725" args="" -->
typedef std::bitset<br>
&lt; VertexProperties::SIZE &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g07cb592df02f93c85a1557e8c5bd2725">Dune::Amg::PropertyGraphVertexPropertyMap::BitSet</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the bitset. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g2ca1d5b02168336e0c7366d663db017c"></a><!-- doxytag: member="ISTL_PAAMG::Reference" ref="g2ca1d5b02168336e0c7366d663db017c" args="" -->
typedef BitSet::reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g2ca1d5b02168336e0c7366d663db017c">Dune::Amg::PropertyGraphVertexPropertyMap::Reference</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The reference type. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g1b21afd4f82aadc87c3c1a66b572c947"></a><!-- doxytag: member="ISTL_PAAMG::ValueType" ref="g1b21afd4f82aadc87c3c1a66b572c947" args="" -->
typedef bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g1b21afd4f82aadc87c3c1a66b572c947">Dune::Amg::PropertyGraphVertexPropertyMap::ValueType</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The value type. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g42735e41c3bd53cfaeabb5da0cd5334c"></a><!-- doxytag: member="ISTL_PAAMG::Vertex" ref="g42735e41c3bd53cfaeabb5da0cd5334c" args="" -->
typedef G::VertexDescriptor&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g42735e41c3bd53cfaeabb5da0cd5334c">Dune::Amg::PropertyGraphVertexPropertyMap::Vertex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The vertex descriptor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g6aee0c6bdb5527b24aa832590ff8eae6"></a><!-- doxytag: member="ISTL_PAAMG::Vertex" ref="g6aee0c6bdb5527b24aa832590ff8eae6" args="" -->
typedef T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g6aee0c6bdb5527b24aa832590ff8eae6">Dune::Amg::OverlapVertex::Vertex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The vertex descriptor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g6669e30805fb10ce64bbc532330dd6bd"></a><!-- doxytag: member="ISTL_PAAMG::ConstEdgeIterator" ref="g6669e30805fb10ce64bbc532330dd6bd" args="" -->
typedef Graph::ConstEdgeIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g6669e30805fb10ce64bbc532330dd6bd">Dune::Amg::BaseConnectivityConstructor::ConnectedBuilder::ConstEdgeIterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The constant edge iterator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g9ef43daa726f0e5682019b382d98fad5"></a><!-- doxytag: member="ISTL_PAAMG::Set" ref="g9ef43daa726f0e5682019b382d98fad5" args="" -->
typedef S&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g9ef43daa726f0e5682019b382d98fad5">Dune::Amg::BaseConnectivityConstructor::ConnectedBuilder::Set</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the connected set. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g846f7449dd71228f1242008abccd25dc"></a><!-- doxytag: member="ISTL_PAAMG::VisitedMap" ref="g846f7449dd71228f1242008abccd25dc" args="" -->
typedef V&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g846f7449dd71228f1242008abccd25dc">Dune::Amg::BaseConnectivityConstructor::ConnectedBuilder::VisitedMap</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the map for marking vertices as visited. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gdeb2a026f87fd62cfe7cfac493a6f465"></a><!-- doxytag: member="ISTL_PAAMG::Vertex" ref="gdeb2a026f87fd62cfe7cfac493a6f465" args="" -->
typedef Graph::VertexDescriptor&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gdeb2a026f87fd62cfe7cfac493a6f465">Dune::Amg::BaseConnectivityConstructor::ConnectedBuilder::Vertex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The vertex descriptor of the graph. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g4d6183e4126cd6a645ea194ac1944d7e"></a><!-- doxytag: member="ISTL_PAAMG::ParallelInformation" ref="g4d6183e4126cd6a645ea194ac1944d7e" args="" -->
typedef T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g4d6183e4126cd6a645ea194ac1944d7e">Dune::Amg::ParallelIndicesCoarsener::ParallelInformation</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the parallel information. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gb8d29bd3eeb184f0042b3e72de6cca32"></a><!-- doxytag: member="ISTL_PAAMG::GlobalIndex" ref="gb8d29bd3eeb184f0042b3e72de6cca32" args="" -->
typedef <br>
ParallelIndexSet::GlobalIndex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gb8d29bd3eeb184f0042b3e72de6cca32">Dune::Amg::ParallelIndicesCoarsener::GlobalIndex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the global index. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g3bd142f155d0e97931e76a914f793c30"></a><!-- doxytag: member="ISTL_PAAMG::LocalIndex" ref="g3bd142f155d0e97931e76a914f793c30" args="" -->
typedef <br>
ParallelIndexSet::LocalIndex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g3bd142f155d0e97931e76a914f793c30">Dune::Amg::ParallelIndicesCoarsener::LocalIndex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the local index. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g18a399553eda5531ae901932cfc42c2f"></a><!-- doxytag: member="ISTL_PAAMG::Attribute" ref="g18a399553eda5531ae901932cfc42c2f" args="" -->
typedef LocalIndex::Attribute&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g18a399553eda5531ae901932cfc42c2f">Dune::Amg::ParallelIndicesCoarsener::Attribute</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the attribute. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g8832a2191ffc86933fa7a010c4c89731"></a><!-- doxytag: member="ISTL_PAAMG::RemoteIndices" ref="g8832a2191ffc86933fa7a010c4c89731" args="" -->
typedef RemoteIndices<br>
&lt; ParallelIndexSet &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g8832a2191ffc86933fa7a010c4c89731">Dune::Amg::ParallelIndicesCoarsener::RemoteIndices</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the remote indices. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g4d1d05811b8c187e362eb440ded69f7c"></a><!-- doxytag: member="ISTL_PAAMG::Reference" ref="g4d1d05811b8c187e362eb440ded69f7c" args="" -->
typedef R&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g4d1d05811b8c187e362eb440ded69f7c">Dune::Amg::RandomAccessBundledPropertyMap::Reference</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The reference type of the container. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ge58f9bb2fd78c2e34a8fa27a9370f66a"></a><!-- doxytag: member="ISTL_PAAMG::Key" ref="ge58f9bb2fd78c2e34a8fa27a9370f66a" args="" -->
typedef K&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#ge58f9bb2fd78c2e34a8fa27a9370f66a">Dune::Amg::RandomAccessBundledPropertyMap::Key</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The key of the property map. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gf4783b71903831056f874305edb3b0d9"></a><!-- doxytag: member="ISTL_PAAMG::Category" ref="gf4783b71903831056f874305edb3b0d9" args="" -->
typedef LvaluePropertyMapTag&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gf4783b71903831056f874305edb3b0d9">Dune::Amg::RandomAccessBundledPropertyMap::Category</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The category of the property map. <br></td></tr>
<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="a00197.html#gg0acb3ac55a6f48bbb17b746b297c94639cd515782eb7ec9b0e9b136d0c3579e7">Dune::Amg::AMG::category</a> =  S::category
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flags of the link. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="a00197.html#gg2f08e1c8a9d3187abb6d9f4f77f9b7843969c5d2ea66a930eea263cec0d7e08b">Dune::Amg::PropertyGraphVertexPropertyMap::index</a> =  i
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="a00197.html#ggb41e701698a8b08f9f618b23129950a8bac431862aa7f43e45b797931ffc9bbf">Dune::Amg::RandomAccessBundledPropertyMap::index</a> =  i
 }</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g0f63d04bf01bab42917249ec824b9319"></a><!-- doxytag: member="ISTL_PAAMG::AggregationCriterion" ref="g0f63d04bf01bab42917249ec824b9319" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g0f63d04bf01bab42917249ec824b9319">Dune::Amg::AggregationCriterion::AggregationCriterion</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#ge4fef1b11ebb9e85ba520baf6d77c766">Dune::Amg::AggregationCriterion::maxDistance</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the maximal distance allowed between to nodes in a aggregate.  <a href="#ge4fef1b11ebb9e85ba520baf6d77c766"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g58f530da670bfa93fba3e127be07f913">Dune::Amg::AggregationCriterion::setMaxDistance</a> (std::size_t distance)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the maximal distance allowed between to nodes in a aggregate.  <a href="#g58f530da670bfa93fba3e127be07f913"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g5a9b3d45eb284edd36fbfb31779b780e">Dune::Amg::AggregationCriterion::minAggregateSize</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the minimum number of nodes a aggregate has to consist of.  <a href="#g5a9b3d45eb284edd36fbfb31779b780e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g0bba564dcd870e6aff3f9bc114d2a715">Dune::Amg::AggregationCriterion::setMinAggregateSize</a> (std::size_t size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the minimum number of nodes a aggregate has to consist of.  <a href="#g0bba564dcd870e6aff3f9bc114d2a715"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g4b7ef7cb7c048dab90204e7360004a41">Dune::Amg::AggregationCriterion::maxAggregateSize</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the maximum number of nodes a aggregate is allowed to have.  <a href="#g4b7ef7cb7c048dab90204e7360004a41"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g6ae3ed417f5b682d58d8486879193be2">Dune::Amg::AggregationCriterion::setMaxAggregateSize</a> (std::size_t size)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the maximum number of nodes a aggregate is allowed to have.  <a href="#g6ae3ed417f5b682d58d8486879193be2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g63591679ca51a29eb8b6db73d5c0c64b">Dune::Amg::AggregationCriterion::maxConnectivity</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the maximum number of connections a aggregate is allowed to have.  <a href="#g63591679ca51a29eb8b6db73d5c0c64b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g0fd73bf448c50c0c2c9d733ca09b00b9">Dune::Amg::AggregationCriterion::setMaxConnectivity</a> (std::size_t connectivity)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the maximum number of connections a aggregate is allowed to have.  <a href="#g0fd73bf448c50c0c2c9d733ca09b00b9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g112134619133e663798f050d995ee16e">Dune::Amg::AggregationCriterion::setDebugLevel</a> (int level)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the debugging level.  <a href="#g112134619133e663798f050d995ee16e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gc0ecfafdcb23f24bfcebf68a6815ff46">Dune::Amg::AggregationCriterion::debugLevel</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the debugging Level.  <a href="#gc0ecfafdcb23f24bfcebf68a6815ff46"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gd4cda39a27265d7281d0a24e7fd77cc2"></a><!-- doxytag: member="ISTL_PAAMG::setBeta" ref="gd4cda39a27265d7281d0a24e7fd77cc2" args="(double b)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gd4cda39a27265d7281d0a24e7fd77cc2">Dune::Amg::DependencyParameters::setBeta</a> (double b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set threshold for marking nodes as isolated. The default value is 1.0E-5. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gdc9d81c0f753b41fc3e66498bce9ab00">Dune::Amg::DependencyParameters::beta</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the threshold for marking nodes as isolated. The default value is 1.0E-5.  <a href="#gdc9d81c0f753b41fc3e66498bce9ab00"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g4a1e3ffba75a11bce0dca3054da77534"></a><!-- doxytag: member="ISTL_PAAMG::setAlpha" ref="g4a1e3ffba75a11bce0dca3054da77534" args="(double a)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g4a1e3ffba75a11bce0dca3054da77534">Dune::Amg::DependencyParameters::setAlpha</a> (double a)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the scaling value for marking connections as strong. Default value is 1/3. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g8a13c7f715bcc33c6209e04fd4c4f14a"></a><!-- doxytag: member="ISTL_PAAMG::alpha" ref="g8a13c7f715bcc33c6209e04fd4c4f14a" args="() const " -->
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g8a13c7f715bcc33c6209e04fd4c4f14a">Dune::Amg::DependencyParameters::alpha</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the scaling value for marking connections as strong. Default value is 1/3. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gaa86514f266a48b07787ab5c8440c9a2"></a><!-- doxytag: member="ISTL_PAAMG::AggregatesMap" ref="gaa86514f266a48b07787ab5c8440c9a2" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gaa86514f266a48b07787ab5c8440c9a2">Dune::Amg::AggregatesMap::AggregatesMap</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs without allocating memory. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#ga57de3c523ca120b4deec855f5e4c124">Dune::Amg::AggregatesMap::AggregatesMap</a> (std::size_t noVertices)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs with allocating memory.  <a href="#ga57de3c523ca120b4deec855f5e4c124"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g556e4f96555dae9b025dc74b5c16467d"></a><!-- doxytag: member="ISTL_PAAMG::~AggregatesMap" ref="g556e4f96555dae9b025dc74b5c16467d" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g556e4f96555dae9b025dc74b5c16467d">Dune::Amg::AggregatesMap::~AggregatesMap</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class M, class G, class C&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Tuple&lt; int, int, int &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00197.html#g259ba5ab939f8b299c4d77129e8ef213">Dune::Amg::AggregatesMap::buildAggregates</a> (const M &amp;matrix, G &amp;graph, const C &amp;criterion)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build the aggregates.  <a href="#g259ba5ab939f8b299c4d77129e8ef213"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;bool reset, class G, class F, class VM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00197.html#g271b83cdc0415c6352b36881deac4515">Dune::Amg::AggregatesMap::breadthFirstSearch</a> (const VertexDescriptor &amp;start, const AggregateDescriptor &amp;aggregate, G &amp;graph, F &amp;aggregateVisitor, VM &amp;visitedMap) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Breadth first search within an aggregate.  <a href="#g271b83cdc0415c6352b36881deac4515"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;bool remove, bool reset, class G, class L, class F1, class F2, class VM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::size_t&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00197.html#ga827f5ef3d5034851ba6abddc8d373aa">Dune::Amg::AggregatesMap::breadthFirstSearch</a> (const VertexDescriptor &amp;start, const AggregateDescriptor &amp;aggregate, G &amp;graph, L &amp;visited, F1 &amp;aggregateVisitor, F2 &amp;nonAggregateVisitor, VM &amp;visitedMap) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Breadth first search within an aggregate.  <a href="#ga827f5ef3d5034851ba6abddc8d373aa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gdf10f6b77f88384bcbcd59cfe29a2002">Dune::Amg::AggregatesMap::allocate</a> (std::size_t noVertices)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocate memory for holding the information.  <a href="#gdf10f6b77f88384bcbcd59cfe29a2002"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gb4153cc79d23bc09e61b7a3a401cacfc"></a><!-- doxytag: member="ISTL_PAAMG::noVertices" ref="gb4153cc79d23bc09e61b7a3a401cacfc" args="() const " -->
std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gb4153cc79d23bc09e61b7a3a401cacfc">Dune::Amg::AggregatesMap::noVertices</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of vertices. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gf34f175c3ba3e120b84ca16c8c5df2b8"></a><!-- doxytag: member="ISTL_PAAMG::free" ref="gf34f175c3ba3e120b84ca16c8c5df2b8" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gf34f175c3ba3e120b84ca16c8c5df2b8">Dune::Amg::AggregatesMap::free</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free the allocated memory. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">AggregateDescriptor &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g3e07dfd73a8a798f722c4a09a25bfbd1">Dune::Amg::AggregatesMap::operator[]</a> (const VertexDescriptor &amp;v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the aggregate a vertex belongs to.  <a href="#g3e07dfd73a8a798f722c4a09a25bfbd1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const AggregateDescriptor &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g9fbeb9f55e40cb276c5286d3891e035c">Dune::Amg::AggregatesMap::operator[]</a> (const VertexDescriptor &amp;v) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the aggregate a vertex belongs to.  <a href="#g9fbeb9f55e40cb276c5286d3891e035c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gcfd89e6e64868331e0cc94523db3f9cd">Dune::Amg::Aggregate::Aggregate</a> (const MatrixGraph &amp;graph, AggregatesMap&lt; Vertex &gt; &amp;aggregates, VertexSet &amp;connectivity)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#gcfd89e6e64868331e0cc94523db3f9cd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g3e3ec8317ac33f0484a3b68dbfacc883">Dune::Amg::Aggregate::reconstruct</a> (const Vertex &amp;vertex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reconstruct the aggregat from an seed node.  <a href="#g3e3ec8317ac33f0484a3b68dbfacc883"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ge96703979cf9c2caa2cc3c1b7af2759c"></a><!-- doxytag: member="ISTL_PAAMG::seed" ref="ge96703979cf9c2caa2cc3c1b7af2759c" args="(const Vertex &amp;vertex)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#ge96703979cf9c2caa2cc3c1b7af2759c">Dune::Amg::Aggregate::seed</a> (const Vertex &amp;vertex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the aggregate with one vertex. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gfce9bc3b2241e2d61f1ea626ab2b48c6"></a><!-- doxytag: member="ISTL_PAAMG::add" ref="gfce9bc3b2241e2d61f1ea626ab2b48c6" args="(const Vertex &amp;vertex)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gfce9bc3b2241e2d61f1ea626ab2b48c6">Dune::Amg::Aggregate::add</a> (const Vertex &amp;vertex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a vertex to the aggregate. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gd84ba771266c30d0fe726665c0978896"></a><!-- doxytag: member="ISTL_PAAMG::clear" ref="gd84ba771266c30d0fe726665c0978896" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gd84ba771266c30d0fe726665c0978896">Dune::Amg::Aggregate::clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the aggregate. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g5ef0c406a4ca4655f909080b98515057"></a><!-- doxytag: member="ISTL_PAAMG::size" ref="g5ef0c406a4ca4655f909080b98515057" args="()" -->
VertexList::size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g5ef0c406a4ca4655f909080b98515057">Dune::Amg::Aggregate::size</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the size of the aggregate. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gad837b91f8cb91f906d648fff8389cb4"></a><!-- doxytag: member="ISTL_PAAMG::id" ref="gad837b91f8cb91f906d648fff8389cb4" args="()" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gad837b91f8cb91f906d648fff8389cb4">Dune::Amg::Aggregate::id</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the id identifying the aggregate. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g941b0f155035fc3d918d48c88a3140fe"></a><!-- doxytag: member="ISTL_PAAMG::begin" ref="g941b0f155035fc3d918d48c88a3140fe" args="() const " -->
const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g941b0f155035fc3d918d48c88a3140fe">Dune::Amg::Aggregate::begin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get an iterator over the vertices of the aggregate. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g8d1e1147051aaa9cf3d9a21120f91462"></a><!-- doxytag: member="ISTL_PAAMG::end" ref="g8d1e1147051aaa9cf3d9a21120f91462" args="() const " -->
const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g8d1e1147051aaa9cf3d9a21120f91462">Dune::Amg::Aggregate::end</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">get an iterator over the vertices of the aggregate. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g841366f64cc179802c21d4fd5a5ac684"></a><!-- doxytag: member="ISTL_PAAMG::Aggregator" ref="g841366f64cc179802c21d4fd5a5ac684" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g841366f64cc179802c21d4fd5a5ac684">Dune::Amg::Aggregator::Aggregator</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g7d14d8929ca6f47b57706e35c6f83c8b"></a><!-- doxytag: member="ISTL_PAAMG::~Aggregator" ref="g7d14d8929ca6f47b57706e35c6f83c8b" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g7d14d8929ca6f47b57706e35c6f83c8b">Dune::Amg::Aggregator::~Aggregator</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class M, class C&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Tuple&lt; int, int, int &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00197.html#gecb7eccaaad0ed4c69e17003498d24b4">Dune::Amg::Aggregator::build</a> (const M &amp;m, G &amp;graph, AggregatesMap&lt; Vertex &gt; &amp;aggregates, const C &amp;c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build the aggregates.  <a href="#gecb7eccaaad0ed4c69e17003498d24b4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g510b6c998062391f238820837f7dfe1d">Dune::Amg::Aggregator::AggregateVisitor::AggregateVisitor</a> (const AggregatesMap&lt; Vertex &gt; &amp;aggregates, const AggregateDescriptor &amp;aggregate, Visitor &amp;visitor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#g510b6c998062391f238820837f7dfe1d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g857f6862a78c5497ae0e8f79d6ab61cf">Dune::Amg::Aggregator::AggregateVisitor::operator()</a> (const typename MatrixGraph::ConstEdgeIterator &amp;edge)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Examine an edge.  <a href="#g857f6862a78c5497ae0e8f79d6ab61cf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gad63a76e83d64c9dafbaf87ac32d0fab"></a><!-- doxytag: member="ISTL_PAAMG::value" ref="gad63a76e83d64c9dafbaf87ac32d0fab" args="()" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gad63a76e83d64c9dafbaf87ac32d0fab">Dune::Amg::Aggregator::Counter::value</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the current count. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gf50b19a16af32bb05655d7139413b6b1"></a><!-- doxytag: member="ISTL_PAAMG::increment" ref="gf50b19a16af32bb05655d7139413b6b1" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gf50b19a16af32bb05655d7139413b6b1">Dune::Amg::Aggregator::Counter::increment</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increment counter. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g5852e16c0431720161d91dcd90be6fa5"></a><!-- doxytag: member="ISTL_PAAMG::decrement" ref="g5852e16c0431720161d91dcd90be6fa5" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g5852e16c0431720161d91dcd90be6fa5">Dune::Amg::Aggregator::Counter::decrement</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Decrement counter. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g36c2f89d85ed2073e2dc21499de840b9">Dune::Amg::AMG::AMG</a> (const OperatorHierarchy &amp;matrices, CoarseSolver &amp;coarseSolver, const SmootherArgs &amp;smootherArgs, std::size_t gamma, std::size_t preSmoothingSteps, std::size_t postSmoothingSteps, bool additive=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a new amg with a specific coarse solver.  <a href="#g36c2f89d85ed2073e2dc21499de840b9"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class C&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00197.html#gcc6aaf87acbde8b55178cc09cfa39d97">Dune::Amg::AMG::AMG</a> (const Operator &amp;fineOperator, const C &amp;criterion, const SmootherArgs &amp;smootherArgs, std::size_t gamma=1, std::size_t preSmoothingSteps=2, std::size_t postSmoothingSteps=2, bool additive=false, const ParallelInformation &amp;pinfo=ParallelInformation())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct an <a class="el" href="a00007.html" title="Parallel algebraic multigrid based on agglomeration.">AMG</a> with an inexact coarse solver based on the smoother.  <a href="#gcc6aaf87acbde8b55178cc09cfa39d97"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gd3a49650f072cbdb92b3871e0c666459">Dune::Amg::AMG::pre</a> (Domain &amp;x, Range &amp;b)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g4e5279dbf6edca8a6bc25efd8d82d26d">Dune::Amg::AMG::apply</a> (Domain &amp;v, const Range &amp;d)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gde1ec1e7156b45627e1cf79d4e901205">Dune::Amg::AMG::post</a> (Domain &amp;x)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g2b4f2296dcb3b3495c69664f0ed02482">Dune::Amg::ConstructionTraits::construct</a> (Arguments &amp;args)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct an object with the specified arguments.  <a href="#g2b4f2296dcb3b3495c69664f0ed02482"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gf3c98e2348db0571b0a5c3dc3d15fa49">Dune::Amg::ConstructionTraits::deconstruct</a> (T *t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroys an object.  <a href="#gf3c98e2348db0571b0a5c3dc3d15fa49"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g6b225fc437b7776aad0fdc95294b969d"></a><!-- doxytag: member="ISTL_PAAMG::EdgeProperties" ref="g6b225fc437b7776aad0fdc95294b969d" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g6b225fc437b7776aad0fdc95294b969d">Dune::Amg::EdgeProperties::EdgeProperties</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gf9ed70e8c29de119849997fa9c5ee715"></a><!-- doxytag: member="ISTL_PAAMG::operator[]" ref="gf9ed70e8c29de119849997fa9c5ee715" args="(std::size_t v)" -->
std::bitset&lt; SIZE &gt;::reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gf9ed70e8c29de119849997fa9c5ee715">Dune::Amg::EdgeProperties::operator[]</a> (std::size_t v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the bits directly. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g03682d464718bd203cc5f9a8ddfae26d"></a><!-- doxytag: member="ISTL_PAAMG::operator[]" ref="g03682d464718bd203cc5f9a8ddfae26d" args="(std::size_t v) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g03682d464718bd203cc5f9a8ddfae26d">Dune::Amg::EdgeProperties::operator[]</a> (std::size_t v) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Acess the bits directly. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g8f839d0d1f804d70914c83c7deaeb7fe">Dune::Amg::EdgeProperties::depends</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks wether the vertex the edge points to depends on the vertex the edge starts.  <a href="#g8f839d0d1f804d70914c83c7deaeb7fe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g38d49bd7fc239574c852219b40534aa0"></a><!-- doxytag: member="ISTL_PAAMG::setDepends" ref="g38d49bd7fc239574c852219b40534aa0" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g38d49bd7fc239574c852219b40534aa0">Dune::Amg::EdgeProperties::setDepends</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marks the edge as one of which the end point depends on the starting point. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gd07409861535f9d530094eff12395e4f"></a><!-- doxytag: member="ISTL_PAAMG::resetDepends" ref="gd07409861535f9d530094eff12395e4f" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gd07409861535f9d530094eff12395e4f">Dune::Amg::EdgeProperties::resetDepends</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets the depends flag. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g31b69fcc9195551bf3dc424311b852bb">Dune::Amg::EdgeProperties::influences</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks wether the start vertex is influenced by the end vertex.  <a href="#g31b69fcc9195551bf3dc424311b852bb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g32b969d0ec7555e95bf78097257189cc"></a><!-- doxytag: member="ISTL_PAAMG::setInfluences" ref="g32b969d0ec7555e95bf78097257189cc" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g32b969d0ec7555e95bf78097257189cc">Dune::Amg::EdgeProperties::setInfluences</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marks the edge as one of which the start vertex by the end vertex. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g6e28aac9c19a543070f372f05da1c2db"></a><!-- doxytag: member="ISTL_PAAMG::resetInfluences" ref="g6e28aac9c19a543070f372f05da1c2db" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g6e28aac9c19a543070f372f05da1c2db">Dune::Amg::EdgeProperties::resetInfluences</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets the influence flag. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gc68c0d87d6d619e819ad5ff1691f6bdf"></a><!-- doxytag: member="ISTL_PAAMG::isOneWay" ref="gc68c0d87d6d619e819ad5ff1691f6bdf" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gc68c0d87d6d619e819ad5ff1691f6bdf">Dune::Amg::EdgeProperties::isOneWay</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks wether the edge is one way. I.e. either the influence or the depends flag but is set. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gd84878d65dfab7ca423c32b529b7db07"></a><!-- doxytag: member="ISTL_PAAMG::isTwoWay" ref="gd84878d65dfab7ca423c32b529b7db07" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gd84878d65dfab7ca423c32b529b7db07">Dune::Amg::EdgeProperties::isTwoWay</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks wether the edge is two way. I.e. both the influence flag and the depends flag are that. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g48527bc55de7a7ca1fb93cf9faf59694"></a><!-- doxytag: member="ISTL_PAAMG::isStrong" ref="g48527bc55de7a7ca1fb93cf9faf59694" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g48527bc55de7a7ca1fb93cf9faf59694">Dune::Amg::EdgeProperties::isStrong</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks wether the edge is strong. I.e. the influence or depends flag is set. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gc915d9cb2f218d94b60f53c275b2fccb"></a><!-- doxytag: member="ISTL_PAAMG::reset" ref="gc915d9cb2f218d94b60f53c275b2fccb" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gc915d9cb2f218d94b60f53c275b2fccb">Dune::Amg::EdgeProperties::reset</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset all flags. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g2e40a2c41f7de6d742246130b42c1b1e"></a><!-- doxytag: member="ISTL_PAAMG::printFlags" ref="g2e40a2c41f7de6d742246130b42c1b1e" args="() const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g2e40a2c41f7de6d742246130b42c1b1e">Dune::Amg::EdgeProperties::printFlags</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prints the attributes of the edge for debugging. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g35339428fc8aa369d2c59b02d5f328e4"></a><!-- doxytag: member="ISTL_PAAMG::VertexProperties" ref="g35339428fc8aa369d2c59b02d5f328e4" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g35339428fc8aa369d2c59b02d5f328e4">Dune::Amg::VertexProperties::VertexProperties</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g85dc242d0fa9a3752c41c26cd7288542"></a><!-- doxytag: member="ISTL_PAAMG::operator[]" ref="g85dc242d0fa9a3752c41c26cd7288542" args="(std::size_t v)" -->
std::bitset&lt; SIZE &gt;::reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g85dc242d0fa9a3752c41c26cd7288542">Dune::Amg::VertexProperties::operator[]</a> (std::size_t v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the bits directly. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g3d7569a3474c4018358f570efaec3eed"></a><!-- doxytag: member="ISTL_PAAMG::operator[]" ref="g3d7569a3474c4018358f570efaec3eed" args="(std::size_t v) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g3d7569a3474c4018358f570efaec3eed">Dune::Amg::VertexProperties::operator[]</a> (std::size_t v) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Acess the bits directly. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#ga21f58805bd7454756362314fa33ddc2">Dune::Amg::VertexProperties::setIsolated</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marks that node as being isolated.  <a href="#ga21f58805bd7454756362314fa33ddc2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g289825460899fdfe9ddf6ee1b8350730"></a><!-- doxytag: member="ISTL_PAAMG::isolated" ref="g289825460899fdfe9ddf6ee1b8350730" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g289825460899fdfe9ddf6ee1b8350730">Dune::Amg::VertexProperties::isolated</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks wether the node is isolated. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gda265503294533b4705b6c80a57cbd03"></a><!-- doxytag: member="ISTL_PAAMG::resetIsolated" ref="gda265503294533b4705b6c80a57cbd03" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gda265503294533b4705b6c80a57cbd03">Dune::Amg::VertexProperties::resetIsolated</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets the isolated flag. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g571cc94a95df4b731bfcdc283341357d"></a><!-- doxytag: member="ISTL_PAAMG::setVisited" ref="g571cc94a95df4b731bfcdc283341357d" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g571cc94a95df4b731bfcdc283341357d">Dune::Amg::VertexProperties::setVisited</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mark the node as already visited. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g5c5ea30c8e77a0985ffba51aa809990b"></a><!-- doxytag: member="ISTL_PAAMG::visited" ref="g5c5ea30c8e77a0985ffba51aa809990b" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g5c5ea30c8e77a0985ffba51aa809990b">Dune::Amg::VertexProperties::visited</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks wether the node is marked as visited. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gb1aae2e817a91d7c9a2a211a22451ddb"></a><!-- doxytag: member="ISTL_PAAMG::resetVisited" ref="gb1aae2e817a91d7c9a2a211a22451ddb" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gb1aae2e817a91d7c9a2a211a22451ddb">Dune::Amg::VertexProperties::resetVisited</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets the visited flag. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g4fcd4940c0a464c170eb6c9cd62f4c60"></a><!-- doxytag: member="ISTL_PAAMG::setFront" ref="g4fcd4940c0a464c170eb6c9cd62f4c60" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g4fcd4940c0a464c170eb6c9cd62f4c60">Dune::Amg::VertexProperties::setFront</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marks the node as belonging to the current clusters front. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gd0d5b56a3f7ca8f22e111bc5cfbf8089"></a><!-- doxytag: member="ISTL_PAAMG::front" ref="gd0d5b56a3f7ca8f22e111bc5cfbf8089" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gd0d5b56a3f7ca8f22e111bc5cfbf8089">Dune::Amg::VertexProperties::front</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks wether the node is marked as a front node. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g0683e6971b0867bf93e027c911d51fda"></a><!-- doxytag: member="ISTL_PAAMG::resetFront" ref="g0683e6971b0867bf93e027c911d51fda" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g0683e6971b0867bf93e027c911d51fda">Dune::Amg::VertexProperties::resetFront</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets the front node flag. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g8bb56b35f17aea06f800c84230ae8469"></a><!-- doxytag: member="ISTL_PAAMG::setExcluded" ref="g8bb56b35f17aea06f800c84230ae8469" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g8bb56b35f17aea06f800c84230ae8469">Dune::Amg::VertexProperties::setExcluded</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marks the vertex as excluded from the aggregation. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g39c6428f42252374646f2d34565e97e4">Dune::Amg::VertexProperties::excluded</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tests whether the vertex is excluded from the aggregation.  <a href="#g39c6428f42252374646f2d34565e97e4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gd0d253b746cd00f1d34fbeb0e3178ba6"></a><!-- doxytag: member="ISTL_PAAMG::resetExcluded" ref="gd0d253b746cd00f1d34fbeb0e3178ba6" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gd0d253b746cd00f1d34fbeb0e3178ba6">Dune::Amg::VertexProperties::resetExcluded</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marks the vertex as included in the aggregation. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g549b5bfb77d6415560898fe54fbeedb5"></a><!-- doxytag: member="ISTL_PAAMG::reset" ref="g549b5bfb77d6415560898fe54fbeedb5" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g549b5bfb77d6415560898fe54fbeedb5">Dune::Amg::VertexProperties::reset</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset all flags. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g413f22fe4fec3a48cf58acd5cc8d387d">Dune::Amg::PropertyGraphVertexPropertyMap::PropertyGraphVertexPropertyMap</a> (G &amp;g)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#g413f22fe4fec3a48cf58acd5cc8d387d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g3c020a2cff554847ffc0a686acbd1530"></a><!-- doxytag: member="ISTL_PAAMG::PropertyGraphVertexPropertyMap" ref="g3c020a2cff554847ffc0a686acbd1530" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g3c020a2cff554847ffc0a686acbd1530">Dune::Amg::PropertyGraphVertexPropertyMap::PropertyGraphVertexPropertyMap</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g04d9513e0514fce98d73e2799eb4e8a2">Dune::Amg::PropertyGraphVertexPropertyMap::operator[]</a> (const Vertex &amp;vertex) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the properties associated to a vertex.  <a href="#g04d9513e0514fce98d73e2799eb4e8a2"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class M, class G, class V, class Set&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">M *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00197.html#g919f770c8a3dfb9f2e720c13052e49eb">Dune::Amg::GalerkinProduct::build</a> (const M &amp;fine, G &amp;fineGraph, V &amp;visitedMap, const ParallelInformation &amp;pinfo, const AggregatesMap&lt; typename G::VertexDescriptor &gt; &amp;aggregates, const typename M::size_type &amp;size, const Set &amp;copy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates the coarse matrix via a Galerkin product.  <a href="#g919f770c8a3dfb9f2e720c13052e49eb"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g018782cf246e066d178f781d2af91943"></a><!-- doxytag: member="ISTL_PAAMG::constructNonOverlapConnectivity" ref="g018782cf246e066d178f781d2af91943" args="(R &amp;row, G &amp;graph, V &amp;visitedMap, const AggregatesMap&lt; typename G::VertexDescriptor &gt; &amp;aggregates, const typename G::VertexDescriptor &amp;seed)" -->
template&lt;class R, class G, class V&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00197.html#g018782cf246e066d178f781d2af91943">Dune::Amg::BaseConnectivityConstructor::constructNonOverlapConnectivity</a> (R &amp;row, G &amp;graph, V &amp;visitedMap, const AggregatesMap&lt; typename G::VertexDescriptor &gt; &amp;aggregates, const typename G::VertexDescriptor &amp;seed)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct the connectivity of an aggregate in the overlap. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g653f898b20814d3e5023a295b88e4f3e">Dune::Amg::BaseConnectivityConstructor::ConnectedBuilder::ConnectedBuilder</a> (const AggregatesMap&lt; Vertex &gt; &amp;aggregates, Graph &amp;graph, VisitedMap &amp;visitedMap, Set &amp;connected)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#g653f898b20814d3e5023a295b88e4f3e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g1c76c672594522d2d0d95be0bb5ecc1d">Dune::Amg::BaseConnectivityConstructor::ConnectedBuilder::operator()</a> (const ConstEdgeIterator &amp;edge)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Process an edge pointing to another aggregate.  <a href="#g1c76c672594522d2d0d95be0bb5ecc1d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class G, class V&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00197.html#g647bb4cab2e448223bad5af1800a7dff">Dune::Amg::visitNeighbours</a> (const G &amp;graph, const typename G::VertexDescriptor &amp;vertex, V &amp;visitor)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Visit all neighbour vertices of a vertex in a graph.  <a href="#g647bb4cab2e448223bad5af1800a7dff"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename Graph, typename VM&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static Graph::VertexDescriptor&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00197.html#g78cce37e5d0e0c1121a3e37b17f733ea">Dune::Amg::ParallelIndicesCoarsener::coarsen</a> (ParallelInformation &amp;fineInfo, Graph &amp;fineGraph, VM &amp;visitedMap, AggregatesMap&lt; typename Graph::VertexDescriptor &gt; &amp;aggregates, ParallelInformation &amp;coarseInfo)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build the coarse index set after the aggregatio.  <a href="#g78cce37e5d0e0c1121a3e37b17f733ea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g12ef2c1377e445577a0a1f967272ccdb">Dune::Amg::RandomAccessBundledPropertyMap::operator[]</a> (const Key &amp;key) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the property for a key.  <a href="#g12ef2c1377e445577a0a1f967272ccdb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g5c06b28bba4d8b06a46bf85bedff135f">Dune::Amg::RandomAccessBundledPropertyMap::RandomAccessBundledPropertyMap</a> (Container &amp;container)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#g5c06b28bba4d8b06a46bf85bedff135f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g4505eb9e29295d0013c666150ea8dcd9"></a><!-- doxytag: member="ISTL_PAAMG::RandomAccessBundledPropertyMap" ref="g4505eb9e29295d0013c666150ea8dcd9" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g4505eb9e29295d0013c666150ea8dcd9">Dune::Amg::RandomAccessBundledPropertyMap::RandomAccessBundledPropertyMap</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The default constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g95bfa81d687ce27c29ce918234d26423"></a><!-- doxytag: member="ISTL_PAAMG::DefaultSmootherArgs" ref="g95bfa81d687ce27c29ce918234d26423" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g95bfa81d687ce27c29ce918234d26423">Dune::Amg::DefaultSmootherArgs::DefaultSmootherArgs</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#geb9809e8ad5d1467042fd1f633cbc1bb">Dune::Amg::SmootherApplier::preSmooth</a> (Smoother &amp;smoother, Domain &amp;v, const Range &amp;d)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">apply pre smoothing in forward direction  <a href="#geb9809e8ad5d1467042fd1f633cbc1bb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#ga5289973434af337b81c8b7119efe832">Dune::Amg::SmootherApplier::postSmooth</a> (Smoother &amp;smoother, Domain &amp;v, const Range &amp;d)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">apply post smoothing in forward direction  <a href="#ga5289973434af337b81c8b7119efe832"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g223f156eaaaf96a8f6840f2177ccc4fd"></a><!-- doxytag: member="ISTL_PAAMG::Counter" ref="g223f156eaaaf96a8f6840f2177ccc4fd" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g223f156eaaaf96a8f6840f2177ccc4fd">Dune::Amg::Aggregator::Counter::Counter</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gb2f81e0c007990646ae2d1a2cba03ee9">Dune::Amg::Aggregator::ConnectivityCounter::ConnectivityCounter</a> (const VertexSet &amp;connected, const AggregatesMap&lt; Vertex &gt; &amp;aggregates)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#gb2f81e0c007990646ae2d1a2cba03ee9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g9a756b97f9143e5125497679c82c2e09"></a><!-- doxytag: member="ISTL_PAAMG::DependencyCounter" ref="g9a756b97f9143e5125497679c82c2e09" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g9a756b97f9143e5125497679c82c2e09">Dune::Amg::Aggregator::DependencyCounter::DependencyCounter</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g7b98a5dcaabbf445e630246eb3984f58">Dune::Amg::Aggregator::FrontMarker::FrontMarker</a> (VertexList &amp;front, MatrixGraph &amp;graph)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#g7b98a5dcaabbf445e630246eb3984f58"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g4a9c2f3b9ca3ad3ddb48388156b88703">Dune::Amg::Aggregator::FrontNeighbourCounter::FrontNeighbourCounter</a> (const MatrixGraph &amp;front)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#g4a9c2f3b9ca3ad3ddb48388156b88703"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g79e2f51c97c2ee301ef6ca9085b7c90c">Dune::Amg::SparsityBuilder::SparsityBuilder</a> (M &amp;matrix, const AggregatesMap&lt; V &gt; &amp;aggregates)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#g79e2f51c97c2ee301ef6ca9085b7c90c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class M, class G, class V, class Set&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">M *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00197.html#gc3b623e54f0e32e19ddf8d80014615ed">Dune::Amg::GalerkinProduct&lt; SequentialInformation &gt;::build</a> (const M &amp;fine, G &amp;fineGraph, V &amp;visitedMap, const SequentialInformation &amp;pinfo, const AggregatesMap&lt; typename G::VertexDescriptor &gt; &amp;aggregates, const typename M::size_type &amp;size, const Set &amp;copy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates the coarse matrix via a Galerkin product.  <a href="#gc3b623e54f0e32e19ddf8d80014615ed"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class M, class V, class I, class O&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00197.html#g993b7c26f04d46d4fb6e384b956e6941">Dune::Amg::BaseGalerkinProduct::calculate</a> (const M &amp;fine, const AggregatesMap&lt; V &gt; &amp;aggregates, M &amp;coarse, const I &amp;pinfo, const O &amp;copy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the galerkin product.  <a href="#g993b7c26f04d46d4fb6e384b956e6941"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g53886320f0887b5103eb19da843f7477"></a><!-- doxytag: member="ISTL_PAAMG::~MatrixGraph" ref="g53886320f0887b5103eb19da843f7477" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g53886320f0887b5103eb19da843f7477">Dune::Amg::MatrixGraph::~MatrixGraph</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gb3046bae33e75f8d7b7486d291582bfb"></a><!-- doxytag: member="ISTL_PAAMG::noEdges" ref="gb3046bae33e75f8d7b7486d291582bfb" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gb3046bae33e75f8d7b7486d291582bfb">Dune::Amg::MatrixGraph::noEdges</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of edges in the graph. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g05d2621488519d64244af3bdc05bec56"></a><!-- doxytag: member="ISTL_PAAMG::noVertices" ref="g05d2621488519d64244af3bdc05bec56" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g05d2621488519d64244af3bdc05bec56">Dune::Amg::MatrixGraph::noVertices</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of vertices in the graph. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VertexDescriptor&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g2dbe4266a8f2f3c4affa24475cb7842d">Dune::Amg::MatrixGraph::maxVertex</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the maximal vertex descriptor.  <a href="#g2dbe4266a8f2f3c4affa24475cb7842d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">EdgeDescriptor&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g7560765b9e6c6ace588ec1e9ce7ac40a">Dune::Amg::MatrixGraph::findEdge</a> (const VertexDescriptor &amp;source, const VertexDescriptor &amp;target) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the descriptor of an edge.  <a href="#g7560765b9e6c6ace588ec1e9ce7ac40a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Matrix &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g3b6223ac9367235e30023b87e05b3bbe">Dune::Amg::MatrixGraph::matrix</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the underlying matrix.  <a href="#g3b6223ac9367235e30023b87e05b3bbe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const Matrix &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g645d82b37832412d239a1743f5897f3d">Dune::Amg::MatrixGraph::matrix</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the underlying matrix.  <a href="#g645d82b37832412d239a1743f5897f3d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g05fd5193403bd77cf47d468f96aa28b1">Dune::Amg::MatrixGraph::EdgeIteratorT::EdgeIteratorT</a> (const VertexDescriptor &amp;source, const ColIterator &amp;block, const ColIterator &amp;end, const EdgeDescriptor &amp;edge)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#g05fd5193403bd77cf47d468f96aa28b1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gb1d04970fd2292a918cac2450682f4dc">Dune::Amg::MatrixGraph::EdgeIteratorT::EdgeIteratorT</a> (const ColIterator &amp;block)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor for the end iterator.  <a href="#gb1d04970fd2292a918cac2450682f4dc"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class C1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00197.html#gbce8c409b2fcb3eb605b29372dda4460">Dune::Amg::MatrixGraph::EdgeIteratorT::EdgeIteratorT</a> (const EdgeIteratorT&lt; C1 &gt; &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy Constructor.  <a href="#gbce8c409b2fcb3eb605b29372dda4460"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g100285ead736900da1c411e7d8b5e829"></a><!-- doxytag: member="ISTL_PAAMG::weight" ref="g100285ead736900da1c411e7d8b5e829" args="() const " -->
WeightType &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g100285ead736900da1c411e7d8b5e829">Dune::Amg::MatrixGraph::EdgeIteratorT::weight</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the edge weight. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g7c978c53defcc5ed2af9fd0c165ae0eb"></a><!-- doxytag: member="ISTL_PAAMG::operator++" ref="g7c978c53defcc5ed2af9fd0c165ae0eb" args="()" -->
EdgeIteratorT&lt; C &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g7c978c53defcc5ed2af9fd0c165ae0eb">Dune::Amg::MatrixGraph::EdgeIteratorT::operator++</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">preincrement operator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g6acb7783d935fb7ee769e4bd311fea23"></a><!-- doxytag: member="ISTL_PAAMG::target" ref="g6acb7783d935fb7ee769e4bd311fea23" args="() const " -->
VertexDescriptor&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g6acb7783d935fb7ee769e4bd311fea23">Dune::Amg::MatrixGraph::EdgeIteratorT::target</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The index of the target vertex of the current edge. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g1f14c46b5842db0a2ceb6ab16008650a"></a><!-- doxytag: member="ISTL_PAAMG::source" ref="g1f14c46b5842db0a2ceb6ab16008650a" args="() const " -->
VertexDescriptor&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g1f14c46b5842db0a2ceb6ab16008650a">Dune::Amg::MatrixGraph::EdgeIteratorT::source</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The index of the source vertex of the current edge. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g45c8b994d2d57585338aaf606bc34e06"></a><!-- doxytag: member="ISTL_PAAMG::operator*" ref="g45c8b994d2d57585338aaf606bc34e06" args="() const " -->
const EdgeDescriptor &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g45c8b994d2d57585338aaf606bc34e06">Dune::Amg::MatrixGraph::EdgeIteratorT::operator*</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the edge descriptor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g1c4de2051e2e0a9829ee40caffca4a8a"></a><!-- doxytag: member="ISTL_PAAMG::operator-&gt;" ref="g1c4de2051e2e0a9829ee40caffca4a8a" args="() const " -->
const EdgeDescriptor *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g1c4de2051e2e0a9829ee40caffca4a8a">Dune::Amg::MatrixGraph::EdgeIteratorT::operator-&gt;</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the edge descriptor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g146dbe671efc5a73ddcfb532a99d31f2">Dune::Amg::MatrixGraph::VertexIteratorT::VertexIteratorT</a> (C *graph, const VertexDescriptor &amp;current)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#g146dbe671efc5a73ddcfb532a99d31f2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gf1197531cc84fa49ba85b6db19be4820">Dune::Amg::MatrixGraph::VertexIteratorT::VertexIteratorT</a> (const VertexDescriptor &amp;current)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor for the end iterator.  <a href="#gf1197531cc84fa49ba85b6db19be4820"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g73d5459437d52040b8aec446a689fb3b"></a><!-- doxytag: member="ISTL_PAAMG::operator!=" ref="g73d5459437d52040b8aec446a689fb3b" args="(const VertexIteratorT&lt; MutableContainer &gt; &amp;other) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g73d5459437d52040b8aec446a689fb3b">Dune::Amg::MatrixGraph::VertexIteratorT::operator!=</a> (const VertexIteratorT&lt; MutableContainer &gt; &amp;other) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inequality operator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g229e3094d10df391b8060d2cb1c8a3af"></a><!-- doxytag: member="ISTL_PAAMG::operator!=" ref="g229e3094d10df391b8060d2cb1c8a3af" args="(const VertexIteratorT&lt; ConstContainer &gt; &amp;other) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g229e3094d10df391b8060d2cb1c8a3af">Dune::Amg::MatrixGraph::VertexIteratorT::operator!=</a> (const VertexIteratorT&lt; ConstContainer &gt; &amp;other) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inequality operator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g85c24efe6a32eebb145e2f6c4d78e352"></a><!-- doxytag: member="ISTL_PAAMG::operator==" ref="g85c24efe6a32eebb145e2f6c4d78e352" args="(const VertexIteratorT&lt; MutableContainer &gt; &amp;other) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g85c24efe6a32eebb145e2f6c4d78e352">Dune::Amg::MatrixGraph::VertexIteratorT::operator==</a> (const VertexIteratorT&lt; MutableContainer &gt; &amp;other) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Equality operator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g5c6f800950cb5231bbded7d2e065bb30"></a><!-- doxytag: member="ISTL_PAAMG::operator==" ref="g5c6f800950cb5231bbded7d2e065bb30" args="(const VertexIteratorT&lt; ConstContainer &gt; &amp;other) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g5c6f800950cb5231bbded7d2e065bb30">Dune::Amg::MatrixGraph::VertexIteratorT::operator==</a> (const VertexIteratorT&lt; ConstContainer &gt; &amp;other) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Equality operator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VertexIteratorT&lt; C &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gda4812de2b28c5d83019375cd7981456">Dune::Amg::MatrixGraph::VertexIteratorT::operator++</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move to the next vertex.  <a href="#gda4812de2b28c5d83019375cd7981456"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g70a18acb9eccfaa2d2e4212c45947a0b"></a><!-- doxytag: member="ISTL_PAAMG::weight" ref="g70a18acb9eccfaa2d2e4212c45947a0b" args="() const " -->
WeightType &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g70a18acb9eccfaa2d2e4212c45947a0b">Dune::Amg::MatrixGraph::VertexIteratorT::weight</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the weight of the vertex. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const VertexDescriptor &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g6fc08102232fde7948f977b9db22be48">Dune::Amg::MatrixGraph::VertexIteratorT::operator*</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the descriptor of the current vertex.  <a href="#g6fc08102232fde7948f977b9db22be48"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">EdgeIteratorT&lt; C &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g21aeab3a90103abdc4932bcb91a87737">Dune::Amg::MatrixGraph::VertexIteratorT::begin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator over all edges starting at the current vertex.  <a href="#g21aeab3a90103abdc4932bcb91a87737"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">EdgeIteratorT&lt; C &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g23f8fb7d9767b13ed9aacd017a0b3950">Dune::Amg::MatrixGraph::VertexIteratorT::end</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator over all edges starting at the current vertex.  <a href="#g23f8fb7d9767b13ed9aacd017a0b3950"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VertexIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g596a7e2bca0d6ce04fea64cd240effd6">Dune::Amg::MatrixGraph::begin</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator over the vertices.  <a href="#g596a7e2bca0d6ce04fea64cd240effd6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VertexIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gee23e1ecff955fa9fa37738250ec7b1a">Dune::Amg::MatrixGraph::end</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator over the vertices.  <a href="#gee23e1ecff955fa9fa37738250ec7b1a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ConstVertexIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#ge583c37e6b121185876cac765627fb17">Dune::Amg::MatrixGraph::begin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator over the vertices.  <a href="#ge583c37e6b121185876cac765627fb17"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ConstVertexIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gc2620750ced24d01aeb31bccf47f22a2">Dune::Amg::MatrixGraph::end</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator over the vertices.  <a href="#gc2620750ced24d01aeb31bccf47f22a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">EdgeIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g998ea57efbb86e1bdb4c0c5db7b33bb4">Dune::Amg::MatrixGraph::beginEdges</a> (const VertexDescriptor &amp;source)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator over the edges starting at a vertex.  <a href="#g998ea57efbb86e1bdb4c0c5db7b33bb4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">EdgeIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g0c8a05b9dc5ae4644284f7d8bfcabc0d">Dune::Amg::MatrixGraph::endEdges</a> (const VertexDescriptor &amp;source)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator over the edges starting at a vertex.  <a href="#g0c8a05b9dc5ae4644284f7d8bfcabc0d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ConstEdgeIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g5f9de1ec5faed113519adf8c9e5daa1b">Dune::Amg::MatrixGraph::beginEdges</a> (const VertexDescriptor &amp;source) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator over the edges starting at a vertex.  <a href="#g5f9de1ec5faed113519adf8c9e5daa1b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ConstEdgeIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g85a2801f3136941d80547a54ea7e9510">Dune::Amg::MatrixGraph::endEdges</a> (const VertexDescriptor &amp;source) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator over the edges starting at a vertex.  <a href="#g85a2801f3136941d80547a54ea7e9510"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gebb52889d4d4ca77442ca7bb00e52bb5">Dune::Amg::SubGraph::EdgeIterator::EdgeIterator</a> (const VertexDescriptor &amp;source, const EdgeDescriptor &amp;edge)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#gebb52889d4d4ca77442ca7bb00e52bb5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g1a93df6d36c486e495755f6d5c7e274a">Dune::Amg::SubGraph::EdgeIterator::EdgeIterator</a> (const EdgeDescriptor &amp;edge)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor for the end iterator.  <a href="#g1a93df6d36c486e495755f6d5c7e274a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">EdgeIndexMap&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g8b633dc60c44de7e1faefde57fd1815b">Dune::Amg::SubGraph::getEdgeIndexMap</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an edge index map for the graph.  <a href="#g8b633dc60c44de7e1faefde57fd1815b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga03ec02f26512aaeb2aa4e173ac64979"></a><!-- doxytag: member="ISTL_PAAMG::equals" ref="ga03ec02f26512aaeb2aa4e173ac64979" args="(const EdgeIterator &amp;other) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#ga03ec02f26512aaeb2aa4e173ac64979">Dune::Amg::SubGraph::EdgeIterator::equals</a> (const EdgeIterator &amp;other) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Equality operator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gc17ae5e687b575f8a065db283ef0fda6"></a><!-- doxytag: member="ISTL_PAAMG::increment" ref="gc17ae5e687b575f8a065db283ef0fda6" args="()" -->
EdgeIterator &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gc17ae5e687b575f8a065db283ef0fda6">Dune::Amg::SubGraph::EdgeIterator::increment</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Preincrement operator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g948978372c2bb4a58cb79f9262509e01"></a><!-- doxytag: member="ISTL_PAAMG::decrement" ref="g948978372c2bb4a58cb79f9262509e01" args="()" -->
EdgeIterator &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g948978372c2bb4a58cb79f9262509e01">Dune::Amg::SubGraph::EdgeIterator::decrement</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Preincrement operator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gbbd627d7e0b543eb4ef640d41c4a844f"></a><!-- doxytag: member="ISTL_PAAMG::source" ref="gbbd627d7e0b543eb4ef640d41c4a844f" args="() const " -->
const VertexDescriptor &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gbbd627d7e0b543eb4ef640d41c4a844f">Dune::Amg::SubGraph::EdgeIterator::source</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The index of the source vertex of the current edge. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga891fc7942aab1a3f2a35f5828bda4f1"></a><!-- doxytag: member="ISTL_PAAMG::target" ref="ga891fc7942aab1a3f2a35f5828bda4f1" args="() const " -->
const VertexDescriptor &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#ga891fc7942aab1a3f2a35f5828bda4f1">Dune::Amg::SubGraph::EdgeIterator::target</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The index of the target vertex of the current edge. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gb2e3e7dffa858622447b6921d735a22e"></a><!-- doxytag: member="ISTL_PAAMG::dereference" ref="gb2e3e7dffa858622447b6921d735a22e" args="() const " -->
const EdgeDescriptor &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gb2e3e7dffa858622447b6921d735a22e">Dune::Amg::SubGraph::EdgeIterator::dereference</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The descriptor of the current edge. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g92ba1680cf48fa40dc3d1ca5f411f1d8">Dune::Amg::SubGraph::VertexIterator::VertexIterator</a> (const SubGraph&lt; G, T &gt; *graph, const VertexDescriptor &amp;current, const VertexDescriptor &amp;end)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#g92ba1680cf48fa40dc3d1ca5f411f1d8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g12cafb57c10c7811dc2b0b7cdbf16f7b">Dune::Amg::SubGraph::VertexIterator::VertexIterator</a> (const VertexDescriptor &amp;current)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor for end iterator.  <a href="#g12cafb57c10c7811dc2b0b7cdbf16f7b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g5c77c520d598292cbbb2e1fd8a32d561"></a><!-- doxytag: member="ISTL_PAAMG::increment" ref="g5c77c520d598292cbbb2e1fd8a32d561" args="()" -->
VertexIterator &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g5c77c520d598292cbbb2e1fd8a32d561">Dune::Amg::SubGraph::VertexIterator::increment</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Preincrement operator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g9e855619e91d619e6ec2cf0fd24890af"></a><!-- doxytag: member="ISTL_PAAMG::equals" ref="g9e855619e91d619e6ec2cf0fd24890af" args="(const VertexIterator &amp;other) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g9e855619e91d619e6ec2cf0fd24890af">Dune::Amg::SubGraph::VertexIterator::equals</a> (const VertexIterator &amp;other) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Equality iterator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const VertexDescriptor &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g70f266616811166cf424eaf500cb0a59">Dune::Amg::SubGraph::VertexIterator::dereference</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the descriptor of the current vertex.  <a href="#g70f266616811166cf424eaf500cb0a59"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">EdgeIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g6f77951ee34f917adfb154af2323212e">Dune::Amg::SubGraph::VertexIterator::begin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator over all edges starting at the current vertex.  <a href="#g6f77951ee34f917adfb154af2323212e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">EdgeIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g3211f2a6cb5f2eed45e10b4db572d1f2">Dune::Amg::SubGraph::VertexIterator::end</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator over all edges starting at the current vertex.  <a href="#g3211f2a6cb5f2eed45e10b4db572d1f2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ConstVertexIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#ga21e2f7d62f68422b0128569d15bacca">Dune::Amg::SubGraph::begin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator over the vertices.  <a href="#ga21e2f7d62f68422b0128569d15bacca"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ConstVertexIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g1b3f828dd88d05ac7d6947b68bed3ca6">Dune::Amg::SubGraph::end</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator over the vertices.  <a href="#g1b3f828dd88d05ac7d6947b68bed3ca6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ConstEdgeIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g4c181177861f5e5e80f5d0e9a56338b6">Dune::Amg::SubGraph::beginEdges</a> (const VertexDescriptor &amp;source) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator over the edges starting at a vertex.  <a href="#g4c181177861f5e5e80f5d0e9a56338b6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ConstEdgeIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g2df2b4071e0737713edae90ad4b9214d">Dune::Amg::SubGraph::endEdges</a> (const VertexDescriptor &amp;source) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator over the edges starting at a vertex.  <a href="#g2df2b4071e0737713edae90ad4b9214d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g73d40986e79e8ce05dad27d010d68df3"></a><!-- doxytag: member="ISTL_PAAMG::noVertices" ref="g73d40986e79e8ce05dad27d010d68df3" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g73d40986e79e8ce05dad27d010d68df3">Dune::Amg::SubGraph::noVertices</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of vertices in the graph. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VertexDescriptor&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g76ae016793a1e2e6731754f5ae3ebfcd">Dune::Amg::SubGraph::maxVertex</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the maximal vertex descriptor.  <a href="#g76ae016793a1e2e6731754f5ae3ebfcd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g3f2b7e7ab7444dea26bf08570430b26f"></a><!-- doxytag: member="ISTL_PAAMG::noEdges" ref="g3f2b7e7ab7444dea26bf08570430b26f" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g3f2b7e7ab7444dea26bf08570430b26f">Dune::Amg::SubGraph::noEdges</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of edges in the graph. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const EdgeDescriptor &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g2de70b24abda2b41c05ffa6cdc622564">Dune::Amg::SubGraph::findEdge</a> (const VertexDescriptor &amp;source, const VertexDescriptor &amp;target) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the descriptor of an edge.  <a href="#g2de70b24abda2b41c05ffa6cdc622564"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g908aeca1dce7cc3c3a5380b688de81de"></a><!-- doxytag: member="ISTL_PAAMG::~SubGraph" ref="g908aeca1dce7cc3c3a5380b688de81de" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g908aeca1dce7cc3c3a5380b688de81de">Dune::Amg::SubGraph::~SubGraph</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gca352a31b817cd349df10182a2cd6adb">Dune::Amg::SubGraph::SubGraph</a> (const Graph &amp;graph, const T &amp;excluded)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#gca352a31b817cd349df10182a2cd6adb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">EdgeIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g654e11e5bb3eecbfb89e335bd84fff0a">Dune::Amg::VertexPropertiesGraph::beginEdges</a> (const VertexDescriptor &amp;source)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the mutable edge iterator over edges starting at a vertex.  <a href="#g654e11e5bb3eecbfb89e335bd84fff0a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">EdgeIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g4827ee0e2a84ae1b6923c3997a378030">Dune::Amg::VertexPropertiesGraph::endEdges</a> (const VertexDescriptor &amp;source)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the mutable edge iterator over edges starting at a vertex.  <a href="#g4827ee0e2a84ae1b6923c3997a378030"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ConstEdgeIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gc0a375c8eb84a65e47d181d3b7eed9d4">Dune::Amg::VertexPropertiesGraph::beginEdges</a> (const VertexDescriptor &amp;source) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the mutable edge iterator over edges starting at a vertex.  <a href="#gc0a375c8eb84a65e47d181d3b7eed9d4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ConstEdgeIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g9237d5800d8f4d9835e509f7a2711fe5">Dune::Amg::VertexPropertiesGraph::endEdges</a> (const VertexDescriptor &amp;source) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the mutable edge iterator over edges starting at a vertex.  <a href="#g9237d5800d8f4d9835e509f7a2711fe5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g17f48954d19d2f63018e407edd28798f">Dune::Amg::VertexPropertiesGraph::VertexIteratorT::VertexIteratorT</a> (const Father &amp;iter, C *graph)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#g17f48954d19d2f63018e407edd28798f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g07c621275b95483308553715fdc2aee3">Dune::Amg::VertexPropertiesGraph::VertexIteratorT::VertexIteratorT</a> (const Father &amp;iter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor for the end iterator.  <a href="#g07c621275b95483308553715fdc2aee3"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class C1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00197.html#g0b0c7be96a78253b7aa47f0a0ae53d42">Dune::Amg::VertexPropertiesGraph::VertexIteratorT::VertexIteratorT</a> (const VertexIteratorT&lt; C1 &gt; &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy Constructor.  <a href="#g0b0c7be96a78253b7aa47f0a0ae53d42"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g56a092b7b658e7ff85b4439163bd70ae"></a><!-- doxytag: member="ISTL_PAAMG::properties" ref="g56a092b7b658e7ff85b4439163bd70ae" args="() const " -->
SelectType&lt; is_same&lt; C, <br>
typename remove_const&lt; C &gt;<br>
::type &gt;::value, <br>
VertexProperties &amp;, const <br>
VertexProperties &amp; &gt;::Type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g56a092b7b658e7ff85b4439163bd70ae">Dune::Amg::VertexPropertiesGraph::VertexIteratorT::properties</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the properties of the current Vertex. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">EdgeIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g812af7c3228dc7340f24616807a02d48">Dune::Amg::VertexPropertiesGraph::VertexIteratorT::begin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator over the edges starting from the current vertex.  <a href="#g812af7c3228dc7340f24616807a02d48"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">EdgeIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gbfcaab04b7bd07e4a8731962e8de7356">Dune::Amg::VertexPropertiesGraph::VertexIteratorT::end</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator over the edges starting from the current vertex.  <a href="#gbfcaab04b7bd07e4a8731962e8de7356"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VertexIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gdcf9375836d35763339d51ccd9e0ec5e">Dune::Amg::VertexPropertiesGraph::begin</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator over the vertices.  <a href="#gdcf9375836d35763339d51ccd9e0ec5e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VertexIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g68fe008f23bb100f79c50221bb90f530">Dune::Amg::VertexPropertiesGraph::end</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator over the vertices.  <a href="#g68fe008f23bb100f79c50221bb90f530"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ConstVertexIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g82b4b7da287d74d6fd9d4ab4e0b123f9">Dune::Amg::VertexPropertiesGraph::begin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator over the vertices.  <a href="#g82b4b7da287d74d6fd9d4ab4e0b123f9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ConstVertexIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g36c4a4206bbc3dc9e668c24e3e5278e3">Dune::Amg::VertexPropertiesGraph::end</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator over the vertices.  <a href="#g36c4a4206bbc3dc9e668c24e3e5278e3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VertexProperties &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g0300e240bca87e1708c7e87e02abd31a">Dune::Amg::VertexPropertiesGraph::getVertexProperties</a> (const VertexDescriptor &amp;vertex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the properties associated with a vertex.  <a href="#g0300e240bca87e1708c7e87e02abd31a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const VertexProperties &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g590aa6fc381fe23e6e8be30ba53fcd1d">Dune::Amg::VertexPropertiesGraph::getVertexProperties</a> (const VertexDescriptor &amp;vertex) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the properties associated with a vertex.  <a href="#g590aa6fc381fe23e6e8be30ba53fcd1d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const Graph &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g1eb61ffab76c755378c3f7eae33b64f7">Dune::Amg::VertexPropertiesGraph::graph</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the graph the properties are attached to.  <a href="#g1eb61ffab76c755378c3f7eae33b64f7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g2d92a7572ace5da996aed8221e3f1e94"></a><!-- doxytag: member="ISTL_PAAMG::noVertices" ref="g2d92a7572ace5da996aed8221e3f1e94" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g2d92a7572ace5da996aed8221e3f1e94">Dune::Amg::VertexPropertiesGraph::noVertices</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of vertices in the graph. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VertexDescriptor&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g50f925de23de4d852831f400efaf07cd">Dune::Amg::VertexPropertiesGraph::maxVertex</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the maximal vertex descriptor.  <a href="#g50f925de23de4d852831f400efaf07cd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g09a6c029c377ec63b41de5f9066ab607">Dune::Amg::VertexPropertiesGraph::VertexPropertiesGraph</a> (Graph &amp;graph, const VertexMap vmap=VertexMap())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#g09a6c029c377ec63b41de5f9066ab607"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g33278adff8485da7cf27b95812308ee3">Dune::Amg::PropertiesGraph::EdgeIteratorT::EdgeIteratorT</a> (const Father &amp;iter, C *graph)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#g33278adff8485da7cf27b95812308ee3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gb3e49b1ee3e0aca073667a86de4b9e33">Dune::Amg::PropertiesGraph::EdgeIteratorT::EdgeIteratorT</a> (const Father &amp;iter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor for the end iterator.  <a href="#gb3e49b1ee3e0aca073667a86de4b9e33"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class C1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00197.html#gadea0697e4eafb9d07de8eaa5acaabfe">Dune::Amg::PropertiesGraph::EdgeIteratorT::EdgeIteratorT</a> (const EdgeIteratorT&lt; C1 &gt; &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor.  <a href="#gadea0697e4eafb9d07de8eaa5acaabfe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g5341a25483f74971bbd0b13aec171c56"></a><!-- doxytag: member="ISTL_PAAMG::properties" ref="g5341a25483f74971bbd0b13aec171c56" args="() const " -->
SelectType&lt; is_same&lt; C, <br>
typename remove_const&lt; C &gt;<br>
::type &gt;::value, <br>
EdgeProperties &amp;, const <br>
EdgeProperties &amp; &gt;::Type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g5341a25483f74971bbd0b13aec171c56">Dune::Amg::PropertiesGraph::EdgeIteratorT::properties</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the properties of the current edge. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">EdgeIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g6fe34b91b5be9814bc2e05c791a4996e">Dune::Amg::PropertiesGraph::beginEdges</a> (const VertexDescriptor &amp;source)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the mutable edge iterator over edges starting at a vertex.  <a href="#g6fe34b91b5be9814bc2e05c791a4996e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">EdgeIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gc7f8f18742ae59b5765f33cb9061e32c">Dune::Amg::PropertiesGraph::endEdges</a> (const VertexDescriptor &amp;source)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the mutable edge iterator over edges starting at a vertex.  <a href="#gc7f8f18742ae59b5765f33cb9061e32c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ConstEdgeIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gaf1e711a05efbc7b2c514f62c9b506d7">Dune::Amg::PropertiesGraph::beginEdges</a> (const VertexDescriptor &amp;source) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the mutable edge iterator over edges starting at a vertex.  <a href="#gaf1e711a05efbc7b2c514f62c9b506d7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ConstEdgeIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g7bf7c2fbdc576e81bd47c9c84c181430">Dune::Amg::PropertiesGraph::endEdges</a> (const VertexDescriptor &amp;source) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the mutable edge iterator over edges starting at a vertex.  <a href="#g7bf7c2fbdc576e81bd47c9c84c181430"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g6edb278cbf18d9d1a674691f6f497f8e">Dune::Amg::PropertiesGraph::VertexIteratorT::VertexIteratorT</a> (const Father &amp;iter, C *graph)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#g6edb278cbf18d9d1a674691f6f497f8e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g6f42fb07a1e17e57ef5486ede117c0dc">Dune::Amg::PropertiesGraph::VertexIteratorT::VertexIteratorT</a> (const Father &amp;iter)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor for the end iterator.  <a href="#g6f42fb07a1e17e57ef5486ede117c0dc"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class C1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00197.html#g123a711f2e9030afc9a66f42246b193e">Dune::Amg::PropertiesGraph::VertexIteratorT::VertexIteratorT</a> (const VertexIteratorT&lt; C1 &gt; &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy Constructor.  <a href="#g123a711f2e9030afc9a66f42246b193e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g9a72defbacf5823cdf4848539576e709"></a><!-- doxytag: member="ISTL_PAAMG::properties" ref="g9a72defbacf5823cdf4848539576e709" args="() const " -->
SelectType&lt; is_same&lt; C, <br>
typename remove_const&lt; C &gt;<br>
::type &gt;::value, <br>
VertexProperties &amp;, const <br>
VertexProperties &amp; &gt;::Type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g9a72defbacf5823cdf4848539576e709">Dune::Amg::PropertiesGraph::VertexIteratorT::properties</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the properties of the current Vertex. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">EdgeIteratorT&lt; C &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g9d353e51e14a6c935ad38530d827be7f">Dune::Amg::PropertiesGraph::VertexIteratorT::begin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator over the edges starting from the current vertex.  <a href="#g9d353e51e14a6c935ad38530d827be7f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">EdgeIteratorT&lt; C &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g2c39a20b396707730d2d70a833a1ca1d">Dune::Amg::PropertiesGraph::VertexIteratorT::end</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator over the edges starting from the current vertex.  <a href="#g2c39a20b396707730d2d70a833a1ca1d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VertexIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g41eac8244ce6592511880708eb23461a">Dune::Amg::PropertiesGraph::begin</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator over the vertices.  <a href="#g41eac8244ce6592511880708eb23461a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VertexIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gdf9e45e93ffa70043f748d40715c7e44">Dune::Amg::PropertiesGraph::end</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator over the vertices.  <a href="#gdf9e45e93ffa70043f748d40715c7e44"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ConstVertexIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gcc3bab4bf9de5dde0e8b6a8c6c96beb8">Dune::Amg::PropertiesGraph::begin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator over the vertices.  <a href="#gcc3bab4bf9de5dde0e8b6a8c6c96beb8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ConstVertexIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g58dd974e008963208bda324ae0493a94">Dune::Amg::PropertiesGraph::end</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator over the vertices.  <a href="#g58dd974e008963208bda324ae0493a94"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VertexProperties &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gf1d26a922fefafbb923e93d559eac632">Dune::Amg::PropertiesGraph::getVertexProperties</a> (const VertexDescriptor &amp;vertex)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the properties associated with a vertex.  <a href="#gf1d26a922fefafbb923e93d559eac632"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const VertexProperties &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g4f1df6b97bb20e026d6b892011fb3fd5">Dune::Amg::PropertiesGraph::getVertexProperties</a> (const VertexDescriptor &amp;vertex) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the properties associated with a vertex.  <a href="#g4f1df6b97bb20e026d6b892011fb3fd5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">EdgeProperties &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gb4aa17404514e2bc67080f60d1b0916e">Dune::Amg::PropertiesGraph::getEdgeProperties</a> (const EdgeDescriptor &amp;edge)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the properties associated with a edge.  <a href="#gb4aa17404514e2bc67080f60d1b0916e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const EdgeProperties &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g90acb2fb795ebd10e38a25dae097c9d0">Dune::Amg::PropertiesGraph::getEdgeProperties</a> (const EdgeDescriptor &amp;edge) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the properties associated with a edge.  <a href="#g90acb2fb795ebd10e38a25dae097c9d0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">EdgeProperties &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g56cf250b14af40c095a4d56ac7a57bf6">Dune::Amg::PropertiesGraph::getEdgeProperties</a> (const VertexDescriptor &amp;source, const VertexDescriptor &amp;target)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the properties associated with a edge.  <a href="#g56cf250b14af40c095a4d56ac7a57bf6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const EdgeProperties &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g0cc37f050cf56de756cb78e5875f3d22">Dune::Amg::PropertiesGraph::getEdgeProperties</a> (const VertexDescriptor &amp;source, const VertexDescriptor &amp;target) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the properties associated with a edge.  <a href="#g0cc37f050cf56de756cb78e5875f3d22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const Graph &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gf39e07a724bd35b821fed373bea51990">Dune::Amg::PropertiesGraph::graph</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the graph the properties are attached to.  <a href="#gf39e07a724bd35b821fed373bea51990"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g69620db1d8b57d8b4a2e40a99d9b83f2"></a><!-- doxytag: member="ISTL_PAAMG::noVertices" ref="g69620db1d8b57d8b4a2e40a99d9b83f2" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g69620db1d8b57d8b4a2e40a99d9b83f2">Dune::Amg::PropertiesGraph::noVertices</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of vertices in the graph. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VertexDescriptor&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#geace8f70fb38cd28d5261f363ef3ee14">Dune::Amg::PropertiesGraph::maxVertex</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the maximal vertex descriptor.  <a href="#geace8f70fb38cd28d5261f363ef3ee14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gc6e00184177e96d465fdeeab78c6c11e">Dune::Amg::PropertiesGraph::PropertiesGraph</a> (Graph &amp;graph, const VertexMap &amp;vmap=VertexMap(), const EdgeMap &amp;emap=EdgeMap())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#gc6e00184177e96d465fdeeab78c6c11e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#ge67b84fea589c9f9bb912ff90b511c3e">Dune::Amg::MatrixHierarchy::MatrixHierarchy</a> (const MatrixOperator &amp;fineMatrix, const ParallelInformation &amp;pinfo=ParallelInformation())</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#ge67b84fea589c9f9bb912ff90b511c3e"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename O, typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00197.html#g00800444c5ce2c60601bfc16760be567">Dune::Amg::MatrixHierarchy::build</a> (const T &amp;criterion)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build the matrix hierarchy using aggregation.  <a href="#g00800444c5ce2c60601bfc16760be567"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const ParallelMatrixHierarchy &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g2b805985392a6ea5eeba3bd900d2d2f1">Dune::Amg::MatrixHierarchy::matrices</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the matrix hierarchy.  <a href="#g2b805985392a6ea5eeba3bd900d2d2f1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const <br>
ParallelInformationHierarchy &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gcaf43b169afef93fa7ea3b431f3a60b8">Dune::Amg::MatrixHierarchy::parallelInformation</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the hierarchy of the parallel data distribution information.  <a href="#gcaf43b169afef93fa7ea3b431f3a60b8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const AggregatesMapList &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g345f0d955c32699df6cca95c5ed28584">Dune::Amg::MatrixHierarchy::aggregatesMaps</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the hierarchy of the mappings of the nodes onto aggregates.  <a href="#g345f0d955c32699df6cca95c5ed28584"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class V, class TA&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00197.html#g5631ad094d4257bb7bec099a515a64c3">Dune::Amg::MatrixHierarchy::coarsenVector</a> (Hierarchy&lt; BlockVector&lt; V, TA &gt; &gt; &amp;hierarchy) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Coarsen the vector hierarchy according to the matrix hierarchy.  <a href="#g5631ad094d4257bb7bec099a515a64c3"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class S, class TA&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00197.html#g9362b04104f5a5e426c480198cbd3aa5">Dune::Amg::MatrixHierarchy::coarsenSmoother</a> (Hierarchy&lt; S, TA &gt; &amp;smoothers, const typename SmootherTraits&lt; S &gt;::Arguments &amp;args) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Coarsen the smoother hierarchy according to the matrix hierarchy.  <a href="#g9362b04104f5a5e426c480198cbd3aa5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class F&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00197.html#g6e1b4740e614de707f5200a1fd4ed3b8">Dune::Amg::MatrixHierarchy::recalculateGalerkin</a> (const F &amp;copyFlags)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Recalculate the galerkin products.  <a href="#g6e1b4740e614de707f5200a1fd4ed3b8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g78d7b7cf130c059d81e250c21eb02fcf">Dune::Amg::MatrixHierarchy::levels</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of levels in the hierarchy.  <a href="#g78d7b7cf130c059d81e250c21eb02fcf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g869a9a18ba099c27906839e66956f538">Dune::Amg::MatrixHierarchy::isBuilt</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Whether the hierarchy wis built.  <a href="#g869a9a18ba099c27906839e66956f538"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gc1ac61848513d182a9111ae4d4ca2593"></a><!-- doxytag: member="ISTL_PAAMG::Hierarchy" ref="gc1ac61848513d182a9111ae4d4ca2593" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gc1ac61848513d182a9111ae4d4ca2593">Dune::Amg::Hierarchy::Hierarchy</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a new empty hierarchy. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gb12ba0f94504959761dc9ba347b0d78f">Dune::Amg::Hierarchy::Hierarchy</a> (MemberType &amp;first)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a new hierarchy.  <a href="#gb12ba0f94504959761dc9ba347b0d78f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gcc7de66ad068bf8e38e5581a7a7cf914"></a><!-- doxytag: member="ISTL_PAAMG::~Hierarchy" ref="gcc7de66ad068bf8e38e5581a7a7cf914" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gcc7de66ad068bf8e38e5581a7a7cf914">Dune::Amg::Hierarchy::~Hierarchy</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g8fbdc44be934a27c6fc0d1178e9bb17f">Dune::Amg::Hierarchy::levels</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of levels in the hierarchy.  <a href="#g8fbdc44be934a27c6fc0d1178e9bb17f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g49ca742763a3bd74b299a52cf9c1c1ac">Dune::Amg::Hierarchy::addCoarser</a> (Arguments &amp;args)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an element on a coarser level.  <a href="#g49ca742763a3bd74b299a52cf9c1c1ac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g5e61b589324ce4af08433a96892b067e">Dune::Amg::Hierarchy::addFiner</a> (Arguments &amp;args)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add an element on a finer level.  <a href="#g5e61b589324ce4af08433a96892b067e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gdfe51fd5682dd55cbc4b15fd4ac890d2">Dune::Amg::Hierarchy::finest</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator positioned at the finest level.  <a href="#gdfe51fd5682dd55cbc4b15fd4ac890d2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gaacf35c23a00d0e9aa93309ff7cfab16">Dune::Amg::Hierarchy::coarsest</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator positioned at the coarsest level.  <a href="#gaacf35c23a00d0e9aa93309ff7cfab16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ConstIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g1202feb79e186b2abf48fe2233883b5d">Dune::Amg::Hierarchy::finest</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator positioned at the finest level.  <a href="#g1202feb79e186b2abf48fe2233883b5d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ConstIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gdef24b6ebe79f2119513819ba8d3cee3">Dune::Amg::Hierarchy::coarsest</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator positioned at the coarsest level.  <a href="#gdef24b6ebe79f2119513819ba8d3cee3"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g9431f7b35947083f3d2a270a4b3b8bb5"></a><!-- doxytag: member="ISTL_PAAMG::ISOLATED" ref="g9431f7b35947083f3d2a270a4b3b8bb5" args="" -->
static const V&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g9431f7b35947083f3d2a270a4b3b8bb5">Dune::Amg::AggregatesMap::ISOLATED</a> = std::numeric_limits&lt;V&gt;::max()-1</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Identifier of isolated vertices. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g679889d8142edb4598974c0637e7c9d3"></a><!-- doxytag: member="ISTL_PAAMG::aggregate" ref="g679889d8142edb4598974c0637e7c9d3" args="" -->
Aggregate&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#g679889d8142edb4598974c0637e7c9d3">Dune::Amg::OverlapVertex::aggregate</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The aggregate the vertex belongs to. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gb7b0edf4b5958d9f290114d9ea5e766a"></a><!-- doxytag: member="ISTL_PAAMG::vertex" ref="gb7b0edf4b5958d9f290114d9ea5e766a" args="" -->
Vertex&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gb7b0edf4b5958d9f290114d9ea5e766a">Dune::Amg::OverlapVertex::vertex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The vertex descriptor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gf86eaea0d7dc0f7841c91ee60cadc3f8"></a><!-- doxytag: member="ISTL_PAAMG::iterations" ref="gf86eaea0d7dc0f7841c91ee60cadc3f8" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gf86eaea0d7dc0f7841c91ee60cadc3f8">Dune::Amg::DefaultSmootherArgs::iterations</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The numbe of iterations to perform. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gd1b07aaab2acba6665e54db06cec5e4c"></a><!-- doxytag: member="ISTL_PAAMG::relaxationFactor" ref="gd1b07aaab2acba6665e54db06cec5e4c" args="" -->
RelaxationFactor&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gd1b07aaab2acba6665e54db06cec5e4c">Dune::Amg::DefaultSmootherArgs::relaxationFactor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The relaxation factor to use. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gd35c6c9e3aa1ec18c07a97279f8d3f77"></a><!-- doxytag: member="ISTL_PAAMG::UNAGGREGATED" ref="gd35c6c9e3aa1ec18c07a97279f8d3f77" args="" -->
static const V&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html#gd35c6c9e3aa1ec18c07a97279f8d3f77">Dune::Amg::AggregatesMap::UNAGGREGATED</a> = std::numeric_limits&lt;V&gt;::max()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Identifier of not yet aggregated vertices. <br></td></tr>
</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="g60efd923eab7d4f2e8e66755c1d86843"></a><!-- doxytag: member="Dune::Amg::AMG::Smoother" ref="g60efd923eab7d4f2e8e66755c1d86843" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M, class X, class S, class PI = SequentialInformation, class A = std::allocator&lt;X&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef S <a class="el" href="a00007.html">Dune::Amg::AMG</a>&lt; M, X, S, PI, A &gt;::Smoother<code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The type of the smoother. 
<p>
One of the preconditioners implementing the <a class="el" href="a00092.html" title="Base class for matrix free definition of preconditioners.">Preconditioner</a> interface. Not that the smoother has to fit the ParallelInformation. 
</div>
</div><p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="g0acb3ac55a6f48bbb17b746b297c9463"></a><!-- doxytag: member="Dune::Amg::AMG::@17" ref="g0acb3ac55a6f48bbb17b746b297c9463" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M, class X, class S, class PI = SequentialInformation, class A = std::allocator&lt;X&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum<code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gg0acb3ac55a6f48bbb17b746b297c94639cd515782eb7ec9b0e9b136d0c3579e7"></a><!-- doxytag: member="category" ref="gg0acb3ac55a6f48bbb17b746b297c94639cd515782eb7ec9b0e9b136d0c3579e7" args="" -->category</em>&nbsp;</td><td>
The solver category. </td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="g2f08e1c8a9d3187abb6d9f4f77f9b784"></a><!-- doxytag: member="Dune::Amg::PropertyGraphVertexPropertyMap::@20" ref="g2f08e1c8a9d3187abb6d9f4f77f9b784" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G, std::size_t i&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum<code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gg2f08e1c8a9d3187abb6d9f4f77f9b7843969c5d2ea66a930eea263cec0d7e08b"></a><!-- doxytag: member="index" ref="gg2f08e1c8a9d3187abb6d9f4f77f9b7843969c5d2ea66a930eea263cec0d7e08b" args="" -->index</em>&nbsp;</td><td>
the index to access in the bitset. </td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="gb41e701698a8b08f9f618b23129950a8"></a><!-- doxytag: member="Dune::Amg::RandomAccessBundledPropertyMap::@27" ref="gb41e701698a8b08f9f618b23129950a8" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C, typename K, std::size_t i, typename T = typename C::ValueType, typename R = typename C::Reference&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum<code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="ggb41e701698a8b08f9f618b23129950a8bac431862aa7f43e45b797931ffc9bbf"></a><!-- doxytag: member="index" ref="ggb41e701698a8b08f9f618b23129950a8bac431862aa7f43e45b797931ffc9bbf" args="" -->index</em>&nbsp;</td><td>
The index of the property in the bundle. </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g49ca742763a3bd74b299a52cf9c1c1ac"></a><!-- doxytag: member="Dune::Amg::Hierarchy::addCoarser" ref="g49ca742763a3bd74b299a52cf9c1c1ac" args="(Arguments &amp;args)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00054.html">Dune::Amg::Hierarchy</a>&lt; T, A &gt;::addCoarser           </td>
          <td>(</td>
          <td class="paramtype">Arguments &amp;&nbsp;</td>
          <td class="paramname"> <em>args</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add an element on a coarser level. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>args</em>&nbsp;</td><td>The arguments needed for the construction. </td></tr>
  </table>
</dl>

<p>Referenced by <a class="el" href="a00221.html#l00557">Dune::Amg::MatrixHierarchy&lt; M, PI, A &gt;::build()</a>, and <a class="el" href="a00221.html#l00821">Dune::Amg::MatrixHierarchy&lt; M, PI, A &gt;::coarsenSmoother()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g5e61b589324ce4af08433a96892b067e"></a><!-- doxytag: member="Dune::Amg::Hierarchy::addFiner" ref="g5e61b589324ce4af08433a96892b067e" args="(Arguments &amp;args)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00054.html">Dune::Amg::Hierarchy</a>&lt; T, A &gt;::addFiner           </td>
          <td>(</td>
          <td class="paramtype">Arguments &amp;&nbsp;</td>
          <td class="paramname"> <em>args</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add an element on a finer level. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>args</em>&nbsp;</td><td>The arguments needed for the construction. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gcfd89e6e64868331e0cc94523db3f9cd"></a><!-- doxytag: member="Dune::Amg::Aggregate::Aggregate" ref="gcfd89e6e64868331e0cc94523db3f9cd" args="(const MatrixGraph &amp;graph, AggregatesMap&lt; Vertex &gt; &amp;aggregates, VertexSet &amp;connectivity)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00002.html">Dune::Amg::Aggregate</a>&lt; G &gt;::Aggregate           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00073.html">MatrixGraph</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00003.html">AggregatesMap</a>&lt; <a class="el" href="a00197.html#gabd0e12ceada9a070a742ea7652852d0">Vertex</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>aggregates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00197.html#g9c57586769fb10c7acf56903b5a6403c">VertexSet</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connectivity</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>graph</em>&nbsp;</td><td>The matrix graph we work on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aggregates</em>&nbsp;</td><td>The mapping of vertices onto aggregates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>connectivity</em>&nbsp;</td><td>The set of vertices connected to the aggregate. distance spheres. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ga57de3c523ca120b4deec855f5e4c124"></a><!-- doxytag: member="Dune::Amg::AggregatesMap::AggregatesMap" ref="ga57de3c523ca120b4deec855f5e4c124" args="(std::size_t noVertices)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00003.html">Dune::Amg::AggregatesMap</a>&lt; V &gt;::AggregatesMap           </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>noVertices</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructs with allocating memory. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>noVertices</em>&nbsp;</td><td>The number of vertices we will hold information for. </td></tr>
  </table>
</dl>

<p>References <a class="el" href="a00203.html#l01376">Dune::Amg::AggregatesMap&lt; V &gt;::allocate()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g345f0d955c32699df6cca95c5ed28584"></a><!-- doxytag: member="Dune::Amg::MatrixHierarchy::aggregatesMaps" ref="g345f0d955c32699df6cca95c5ed28584" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M, class IS, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const MatrixHierarchy&lt; M, IS, A &gt;::AggregatesMapList &amp; <a class="el" href="a00076.html">Dune::Amg::MatrixHierarchy</a>&lt; M, IS, A &gt;::aggregatesMaps           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the hierarchy of the mappings of the nodes onto aggregates. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The hierarchy of the mappings of the nodes onto aggregates. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g510b6c998062391f238820837f7dfe1d"></a><!-- doxytag: member="Dune::Amg::Aggregator::AggregateVisitor::AggregateVisitor" ref="g510b6c998062391f238820837f7dfe1d" args="(const AggregatesMap&lt; Vertex &gt; &amp;aggregates, const AggregateDescriptor &amp;aggregate, Visitor &amp;visitor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G&gt; </div>
<div class="memtemplate">
template&lt;class V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00006.html">Dune::Amg::Aggregator</a>&lt; G &gt;::AggregateVisitor&lt; V &gt;::AggregateVisitor           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00003.html">AggregatesMap</a>&lt; <a class="el" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678">Vertex</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>aggregates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00197.html#g753ac555d3d946b7cf76e5ab9b5824c2">AggregateDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aggregate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Visitor &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aggregates</em>&nbsp;</td><td>The aggregate numbers of the vertices. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aggregate</em>&nbsp;</td><td>The id of the aggregate to visit. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>visitor</em>&nbsp;</td><td>The visitor. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gdf10f6b77f88384bcbcd59cfe29a2002"></a><!-- doxytag: member="Dune::Amg::AggregatesMap::allocate" ref="gdf10f6b77f88384bcbcd59cfe29a2002" args="(std::size_t noVertices)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00003.html">Dune::Amg::AggregatesMap</a>&lt; V &gt;::allocate           </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>noVertices</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allocate memory for holding the information. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>noVertices</em>&nbsp;</td><td>The total number of vertices to be mapped. </td></tr>
  </table>
</dl>

<p>References <a class="el" href="a00203.html#l00394">Dune::Amg::AggregatesMap&lt; V &gt;::UNAGGREGATED</a>.</p>

<p>Referenced by <a class="el" href="a00203.html#l01364">Dune::Amg::AggregatesMap&lt; V &gt;::AggregatesMap()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gcc6aaf87acbde8b55178cc09cfa39d97"></a><!-- doxytag: member="Dune::Amg::AMG::AMG" ref="gcc6aaf87acbde8b55178cc09cfa39d97" args="(const Operator &amp;fineOperator, const C &amp;criterion, const SmootherArgs &amp;smootherArgs, std::size_t gamma=1, std::size_t preSmoothingSteps=2, std::size_t postSmoothingSteps=2, bool additive=false, const ParallelInformation &amp;pinfo=ParallelInformation())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M, class X, class S, class PI = SequentialInformation, class A = std::allocator&lt;X&gt;&gt; </div>
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00007.html">Dune::Amg::AMG</a>&lt; M, X, S, PI, A &gt;::AMG           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00007.html#66dc78b3214f4ebfc19c8ba3d467d25b">Operator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fineOperator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const C &amp;&nbsp;</td>
          <td class="paramname"> <em>criterion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00045.html">SmootherArgs</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>smootherArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>gamma</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>preSmoothingSteps</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>postSmoothingSteps</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>additive</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00197.html#gfc3d32c625bd4cabd2481107019b2fb2">ParallelInformation</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pinfo</em> = <code><a class="el" href="a00197.html#gfc3d32c625bd4cabd2481107019b2fb2">ParallelInformation</a>()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct an <a class="el" href="a00007.html" title="Parallel algebraic multigrid based on agglomeration.">AMG</a> with an inexact coarse solver based on the smoother. 
<p>
As coarse solver a preconditioned CG method with the smoother as preconditioner will be used. The matrix hierarchy is built automatically. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fineOperator</em>&nbsp;</td><td>The operator on the fine level. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>criterion</em>&nbsp;</td><td>The criterion describing the coarsening strategy. E. g. <a class="el" href="a00123.html" title="Criterion taking advantage of symmetric matrices.">SymmetricCriterion</a> or UnsymmetricCriterion. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>smootherArgs</em>&nbsp;</td><td>The arguments for constructing the smoothers. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gamma</em>&nbsp;</td><td>1 for V-cycle, 2 for W-cycle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>preSmoothingSteps</em>&nbsp;</td><td>The number of smoothing steps for premoothing. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>postSmoothingSteps</em>&nbsp;</td><td>The number of smoothing steps for postmoothing. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pinfo</em>&nbsp;</td><td>The information about the parallel distribution of the data. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g36c2f89d85ed2073e2dc21499de840b9"></a><!-- doxytag: member="Dune::Amg::AMG::AMG" ref="g36c2f89d85ed2073e2dc21499de840b9" args="(const OperatorHierarchy &amp;matrices, CoarseSolver &amp;coarseSolver, const SmootherArgs &amp;smootherArgs, std::size_t gamma, std::size_t preSmoothingSteps, std::size_t postSmoothingSteps, bool additive=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M, class X, class S, class P, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00007.html">Dune::Amg::AMG</a>&lt; M, X, S, P, A &gt;::AMG           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00076.html">OperatorHierarchy</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>matrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00064.html">CoarseSolver</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>coarseSolver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00045.html">SmootherArgs</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>smootherArgs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>gamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>preSmoothingSteps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>postSmoothingSteps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>additive</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a new amg with a specific coarse solver. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>matrices</em>&nbsp;</td><td>The already set up matix hierarchy. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coarseSolver</em>&nbsp;</td><td>The set up solver to use on the coarse grid, must natch the soarse matrix in the matrix hierachy. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>smootherArgs</em>&nbsp;</td><td>The arguments needed for thesmoother to use for pre and post smoothing </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gamma</em>&nbsp;</td><td>The number of subcycles. 1 for V-cycle, 2 for W-cycle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>preSmoothingSteps</em>&nbsp;</td><td>The number of smoothing steps for premoothing. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>postSmoothingSteps</em>&nbsp;</td><td>The number of smoothing steps for postmoothing. </td></tr>
  </table>
</dl>

<p>References <a class="el" href="a00221.html#l00821">Dune::Amg::MatrixHierarchy&lt; M, PI, A &gt;::coarsenSmoother()</a>, and <a class="el" href="a00221.html#l00869">Dune::Amg::MatrixHierarchy&lt; M, PI, A &gt;::isBuilt()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g4e5279dbf6edca8a6bc25efd8d82d26d"></a><!-- doxytag: member="Dune::Amg::AMG::apply" ref="g4e5279dbf6edca8a6bc25efd8d82d26d" args="(Domain &amp;v, const Range &amp;d)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M, class X, class S, class P, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00007.html">Dune::Amg::AMG</a>&lt; M, X, S, P, A &gt;::apply           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00197.html#g2baddcf013a5166a162950672bd21a03">Domain</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00197.html#g7c0496b0f7de49193c227a8c93c045d1">Range</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>d</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Apply one step of the preconditioner to the system A(v)=d. <p>
On entry v=0 and d=b-A(x) (although this might not be computed in that way. On exit v contains the update, i.e one step computes <img class="formulaInl" alt="$ v = M^{-1} d $" src="form_42.png"> where <img class="formulaInl" alt="$ M $" src="form_43.png"> is the approximate inverse of the operator <img class="formulaInl" alt="$ A $" src="form_44.png"> characterizing the preconditioner. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>The update to be computed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>d</em>&nbsp;</td><td>The current defect. </td></tr>
  </table>
</dl>
 
<p>Implements <a class="el" href="a00092.html#05b45208eec670e82b65bbc8e2601af0">Dune::Preconditioner&lt; X, X &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="gcc3bab4bf9de5dde0e8b6a8c6c96beb8"></a><!-- doxytag: member="Dune::Amg::PropertiesGraph::begin" ref="gcc3bab4bf9de5dde0e8b6a8c6c96beb8" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class E, class VM, class EM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PropertiesGraph&lt; G, V, E, VM, EM &gt;::ConstVertexIterator <a class="el" href="a00093.html">Dune::Amg::PropertiesGraph</a>&lt; G, V, E, VM, EM &gt;::begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator over the vertices. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A vertex Iterator positioned at the first vertex. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g41eac8244ce6592511880708eb23461a"></a><!-- doxytag: member="Dune::Amg::PropertiesGraph::begin" ref="g41eac8244ce6592511880708eb23461a" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class E, class VM, class EM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PropertiesGraph&lt; G, V, E, VM, EM &gt;::VertexIterator <a class="el" href="a00093.html">Dune::Amg::PropertiesGraph</a>&lt; G, V, E, VM, EM &gt;::begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator over the vertices. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A vertex Iterator positioned at the first vertex. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g9d353e51e14a6c935ad38530d827be7f"></a><!-- doxytag: member="Dune::Amg::PropertiesGraph::VertexIteratorT::begin" ref="g9d353e51e14a6c935ad38530d827be7f" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class E, class VM, class EM&gt; </div>
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PropertiesGraph&lt; G, V, E, VM, EM &gt;::EdgeIteratorT&lt; C &gt; <a class="el" href="a00093.html">Dune::Amg::PropertiesGraph</a>&lt; G, V, E, VM, EM &gt;::VertexIteratorT&lt; C &gt;::begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator over the edges starting from the current vertex. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An iterator over the edges starting from the current vertex positioned at the first edge. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g82b4b7da287d74d6fd9d4ab4e0b123f9"></a><!-- doxytag: member="Dune::Amg::VertexPropertiesGraph::begin" ref="g82b4b7da287d74d6fd9d4ab4e0b123f9" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class VM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VertexPropertiesGraph&lt; G, V, VM &gt;::ConstVertexIterator <a class="el" href="a00132.html">Dune::Amg::VertexPropertiesGraph</a>&lt; G, V, VM &gt;::begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator over the vertices. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A vertex Iterator positioned at the first vertex. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gdcf9375836d35763339d51ccd9e0ec5e"></a><!-- doxytag: member="Dune::Amg::VertexPropertiesGraph::begin" ref="gdcf9375836d35763339d51ccd9e0ec5e" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class VM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VertexPropertiesGraph&lt; G, V, VM &gt;::VertexIterator <a class="el" href="a00132.html">Dune::Amg::VertexPropertiesGraph</a>&lt; G, V, VM &gt;::begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator over the vertices. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A vertex Iterator positioned at the first vertex. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g812af7c3228dc7340f24616807a02d48"></a><!-- doxytag: member="Dune::Amg::VertexPropertiesGraph::VertexIteratorT::begin" ref="g812af7c3228dc7340f24616807a02d48" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class VM&gt; </div>
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SelectType&lt; is_same&lt; typename remove_const&lt; C &gt;::type, C &gt;::value, typename G::EdgeIterator, typename G::ConstEdgeIterator &gt;::Type <a class="el" href="a00132.html">Dune::Amg::VertexPropertiesGraph</a>&lt; G, V, VM &gt;::VertexIteratorT&lt; C &gt;::begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator over the edges starting from the current vertex. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An iterator over the edges starting from the current vertex positioned at the first edge. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ga21e2f7d62f68422b0128569d15bacca"></a><!-- doxytag: member="Dune::Amg::SubGraph::begin" ref="ga21e2f7d62f68422b0128569d15bacca" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SubGraph&lt; G, T &gt;::VertexIterator <a class="el" href="a00116.html">Dune::Amg::SubGraph</a>&lt; G, T &gt;::begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator over the vertices. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A vertex Iterator positioned at the first vertex. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g6f77951ee34f917adfb154af2323212e"></a><!-- doxytag: member="Dune::Amg::SubGraph::VertexIterator::begin" ref="g6f77951ee34f917adfb154af2323212e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SubGraph&lt; G, T &gt;::EdgeIterator <a class="el" href="a00116.html">Dune::Amg::SubGraph</a>&lt; G, T &gt;::VertexIterator::begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator over all edges starting at the current vertex. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Iterator position on the first edge to another vertex. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ge583c37e6b121185876cac765627fb17"></a><!-- doxytag: member="Dune::Amg::MatrixGraph::begin" ref="ge583c37e6b121185876cac765627fb17" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MatrixGraph&lt; M &gt;::VertexIteratorT&lt; const MatrixGraph&lt; M &gt; &gt; <a class="el" href="a00073.html">Dune::Amg::MatrixGraph</a>&lt; M &gt;::begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator over the vertices. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A vertex Iterator positioned at the first vertex. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g596a7e2bca0d6ce04fea64cd240effd6"></a><!-- doxytag: member="Dune::Amg::MatrixGraph::begin" ref="g596a7e2bca0d6ce04fea64cd240effd6" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MatrixGraph&lt; M &gt;::VertexIteratorT&lt; MatrixGraph&lt; M &gt; &gt; <a class="el" href="a00073.html">Dune::Amg::MatrixGraph</a>&lt; M &gt;::begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator over the vertices. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A vertex Iterator positioned at the first vertex. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g21aeab3a90103abdc4932bcb91a87737"></a><!-- doxytag: member="Dune::Amg::MatrixGraph::VertexIteratorT::begin" ref="g21aeab3a90103abdc4932bcb91a87737" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M&gt; </div>
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MatrixGraph&lt; M &gt;::EdgeIteratorT&lt; C &gt; <a class="el" href="a00073.html">Dune::Amg::MatrixGraph</a>&lt; M &gt;::VertexIteratorT&lt; C &gt;::begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator over all edges starting at the current vertex. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Iterator position on the first edge to another vertex. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gaf1e711a05efbc7b2c514f62c9b506d7"></a><!-- doxytag: member="Dune::Amg::PropertiesGraph::beginEdges" ref="gaf1e711a05efbc7b2c514f62c9b506d7" args="(const VertexDescriptor &amp;source) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class E, class VM, class EM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PropertiesGraph&lt; G, V, E, VM, EM &gt;::ConstEdgeIterator <a class="el" href="a00093.html">Dune::Amg::PropertiesGraph</a>&lt; G, V, E, VM, EM &gt;::beginEdges           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00093.html#cc1d8f22266e986a90c7ff0a380517d8">VertexDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the mutable edge iterator over edges starting at a vertex. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An edge iterator over edges starting at a vertex positioned at the first edge. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g6fe34b91b5be9814bc2e05c791a4996e"></a><!-- doxytag: member="Dune::Amg::PropertiesGraph::beginEdges" ref="g6fe34b91b5be9814bc2e05c791a4996e" args="(const VertexDescriptor &amp;source)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class E, class VM, class EM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PropertiesGraph&lt; G, V, E, VM, EM &gt;::EdgeIterator <a class="el" href="a00093.html">Dune::Amg::PropertiesGraph</a>&lt; G, V, E, VM, EM &gt;::beginEdges           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00093.html#cc1d8f22266e986a90c7ff0a380517d8">VertexDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the mutable edge iterator over edges starting at a vertex. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An edge iterator over edges starting at a vertex positioned at the first edge. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gc0a375c8eb84a65e47d181d3b7eed9d4"></a><!-- doxytag: member="Dune::Amg::VertexPropertiesGraph::beginEdges" ref="gc0a375c8eb84a65e47d181d3b7eed9d4" args="(const VertexDescriptor &amp;source) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class VM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VertexPropertiesGraph&lt; G, V, VM &gt;::ConstEdgeIterator <a class="el" href="a00132.html">Dune::Amg::VertexPropertiesGraph</a>&lt; G, V, VM &gt;::beginEdges           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00132.html#79f61a7abf2ffba549f7ca3573c294b5">VertexDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the mutable edge iterator over edges starting at a vertex. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An edge iterator over edges starting at a vertex positioned at the first edge. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g654e11e5bb3eecbfb89e335bd84fff0a"></a><!-- doxytag: member="Dune::Amg::VertexPropertiesGraph::beginEdges" ref="g654e11e5bb3eecbfb89e335bd84fff0a" args="(const VertexDescriptor &amp;source)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class VM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VertexPropertiesGraph&lt; G, V, VM &gt;::EdgeIterator <a class="el" href="a00132.html">Dune::Amg::VertexPropertiesGraph</a>&lt; G, V, VM &gt;::beginEdges           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00132.html#79f61a7abf2ffba549f7ca3573c294b5">VertexDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the mutable edge iterator over edges starting at a vertex. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An edge iterator over edges starting at a vertex positioned at the first edge. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g4c181177861f5e5e80f5d0e9a56338b6"></a><!-- doxytag: member="Dune::Amg::SubGraph::beginEdges" ref="g4c181177861f5e5e80f5d0e9a56338b6" args="(const VertexDescriptor &amp;source) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SubGraph&lt; G, T &gt;::EdgeIterator <a class="el" href="a00116.html">Dune::Amg::SubGraph</a>&lt; G, T &gt;::beginEdges           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00116.html#e935b74e150a8a496b56457eb5372c40">VertexDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator over the edges starting at a vertex. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The vertex where the edges should start. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An edge iterator positioned at the first edge starting from vertex source. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g5f9de1ec5faed113519adf8c9e5daa1b"></a><!-- doxytag: member="Dune::Amg::MatrixGraph::beginEdges" ref="g5f9de1ec5faed113519adf8c9e5daa1b" args="(const VertexDescriptor &amp;source) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MatrixGraph&lt; M &gt;::EdgeIteratorT&lt; const MatrixGraph&lt; M &gt; &gt; <a class="el" href="a00073.html">Dune::Amg::MatrixGraph</a>&lt; M &gt;::beginEdges           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00073.html#594cca89416b534b0b1a196c39684447">VertexDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator over the edges starting at a vertex. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The vertex where the edges should start. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An edge iterator positioned at the first edge starting from vertex source. </dd></dl>

<p>References <a class="el" href="a00231.html#l00083">Dune::Matrix&lt; T, A &gt;::begin()</a>, and <a class="el" href="a00218.html#l01714">Dune::Amg::MatrixGraph&lt; M &gt;::end()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g998ea57efbb86e1bdb4c0c5db7b33bb4"></a><!-- doxytag: member="Dune::Amg::MatrixGraph::beginEdges" ref="g998ea57efbb86e1bdb4c0c5db7b33bb4" args="(const VertexDescriptor &amp;source)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MatrixGraph&lt; M &gt;::EdgeIteratorT&lt; MatrixGraph&lt; M &gt; &gt; <a class="el" href="a00073.html">Dune::Amg::MatrixGraph</a>&lt; M &gt;::beginEdges           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00073.html#594cca89416b534b0b1a196c39684447">VertexDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator over the edges starting at a vertex. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The vertex where the edges should start. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An edge iterator positioned at the first edge starting from vertex source. </dd></dl>

<p>References <a class="el" href="a00231.html#l00083">Dune::Matrix&lt; T, A &gt;::begin()</a>, and <a class="el" href="a00218.html#l01714">Dune::Amg::MatrixGraph&lt; M &gt;::end()</a>.</p>

<p>Referenced by <a class="el" href="a00203.html#l01297">Dune::Amg::Aggregate&lt; G &gt;::add()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gdc9d81c0f753b41fc3e66498bce9ab00"></a><!-- doxytag: member="Dune::Amg::DependencyParameters::beta" ref="gdc9d81c0f753b41fc3e66498bce9ab00" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Dune::Amg::DependencyParameters::beta           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the threshold for marking nodes as isolated. The default value is 1.0E-5. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>beta </dd></dl>

</div>
</div><p>
<a class="anchor" name="ga827f5ef3d5034851ba6abddc8d373aa"></a><!-- doxytag: member="Dune::Amg::AggregatesMap::breadthFirstSearch" ref="ga827f5ef3d5034851ba6abddc8d373aa" args="(const VertexDescriptor &amp;start, const AggregateDescriptor &amp;aggregate, G &amp;graph, L &amp;visited, F1 &amp;aggregateVisitor, F2 &amp;nonAggregateVisitor, VM &amp;visitedMap) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V&gt; </div>
<div class="memtemplate">
template&lt;bool remove, bool reset, class G, class L, class F1, class F2, class VM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="a00003.html">Dune::Amg::AggregatesMap</a>&lt; V &gt;::breadthFirstSearch           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00197.html#gf657e8e9f35ddf9811f6ab7ea72ab9f5">VertexDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00197.html#g9258a3f0e9738c7c77d348cbb28b4b8d">AggregateDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aggregate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">G &amp;&nbsp;</td>
          <td class="paramname"> <em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">L &amp;&nbsp;</td>
          <td class="paramname"> <em>visited</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F1 &amp;&nbsp;</td>
          <td class="paramname"> <em>aggregateVisitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F2 &amp;&nbsp;</td>
          <td class="paramname"> <em>nonAggregateVisitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VM &amp;&nbsp;</td>
          <td class="paramname"> <em>visitedMap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Breadth first search within an aggregate. 
<p>
The template parameters: <br>
 <dl>
<dt>L</dt>
<dd>A container type providing push_back(Vertex), and pop_front() in case remove is true </dd>
<dt>remove</dt>
<dd>If true the entries in the visited list will be removed. </dd>
<dt>reset</dt>
<dd>If true the visited flag will be reset after the search</dd>
</dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>The vertex where the search should start from. This does not need to belong to the aggregate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aggregate</em>&nbsp;</td><td>The aggregate id. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>graph</em>&nbsp;</td><td>The matrix graph to perform the search on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>visited</em>&nbsp;</td><td>A list to store the visited vertices in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aggregateVisitor</em>&nbsp;</td><td>A functor that is called with each G::ConstEdgeIterator with an edge pointing to the aggregate. Use DummyVisitor these are of no interest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nonAggregateVisitor</em>&nbsp;</td><td>A functor that is called with each G::ConstEdgeIterator with an edge pointing to another aggregate. Use DummyVisitor these are of no interest. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>visitedMap</em>&nbsp;</td><td>A map to mark the already visited vertices </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g271b83cdc0415c6352b36881deac4515"></a><!-- doxytag: member="Dune::Amg::AggregatesMap::breadthFirstSearch" ref="g271b83cdc0415c6352b36881deac4515" args="(const VertexDescriptor &amp;start, const AggregateDescriptor &amp;aggregate, G &amp;graph, F &amp;aggregateVisitor, VM &amp;visitedMap) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V&gt; </div>
<div class="memtemplate">
template&lt;bool reset, class G, class F, class VM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="a00003.html">Dune::Amg::AggregatesMap</a>&lt; V &gt;::breadthFirstSearch           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00197.html#gf657e8e9f35ddf9811f6ab7ea72ab9f5">VertexDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00197.html#g9258a3f0e9738c7c77d348cbb28b4b8d">AggregateDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aggregate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">G &amp;&nbsp;</td>
          <td class="paramname"> <em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&nbsp;</td>
          <td class="paramname"> <em>aggregateVisitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VM &amp;&nbsp;</td>
          <td class="paramname"> <em>visitedMap</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Breadth first search within an aggregate. 
<p>
The template parameters: <br>
 <dl>
<dt>reset</dt>
<dd>If true the visited flags of the vertices will be reset after the search </dd>
<dt>G</dt>
<dd>The type of the graph we perform the search on. </dd>
<dt>F</dt>
<dd>The type of the visitor to operate on the vertices </dd>
</dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start</em>&nbsp;</td><td>The vertex where the search should start from. This does not need to belong to the aggregate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aggregate</em>&nbsp;</td><td>The aggregate id. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>graph</em>&nbsp;</td><td>The matrix graph to perform the search on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>visitedMap</em>&nbsp;</td><td>A map to mark the already visited vertices </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aggregateVisitor</em>&nbsp;</td><td>A functor that is called with each G::ConstEdgeIterator with an edge pointing to the aggregate. Use DummyVisitor if these are of no interest. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g00800444c5ce2c60601bfc16760be567"></a><!-- doxytag: member="Dune::Amg::MatrixHierarchy::build" ref="g00800444c5ce2c60601bfc16760be567" args="(const T &amp;criterion)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M, class IS, class A&gt; </div>
<div class="memtemplate">
template&lt;typename O, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00076.html">Dune::Amg::MatrixHierarchy</a>&lt; M, IS, A &gt;::build           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>criterion</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Build the matrix hierarchy using aggregation. 
<p>
criterion The criterion describing the aggregation process. 
<p>References <a class="el" href="a00221.html#l00913">Dune::Amg::Hierarchy&lt; T, A &gt;::addCoarser()</a>, <a class="el" href="a00203.html#l01912">Dune::Amg::AggregatesMap&lt; V &gt;::buildAggregates()</a>, and <a class="el" href="a00221.html#l00953">Dune::Amg::Hierarchy&lt; T, A &gt;::finest()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gc3b623e54f0e32e19ddf8d80014615ed"></a><!-- doxytag: member="Dune::Amg::GalerkinProduct&lt; SequentialInformation &gt;::build" ref="gc3b623e54f0e32e19ddf8d80014615ed" args="(const M &amp;fine, G &amp;fineGraph, V &amp;visitedMap, const SequentialInformation &amp;pinfo, const AggregatesMap&lt; typename G::VertexDescriptor &gt; &amp;aggregates, const typename M::size_type &amp;size, const Set &amp;copy)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M, class G, class V, class Set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">M * Dune::Amg::GalerkinProduct&lt; SequentialInformation &gt;::build           </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&nbsp;</td>
          <td class="paramname"> <em>fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">G &amp;&nbsp;</td>
          <td class="paramname"> <em>fineGraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&nbsp;</td>
          <td class="paramname"> <em>visitedMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SequentialInformation &amp;&nbsp;</td>
          <td class="paramname"> <em>pinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00003.html">AggregatesMap</a>&lt; typename G::VertexDescriptor &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>aggregates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename M::size_type &amp;&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Set &amp;&nbsp;</td>
          <td class="paramname"> <em>copy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculates the coarse matrix via a Galerkin product. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fine</em>&nbsp;</td><td>The matrix on the fine level. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fineGraph</em>&nbsp;</td><td>The graph of the fine matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>visitedMap</em>&nbsp;</td><td>Map for marking vertices as visited. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pinfo</em>&nbsp;</td><td>Parallel information about the fine level. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aggregates</em>&nbsp;</td><td>The mapping of the fine level unknowns onto aggregates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The number of columns and rows of the coarse matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>copy</em>&nbsp;</td><td>The attribute set identifying the copy nodes of the graph. </td></tr>
  </table>
</dl>

<p>References <a class="el" href="a00216.html#l00524">Dune::Amg::SparsityBuilder&lt; M, V &gt;::maxRowSize()</a>, <a class="el" href="a00216.html#l00529">Dune::Amg::SparsityBuilder&lt; M, V &gt;::minRowSize()</a>, and <a class="el" href="a00216.html#l00535">Dune::Amg::SparsityBuilder&lt; M, V &gt;::sumRowSize()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g919f770c8a3dfb9f2e720c13052e49eb"></a><!-- doxytag: member="Dune::Amg::GalerkinProduct::build" ref="g919f770c8a3dfb9f2e720c13052e49eb" args="(const M &amp;fine, G &amp;fineGraph, V &amp;visitedMap, const ParallelInformation &amp;pinfo, const AggregatesMap&lt; typename G::VertexDescriptor &gt; &amp;aggregates, const typename M::size_type &amp;size, const Set &amp;copy)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class M, class G, class V, class Set&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">M * Dune::Amg::GalerkinProduct&lt; T &gt;::build           </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&nbsp;</td>
          <td class="paramname"> <em>fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">G &amp;&nbsp;</td>
          <td class="paramname"> <em>fineGraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&nbsp;</td>
          <td class="paramname"> <em>visitedMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ParallelInformation &amp;&nbsp;</td>
          <td class="paramname"> <em>pinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00003.html">AggregatesMap</a>&lt; typename G::VertexDescriptor &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>aggregates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename M::size_type &amp;&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Set &amp;&nbsp;</td>
          <td class="paramname"> <em>copy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculates the coarse matrix via a Galerkin product. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fine</em>&nbsp;</td><td>The matrix on the fine level. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fineGraph</em>&nbsp;</td><td>The graph of the fine matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>visitedMap</em>&nbsp;</td><td>Map for marking vertices as visited. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pinfo</em>&nbsp;</td><td>Parallel information about the fine level. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aggregates</em>&nbsp;</td><td>The mapping of the fine level unknowns onto aggregates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The number of columns and rows of the coarse matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>copy</em>&nbsp;</td><td>The attribute set identifying the copy nodes of the graph. </td></tr>
  </table>
</dl>

<p>References <a class="el" href="a00216.html#l00524">Dune::Amg::SparsityBuilder&lt; M, V &gt;::maxRowSize()</a>, <a class="el" href="a00216.html#l00529">Dune::Amg::SparsityBuilder&lt; M, V &gt;::minRowSize()</a>, and <a class="el" href="a00216.html#l00535">Dune::Amg::SparsityBuilder&lt; M, V &gt;::sumRowSize()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gecb7eccaaad0ed4c69e17003498d24b4"></a><!-- doxytag: member="Dune::Amg::Aggregator::build" ref="gecb7eccaaad0ed4c69e17003498d24b4" args="(const M &amp;m, G &amp;graph, AggregatesMap&lt; Vertex &gt; &amp;aggregates, const C &amp;c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G&gt; </div>
<div class="memtemplate">
template&lt;class M, class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Tuple&lt; int, int, int &gt; <a class="el" href="a00006.html">Dune::Amg::Aggregator</a>&lt; G &gt;::build           </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">G &amp;&nbsp;</td>
          <td class="paramname"> <em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00003.html">AggregatesMap</a>&lt; <a class="el" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678">Vertex</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>aggregates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const C &amp;&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Build the aggregates. 
<p>
The template parameter C Is the type of the coarsening Criterion to use. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>The matrix to build the aggregates accordingly. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>graph</em>&nbsp;</td><td>A (sub) graph of the matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aggregates</em>&nbsp;</td><td><a class="el" href="a00002.html" title="A class for temporarily storing the vertices of an aggregate in.">Aggregate</a> map we will build. All entries should be initialized to UNAGGREGATED! </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>The coarsening criterion to use. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of (not skipped) aggregates built. </dd></dl>

<p>Referenced by <a class="el" href="a00203.html#l01912">Dune::Amg::AggregatesMap&lt; V &gt;::buildAggregates()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g259ba5ab939f8b299c4d77129e8ef213"></a><!-- doxytag: member="Dune::Amg::AggregatesMap::buildAggregates" ref="g259ba5ab939f8b299c4d77129e8ef213" args="(const M &amp;matrix, G &amp;graph, const C &amp;criterion)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V&gt; </div>
<div class="memtemplate">
template&lt;typename M, typename G, typename C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Tuple&lt; int, int, int &gt; <a class="el" href="a00003.html">Dune::Amg::AggregatesMap</a>&lt; V &gt;::buildAggregates           </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">G &amp;&nbsp;</td>
          <td class="paramname"> <em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const C &amp;&nbsp;</td>
          <td class="paramname"> <em>criterion</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Build the aggregates. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>matrix</em>&nbsp;</td><td>The matrix describing the dependency. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>graph</em>&nbsp;</td><td>The graph corresponding to the matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>criterion</em>&nbsp;</td><td>The aggregation criterion. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of aggregates built. </dd></dl>

<p>References <a class="el" href="a00203.html#l01920">Dune::Amg::Aggregator&lt; G &gt;::build()</a>.</p>

<p>Referenced by <a class="el" href="a00221.html#l00557">Dune::Amg::MatrixHierarchy&lt; M, PI, A &gt;::build()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g993b7c26f04d46d4fb6e384b956e6941"></a><!-- doxytag: member="Dune::Amg::BaseGalerkinProduct::calculate" ref="g993b7c26f04d46d4fb6e384b956e6941" args="(const M &amp;fine, const AggregatesMap&lt; V &gt; &amp;aggregates, M &amp;coarse, const I &amp;pinfo, const O &amp;copy)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M, class V, class P, class O&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Dune::Amg::BaseGalerkinProduct::calculate           </td>
          <td>(</td>
          <td class="paramtype">const M &amp;&nbsp;</td>
          <td class="paramname"> <em>fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00003.html">AggregatesMap</a>&lt; V &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>aggregates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M &amp;&nbsp;</td>
          <td class="paramname"> <em>coarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const P &amp;&nbsp;</td>
          <td class="paramname"> <em>pinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const O &amp;&nbsp;</td>
          <td class="paramname"> <em>copy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate the galerkin product. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fine</em>&nbsp;</td><td>The fine matrix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aggregates</em>&nbsp;</td><td>The aggregate mapping. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coarse</em>&nbsp;</td><td>The coarse <a class="el" href="a00071.html" title="A generic dynamic matrix.">Matrix</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pinfo</em>&nbsp;</td><td>Parallel information about the fine level. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>copy</em>&nbsp;</td><td>The attribute set identifying the copy nodes of the graph. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g78cce37e5d0e0c1121a3e37b17f733ea"></a><!-- doxytag: member="Dune::Amg::ParallelIndicesCoarsener::coarsen" ref="g78cce37e5d0e0c1121a3e37b17f733ea" args="(ParallelInformation &amp;fineInfo, Graph &amp;fineGraph, VM &amp;visitedMap, AggregatesMap&lt; typename Graph::VertexDescriptor &gt; &amp;aggregates, ParallelInformation &amp;coarseInfo)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename E&gt; </div>
<div class="memtemplate">
template&lt;typename Graph, typename VM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Graph::VertexDescriptor Dune::Amg::ParallelIndicesCoarsener&lt; T, E &gt;::coarsen           </td>
          <td>(</td>
          <td class="paramtype">ParallelInformation &amp;&nbsp;</td>
          <td class="paramname"> <em>fineInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Graph &amp;&nbsp;</td>
          <td class="paramname"> <em>fineGraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VM &amp;&nbsp;</td>
          <td class="paramname"> <em>visitedMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00003.html">AggregatesMap</a>&lt; typename Graph::VertexDescriptor &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>aggregates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ParallelInformation &amp;&nbsp;</td>
          <td class="paramname"> <em>coarseInfo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Build the coarse index set after the aggregatio. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fineInfo</em>&nbsp;</td><td>The parallel information at the fine level. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fineGraph</em>&nbsp;</td><td>The graph of the fine lecel, </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>visitedMap</em>&nbsp;</td><td>Map for marking vertices as visited. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aggregates</em>&nbsp;</td><td>The mapping of unknowns onto aggregates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>coarseInfo</em>&nbsp;</td><td>The information about the parallel data decomposition on the coarse level. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of unknowns on the coarse level. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g9362b04104f5a5e426c480198cbd3aa5"></a><!-- doxytag: member="Dune::Amg::MatrixHierarchy::coarsenSmoother" ref="g9362b04104f5a5e426c480198cbd3aa5" args="(Hierarchy&lt; S, TA &gt; &amp;smoothers, const typename SmootherTraits&lt; S &gt;::Arguments &amp;args) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M, class IS, class A&gt; </div>
<div class="memtemplate">
template&lt;class S, class TA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00076.html">Dune::Amg::MatrixHierarchy</a>&lt; M, IS, A &gt;::coarsenSmoother           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00054.html">Hierarchy</a>&lt; S, TA &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>smoothers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="a00113.html">SmootherTraits</a>&lt; S &gt;::Arguments &amp;&nbsp;</td>
          <td class="paramname"> <em>args</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Coarsen the smoother hierarchy according to the matrix hierarchy. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>smoothers</em>&nbsp;</td><td>The smoother hierarchy to coarsen. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>args</em>&nbsp;</td><td>The arguments for the construction of the coarse level smoothers. </td></tr>
  </table>
</dl>

<p>References <a class="el" href="a00221.html#l00913">Dune::Amg::Hierarchy&lt; T, A &gt;::addCoarser()</a>, <a class="el" href="a00221.html#l00959">Dune::Amg::Hierarchy&lt; T, A &gt;::coarsest()</a>, <a class="el" href="a00221.html#l00953">Dune::Amg::Hierarchy&lt; T, A &gt;::finest()</a>, and <a class="el" href="a00221.html#l00907">Dune::Amg::Hierarchy&lt; T, A &gt;::levels()</a>.</p>

<p>Referenced by <a class="el" href="a00206.html#l00171">Dune::Amg::AMG&lt; M, X, S, PI, A &gt;::AMG()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g5631ad094d4257bb7bec099a515a64c3"></a><!-- doxytag: member="Dune::Amg::MatrixHierarchy::coarsenVector" ref="g5631ad094d4257bb7bec099a515a64c3" args="(Hierarchy&lt; BlockVector&lt; V, TA &gt; &gt; &amp;hierarchy) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M, class IS, class A&gt; </div>
<div class="memtemplate">
template&lt;class V, class TA&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00076.html">Dune::Amg::MatrixHierarchy</a>&lt; M, IS, A &gt;::coarsenVector           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00054.html">Hierarchy</a>&lt; <a class="el" href="a00022.html">BlockVector</a>&lt; V, TA &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>hierarchy</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Coarsen the vector hierarchy according to the matrix hierarchy. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hierarchy</em>&nbsp;</td><td>The vector hierarchy to coarsen. </td></tr>
  </table>
</dl>

<p>References <a class="el" href="a00221.html#l00959">Dune::Amg::Hierarchy&lt; T, A &gt;::coarsest()</a>, and <a class="el" href="a00221.html#l00953">Dune::Amg::Hierarchy&lt; T, A &gt;::finest()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gdef24b6ebe79f2119513819ba8d3cee3"></a><!-- doxytag: member="Dune::Amg::Hierarchy::coarsest" ref="gdef24b6ebe79f2119513819ba8d3cee3" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Hierarchy&lt; T, A &gt;::ConstIterator <a class="el" href="a00054.html">Dune::Amg::Hierarchy</a>&lt; T, A &gt;::coarsest           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator positioned at the coarsest level. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An iterator positioned at the coarsest level. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gaacf35c23a00d0e9aa93309ff7cfab16"></a><!-- doxytag: member="Dune::Amg::Hierarchy::coarsest" ref="gaacf35c23a00d0e9aa93309ff7cfab16" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Hierarchy&lt; T, A &gt;::Iterator <a class="el" href="a00054.html">Dune::Amg::Hierarchy</a>&lt; T, A &gt;::coarsest           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator positioned at the coarsest level. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An iterator positioned at the coarsest level. </dd></dl>

<p>Referenced by <a class="el" href="a00221.html#l00821">Dune::Amg::MatrixHierarchy&lt; M, PI, A &gt;::coarsenSmoother()</a>, <a class="el" href="a00221.html#l00803">Dune::Amg::MatrixHierarchy&lt; M, PI, A &gt;::coarsenVector()</a>, and <a class="el" href="a00221.html#l00843">Dune::Amg::MatrixHierarchy&lt; M, PI, A &gt;::recalculateGalerkin()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g653f898b20814d3e5023a295b88e4f3e"></a><!-- doxytag: member="Dune::Amg::BaseConnectivityConstructor::ConnectedBuilder::ConnectedBuilder" ref="g653f898b20814d3e5023a295b88e4f3e" args="(const AggregatesMap&lt; Vertex &gt; &amp;aggregates, Graph &amp;graph, VisitedMap &amp;visitedMap, Set &amp;connected)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class S, class V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00013.html">Dune::Amg::BaseConnectivityConstructor::ConnectedBuilder</a>&lt; G, S, V &gt;::ConnectedBuilder           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00003.html">AggregatesMap</a>&lt; <a class="el" href="a00197.html#gdeb2a026f87fd62cfe7cfac493a6f465">Vertex</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>aggregates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00013.html#1101b3d4651097cd30faa0db028fb128">Graph</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00197.html#g846f7449dd71228f1242008abccd25dc">VisitedMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>visitedMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00197.html#g9ef43daa726f0e5682019b382d98fad5">Set</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>connected</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aggregates</em>&nbsp;</td><td>The mapping of the vertices onto the aggregates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>graph</em>&nbsp;</td><td>The graph to work on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>visitedMap</em>&nbsp;</td><td>The map for marking vertices as visited </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>connected</em>&nbsp;</td><td>The set to added the connected aggregates to. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gb2f81e0c007990646ae2d1a2cba03ee9"></a><!-- doxytag: member="Dune::Amg::Aggregator::ConnectivityCounter::ConnectivityCounter" ref="gb2f81e0c007990646ae2d1a2cba03ee9" args="(const VertexSet &amp;connected, const AggregatesMap&lt; Vertex &gt; &amp;aggregates)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00006.html">Dune::Amg::Aggregator</a>&lt; G &gt;::ConnectivityCounter::ConnectivityCounter           </td>
          <td>(</td>
          <td class="paramtype">const VertexSet &amp;&nbsp;</td>
          <td class="paramname"> <em>connected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00003.html">AggregatesMap</a>&lt; <a class="el" href="a00197.html#g0f4859e7d55855bace8c873cfdafa678">Vertex</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>aggregates</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connected</em>&nbsp;</td><td>The set of connected aggregates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aggregates</em>&nbsp;</td><td>Mapping of the vertices onto the aggregates. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aggregates</em>&nbsp;</td><td>The mapping of aggregates to vertices. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g2b4f2296dcb3b3495c69664f0ed02482"></a><!-- doxytag: member="Dune::Amg::ConstructionTraits::construct" ref="g2b4f2296dcb3b3495c69664f0ed02482" args="(Arguments &amp;args)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static T* <a class="el" href="a00037.html">Dune::Amg::ConstructionTraits</a>&lt; T &gt;::construct           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00037.html#9dafe554e419097e37bcb2fe0a511119">Arguments</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>args</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct an object with the specified arguments. 
<p>
In the default implementation the copy constructor is called. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>args</em>&nbsp;</td><td>The arguments for the construction. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gc0ecfafdcb23f24bfcebf68a6815ff46"></a><!-- doxytag: member="Dune::Amg::AggregationCriterion::debugLevel" ref="gc0ecfafdcb23f24bfcebf68a6815ff46" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="a00005.html">Dune::Amg::AggregationCriterion</a>&lt; T &gt;::debugLevel           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the debugging Level. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 if no debugging output will be generated. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf3c98e2348db0571b0a5c3dc3d15fa49"></a><!-- doxytag: member="Dune::Amg::ConstructionTraits::deconstruct" ref="gf3c98e2348db0571b0a5c3dc3d15fa49" args="(T *t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="a00037.html">Dune::Amg::ConstructionTraits</a>&lt; T &gt;::deconstruct           </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>t</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroys an object. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>Pointer to the object to destroy. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g8f839d0d1f804d70914c83c7deaeb7fe"></a><!-- doxytag: member="Dune::Amg::EdgeProperties::depends" ref="g8f839d0d1f804d70914c83c7deaeb7fe" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Dune::Amg::EdgeProperties::depends           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks wether the vertex the edge points to depends on the vertex the edge starts. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if it depends on the starting point. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g70f266616811166cf424eaf500cb0a59"></a><!-- doxytag: member="Dune::Amg::SubGraph::VertexIterator::dereference" ref="g70f266616811166cf424eaf500cb0a59" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const G::VertexDescriptor &amp; <a class="el" href="a00116.html">Dune::Amg::SubGraph</a>&lt; G, T &gt;::VertexIterator::dereference           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the descriptor of the current vertex. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The index of the currently referenced vertex. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g1a93df6d36c486e495755f6d5c7e274a"></a><!-- doxytag: member="Dune::Amg::SubGraph::EdgeIterator::EdgeIterator" ref="g1a93df6d36c486e495755f6d5c7e274a" args="(const EdgeDescriptor &amp;edge)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00116.html">Dune::Amg::SubGraph</a>&lt; G, T &gt;::EdgeIterator::EdgeIterator           </td>
          <td>(</td>
          <td class="paramtype">const EdgeDescriptor &amp;&nbsp;</td>
          <td class="paramname"> <em>edge</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor for the end iterator. 
<p>
Only operator== or operator!= can be called safely on an iterator constructed this way! <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>edge</em>&nbsp;</td><td>Pointer to the end of the graph's edge array. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gebb52889d4d4ca77442ca7bb00e52bb5"></a><!-- doxytag: member="Dune::Amg::SubGraph::EdgeIterator::EdgeIterator" ref="gebb52889d4d4ca77442ca7bb00e52bb5" args="(const VertexDescriptor &amp;source, const EdgeDescriptor &amp;edge)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00116.html">Dune::Amg::SubGraph</a>&lt; G, T &gt;::EdgeIterator::EdgeIterator           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00116.html#e935b74e150a8a496b56457eb5372c40">VertexDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EdgeDescriptor &amp;&nbsp;</td>
          <td class="paramname"> <em>edge</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source vertex of the edge. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>edge</em>&nbsp;</td><td>Pointer to the edge the iterator should point to. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gadea0697e4eafb9d07de8eaa5acaabfe"></a><!-- doxytag: member="Dune::Amg::PropertiesGraph::EdgeIteratorT::EdgeIteratorT" ref="gadea0697e4eafb9d07de8eaa5acaabfe" args="(const EdgeIteratorT&lt; C1 &gt; &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class E, class VM, class EM&gt; </div>
<div class="memtemplate">
template&lt;class C&gt; </div>
<div class="memtemplate">
template&lt;class C1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00093.html">Dune::Amg::PropertiesGraph</a>&lt; G, V, E, VM, EM &gt;::EdgeIteratorT&lt; C &gt;::EdgeIteratorT           </td>
          <td>(</td>
          <td class="paramtype">const EdgeIteratorT&lt; C1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>the iterator to copy. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gb3e49b1ee3e0aca073667a86de4b9e33"></a><!-- doxytag: member="Dune::Amg::PropertiesGraph::EdgeIteratorT::EdgeIteratorT" ref="gb3e49b1ee3e0aca073667a86de4b9e33" args="(const Father &amp;iter)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class E, class VM, class EM&gt; </div>
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00093.html">Dune::Amg::PropertiesGraph</a>&lt; G, V, E, VM, EM &gt;::EdgeIteratorT&lt; C &gt;::EdgeIteratorT           </td>
          <td>(</td>
          <td class="paramtype">const Father &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor for the end iterator. 
<p>
Only operator== or operator!= should be called on an iterator constructed this way. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>The iterator of the underlying graph. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g33278adff8485da7cf27b95812308ee3"></a><!-- doxytag: member="Dune::Amg::PropertiesGraph::EdgeIteratorT::EdgeIteratorT" ref="g33278adff8485da7cf27b95812308ee3" args="(const Father &amp;iter, C *graph)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class E, class VM, class EM&gt; </div>
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00093.html">Dune::Amg::PropertiesGraph</a>&lt; G, V, E, VM, EM &gt;::EdgeIteratorT&lt; C &gt;::EdgeIteratorT           </td>
          <td>(</td>
          <td class="paramtype">const Father &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C *&nbsp;</td>
          <td class="paramname"> <em>graph</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>The iterator of the underlying graph. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>graph</em>&nbsp;</td><td>The graph over whose edges we iterate on. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gbce8c409b2fcb3eb605b29372dda4460"></a><!-- doxytag: member="Dune::Amg::MatrixGraph::EdgeIteratorT::EdgeIteratorT" ref="gbce8c409b2fcb3eb605b29372dda4460" args="(const EdgeIteratorT&lt; C1 &gt; &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M&gt; </div>
<div class="memtemplate">
template&lt;class C&gt; </div>
<div class="memtemplate">
template&lt;class C1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00073.html">Dune::Amg::MatrixGraph</a>&lt; M &gt;::EdgeIteratorT&lt; C &gt;::EdgeIteratorT           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00074.html">EdgeIteratorT</a>&lt; C1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy Constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>The iterator to copy. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gb1d04970fd2292a918cac2450682f4dc"></a><!-- doxytag: member="Dune::Amg::MatrixGraph::EdgeIteratorT::EdgeIteratorT" ref="gb1d04970fd2292a918cac2450682f4dc" args="(const ColIterator &amp;block)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M&gt; </div>
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00073.html">Dune::Amg::MatrixGraph</a>&lt; M &gt;::EdgeIteratorT&lt; C &gt;::EdgeIteratorT           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00074.html#30fc156e37f11a52cb73cf19d3d4d429">ColIterator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor for the end iterator. 
<p>
Variables not needed by operator== or operator!= will not be initialized. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>The matrix column block the iterator is initialized to. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g05fd5193403bd77cf47d468f96aa28b1"></a><!-- doxytag: member="Dune::Amg::MatrixGraph::EdgeIteratorT::EdgeIteratorT" ref="g05fd5193403bd77cf47d468f96aa28b1" args="(const VertexDescriptor &amp;source, const ColIterator &amp;block, const ColIterator &amp;end, const EdgeDescriptor &amp;edge)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M&gt; </div>
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00073.html">Dune::Amg::MatrixGraph</a>&lt; M &gt;::EdgeIteratorT&lt; C &gt;::EdgeIteratorT           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00073.html#594cca89416b534b0b1a196c39684447">VertexDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00074.html#30fc156e37f11a52cb73cf19d3d4d429">ColIterator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00074.html#30fc156e37f11a52cb73cf19d3d4d429">ColIterator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00073.html#58193efcda473147fe4a3d85fdedc38e">EdgeDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>edge</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source vertex of the edges. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>The matrix column block the iterator is initialized to, </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>The end iterator of the matrix row. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>edge</em>&nbsp;</td><td>The edge descriptor of the current edge. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g58dd974e008963208bda324ae0493a94"></a><!-- doxytag: member="Dune::Amg::PropertiesGraph::end" ref="g58dd974e008963208bda324ae0493a94" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class E, class VM, class EM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PropertiesGraph&lt; G, V, E, VM, EM &gt;::ConstVertexIterator <a class="el" href="a00093.html">Dune::Amg::PropertiesGraph</a>&lt; G, V, E, VM, EM &gt;::end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator over the vertices. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A vertex Iterator positioned behind the last vertex. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gdf9e45e93ffa70043f748d40715c7e44"></a><!-- doxytag: member="Dune::Amg::PropertiesGraph::end" ref="gdf9e45e93ffa70043f748d40715c7e44" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class E, class VM, class EM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PropertiesGraph&lt; G, V, E, VM, EM &gt;::VertexIterator <a class="el" href="a00093.html">Dune::Amg::PropertiesGraph</a>&lt; G, V, E, VM, EM &gt;::end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator over the vertices. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A vertex Iterator positioned behind the last vertex. </dd></dl>

<p>Referenced by <a class="el" href="a00218.html#l02333">Dune::Amg::visitNeighbours()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g2c39a20b396707730d2d70a833a1ca1d"></a><!-- doxytag: member="Dune::Amg::PropertiesGraph::VertexIteratorT::end" ref="g2c39a20b396707730d2d70a833a1ca1d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class E, class VM, class EM&gt; </div>
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PropertiesGraph&lt; G, V, E, VM, EM &gt;::EdgeIteratorT&lt; C &gt; <a class="el" href="a00093.html">Dune::Amg::PropertiesGraph</a>&lt; G, V, E, VM, EM &gt;::VertexIteratorT&lt; C &gt;::end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator over the edges starting from the current vertex. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An iterator over the edges starting from the current vertex positioned after the last edge. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g36c4a4206bbc3dc9e668c24e3e5278e3"></a><!-- doxytag: member="Dune::Amg::VertexPropertiesGraph::end" ref="g36c4a4206bbc3dc9e668c24e3e5278e3" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class VM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VertexPropertiesGraph&lt; G, V, VM &gt;::ConstVertexIterator <a class="el" href="a00132.html">Dune::Amg::VertexPropertiesGraph</a>&lt; G, V, VM &gt;::end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator over the vertices. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A vertex Iterator positioned behind the last vertex. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g68fe008f23bb100f79c50221bb90f530"></a><!-- doxytag: member="Dune::Amg::VertexPropertiesGraph::end" ref="g68fe008f23bb100f79c50221bb90f530" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class VM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VertexPropertiesGraph&lt; G, V, VM &gt;::VertexIterator <a class="el" href="a00132.html">Dune::Amg::VertexPropertiesGraph</a>&lt; G, V, VM &gt;::end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator over the vertices. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A vertex Iterator positioned behind the last vertex. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gbfcaab04b7bd07e4a8731962e8de7356"></a><!-- doxytag: member="Dune::Amg::VertexPropertiesGraph::VertexIteratorT::end" ref="gbfcaab04b7bd07e4a8731962e8de7356" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class VM&gt; </div>
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SelectType&lt; is_same&lt; typename remove_const&lt; C &gt;::type, C &gt;::value, typename G::EdgeIterator, typename G::ConstEdgeIterator &gt;::Type <a class="el" href="a00132.html">Dune::Amg::VertexPropertiesGraph</a>&lt; G, V, VM &gt;::VertexIteratorT&lt; C &gt;::end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator over the edges starting from the current vertex. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An iterator over the edges starting from the current vertex positioned after the last edge. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g1b3f828dd88d05ac7d6947b68bed3ca6"></a><!-- doxytag: member="Dune::Amg::SubGraph::end" ref="g1b3f828dd88d05ac7d6947b68bed3ca6" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SubGraph&lt; G, T &gt;::VertexIterator <a class="el" href="a00116.html">Dune::Amg::SubGraph</a>&lt; G, T &gt;::end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator over the vertices. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A vertex Iterator positioned behind the last vertex. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g3211f2a6cb5f2eed45e10b4db572d1f2"></a><!-- doxytag: member="Dune::Amg::SubGraph::VertexIterator::end" ref="g3211f2a6cb5f2eed45e10b4db572d1f2" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SubGraph&lt; G, T &gt;::EdgeIterator <a class="el" href="a00116.html">Dune::Amg::SubGraph</a>&lt; G, T &gt;::VertexIterator::end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator over all edges starting at the current vertex. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Iterator position on the first edge to another vertex. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gc2620750ced24d01aeb31bccf47f22a2"></a><!-- doxytag: member="Dune::Amg::MatrixGraph::end" ref="gc2620750ced24d01aeb31bccf47f22a2" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MatrixGraph&lt; M &gt;::VertexIteratorT&lt; const MatrixGraph&lt; M &gt; &gt; <a class="el" href="a00073.html">Dune::Amg::MatrixGraph</a>&lt; M &gt;::end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator over the vertices. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A vertex Iterator positioned behind the last vertex. </dd></dl>

<p>References <a class="el" href="a00231.html#l00164">Dune::Matrix&lt; T, A &gt;::N()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gee23e1ecff955fa9fa37738250ec7b1a"></a><!-- doxytag: member="Dune::Amg::MatrixGraph::end" ref="gee23e1ecff955fa9fa37738250ec7b1a" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MatrixGraph&lt; M &gt;::VertexIteratorT&lt; MatrixGraph&lt; M &gt; &gt; <a class="el" href="a00073.html">Dune::Amg::MatrixGraph</a>&lt; M &gt;::end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator over the vertices. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A vertex Iterator positioned behind the last vertex. </dd></dl>

<p>References <a class="el" href="a00231.html#l00164">Dune::Matrix&lt; T, A &gt;::N()</a>.</p>

<p>Referenced by <a class="el" href="a00218.html#l01736">Dune::Amg::MatrixGraph&lt; M &gt;::beginEdges()</a>, and <a class="el" href="a00218.html#l01477">Dune::Amg::MatrixGraph&lt; M &gt;::findEdge()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g23f8fb7d9767b13ed9aacd017a0b3950"></a><!-- doxytag: member="Dune::Amg::MatrixGraph::VertexIteratorT::end" ref="g23f8fb7d9767b13ed9aacd017a0b3950" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M&gt; </div>
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MatrixGraph&lt; M &gt;::EdgeIteratorT&lt; C &gt; <a class="el" href="a00073.html">Dune::Amg::MatrixGraph</a>&lt; M &gt;::VertexIteratorT&lt; C &gt;::end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator over all edges starting at the current vertex. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Iterator position on the first edge to another vertex. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g7bf7c2fbdc576e81bd47c9c84c181430"></a><!-- doxytag: member="Dune::Amg::PropertiesGraph::endEdges" ref="g7bf7c2fbdc576e81bd47c9c84c181430" args="(const VertexDescriptor &amp;source) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class E, class VM, class EM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PropertiesGraph&lt; G, V, E, VM, EM &gt;::ConstEdgeIterator <a class="el" href="a00093.html">Dune::Amg::PropertiesGraph</a>&lt; G, V, E, VM, EM &gt;::endEdges           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00093.html#cc1d8f22266e986a90c7ff0a380517d8">VertexDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the mutable edge iterator over edges starting at a vertex. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An edge iterator over edges starting at a vertex positioned after the last edge. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gc7f8f18742ae59b5765f33cb9061e32c"></a><!-- doxytag: member="Dune::Amg::PropertiesGraph::endEdges" ref="gc7f8f18742ae59b5765f33cb9061e32c" args="(const VertexDescriptor &amp;source)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class E, class VM, class EM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PropertiesGraph&lt; G, V, E, VM, EM &gt;::EdgeIterator <a class="el" href="a00093.html">Dune::Amg::PropertiesGraph</a>&lt; G, V, E, VM, EM &gt;::endEdges           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00093.html#cc1d8f22266e986a90c7ff0a380517d8">VertexDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the mutable edge iterator over edges starting at a vertex. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An edge iterator over edges starting at a vertex positioned after the last edge. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g9237d5800d8f4d9835e509f7a2711fe5"></a><!-- doxytag: member="Dune::Amg::VertexPropertiesGraph::endEdges" ref="g9237d5800d8f4d9835e509f7a2711fe5" args="(const VertexDescriptor &amp;source) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class VM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VertexPropertiesGraph&lt; G, V, VM &gt;::ConstEdgeIterator <a class="el" href="a00132.html">Dune::Amg::VertexPropertiesGraph</a>&lt; G, V, VM &gt;::endEdges           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00132.html#79f61a7abf2ffba549f7ca3573c294b5">VertexDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the mutable edge iterator over edges starting at a vertex. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An edge iterator over edges starting at a vertex positioned after the last edge. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g4827ee0e2a84ae1b6923c3997a378030"></a><!-- doxytag: member="Dune::Amg::VertexPropertiesGraph::endEdges" ref="g4827ee0e2a84ae1b6923c3997a378030" args="(const VertexDescriptor &amp;source)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class VM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VertexPropertiesGraph&lt; G, V, VM &gt;::EdgeIterator <a class="el" href="a00132.html">Dune::Amg::VertexPropertiesGraph</a>&lt; G, V, VM &gt;::endEdges           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00132.html#79f61a7abf2ffba549f7ca3573c294b5">VertexDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the mutable edge iterator over edges starting at a vertex. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An edge iterator over edges starting at a vertex positioned after the last edge. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g2df2b4071e0737713edae90ad4b9214d"></a><!-- doxytag: member="Dune::Amg::SubGraph::endEdges" ref="g2df2b4071e0737713edae90ad4b9214d" args="(const VertexDescriptor &amp;source) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SubGraph&lt; G, T &gt;::EdgeIterator <a class="el" href="a00116.html">Dune::Amg::SubGraph</a>&lt; G, T &gt;::endEdges           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00116.html#e935b74e150a8a496b56457eb5372c40">VertexDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator over the edges starting at a vertex. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The vertex where the edges should start. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An edge iterator positioned behind the last edge starting from vertex source. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g85a2801f3136941d80547a54ea7e9510"></a><!-- doxytag: member="Dune::Amg::MatrixGraph::endEdges" ref="g85a2801f3136941d80547a54ea7e9510" args="(const VertexDescriptor &amp;source) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MatrixGraph&lt; M &gt;::EdgeIteratorT&lt; const MatrixGraph&lt; M &gt; &gt; <a class="el" href="a00073.html">Dune::Amg::MatrixGraph</a>&lt; M &gt;::endEdges           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00073.html#594cca89416b534b0b1a196c39684447">VertexDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator over the edges starting at a vertex. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The vertex where the edges should start. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An edge iterator positioned behind the last edge starting from vertex source. </dd></dl>

<p>References <a class="el" href="a00231.html#l00089">Dune::Matrix&lt; T, A &gt;::end()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g0c8a05b9dc5ae4644284f7d8bfcabc0d"></a><!-- doxytag: member="Dune::Amg::MatrixGraph::endEdges" ref="g0c8a05b9dc5ae4644284f7d8bfcabc0d" args="(const VertexDescriptor &amp;source)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MatrixGraph&lt; M &gt;::EdgeIteratorT&lt; MatrixGraph&lt; M &gt; &gt; <a class="el" href="a00073.html">Dune::Amg::MatrixGraph</a>&lt; M &gt;::endEdges           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00073.html#594cca89416b534b0b1a196c39684447">VertexDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator over the edges starting at a vertex. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The vertex where the edges should start. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An edge iterator positioned behind the last edge starting from vertex source. </dd></dl>

<p>References <a class="el" href="a00231.html#l00089">Dune::Matrix&lt; T, A &gt;::end()</a>.</p>

<p>Referenced by <a class="el" href="a00203.html#l01297">Dune::Amg::Aggregate&lt; G &gt;::add()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g39c6428f42252374646f2d34565e97e4"></a><!-- doxytag: member="Dune::Amg::VertexProperties::excluded" ref="g39c6428f42252374646f2d34565e97e4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Dune::Amg::VertexProperties::excluded           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tests whether the vertex is excluded from the aggregation. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if the vertex is excluded from the aggregation process. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g2de70b24abda2b41c05ffa6cdc622564"></a><!-- doxytag: member="Dune::Amg::SubGraph::findEdge" ref="g2de70b24abda2b41c05ffa6cdc622564" args="(const VertexDescriptor &amp;source, const VertexDescriptor &amp;target) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const SubGraph&lt; G, T &gt;::EdgeDescriptor &amp; <a class="el" href="a00116.html">Dune::Amg::SubGraph</a>&lt; G, T &gt;::findEdge           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00116.html#e935b74e150a8a496b56457eb5372c40">VertexDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00116.html#e935b74e150a8a496b56457eb5372c40">VertexDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the descriptor of an edge. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source vertex of the edge we search for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>The target vertex of the edge we search for. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The edge we found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g7560765b9e6c6ace588ec1e9ce7ac40a"></a><!-- doxytag: member="Dune::Amg::MatrixGraph::findEdge" ref="g7560765b9e6c6ace588ec1e9ce7ac40a" args="(const VertexDescriptor &amp;source, const VertexDescriptor &amp;target) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MatrixGraph&lt; M &gt;::EdgeDescriptor <a class="el" href="a00073.html">Dune::Amg::MatrixGraph</a>&lt; M &gt;::findEdge           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00073.html#594cca89416b534b0b1a196c39684447">VertexDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00073.html#594cca89416b534b0b1a196c39684447">VertexDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Find the descriptor of an edge. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The source vertex of the edge we search for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>The target vertex of the edge we search for. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The edge we found. </dd></dl>

<p>References <a class="el" href="a00218.html#l01714">Dune::Amg::MatrixGraph&lt; M &gt;::end()</a>, <a class="el" href="a00231.html#l00550">Dune::Matrix&lt; T, A &gt;::exists()</a>, and <a class="el" href="a00218.html#l01458">Dune::Amg::MatrixGraph&lt; M &gt;::noEdges()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g1202feb79e186b2abf48fe2233883b5d"></a><!-- doxytag: member="Dune::Amg::Hierarchy::finest" ref="g1202feb79e186b2abf48fe2233883b5d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Hierarchy&lt; T, A &gt;::ConstIterator <a class="el" href="a00054.html">Dune::Amg::Hierarchy</a>&lt; T, A &gt;::finest           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator positioned at the finest level. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An iterator positioned at the finest level. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gdfe51fd5682dd55cbc4b15fd4ac890d2"></a><!-- doxytag: member="Dune::Amg::Hierarchy::finest" ref="gdfe51fd5682dd55cbc4b15fd4ac890d2" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Hierarchy&lt; T, A &gt;::Iterator <a class="el" href="a00054.html">Dune::Amg::Hierarchy</a>&lt; T, A &gt;::finest           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator positioned at the finest level. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An iterator positioned at the finest level. </dd></dl>

<p>Referenced by <a class="el" href="a00221.html#l00557">Dune::Amg::MatrixHierarchy&lt; M, PI, A &gt;::build()</a>, <a class="el" href="a00221.html#l00821">Dune::Amg::MatrixHierarchy&lt; M, PI, A &gt;::coarsenSmoother()</a>, <a class="el" href="a00221.html#l00803">Dune::Amg::MatrixHierarchy&lt; M, PI, A &gt;::coarsenVector()</a>, and <a class="el" href="a00221.html#l00843">Dune::Amg::MatrixHierarchy&lt; M, PI, A &gt;::recalculateGalerkin()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g7b98a5dcaabbf445e630246eb3984f58"></a><!-- doxytag: member="Dune::Amg::Aggregator::FrontMarker::FrontMarker" ref="g7b98a5dcaabbf445e630246eb3984f58" args="(VertexList &amp;front, MatrixGraph &amp;graph)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00006.html">Dune::Amg::Aggregator</a>&lt; G &gt;::FrontMarker::FrontMarker           </td>
          <td>(</td>
          <td class="paramtype">VertexList &amp;&nbsp;</td>
          <td class="paramname"> <em>front</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00073.html">MatrixGraph</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>graph</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>front</em>&nbsp;</td><td>The list to store the front vertices in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>graph</em>&nbsp;</td><td>The matrix graph we work on. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g4a9c2f3b9ca3ad3ddb48388156b88703"></a><!-- doxytag: member="Dune::Amg::Aggregator::FrontNeighbourCounter::FrontNeighbourCounter" ref="g4a9c2f3b9ca3ad3ddb48388156b88703" args="(const MatrixGraph &amp;front)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00006.html">Dune::Amg::Aggregator</a>&lt; G &gt;::FrontNeighbourCounter::FrontNeighbourCounter           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00073.html">MatrixGraph</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>front</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>front</em>&nbsp;</td><td>The vertices of the front. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g8b633dc60c44de7e1faefde57fd1815b"></a><!-- doxytag: member="Dune::Amg::SubGraph::getEdgeIndexMap" ref="g8b633dc60c44de7e1faefde57fd1815b" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SubGraph&lt; G, T &gt;::EdgeIndexMap <a class="el" href="a00116.html">Dune::Amg::SubGraph</a>&lt; G, T &gt;::getEdgeIndexMap           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an edge index map for the graph. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An edge index map for the graph. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g0cc37f050cf56de756cb78e5875f3d22"></a><!-- doxytag: member="Dune::Amg::PropertiesGraph::getEdgeProperties" ref="g0cc37f050cf56de756cb78e5875f3d22" args="(const VertexDescriptor &amp;source, const VertexDescriptor &amp;target) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class E, class VM, class EM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const E &amp; <a class="el" href="a00093.html">Dune::Amg::PropertiesGraph</a>&lt; G, V, E, VM, EM &gt;::getEdgeProperties           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00093.html#cc1d8f22266e986a90c7ff0a380517d8">VertexDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00093.html#cc1d8f22266e986a90c7ff0a380517d8">VertexDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the properties associated with a edge. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The descriptor identifying the source vertex of the edge. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>The descriptor identifying the target vertex of the edge. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The properties of the edge. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g56cf250b14af40c095a4d56ac7a57bf6"></a><!-- doxytag: member="Dune::Amg::PropertiesGraph::getEdgeProperties" ref="g56cf250b14af40c095a4d56ac7a57bf6" args="(const VertexDescriptor &amp;source, const VertexDescriptor &amp;target)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class E, class VM, class EM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">E &amp; <a class="el" href="a00093.html">Dune::Amg::PropertiesGraph</a>&lt; G, V, E, VM, EM &gt;::getEdgeProperties           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00093.html#cc1d8f22266e986a90c7ff0a380517d8">VertexDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00093.html#cc1d8f22266e986a90c7ff0a380517d8">VertexDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the properties associated with a edge. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>The descriptor identifying the source vertex of the edge. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>The descriptor identifying the target vertex of the edge. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The properties of the edge. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g90acb2fb795ebd10e38a25dae097c9d0"></a><!-- doxytag: member="Dune::Amg::PropertiesGraph::getEdgeProperties" ref="g90acb2fb795ebd10e38a25dae097c9d0" args="(const EdgeDescriptor &amp;edge) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class E, class VM, class EM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const E &amp; <a class="el" href="a00093.html">Dune::Amg::PropertiesGraph</a>&lt; G, V, E, VM, EM &gt;::getEdgeProperties           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00093.html#1e87b1382ebbf1cab6a77fc3cb3849c6">EdgeDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>edge</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the properties associated with a edge. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>edge</em>&nbsp;</td><td>The descriptor identifying the edge. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The properties of the edge. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb4aa17404514e2bc67080f60d1b0916e"></a><!-- doxytag: member="Dune::Amg::PropertiesGraph::getEdgeProperties" ref="gb4aa17404514e2bc67080f60d1b0916e" args="(const EdgeDescriptor &amp;edge)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class E, class VM, class EM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">E &amp; <a class="el" href="a00093.html">Dune::Amg::PropertiesGraph</a>&lt; G, V, E, VM, EM &gt;::getEdgeProperties           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00093.html#1e87b1382ebbf1cab6a77fc3cb3849c6">EdgeDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>edge</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the properties associated with a edge. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>edge</em>&nbsp;</td><td>The descriptor identifying the edge. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The properties of the edge. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g4f1df6b97bb20e026d6b892011fb3fd5"></a><!-- doxytag: member="Dune::Amg::PropertiesGraph::getVertexProperties" ref="g4f1df6b97bb20e026d6b892011fb3fd5" args="(const VertexDescriptor &amp;vertex) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class E, class VM, class EM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const V &amp; <a class="el" href="a00093.html">Dune::Amg::PropertiesGraph</a>&lt; G, V, E, VM, EM &gt;::getVertexProperties           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00093.html#cc1d8f22266e986a90c7ff0a380517d8">VertexDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vertex</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the properties associated with a vertex. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vertex</em>&nbsp;</td><td>The descriptor identifying the vertex. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The properties of the vertex. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf1d26a922fefafbb923e93d559eac632"></a><!-- doxytag: member="Dune::Amg::PropertiesGraph::getVertexProperties" ref="gf1d26a922fefafbb923e93d559eac632" args="(const VertexDescriptor &amp;vertex)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class E, class VM, class EM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V &amp; <a class="el" href="a00093.html">Dune::Amg::PropertiesGraph</a>&lt; G, V, E, VM, EM &gt;::getVertexProperties           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00093.html#cc1d8f22266e986a90c7ff0a380517d8">VertexDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vertex</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the properties associated with a vertex. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vertex</em>&nbsp;</td><td>The descriptor identifying the vertex. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The properties of the vertex. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g590aa6fc381fe23e6e8be30ba53fcd1d"></a><!-- doxytag: member="Dune::Amg::VertexPropertiesGraph::getVertexProperties" ref="g590aa6fc381fe23e6e8be30ba53fcd1d" args="(const VertexDescriptor &amp;vertex) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class VM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const V &amp; <a class="el" href="a00132.html">Dune::Amg::VertexPropertiesGraph</a>&lt; G, V, VM &gt;::getVertexProperties           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00132.html#79f61a7abf2ffba549f7ca3573c294b5">VertexDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vertex</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the properties associated with a vertex. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vertex</em>&nbsp;</td><td>The descriptor identifying the vertex. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The properties of the vertex. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g0300e240bca87e1708c7e87e02abd31a"></a><!-- doxytag: member="Dune::Amg::VertexPropertiesGraph::getVertexProperties" ref="g0300e240bca87e1708c7e87e02abd31a" args="(const VertexDescriptor &amp;vertex)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class VM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V &amp; <a class="el" href="a00132.html">Dune::Amg::VertexPropertiesGraph</a>&lt; G, V, VM &gt;::getVertexProperties           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00132.html#79f61a7abf2ffba549f7ca3573c294b5">VertexDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vertex</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the properties associated with a vertex. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vertex</em>&nbsp;</td><td>The descriptor identifying the vertex. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The properties of the vertex. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gf39e07a724bd35b821fed373bea51990"></a><!-- doxytag: member="Dune::Amg::PropertiesGraph::graph" ref="gf39e07a724bd35b821fed373bea51990" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class E, class VM, class EM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const G &amp; <a class="el" href="a00093.html">Dune::Amg::PropertiesGraph</a>&lt; G, V, E, VM, EM &gt;::graph           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the graph the properties are attached to. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The underlying graph. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g1eb61ffab76c755378c3f7eae33b64f7"></a><!-- doxytag: member="Dune::Amg::VertexPropertiesGraph::graph" ref="g1eb61ffab76c755378c3f7eae33b64f7" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class VM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const G &amp; <a class="el" href="a00132.html">Dune::Amg::VertexPropertiesGraph</a>&lt; G, V, VM &gt;::graph           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the graph the properties are attached to. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The underlying graph. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb12ba0f94504959761dc9ba347b0d78f"></a><!-- doxytag: member="Dune::Amg::Hierarchy::Hierarchy" ref="gb12ba0f94504959761dc9ba347b0d78f" args="(MemberType &amp;first)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00054.html">Dune::Amg::Hierarchy</a>&lt; T, A &gt;::Hierarchy           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00054.html#174c9e78c20945f946429d1ca5c24eff">MemberType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>first</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct a new hierarchy. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The first element in the hierarchy. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g31b69fcc9195551bf3dc424311b852bb"></a><!-- doxytag: member="Dune::Amg::EdgeProperties::influences" ref="g31b69fcc9195551bf3dc424311b852bb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Dune::Amg::EdgeProperties::influences           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks wether the start vertex is influenced by the end vertex. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if it is influenced. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g869a9a18ba099c27906839e66956f538"></a><!-- doxytag: member="Dune::Amg::MatrixHierarchy::isBuilt" ref="g869a9a18ba099c27906839e66956f538" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M, class IS, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00076.html">Dune::Amg::MatrixHierarchy</a>&lt; M, IS, A &gt;::isBuilt           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Whether the hierarchy wis built. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the coarsen method was called. </dd></dl>

<p>Referenced by <a class="el" href="a00206.html#l00171">Dune::Amg::AMG&lt; M, X, S, PI, A &gt;::AMG()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g8fbdc44be934a27c6fc0d1178e9bb17f"></a><!-- doxytag: member="Dune::Amg::Hierarchy::levels" ref="g8fbdc44be934a27c6fc0d1178e9bb17f" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="a00054.html">Dune::Amg::Hierarchy</a>&lt; T, A &gt;::levels           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the number of levels in the hierarchy. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of levels. </dd></dl>

<p>Referenced by <a class="el" href="a00221.html#l00821">Dune::Amg::MatrixHierarchy&lt; M, PI, A &gt;::coarsenSmoother()</a>, and <a class="el" href="a00221.html#l00863">Dune::Amg::MatrixHierarchy&lt; M, PI, A &gt;::levels()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g78d7b7cf130c059d81e250c21eb02fcf"></a><!-- doxytag: member="Dune::Amg::MatrixHierarchy::levels" ref="g78d7b7cf130c059d81e250c21eb02fcf" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M, class IS, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="a00076.html">Dune::Amg::MatrixHierarchy</a>&lt; M, IS, A &gt;::levels           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the number of levels in the hierarchy. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of levels. </dd></dl>

<p>References <a class="el" href="a00221.html#l00907">Dune::Amg::Hierarchy&lt; T, A &gt;::levels()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g2b805985392a6ea5eeba3bd900d2d2f1"></a><!-- doxytag: member="Dune::Amg::MatrixHierarchy::matrices" ref="g2b805985392a6ea5eeba3bd900d2d2f1" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M, class IS, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const MatrixHierarchy&lt; M, IS, A &gt;::ParallelMatrixHierarchy &amp; <a class="el" href="a00076.html">Dune::Amg::MatrixHierarchy</a>&lt; M, IS, A &gt;::matrices           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the matrix hierarchy. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The matrix hierarchy. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g645d82b37832412d239a1743f5897f3d"></a><!-- doxytag: member="Dune::Amg::MatrixGraph::matrix" ref="g645d82b37832412d239a1743f5897f3d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const M &amp; <a class="el" href="a00073.html">Dune::Amg::MatrixGraph</a>&lt; M &gt;::matrix           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the underlying matrix. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The matrix of the graph. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g3b6223ac9367235e30023b87e05b3bbe"></a><!-- doxytag: member="Dune::Amg::MatrixGraph::matrix" ref="g3b6223ac9367235e30023b87e05b3bbe" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">M &amp; <a class="el" href="a00073.html">Dune::Amg::MatrixGraph</a>&lt; M &gt;::matrix           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the underlying matrix. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The matrix of the graph. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ge67b84fea589c9f9bb912ff90b511c3e"></a><!-- doxytag: member="Dune::Amg::MatrixHierarchy::MatrixHierarchy" ref="ge67b84fea589c9f9bb912ff90b511c3e" args="(const MatrixOperator &amp;fineMatrix, const ParallelInformation &amp;pinfo=ParallelInformation())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M, class IS, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00076.html">Dune::Amg::MatrixHierarchy</a>&lt; M, IS, A &gt;::MatrixHierarchy           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00076.html#f74ed9452d007de1b3b930f8e2fa91ec">MatrixOperator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>fineMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00076.html#7055367d7a4da283a81703b79f2c81d8">ParallelInformation</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pinfo</em> = <code><a class="el" href="a00076.html#7055367d7a4da283a81703b79f2c81d8">ParallelInformation</a>()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fineMatrix</em>&nbsp;</td><td>The matrix to coarsen. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pinfo</em>&nbsp;</td><td>The information about the parallel data decomposition at the first level. </td></tr>
  </table>
</dl>

<p>References <a class="el" href="a00251.html#l00024">Dune::SolverCategory::overlapping</a>, and <a class="el" href="a00251.html#l00020">Dune::SolverCategory::sequential</a>.</p>

</div>
</div><p>
<a class="anchor" name="g4b7ef7cb7c048dab90204e7360004a41"></a><!-- doxytag: member="Dune::Amg::AggregationCriterion::maxAggregateSize" ref="g4b7ef7cb7c048dab90204e7360004a41" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="a00005.html">Dune::Amg::AggregationCriterion</a>&lt; T &gt;::maxAggregateSize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the maximum number of nodes a aggregate is allowed to have. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The maximum number of nodes. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g63591679ca51a29eb8b6db73d5c0c64b"></a><!-- doxytag: member="Dune::Amg::AggregationCriterion::maxConnectivity" ref="g63591679ca51a29eb8b6db73d5c0c64b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="a00005.html">Dune::Amg::AggregationCriterion</a>&lt; T &gt;::maxConnectivity           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the maximum number of connections a aggregate is allowed to have. 
<p>
This limit exists to achieve sparsity of the coarse matrix. the default value is 15.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The maximum number of connections a aggregate is allowed to have. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ge4fef1b11ebb9e85ba520baf6d77c766"></a><!-- doxytag: member="Dune::Amg::AggregationCriterion::maxDistance" ref="ge4fef1b11ebb9e85ba520baf6d77c766" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="a00005.html">Dune::Amg::AggregationCriterion</a>&lt; T &gt;::maxDistance           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the maximal distance allowed between to nodes in a aggregate. 
<p>
The distance between two nodes in a aggregate is the minimal number of edges it takes to travel from one node to the other without leaving the aggregate. <dl class="return" compact><dt><b>Returns:</b></dt><dd>The maximum distance allowed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="geace8f70fb38cd28d5261f363ef3ee14"></a><!-- doxytag: member="Dune::Amg::PropertiesGraph::maxVertex" ref="geace8f70fb38cd28d5261f363ef3ee14" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class E, class VM, class EM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PropertiesGraph&lt; G, V, E, VM, EM &gt;::VertexDescriptor <a class="el" href="a00093.html">Dune::Amg::PropertiesGraph</a>&lt; G, V, E, VM, EM &gt;::maxVertex           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the maximal vertex descriptor. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The minimum value v such that for all vertices w in the graph w&lt;v holds. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g50f925de23de4d852831f400efaf07cd"></a><!-- doxytag: member="Dune::Amg::VertexPropertiesGraph::maxVertex" ref="g50f925de23de4d852831f400efaf07cd" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class VM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VertexPropertiesGraph&lt; G, V, VM &gt;::VertexDescriptor <a class="el" href="a00132.html">Dune::Amg::VertexPropertiesGraph</a>&lt; G, V, VM &gt;::maxVertex           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the maximal vertex descriptor. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The minimum value v such that for all vertices w in the graph w&lt;v holds. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g76ae016793a1e2e6731754f5ae3ebfcd"></a><!-- doxytag: member="Dune::Amg::SubGraph::maxVertex" ref="g76ae016793a1e2e6731754f5ae3ebfcd" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SubGraph&lt; G, T &gt;::VertexDescriptor <a class="el" href="a00116.html">Dune::Amg::SubGraph</a>&lt; G, T &gt;::maxVertex           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the maximal vertex descriptor. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The minimum value v such that for all vertices w in the graph w&lt;v holds. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g2dbe4266a8f2f3c4affa24475cb7842d"></a><!-- doxytag: member="Dune::Amg::MatrixGraph::maxVertex" ref="g2dbe4266a8f2f3c4affa24475cb7842d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MatrixGraph&lt; M &gt;::VertexDescriptor <a class="el" href="a00073.html">Dune::Amg::MatrixGraph</a>&lt; M &gt;::maxVertex           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the maximal vertex descriptor. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The minimum value v such that for all vertices w in the graph w&lt;v holds. </dd></dl>

<p>References <a class="el" href="a00231.html#l00164">Dune::Matrix&lt; T, A &gt;::N()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g5a9b3d45eb284edd36fbfb31779b780e"></a><!-- doxytag: member="Dune::Amg::AggregationCriterion::minAggregateSize" ref="g5a9b3d45eb284edd36fbfb31779b780e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="a00005.html">Dune::Amg::AggregationCriterion</a>&lt; T &gt;::minAggregateSize           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the minimum number of nodes a aggregate has to consist of. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The minimum number of nodes. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g1c76c672594522d2d0d95be0bb5ecc1d"></a><!-- doxytag: member="Dune::Amg::BaseConnectivityConstructor::ConnectedBuilder::operator()" ref="g1c76c672594522d2d0d95be0bb5ecc1d" args="(const ConstEdgeIterator &amp;edge)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class S, class V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00013.html">Dune::Amg::BaseConnectivityConstructor::ConnectedBuilder</a>&lt; G, S, V &gt;::operator()           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00197.html#g6669e30805fb10ce64bbc532330dd6bd">ConstEdgeIterator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>edge</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Process an edge pointing to another aggregate. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>edge</em>&nbsp;</td><td>The iterator positioned at the edge. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g857f6862a78c5497ae0e8f79d6ab61cf"></a><!-- doxytag: member="Dune::Amg::Aggregator::AggregateVisitor::operator()" ref="g857f6862a78c5497ae0e8f79d6ab61cf" args="(const typename MatrixGraph::ConstEdgeIterator &amp;edge)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G&gt; </div>
<div class="memtemplate">
template&lt;class V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00006.html">Dune::Amg::Aggregator</a>&lt; G &gt;::AggregateVisitor&lt; V &gt;::operator()           </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="a00074.html">MatrixGraph::ConstEdgeIterator</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>edge</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Examine an edge. 
<p>
The edge will be examined by the adapted visitor if it belongs to the right aggregate. 
<p>References <a class="el" href="a00218.html#l01590">Dune::Amg::MatrixGraph&lt; M &gt;::EdgeIteratorT&lt; C &gt;::target()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g6fc08102232fde7948f977b9db22be48"></a><!-- doxytag: member="Dune::Amg::MatrixGraph::VertexIteratorT::operator*" ref="g6fc08102232fde7948f977b9db22be48" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M&gt; </div>
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const MatrixGraph&lt; M &gt;::VertexDescriptor &amp; <a class="el" href="a00073.html">Dune::Amg::MatrixGraph</a>&lt; M &gt;::VertexIteratorT&lt; C &gt;::operator*           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the descriptor of the current vertex. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The index of the currently referenced vertex. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gda4812de2b28c5d83019375cd7981456"></a><!-- doxytag: member="Dune::Amg::MatrixGraph::VertexIteratorT::operator++" ref="gda4812de2b28c5d83019375cd7981456" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M&gt; </div>
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MatrixGraph&lt; M &gt;::VertexIteratorT&lt; C &gt; &amp; <a class="el" href="a00073.html">Dune::Amg::MatrixGraph</a>&lt; M &gt;::VertexIteratorT&lt; C &gt;::operator++           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Move to the next vertex. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>This iterator positioned at the next vertex. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g12ef2c1377e445577a0a1f967272ccdb"></a><!-- doxytag: member="Dune::Amg::RandomAccessBundledPropertyMap::operator[]" ref="g12ef2c1377e445577a0a1f967272ccdb" args="(const Key &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C, typename K, std::size_t i, typename T = typename C::ValueType, typename R = typename C::Reference&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Reference <a class="el" href="a00094.html">Dune::Amg::RandomAccessBundledPropertyMap</a>&lt; C, K, i, T, R &gt;::operator[]           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00197.html#ge58f9bb2fd78c2e34a8fa27a9370f66a">Key</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the property for a key. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The corresponding property. </dd></dl>

<p>References <a class="el" href="a00244.html#l00057">Dune::Amg::RandomAccessBundledPropertyMap&lt; C, K, i, T, R &gt;::index</a>.</p>

</div>
</div><p>
<a class="anchor" name="g04d9513e0514fce98d73e2799eb4e8a2"></a><!-- doxytag: member="Dune::Amg::PropertyGraphVertexPropertyMap::operator[]" ref="g04d9513e0514fce98d73e2799eb4e8a2" args="(const Vertex &amp;vertex) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G, std::size_t i&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Reference Dune::Amg::PropertyGraphVertexPropertyMap&lt; G, i &gt;::operator[]           </td>
          <td>(</td>
          <td class="paramtype">const Vertex &amp;&nbsp;</td>
          <td class="paramname"> <em>vertex</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the properties associated to a vertex. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vertex</em>&nbsp;</td><td>The vertex whose Properties we want. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g9fbeb9f55e40cb276c5286d3891e035c"></a><!-- doxytag: member="Dune::Amg::AggregatesMap::operator[]" ref="g9fbeb9f55e40cb276c5286d3891e035c" args="(const VertexDescriptor &amp;v) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const AggregatesMap&lt; V &gt;::AggregateDescriptor &amp; <a class="el" href="a00003.html">Dune::Amg::AggregatesMap</a>&lt; V &gt;::operator[]           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00197.html#gf657e8e9f35ddf9811f6ab7ea72ab9f5">VertexDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the aggregate a vertex belongs to. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>The vertex we want to know the aggregate of. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The aggregate the vertex is mapped to. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g3e07dfd73a8a798f722c4a09a25bfbd1"></a><!-- doxytag: member="Dune::Amg::AggregatesMap::operator[]" ref="g3e07dfd73a8a798f722c4a09a25bfbd1" args="(const VertexDescriptor &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">AggregatesMap&lt; V &gt;::AggregateDescriptor &amp; <a class="el" href="a00003.html">Dune::Amg::AggregatesMap</a>&lt; V &gt;::operator[]           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00197.html#gf657e8e9f35ddf9811f6ab7ea72ab9f5">VertexDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the aggregate a vertex belongs to. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>The vertex we want to know the aggregate of. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The aggregate the vertex is mapped to. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gcaf43b169afef93fa7ea3b431f3a60b8"></a><!-- doxytag: member="Dune::Amg::MatrixHierarchy::parallelInformation" ref="gcaf43b169afef93fa7ea3b431f3a60b8" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M, class IS, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const MatrixHierarchy&lt; M, IS, A &gt;::ParallelInformationHierarchy &amp; <a class="el" href="a00076.html">Dune::Amg::MatrixHierarchy</a>&lt; M, IS, A &gt;::parallelInformation           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the hierarchy of the parallel data distribution information. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The hierarchy of the parallel data distribution information. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gde1ec1e7156b45627e1cf79d4e901205"></a><!-- doxytag: member="Dune::Amg::AMG::post" ref="gde1ec1e7156b45627e1cf79d4e901205" args="(Domain &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M, class X, class S, class P, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00007.html">Dune::Amg::AMG</a>&lt; M, X, S, P, A &gt;::post           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00197.html#g2baddcf013a5166a162950672bd21a03">Domain</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clean up. <p>
This method is called after the last apply call for the linear system to be solved. Memory may be deallocated safely here. x is the solution of the linear equation.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The right hand side of the equation. </td></tr>
  </table>
</dl>
 
<p>Implements <a class="el" href="a00092.html#02d7633248cb4c68af7e0e787ec4029d">Dune::Preconditioner&lt; X, X &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="ga5289973434af337b81c8b7119efe832"></a><!-- doxytag: member="Dune::Amg::SmootherApplier::postSmooth" ref="ga5289973434af337b81c8b7119efe832" args="(Smoother &amp;smoother, Domain &amp;v, const Range &amp;d)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="a00112.html">Dune::Amg::SmootherApplier</a>&lt; T &gt;::postSmooth           </td>
          <td>(</td>
          <td class="paramtype">Smoother &amp;&nbsp;</td>
          <td class="paramname"> <em>smoother</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Domain &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range &amp;&nbsp;</td>
          <td class="paramname"> <em>d</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
apply post smoothing in forward direction 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>smoother</em>&nbsp;</td><td>The smoother to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>d</em>&nbsp;</td><td>The current defect. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>handle to store the update in. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gd3a49650f072cbdb92b3871e0c666459"></a><!-- doxytag: member="Dune::Amg::AMG::pre" ref="gd3a49650f072cbdb92b3871e0c666459" args="(Domain &amp;x, Range &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M, class X, class S, class P, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00007.html">Dune::Amg::AMG</a>&lt; M, X, S, P, A &gt;::pre           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00197.html#g2baddcf013a5166a162950672bd21a03">Domain</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00197.html#g7c0496b0f7de49193c227a8c93c045d1">Range</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prepare the preconditioner. <p>
A solver solves a linear operator equation A(x)=b by applying one or several steps of the preconditioner. The method <a class="el" href="a00092.html#d524e05b6c42f49fbe8b29577ae67265" title="Prepare the preconditioner.">pre()</a> is called before the first apply operation. b and x are right hand side and solution vector of the linear system respectively. It may. e.g., scale the system, allocate memory or compute a (I)LU decomposition. Note: The ILU decomposition could also be computed in the constructor or with a separate method of the derived method if several linear systems with the same matrix are to be solved.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The left hand side of the equation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>b</em>&nbsp;</td><td>The right hand side of the equation. </td></tr>
  </table>
</dl>
 
<p>Implements <a class="el" href="a00092.html#d524e05b6c42f49fbe8b29577ae67265">Dune::Preconditioner&lt; X, X &gt;</a>.</p>

<p>References <a class="el" href="a00250.html#l00041">Dune::Amg::DefaultSmootherArgs&lt; T &gt;::iterations</a>.</p>

</div>
</div><p>
<a class="anchor" name="geb9809e8ad5d1467042fd1f633cbc1bb"></a><!-- doxytag: member="Dune::Amg::SmootherApplier::preSmooth" ref="geb9809e8ad5d1467042fd1f633cbc1bb" args="(Smoother &amp;smoother, Domain &amp;v, const Range &amp;d)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="a00112.html">Dune::Amg::SmootherApplier</a>&lt; T &gt;::preSmooth           </td>
          <td>(</td>
          <td class="paramtype">Smoother &amp;&nbsp;</td>
          <td class="paramname"> <em>smoother</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Domain &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range &amp;&nbsp;</td>
          <td class="paramname"> <em>d</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
apply pre smoothing in forward direction 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>smoother</em>&nbsp;</td><td>The smoother to use. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>d</em>&nbsp;</td><td>The current defect. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>handle to store the update in. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gc6e00184177e96d465fdeeab78c6c11e"></a><!-- doxytag: member="Dune::Amg::PropertiesGraph::PropertiesGraph" ref="gc6e00184177e96d465fdeeab78c6c11e" args="(Graph &amp;graph, const VertexMap &amp;vmap=VertexMap(), const EdgeMap &amp;emap=EdgeMap())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class E, class VM, class EM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00093.html">Dune::Amg::PropertiesGraph</a>&lt; G, V, E, VM, EM &gt;::PropertiesGraph           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00093.html#6e83e9aa4e797967fa318b86459d0149">Graph</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00093.html#965116a5ca037414e1c5ae6ab342b8ad">VertexMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vmap</em> = <code><a class="el" href="a00093.html#965116a5ca037414e1c5ae6ab342b8ad">VertexMap</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00093.html#8179cbefa851d6c0094255659e1930a9">EdgeMap</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>emap</em> = <code><a class="el" href="a00093.html#8179cbefa851d6c0094255659e1930a9">EdgeMap</a>()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>graph</em>&nbsp;</td><td>The graph we attach properties to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vmap</em>&nbsp;</td><td>The map of the vertices onto indices. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>emap</em>&nbsp;</td><td>The map of the edges onto indices. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g413f22fe4fec3a48cf58acd5cc8d387d"></a><!-- doxytag: member="Dune::Amg::PropertyGraphVertexPropertyMap::PropertyGraphVertexPropertyMap" ref="g413f22fe4fec3a48cf58acd5cc8d387d" args="(G &amp;g)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G, std::size_t i&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Dune::Amg::PropertyGraphVertexPropertyMap&lt; G, i &gt;::PropertyGraphVertexPropertyMap           </td>
          <td>(</td>
          <td class="paramtype">G &amp;&nbsp;</td>
          <td class="paramname"> <em>g</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>g</em>&nbsp;</td><td>The graph whose properties we access. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g5c06b28bba4d8b06a46bf85bedff135f"></a><!-- doxytag: member="Dune::Amg::RandomAccessBundledPropertyMap::RandomAccessBundledPropertyMap" ref="g5c06b28bba4d8b06a46bf85bedff135f" args="(Container &amp;container)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename C, typename K, std::size_t i, typename T = typename C::ValueType, typename R = typename C::Reference&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00094.html">Dune::Amg::RandomAccessBundledPropertyMap</a>&lt; C, K, i, T, R &gt;::RandomAccessBundledPropertyMap           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00094.html#fe8f70a7b360908afd4d45ff50ffd901">Container</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>container</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>container</em>&nbsp;</td><td>The container with the property bundle. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g6e1b4740e614de707f5200a1fd4ed3b8"></a><!-- doxytag: member="Dune::Amg::MatrixHierarchy::recalculateGalerkin" ref="g6e1b4740e614de707f5200a1fd4ed3b8" args="(const F &amp;copyFlags)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M, class IS, class A&gt; </div>
<div class="memtemplate">
template&lt;class F&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00076.html">Dune::Amg::MatrixHierarchy</a>&lt; M, IS, A &gt;::recalculateGalerkin           </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&nbsp;</td>
          <td class="paramname"> <em>copyFlags</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Recalculate the galerkin products. 
<p>
If the data of the fine matrix changes but not its sparsity pattern this will recalculate all coarser level without starting the expensive aggregation process all over again. 
<p>References <a class="el" href="a00221.html#l00959">Dune::Amg::Hierarchy&lt; T, A &gt;::coarsest()</a>, and <a class="el" href="a00221.html#l00953">Dune::Amg::Hierarchy&lt; T, A &gt;::finest()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g3e3ec8317ac33f0484a3b68dbfacc883"></a><!-- doxytag: member="Dune::Amg::Aggregate::reconstruct" ref="g3e3ec8317ac33f0484a3b68dbfacc883" args="(const Vertex &amp;vertex)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00002.html">Dune::Amg::Aggregate</a>&lt; G &gt;::reconstruct           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00197.html#gabd0e12ceada9a070a742ea7652852d0">Vertex</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vertex</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reconstruct the aggregat from an seed node. 
<p>
Will determine all vertices of the same agggregate and reference those. 
<p>References <a class="el" href="a00203.html#l01333">Dune::Amg::Aggregate&lt; G &gt;::begin()</a>, and <a class="el" href="a00203.html#l01339">Dune::Amg::Aggregate&lt; G &gt;::end()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g112134619133e663798f050d995ee16e"></a><!-- doxytag: member="Dune::Amg::AggregationCriterion::setDebugLevel" ref="g112134619133e663798f050d995ee16e" args="(int level)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00005.html">Dune::Amg::AggregationCriterion</a>&lt; T &gt;::setDebugLevel           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the debugging level. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td>If 0 no debugging output will be generated. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ga21f58805bd7454756362314fa33ddc2"></a><!-- doxytag: member="Dune::Amg::VertexProperties::setIsolated" ref="ga21f58805bd7454756362314fa33ddc2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Dune::Amg::VertexProperties::setIsolated           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Marks that node as being isolated. 
<p>
A node is isolated if it ha not got any strong connections to other nodes in the matrix graph. 
</div>
</div><p>
<a class="anchor" name="g6ae3ed417f5b682d58d8486879193be2"></a><!-- doxytag: member="Dune::Amg::AggregationCriterion::setMaxAggregateSize" ref="g6ae3ed417f5b682d58d8486879193be2" args="(std::size_t size)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00005.html">Dune::Amg::AggregationCriterion</a>&lt; T &gt;::setMaxAggregateSize           </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the maximum number of nodes a aggregate is allowed to have. 
<p>
The default values is 6. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The maximum number of nodes. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g0fd73bf448c50c0c2c9d733ca09b00b9"></a><!-- doxytag: member="Dune::Amg::AggregationCriterion::setMaxConnectivity" ref="g0fd73bf448c50c0c2c9d733ca09b00b9" args="(std::size_t connectivity)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00005.html">Dune::Amg::AggregationCriterion</a>&lt; T &gt;::setMaxConnectivity           </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>connectivity</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the maximum number of connections a aggregate is allowed to have. 
<p>
This limit exists to achieve sparsity of the coarse matrix. the default value is 15.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>connectivity</em>&nbsp;</td><td>The maximum number of connections a aggregate is allowed to have. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g58f530da670bfa93fba3e127be07f913"></a><!-- doxytag: member="Dune::Amg::AggregationCriterion::setMaxDistance" ref="g58f530da670bfa93fba3e127be07f913" args="(std::size_t distance)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00005.html">Dune::Amg::AggregationCriterion</a>&lt; T &gt;::setMaxDistance           </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>distance</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the maximal distance allowed between to nodes in a aggregate. 
<p>
The distance between two nodes in a aggregate is the minimal number of edges it takes to travel from one node to the other without leaving the aggregate. The default value is 2. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>distance</em>&nbsp;</td><td>The maximum distance allowed. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g0bba564dcd870e6aff3f9bc114d2a715"></a><!-- doxytag: member="Dune::Amg::AggregationCriterion::setMinAggregateSize" ref="g0bba564dcd870e6aff3f9bc114d2a715" args="(std::size_t size)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00005.html">Dune::Amg::AggregationCriterion</a>&lt; T &gt;::setMinAggregateSize           </td>
          <td>(</td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>size</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the minimum number of nodes a aggregate has to consist of. 
<p>
the default value is 4. <dl class="return" compact><dt><b>Returns:</b></dt><dd>The minimum number of nodes. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g79e2f51c97c2ee301ef6ca9085b7c90c"></a><!-- doxytag: member="Dune::Amg::SparsityBuilder::SparsityBuilder" ref="g79e2f51c97c2ee301ef6ca9085b7c90c" args="(M &amp;matrix, const AggregatesMap&lt; V &gt; &amp;aggregates)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M, class V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00115.html">Dune::Amg::SparsityBuilder</a>&lt; M, V &gt;::SparsityBuilder           </td>
          <td>(</td>
          <td class="paramtype">M &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00003.html">AggregatesMap</a>&lt; V &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>aggregates</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>matrix</em>&nbsp;</td><td>The matrix whose sparsity pattern we should set up. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aggregates</em>&nbsp;</td><td>THe mapping of the vertices onto the aggregates. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gca352a31b817cd349df10182a2cd6adb"></a><!-- doxytag: member="Dune::Amg::SubGraph::SubGraph" ref="gca352a31b817cd349df10182a2cd6adb" args="(const Graph &amp;graph, const T &amp;excluded)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00116.html">Dune::Amg::SubGraph</a>&lt; G, T &gt;::SubGraph           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00116.html#afca1374f2584990399c44a7977ba6d8">Graph</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>excluded</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>graph</em>&nbsp;</td><td>The graph we are a sub graph for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>excluded</em>&nbsp;</td><td>If excluded[i] is true then vertex i will not appear in the sub graph. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g12cafb57c10c7811dc2b0b7cdbf16f7b"></a><!-- doxytag: member="Dune::Amg::SubGraph::VertexIterator::VertexIterator" ref="g12cafb57c10c7811dc2b0b7cdbf16f7b" args="(const VertexDescriptor &amp;current)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00116.html">Dune::Amg::SubGraph</a>&lt; G, T &gt;::VertexIterator::VertexIterator           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00116.html#e935b74e150a8a496b56457eb5372c40">VertexDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>current</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor for end iterator. 
<p>
Use with care! All operations except operator== or operator!= will fail! <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>current</em>&nbsp;</td><td>The position of the iterator. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g92ba1680cf48fa40dc3d1ca5f411f1d8"></a><!-- doxytag: member="Dune::Amg::SubGraph::VertexIterator::VertexIterator" ref="g92ba1680cf48fa40dc3d1ca5f411f1d8" args="(const SubGraph&lt; G, T &gt; *graph, const VertexDescriptor &amp;current, const VertexDescriptor &amp;end)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00116.html">Dune::Amg::SubGraph</a>&lt; G, T &gt;::VertexIterator::VertexIterator           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00116.html">SubGraph</a>&lt; G, T &gt; *&nbsp;</td>
          <td class="paramname"> <em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00116.html#e935b74e150a8a496b56457eb5372c40">VertexDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00116.html#e935b74e150a8a496b56457eb5372c40">VertexDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>graph</em>&nbsp;</td><td>The graph over whose vertices to iterate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>current</em>&nbsp;</td><td>The position of the iterator. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>end</em>&nbsp;</td><td>The last vertex of the graph. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g123a711f2e9030afc9a66f42246b193e"></a><!-- doxytag: member="Dune::Amg::PropertiesGraph::VertexIteratorT::VertexIteratorT" ref="g123a711f2e9030afc9a66f42246b193e" args="(const VertexIteratorT&lt; C1 &gt; &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class E, class VM, class EM&gt; </div>
<div class="memtemplate">
template&lt;class C&gt; </div>
<div class="memtemplate">
template&lt;class C1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00093.html">Dune::Amg::PropertiesGraph</a>&lt; G, V, E, VM, EM &gt;::VertexIteratorT&lt; C &gt;::VertexIteratorT           </td>
          <td>(</td>
          <td class="paramtype">const VertexIteratorT&lt; C1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy Constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>The iterator to copy. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g6f42fb07a1e17e57ef5486ede117c0dc"></a><!-- doxytag: member="Dune::Amg::PropertiesGraph::VertexIteratorT::VertexIteratorT" ref="g6f42fb07a1e17e57ef5486ede117c0dc" args="(const Father &amp;iter)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class E, class VM, class EM&gt; </div>
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00093.html">Dune::Amg::PropertiesGraph</a>&lt; G, V, E, VM, EM &gt;::VertexIteratorT&lt; C &gt;::VertexIteratorT           </td>
          <td>(</td>
          <td class="paramtype">const Father &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor for the end iterator. 
<p>
Only operator!= or operator== can be called safely on an iterator constructed this way. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>The iterator of the underlying graph. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g6edb278cbf18d9d1a674691f6f497f8e"></a><!-- doxytag: member="Dune::Amg::PropertiesGraph::VertexIteratorT::VertexIteratorT" ref="g6edb278cbf18d9d1a674691f6f497f8e" args="(const Father &amp;iter, C *graph)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class E, class VM, class EM&gt; </div>
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00093.html">Dune::Amg::PropertiesGraph</a>&lt; G, V, E, VM, EM &gt;::VertexIteratorT&lt; C &gt;::VertexIteratorT           </td>
          <td>(</td>
          <td class="paramtype">const Father &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C *&nbsp;</td>
          <td class="paramname"> <em>graph</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>The iterator of the underlying graph. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>graph</em>&nbsp;</td><td>The property graph over whose vertices we iterate. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g0b0c7be96a78253b7aa47f0a0ae53d42"></a><!-- doxytag: member="Dune::Amg::VertexPropertiesGraph::VertexIteratorT::VertexIteratorT" ref="g0b0c7be96a78253b7aa47f0a0ae53d42" args="(const VertexIteratorT&lt; C1 &gt; &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class VM&gt; </div>
<div class="memtemplate">
template&lt;class C&gt; </div>
<div class="memtemplate">
template&lt;class C1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00132.html">Dune::Amg::VertexPropertiesGraph</a>&lt; G, V, VM &gt;::VertexIteratorT&lt; C &gt;::VertexIteratorT           </td>
          <td>(</td>
          <td class="paramtype">const VertexIteratorT&lt; C1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy Constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>The iterator to copy. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g07c621275b95483308553715fdc2aee3"></a><!-- doxytag: member="Dune::Amg::VertexPropertiesGraph::VertexIteratorT::VertexIteratorT" ref="g07c621275b95483308553715fdc2aee3" args="(const Father &amp;iter)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class VM&gt; </div>
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00132.html">Dune::Amg::VertexPropertiesGraph</a>&lt; G, V, VM &gt;::VertexIteratorT&lt; C &gt;::VertexIteratorT           </td>
          <td>(</td>
          <td class="paramtype">const Father &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor for the end iterator. 
<p>
Only operator!= or operator== can be calles safely on an iterator constructed this way. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>The iterator of the underlying graph. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g17f48954d19d2f63018e407edd28798f"></a><!-- doxytag: member="Dune::Amg::VertexPropertiesGraph::VertexIteratorT::VertexIteratorT" ref="g17f48954d19d2f63018e407edd28798f" args="(const Father &amp;iter, C *graph)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class VM&gt; </div>
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00132.html">Dune::Amg::VertexPropertiesGraph</a>&lt; G, V, VM &gt;::VertexIteratorT&lt; C &gt;::VertexIteratorT           </td>
          <td>(</td>
          <td class="paramtype">const Father &amp;&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C *&nbsp;</td>
          <td class="paramname"> <em>graph</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>iter</em>&nbsp;</td><td>The iterator of the underlying graph. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>graph</em>&nbsp;</td><td>The property graph over whose vertices we iterate. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gf1197531cc84fa49ba85b6db19be4820"></a><!-- doxytag: member="Dune::Amg::MatrixGraph::VertexIteratorT::VertexIteratorT" ref="gf1197531cc84fa49ba85b6db19be4820" args="(const VertexDescriptor &amp;current)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M&gt; </div>
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00073.html">Dune::Amg::MatrixGraph</a>&lt; M &gt;::VertexIteratorT&lt; C &gt;::VertexIteratorT           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00073.html#594cca89416b534b0b1a196c39684447">VertexDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>current</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor for the end iterator. 
<p>
only operator== or operator!= may be called safely on an iterator constructed this way. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>current</em>&nbsp;</td><td>The current vertex to position on. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g146dbe671efc5a73ddcfb532a99d31f2"></a><!-- doxytag: member="Dune::Amg::MatrixGraph::VertexIteratorT::VertexIteratorT" ref="g146dbe671efc5a73ddcfb532a99d31f2" args="(C *graph, const VertexDescriptor &amp;current)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class M&gt; </div>
<div class="memtemplate">
template&lt;class C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00073.html">Dune::Amg::MatrixGraph</a>&lt; M &gt;::VertexIteratorT&lt; C &gt;::VertexIteratorT           </td>
          <td>(</td>
          <td class="paramtype">C *&nbsp;</td>
          <td class="paramname"> <em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00073.html#594cca89416b534b0b1a196c39684447">VertexDescriptor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>current</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>graph</em>&nbsp;</td><td>The graph we are a vertex iterator for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>current</em>&nbsp;</td><td>The current vertex to position on. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g09a6c029c377ec63b41de5f9066ab607"></a><!-- doxytag: member="Dune::Amg::VertexPropertiesGraph::VertexPropertiesGraph" ref="g09a6c029c377ec63b41de5f9066ab607" args="(Graph &amp;graph, const VertexMap vmap=VertexMap())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V, class VM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00132.html">Dune::Amg::VertexPropertiesGraph</a>&lt; G, V, VM &gt;::VertexPropertiesGraph           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00132.html#8303ceadc9d95572dbb3300be69a6409">Graph</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00132.html#88642539b218faf3c732d6e6ded01498">VertexMap</a>&nbsp;</td>
          <td class="paramname"> <em>vmap</em> = <code><a class="el" href="a00132.html#88642539b218faf3c732d6e6ded01498">VertexMap</a>()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>graph</em>&nbsp;</td><td>The graph we attach properties to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vmap</em>&nbsp;</td><td>The vertex map. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g647bb4cab2e448223bad5af1800a7dff"></a><!-- doxytag: member="Dune::Amg::visitNeighbours" ref="g647bb4cab2e448223bad5af1800a7dff" args="(const G &amp;graph, const typename G::VertexDescriptor &amp;vertex, V &amp;visitor)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G, class V&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int Dune::Amg::visitNeighbours           </td>
          <td>(</td>
          <td class="paramtype">const G &amp;&nbsp;</td>
          <td class="paramname"> <em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename G::VertexDescriptor &amp;&nbsp;</td>
          <td class="paramname"> <em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&nbsp;</td>
          <td class="paramname"> <em>visitor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Visit all neighbour vertices of a vertex in a graph. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>graph</em>&nbsp;</td><td>The graph whose vertices to visit. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vertex</em>&nbsp;</td><td>The vertex whose neighbours we want to visit. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>visitor</em>&nbsp;</td><td>The visitor evaluated for each EdgeIterator (by its method operator()(const ConstEdgeIterator&amp; edge) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of neighbours of the vertex. </dd></dl>

<p>References <a class="el" href="a00218.html#l02251">Dune::Amg::PropertiesGraph&lt; G, VP, EP, VM, EM &gt;::end()</a>.</p>

</div>
</div><p>
</div>
</div> <!-- end doxygen -->
</div> <!-- end main -->
<div class="foot">

<p class="foot">
  Generated on 6 Nov 2008 with <a
  href="http://www.doxygen.org/">Doxygen</a> (ver 1.5.6)  
  [<a href="doxygen.log">logfile</a>].
</p>

</div>

</body>
</html>
