<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN""http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>dune-istl: schwarz.hh Source File (dune-istl )</title>
  <link rel="stylesheet" type="text/css" href="./dune-doxy.css">
  <link rel="stylesheet" type="text/css" href="./tabs.css">
</head>
<div class="main">
<div class="doxygen">
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_39c25fa0261c9359275e2f8975608afb.html">istl</a>
  </div>
</div>
<div class="contents">
<h1>schwarz.hh</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef DUNE_SCHWARZ_HH</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define DUNE_SCHWARZ_HH</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="preprocessor">#include &lt;iostream&gt;</span>              <span class="comment">// for input/output to shell</span>
<a name="l00005"></a>00005 <span class="preprocessor">#include &lt;fstream&gt;</span>               <span class="comment">// for input/output to files</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include &lt;vector&gt;</span>                <span class="comment">// STL vector class</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include &lt;sstream&gt;</span>
<a name="l00008"></a>00008 
<a name="l00009"></a>00009 <span class="preprocessor">#include &lt;cmath&gt;</span>                <span class="comment">// Yes, we do some math here</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include &lt;sys/times.h&gt;</span>           <span class="comment">// for timing measurements</span>
<a name="l00011"></a>00011 
<a name="l00012"></a>00012 <span class="preprocessor">#include &lt;dune/common/timer.hh&gt;</span>
<a name="l00013"></a>00013 
<a name="l00014"></a>00014 <span class="preprocessor">#include"<a class="code" href="a00157.html" title="Some generic functions for pretty printing vectors and matrices.">io.hh</a>"</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include"<a class="code" href="a00140.html" title="This file implements a vector space as a tensor product of a given vector space....">bvector.hh</a>"</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include"<a class="code" href="a00187.html" title="???">vbvector.hh</a>"</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include"<a class="code" href="a00138.html" title="Implementation of the BCRSMatrix class.">bcrsmatrix.hh</a>"</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include"<a class="code" href="a00157.html" title="Some generic functions for pretty printing vectors and matrices.">io.hh</a>"</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include"<a class="code" href="a00150.html" title="Simple iterative methods like Jacobi, Gauss-Seidel, SOR, SSOR, etc. in a generic...">gsetc.hh</a>"</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include"<a class="code" href="a00152.html" title="???">ilu.hh</a>"</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include"<a class="code" href="a00166.html" title="Define general, extensible interface for operators. The available implementation...">operators.hh</a>"</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include"<a class="code" href="a00182.html" title="Define general, extensible interface for inverse operators.">solvers.hh</a>"</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include"<a class="code" href="a00173.html" title="Define general preconditioner interface.">preconditioners.hh</a>"</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include"<a class="code" href="a00177.html" title="Define base class for scalar product and norm.">scalarproducts.hh</a>"</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include"<a class="code" href="a00168.html" title="Classes providing communication interfaces for overlapping Schwarz methods.">owneroverlapcopy.hh</a>"</span>
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 <span class="keyword">namespace </span>Dune {
<a name="l00028"></a>00028 
<a name="l00057"></a>00057   <span class="keyword">template</span>&lt;<span class="keyword">class</span> M, <span class="keyword">class</span> X, <span class="keyword">class</span> Y, <span class="keyword">class</span> C&gt;
<a name="l00058"></a><a class="code" href="a00083.html">00058</a>   <span class="keyword">class </span><a class="code" href="a00083.html" title="An overlapping schwarz operator.">OverlappingSchwarzOperator</a> : <span class="keyword">public</span> <a class="code" href="a00008.html" title="A linear operator exporting itself in matrix form.">AssembledLinearOperator</a>&lt;M,X,Y&gt;
<a name="l00059"></a>00059   {
<a name="l00060"></a>00060   <span class="keyword">public</span>:
<a name="l00062"></a><a class="code" href="a00083.html#d93bebea5fa3e8e78adcb1a7974a76b5">00062</a>         <span class="keyword">typedef</span> M <a class="code" href="a00083.html#d93bebea5fa3e8e78adcb1a7974a76b5" title="The type of the matrix we operate on.">matrix_type</a>;
<a name="l00064"></a><a class="code" href="a00083.html#d7aff8104d7495a55ae19732a68aa55d">00064</a>         <span class="keyword">typedef</span> X <a class="code" href="a00083.html#d7aff8104d7495a55ae19732a68aa55d" title="The type of the domain.">domain_type</a>;
<a name="l00066"></a><a class="code" href="a00083.html#dc1a077ec0f64307451e89ee237dc40d">00066</a>         <span class="keyword">typedef</span> Y <a class="code" href="a00083.html#dc1a077ec0f64307451e89ee237dc40d" title="The type of the range.">range_type</a>;
<a name="l00068"></a><a class="code" href="a00083.html#e1e7f3c84315220220bd995dc64d379a">00068</a>         <span class="keyword">typedef</span> <span class="keyword">typename</span> X::field_type <a class="code" href="a00083.html#e1e7f3c84315220220bd995dc64d379a" title="The field type of the range.">field_type</a>;
<a name="l00070"></a><a class="code" href="a00083.html#afc9bff73a9c5544c16e94a834b1b6e9">00070</a>     <span class="keyword">typedef</span> C <a class="code" href="a00083.html#afc9bff73a9c5544c16e94a834b1b6e9" title="The type of the communication object.">communication_type</a>;
<a name="l00071"></a>00071     
<a name="l00072"></a>00072         <span class="keyword">enum</span> {
<a name="l00074"></a><a class="code" href="a00083.html#b4abd5f19d54e0e8a94891a830a336840c9a350546a85251c12c85cde4f74812">00074</a>           <a class="code" href="a00083.html#b4abd5f19d54e0e8a94891a830a336840c9a350546a85251c12c85cde4f74812" title="The solver category.">category</a>=<a class="code" href="a00114.html#c8ffad5e3e40145669da6089b16c9574fa10e78074c8114bcbcd6dfae4dc0888" title="Category for ovelapping solvers.">SolverCategory::overlapping</a>
<a name="l00075"></a>00075         };
<a name="l00076"></a>00076 
<a name="l00084"></a><a class="code" href="a00083.html#e4b3bc2a2c64c06f2df67d8b698ea7b0">00084</a>         <a class="code" href="a00083.html#e4b3bc2a2c64c06f2df67d8b698ea7b0" title="constructor: just store a reference to a matrix.">OverlappingSchwarzOperator</a> (<span class="keyword">const</span> <a class="code" href="a00083.html#d93bebea5fa3e8e78adcb1a7974a76b5" title="The type of the matrix we operate on.">matrix_type</a>&amp; A, <span class="keyword">const</span> <a class="code" href="a00083.html#afc9bff73a9c5544c16e94a834b1b6e9" title="The type of the communication object.">communication_type</a>&amp; com) 
<a name="l00085"></a>00085           : _A_(A), communication(com) 
<a name="l00086"></a>00086         {}
<a name="l00087"></a>00087 
<a name="l00089"></a><a class="code" href="a00083.html#c608da4e6e93e2a32bfa7de007dfc90a">00089</a>         <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="a00083.html#c608da4e6e93e2a32bfa7de007dfc90a" title="apply operator to x: ">apply</a> (<span class="keyword">const</span> X&amp; x, Y&amp; y)<span class="keyword"> const</span>
<a name="l00090"></a>00090 <span class="keyword">        </span>{
<a name="l00091"></a>00091           y = 0;
<a name="l00092"></a>00092           _A_.umv(x,y); <span class="comment">// result is consistent on interior+border</span>
<a name="l00093"></a>00093           communication.project(y); <span class="comment">// we want this here to avoid it before the preconditioner</span>
<a name="l00094"></a>00094                                     <span class="comment">// since there d is const!</span>
<a name="l00095"></a>00095         }
<a name="l00096"></a>00096 
<a name="l00098"></a><a class="code" href="a00083.html#2ea4214331f4b16044e726b788b6d928">00098</a>         <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="a00083.html#2ea4214331f4b16044e726b788b6d928" title="apply operator to x, scale and add: ">applyscaleadd</a> (<a class="code" href="a00083.html#e1e7f3c84315220220bd995dc64d379a" title="The field type of the range.">field_type</a> alpha, <span class="keyword">const</span> X&amp; x, Y&amp; y)<span class="keyword"> const</span>
<a name="l00099"></a>00099 <span class="keyword">        </span>{
<a name="l00100"></a>00100           _A_.usmv(alpha,x,y); <span class="comment">// result is consistent on interior+border</span>
<a name="l00101"></a>00101           communication.project(y); <span class="comment">// we want this here to avoid it before the preconditioner</span>
<a name="l00102"></a>00102                                     <span class="comment">// since there d is const!</span>
<a name="l00103"></a>00103         }
<a name="l00104"></a>00104 
<a name="l00106"></a><a class="code" href="a00083.html#37432ca0e08471b6f0f58f62bfb91efc">00106</a>         <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="a00083.html#d93bebea5fa3e8e78adcb1a7974a76b5" title="The type of the matrix we operate on.">matrix_type</a>&amp; <a class="code" href="a00083.html#37432ca0e08471b6f0f58f62bfb91efc" title="get matrix via *">getmat</a> ()<span class="keyword"> const</span>
<a name="l00107"></a>00107 <span class="keyword">        </span>{
<a name="l00108"></a>00108           <span class="keywordflow">return</span> _A_;
<a name="l00109"></a>00109         }
<a name="l00110"></a>00110 
<a name="l00111"></a>00111   <span class="keyword">private</span>:
<a name="l00112"></a>00112         <span class="keyword">const</span> <a class="code" href="a00083.html#d93bebea5fa3e8e78adcb1a7974a76b5" title="The type of the matrix we operate on.">matrix_type</a>&amp; _A_;
<a name="l00113"></a>00113         <span class="keyword">const</span> <a class="code" href="a00083.html#afc9bff73a9c5544c16e94a834b1b6e9" title="The type of the communication object.">communication_type</a>&amp; communication;
<a name="l00114"></a>00114   };
<a name="l00115"></a>00115 
<a name="l00127"></a>00127   <span class="keyword">template</span>&lt;<span class="keyword">class</span> X, <span class="keyword">class</span> C&gt;
<a name="l00128"></a><a class="code" href="a00084.html">00128</a>   <span class="keyword">class </span><a class="code" href="a00084.html" title="Scalar product for overlapping schwarz methods.">OverlappingSchwarzScalarProduct</a> : <span class="keyword">public</span> <a class="code" href="a00099.html" title="Base class for scalar product and norm computation.">ScalarProduct</a>&lt;X&gt;
<a name="l00129"></a>00129   {
<a name="l00130"></a>00130   <span class="keyword">public</span>:
<a name="l00132"></a><a class="code" href="a00084.html#cef730db3338bd7ddf9300fde5505267">00132</a>         <span class="keyword">typedef</span> X <a class="code" href="a00084.html#cef730db3338bd7ddf9300fde5505267" title="The type of the domain.">domain_type</a>;
<a name="l00134"></a><a class="code" href="a00084.html#df1b7eedc5e455a027ec5e33f6425a31">00134</a>         <span class="keyword">typedef</span> <span class="keyword">typename</span> X::field_type <a class="code" href="a00084.html#df1b7eedc5e455a027ec5e33f6425a31" title="The type of the range.">field_type</a>;
<a name="l00136"></a><a class="code" href="a00084.html#45c2d5dccdd79fd6d74d57c8cfc3bc46">00136</a>     <span class="keyword">typedef</span> C <a class="code" href="a00084.html#45c2d5dccdd79fd6d74d57c8cfc3bc46" title="The type of the communication object.">communication_type</a>;
<a name="l00137"></a>00137     
<a name="l00139"></a>00139         <span class="keyword">enum</span> {category=<a class="code" href="a00114.html#c8ffad5e3e40145669da6089b16c9574fa10e78074c8114bcbcd6dfae4dc0888" title="Category for ovelapping solvers.">SolverCategory::overlapping</a>};
<a name="l00140"></a>00140 
<a name="l00145"></a><a class="code" href="a00084.html#e82bd00b5a0f443e2d9dd1c8cd62b0c4">00145</a>         <a class="code" href="a00084.html#e82bd00b5a0f443e2d9dd1c8cd62b0c4" title="Constructor needs to know the grid.">OverlappingSchwarzScalarProduct</a> (<span class="keyword">const</span> <a class="code" href="a00084.html#45c2d5dccdd79fd6d74d57c8cfc3bc46" title="The type of the communication object.">communication_type</a>&amp; com)
<a name="l00146"></a>00146           : communication(com)
<a name="l00147"></a>00147         {}
<a name="l00148"></a>00148 
<a name="l00153"></a><a class="code" href="a00084.html#cbaeed303f149eceb678d79d0679839f">00153</a>         <span class="keyword">virtual</span> <a class="code" href="a00084.html#df1b7eedc5e455a027ec5e33f6425a31" title="The type of the range.">field_type</a> <a class="code" href="a00084.html#cbaeed303f149eceb678d79d0679839f" title="Dot product of two vectors. It is assumed that the vectors are consistent on the...">dot</a> (<span class="keyword">const</span> X&amp; x, <span class="keyword">const</span> X&amp; y)
<a name="l00154"></a>00154         {
<a name="l00155"></a>00155           <a class="code" href="a00084.html#df1b7eedc5e455a027ec5e33f6425a31" title="The type of the range.">field_type</a> result;
<a name="l00156"></a>00156           communication.dot(x,y,result);
<a name="l00157"></a>00157           <span class="keywordflow">return</span> result;
<a name="l00158"></a>00158         }
<a name="l00159"></a>00159 
<a name="l00163"></a><a class="code" href="a00084.html#2a03a55199faa35b55ed41f8fbfd7fe7">00163</a>         <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="a00084.html#2a03a55199faa35b55ed41f8fbfd7fe7" title="Norm of a right-hand side vector. The vector must be consistent on the interior+border...">norm</a> (<span class="keyword">const</span> X&amp; x)
<a name="l00164"></a>00164         {
<a name="l00165"></a>00165           <span class="keywordflow">return</span> communication.norm(x);
<a name="l00166"></a>00166         }
<a name="l00167"></a>00167 
<a name="l00168"></a>00168   <span class="keyword">private</span>:
<a name="l00169"></a>00169         <span class="keyword">const</span> <a class="code" href="a00084.html#45c2d5dccdd79fd6d74d57c8cfc3bc46" title="The type of the communication object.">communication_type</a>&amp; communication;
<a name="l00170"></a>00170   };
<a name="l00171"></a>00171 
<a name="l00172"></a>00172   <span class="keyword">template</span>&lt;<span class="keyword">class</span> X, <span class="keyword">class</span> C&gt;
<a name="l00173"></a>00173   <span class="keyword">struct </span>ScalarProductChooser&lt;X,C,SolverCategory::overlapping&gt;
<a name="l00174"></a>00174   {
<a name="l00176"></a>00176     <span class="keyword">typedef</span> OverlappingSchwarzScalarProduct&lt;X,C&gt; ScalarProduct;
<a name="l00178"></a>00178     <span class="keyword">typedef</span> C <a class="code" href="a00100.html#b7c06745fd9c563f73837c194a52582b" title="The type of the communication object.">communication_type</a>;
<a name="l00179"></a>00179 
<a name="l00180"></a>00180     <span class="keyword">enum</span>{
<a name="l00182"></a>00182       <a class="code" href="a00100.html#d99c752fef17ea84b2b1203c4f47de1dbb668a8f1f9b0dbb565f2535c190e123" title="The solver category.">solverCategory</a>=<a class="code" href="a00114.html#c8ffad5e3e40145669da6089b16c9574fa10e78074c8114bcbcd6dfae4dc0888" title="Category for ovelapping solvers.">SolverCategory::overlapping</a>
<a name="l00183"></a>00183         };
<a name="l00184"></a>00184 
<a name="l00185"></a>00185     <span class="keyword">static</span> ScalarProduct* construct(<span class="keyword">const</span> <a class="code" href="a00100.html#b7c06745fd9c563f73837c194a52582b" title="The type of the communication object.">communication_type</a>&amp; comm)
<a name="l00186"></a>00186     {
<a name="l00187"></a>00187       <span class="keywordflow">return</span> <span class="keyword">new</span> ScalarProduct(comm);
<a name="l00188"></a>00188     }
<a name="l00189"></a>00189   };
<a name="l00190"></a>00190 
<a name="l00197"></a>00197 
<a name="l00198"></a>00198   <span class="keyword">template</span>&lt;<span class="keyword">class</span> M, <span class="keyword">class</span> X, <span class="keyword">class</span> Y, <span class="keyword">class</span> C&gt;
<a name="l00199"></a><a class="code" href="a00091.html">00199</a>   <span class="keyword">class </span><a class="code" href="a00091.html" title="A parallel SSOR preconditioner.">ParSSOR</a> : <span class="keyword">public</span> <a class="code" href="a00092.html" title="Base class for matrix free definition of preconditioners.">Preconditioner</a>&lt;X,Y&gt; {
<a name="l00200"></a>00200   <span class="keyword">public</span>:
<a name="l00202"></a><a class="code" href="a00091.html#a520a2569391532c1bb6bea8c3d51cfe">00202</a>     <span class="keyword">typedef</span> M <a class="code" href="a00091.html#a520a2569391532c1bb6bea8c3d51cfe" title="The matrix type the preconditioner is for.">matrix_type</a>;
<a name="l00204"></a><a class="code" href="a00091.html#6fe9b3290c12e9da0daa878958382dce">00204</a>     <span class="keyword">typedef</span> X <a class="code" href="a00091.html#6fe9b3290c12e9da0daa878958382dce" title="The domain type of the preconditioner.">domain_type</a>;
<a name="l00206"></a><a class="code" href="a00091.html#81e2c62a301e23cc2e269448abeb9ff2">00206</a>     <span class="keyword">typedef</span> Y <a class="code" href="a00091.html#81e2c62a301e23cc2e269448abeb9ff2" title="The range type of the preconditioner.">range_type</a>;
<a name="l00208"></a><a class="code" href="a00091.html#059ec0e8a44561c2791bf29e242bf010">00208</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> X::field_type <a class="code" href="a00091.html#059ec0e8a44561c2791bf29e242bf010" title="The field type of the preconditioner.">field_type</a>;
<a name="l00210"></a><a class="code" href="a00091.html#14ccc9445c0de022218e2799b86a5038">00210</a>     <span class="keyword">typedef</span> C <a class="code" href="a00091.html#14ccc9445c0de022218e2799b86a5038" title="The type of the communication object.">communication_type</a>;
<a name="l00211"></a>00211     
<a name="l00212"></a>00212     <span class="comment">// define the category</span>
<a name="l00213"></a>00213     <span class="keyword">enum</span> {
<a name="l00215"></a><a class="code" href="a00091.html#f29091604eab0ecb77b03b878290acdd68f76453755c66702ce62e80f0f1536f">00215</a>       <a class="code" href="a00091.html#f29091604eab0ecb77b03b878290acdd68f76453755c66702ce62e80f0f1536f" title="The category the precondtioner is part of.">category</a>=<a class="code" href="a00114.html#c8ffad5e3e40145669da6089b16c9574fa10e78074c8114bcbcd6dfae4dc0888" title="Category for ovelapping solvers.">SolverCategory::overlapping</a>};
<a name="l00216"></a>00216     
<a name="l00226"></a><a class="code" href="a00091.html#5e5b3f1f8d25f4f27be9174db67b2f3b">00226</a>     <a class="code" href="a00091.html#5e5b3f1f8d25f4f27be9174db67b2f3b" title="Constructor.">ParSSOR</a> (<span class="keyword">const</span> <a class="code" href="a00091.html#a520a2569391532c1bb6bea8c3d51cfe" title="The matrix type the preconditioner is for.">matrix_type</a>&amp; A, <span class="keywordtype">int</span> n, <a class="code" href="a00091.html#059ec0e8a44561c2791bf29e242bf010" title="The field type of the preconditioner.">field_type</a> w, <span class="keyword">const</span> <a class="code" href="a00091.html#14ccc9445c0de022218e2799b86a5038" title="The type of the communication object.">communication_type</a>&amp; c)
<a name="l00227"></a>00227       : _A_(A), _n(n), _w(w), communication(c)
<a name="l00228"></a>00228     {   }
<a name="l00229"></a>00229 
<a name="l00235"></a><a class="code" href="a00091.html#ef35f3db486419588682ed9f1dff6c1d">00235</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="a00091.html#ef35f3db486419588682ed9f1dff6c1d" title="Prepare the preconditioner.">pre</a> (X&amp; x, Y&amp; b) 
<a name="l00236"></a>00236         {
<a name="l00237"></a>00237           communication.copyOwnerToAll(x,x); <span class="comment">// make dirichlet values consistent</span>
<a name="l00238"></a>00238         }
<a name="l00239"></a>00239 
<a name="l00245"></a><a class="code" href="a00091.html#bc2402f453ff66be359372f52fa76e74">00245</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="a00091.html#bc2402f453ff66be359372f52fa76e74" title="Apply the precondtioner.">apply</a> (X&amp; v, <span class="keyword">const</span> Y&amp; d)
<a name="l00246"></a>00246     {
<a name="l00247"></a>00247       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;_n; i++){
<a name="l00248"></a>00248                 <a class="code" href="a00202.html#g4c250fe4ba236b00884d4055a6c17450" title="SOR step.">bsorf</a>(_A_,v,d,_w);
<a name="l00249"></a>00249                 <a class="code" href="a00202.html#g481cf6bb612fcb42577830118fdd7be5" title="SSOR step.">bsorb</a>(_A_,v,d,_w);
<a name="l00250"></a>00250       }
<a name="l00251"></a>00251           communication.copyOwnerToAll(v,v);
<a name="l00252"></a>00252     }
<a name="l00253"></a>00253 
<a name="l00259"></a><a class="code" href="a00091.html#66ce39857cfd15841a543f0a697c4b98">00259</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="a00091.html#66ce39857cfd15841a543f0a697c4b98" title="Clean up.">post</a> (X&amp; x) {}
<a name="l00260"></a>00260 
<a name="l00261"></a>00261   <span class="keyword">private</span>:
<a name="l00263"></a>00263     <span class="keyword">const</span> <a class="code" href="a00091.html#a520a2569391532c1bb6bea8c3d51cfe" title="The matrix type the preconditioner is for.">matrix_type</a>&amp; _A_;
<a name="l00265"></a>00265     <span class="keywordtype">int</span> _n;
<a name="l00267"></a>00267     <a class="code" href="a00091.html#059ec0e8a44561c2791bf29e242bf010" title="The field type of the preconditioner.">field_type</a> _w;
<a name="l00269"></a>00269         <span class="keyword">const</span> <a class="code" href="a00091.html#14ccc9445c0de022218e2799b86a5038" title="The type of the communication object.">communication_type</a>&amp; communication;
<a name="l00270"></a>00270   };
<a name="l00271"></a>00271 
<a name="l00272"></a>00272   <span class="keyword">namespace </span>Amg
<a name="l00273"></a>00273   {
<a name="l00274"></a>00274     <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">class </span>ConstructionTraits;
<a name="l00275"></a>00275   }
<a name="l00276"></a>00276 
<a name="l00285"></a>00285   <span class="keyword">template</span>&lt;<span class="keyword">class</span> X, <span class="keyword">class</span> Y, <span class="keyword">class</span> C, <span class="keyword">class</span> T=Preconditioner&lt;X,Y&gt; &gt;
<a name="l00286"></a><a class="code" href="a00021.html">00286</a>   <span class="keyword">class </span><a class="code" href="a00021.html" title="Block parallel preconditioner.">BlockPreconditioner</a> : <span class="keyword">public</span> <a class="code" href="a00092.html" title="Base class for matrix free definition of preconditioners.">Preconditioner</a>&lt;X,Y&gt; {
<a name="l00287"></a>00287     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00037.html" title="Traits class for generically constructing non default constructable types.">Amg::ConstructionTraits</a>&lt;BlockPreconditioner&lt;X,Y,C,T&gt; &gt;;
<a name="l00288"></a>00288   <span class="keyword">public</span>:
<a name="l00290"></a><a class="code" href="a00021.html#15efcc21c550a36f6168c40ca3ed6a62">00290</a>     <span class="keyword">typedef</span> X <a class="code" href="a00021.html#15efcc21c550a36f6168c40ca3ed6a62" title="The domain type of the preconditioner.">domain_type</a>;
<a name="l00292"></a><a class="code" href="a00021.html#36f36f1b3fc938e6e5156122a62fe90a">00292</a>     <span class="keyword">typedef</span> Y <a class="code" href="a00021.html#36f36f1b3fc938e6e5156122a62fe90a" title="The range type of the preconditioner.">range_type</a>;
<a name="l00294"></a><a class="code" href="a00021.html#f66872e60308207a7e25556efabfa803">00294</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> X::field_type <a class="code" href="a00021.html#f66872e60308207a7e25556efabfa803" title="The field type of the preconditioner.">field_type</a>;
<a name="l00296"></a><a class="code" href="a00021.html#497ff212c89155c45ae2ec93dc6f1bde">00296</a>     <span class="keyword">typedef</span> C <a class="code" href="a00021.html#497ff212c89155c45ae2ec93dc6f1bde" title="The type of the communication object.">communication_type</a>;
<a name="l00297"></a>00297 
<a name="l00298"></a>00298     <span class="comment">// define the category</span>
<a name="l00299"></a>00299     <span class="keyword">enum</span> {
<a name="l00301"></a><a class="code" href="a00021.html#f8b5da2e9d63aa4a609a612d497a85a05598c7158bb06605112dbb37d5003f86">00301</a>       <a class="code" href="a00021.html#f8b5da2e9d63aa4a609a612d497a85a05598c7158bb06605112dbb37d5003f86" title="The category the precondtioner is part of.">category</a>=<a class="code" href="a00114.html#c8ffad5e3e40145669da6089b16c9574fa10e78074c8114bcbcd6dfae4dc0888" title="Category for ovelapping solvers.">SolverCategory::overlapping</a>};
<a name="l00302"></a>00302     
<a name="l00310"></a><a class="code" href="a00021.html#4200a047825a7ba0ba1d41c47d69d745">00310</a>     <a class="code" href="a00021.html#4200a047825a7ba0ba1d41c47d69d745" title="Constructor.">BlockPreconditioner</a> (T&amp; p, <span class="keyword">const</span> <a class="code" href="a00021.html#497ff212c89155c45ae2ec93dc6f1bde" title="The type of the communication object.">communication_type</a>&amp; c)
<a name="l00311"></a>00311       : preconditioner(p), communication(c)
<a name="l00312"></a>00312     {   }
<a name="l00313"></a>00313 
<a name="l00319"></a><a class="code" href="a00021.html#9a85095ac17d62a65ef1e14ce41b9d9f">00319</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="a00021.html#9a85095ac17d62a65ef1e14ce41b9d9f" title="Prepare the preconditioner.">pre</a> (X&amp; x, Y&amp; b) 
<a name="l00320"></a>00320         {
<a name="l00321"></a>00321           communication.copyOwnerToAll(x,x); <span class="comment">// make dirichlet values consistent</span>
<a name="l00322"></a>00322           preconditioner.pre(x,b);
<a name="l00323"></a>00323         }
<a name="l00324"></a>00324 
<a name="l00330"></a><a class="code" href="a00021.html#f94c9ce904767c1430b7bd429a359860">00330</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="a00021.html#f94c9ce904767c1430b7bd429a359860" title="Apply the preconditioner.">apply</a> (X&amp; v, <span class="keyword">const</span> Y&amp; d)
<a name="l00331"></a>00331     {
<a name="l00332"></a>00332           preconditioner.apply(v,d);
<a name="l00333"></a>00333           communication.copyOwnerToAll(v,v);
<a name="l00334"></a>00334     }
<a name="l00335"></a>00335 
<a name="l00341"></a><a class="code" href="a00021.html#55b04fae5f0728e88d63c44332af7243">00341</a>     <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="a00021.html#55b04fae5f0728e88d63c44332af7243" title="Clean up.">post</a> (X&amp; x) 
<a name="l00342"></a>00342         {
<a name="l00343"></a>00343           preconditioner.post(x);
<a name="l00344"></a>00344         }
<a name="l00345"></a>00345 
<a name="l00346"></a>00346   <span class="keyword">private</span>:
<a name="l00348"></a>00348         <a class="code" href="a00092.html" title="Base class for matrix free definition of preconditioners.">Preconditioner&lt;X,Y&gt;</a>&amp; preconditioner;
<a name="l00349"></a>00349 
<a name="l00351"></a>00351         <span class="keyword">const</span> <a class="code" href="a00021.html#497ff212c89155c45ae2ec93dc6f1bde" title="The type of the communication object.">communication_type</a>&amp; communication;
<a name="l00352"></a>00352   };
<a name="l00353"></a>00353 
<a name="l00356"></a>00356 } <span class="comment">// end namespace</span>
<a name="l00357"></a>00357 
<a name="l00358"></a>00358 <span class="preprocessor">#endif</span>
</pre></div></div>
</div> <!-- end doxygen -->
</div> <!-- end main -->
<div class="foot">

<p class="foot">
  Generated on 6 Nov 2008 with <a
  href="http://www.doxygen.org/">Doxygen</a> (ver 1.5.6)  
  [<a href="doxygen.log">logfile</a>].
</p>

</div>

</body>
</html>
