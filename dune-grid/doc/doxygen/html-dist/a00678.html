<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN""http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>dune-grid: uggrid.hh Source File (dune-grid )</title>
  <link rel="stylesheet" type="text/css" href="./dune-doxy.css">
  <link rel="stylesheet" type="text/css" href="./tabs.css">
</head>
<div class="main">
<div class="doxygen">
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_5edca94048dae04696b7e65d07cd8e9c.html">grid</a>
  </div>
</div>
<div class="contents">
<h1>uggrid.hh</h1><a href="a00461.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef DUNE_UGGRID_HH</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define DUNE_UGGRID_HH</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00008"></a>00008 <span class="preprocessor">#include &lt;dune/grid/common/capabilities.hh&gt;</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include &lt;dune/grid/common/grid.hh&gt;</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include &lt;dune/grid/common/boundarysegment.hh&gt;</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include &lt;dune/common/collectivecommunication.hh&gt;</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &lt;dune/common/deprecated.hh&gt;</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include &lt;dune/common/static_assert.hh&gt;</span>
<a name="l00014"></a>00014 
<a name="l00015"></a>00015 <span class="comment">/* The following lines including the necessary UG headers are somewhat</span>
<a name="l00016"></a>00016 <span class="comment">   tricky.  Here's what's happening:</span>
<a name="l00017"></a>00017 <span class="comment">   UG can support two- and three-dimensional grids.  You choose be setting</span>
<a name="l00018"></a>00018 <span class="comment">   either _2 oder _3 while compiling.  This changes all sorts of stuff, in</span>
<a name="l00019"></a>00019 <span class="comment">   particular data structures in the headers.</span>
<a name="l00020"></a>00020 <span class="comment">   UG was never supposed to provide 2d and 3d grids at the same time. </span>
<a name="l00021"></a>00021 <span class="comment">   However, when compiling it as c++, the dimension-dependent parts are</span>
<a name="l00022"></a>00022 <span class="comment">   wrapped up cleanly in the namespaces UG::D2 and UG::D3, respectively.  That</span>
<a name="l00023"></a>00023 <span class="comment">   way it is possible to link together the UG lib for 2d and the one for 3d.</span>
<a name="l00024"></a>00024 <span class="comment">   But we also need the headers twice!  Once with _2 set and once with _3!</span>
<a name="l00025"></a>00025 <span class="comment">   So here we go:*/</span>
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 <span class="comment">/* The following define tells the UG headers that we want access to a few</span>
<a name="l00028"></a>00028 <span class="comment">   special fields, for example the extra index fields in the element data structures. */</span>
<a name="l00029"></a>00029 <span class="preprocessor">#define FOR_DUNE</span>
<a name="l00030"></a>00030 <span class="preprocessor"></span>
<a name="l00031"></a>00031 <span class="comment">// Set UG's space-dimension flag to 2d</span>
<a name="l00032"></a>00032 <span class="preprocessor">#define _2</span>
<a name="l00033"></a>00033 <span class="preprocessor"></span><span class="comment">// And include all necessary UG headers</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include "uggrid/ugincludes.hh"</span>
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 <span class="comment">// Wrap a few large UG macros by functions before they get undef'ed away.</span>
<a name="l00037"></a>00037 <span class="comment">// Here: The 2d-version of the macros</span>
<a name="l00038"></a>00038 <span class="preprocessor">#define UG_DIM 2</span>
<a name="l00039"></a>00039 <span class="preprocessor"></span><span class="preprocessor">#include "uggrid/ugwrapper.hh"</span>
<a name="l00040"></a>00040 <span class="preprocessor">#undef UG_DIM</span>
<a name="l00041"></a>00041 <span class="preprocessor"></span>
<a name="l00042"></a>00042 <span class="comment">// UG defines a whole load of preprocessor macros.  ug_undefs.hh undefines</span>
<a name="l00043"></a>00043 <span class="comment">// them all, so we don't get name clashes.</span>
<a name="l00044"></a>00044 <span class="preprocessor">#ifdef UG_LGMDOMAIN</span>
<a name="l00045"></a>00045 <span class="preprocessor"></span><span class="preprocessor">#include "uggrid/ug_undefs_lgm_seq.hh"</span>
<a name="l00046"></a>00046 <span class="preprocessor">#else</span>
<a name="l00047"></a>00047 <span class="preprocessor"></span><span class="preprocessor">#include "uggrid/ug_undefs.hh"</span>
<a name="l00048"></a>00048 <span class="preprocessor">#endif</span>
<a name="l00049"></a>00049 <span class="preprocessor"></span><span class="preprocessor">#undef _2</span>
<a name="l00050"></a>00050 <span class="preprocessor"></span>
<a name="l00051"></a>00051 <span class="comment">/* Now we're done with 2d, and we can do the whole thing over again for 3d */</span>
<a name="l00052"></a>00052 
<a name="l00053"></a>00053 <span class="comment">/* All macros set by UG have been unset.  This includes the macros that ensure</span>
<a name="l00054"></a>00054 <span class="comment">   single inclusion of headers.  We can thus include them again.  However, we</span>
<a name="l00055"></a>00055 <span class="comment">   only want to include those headers again that contain dimension-dependent stuff.</span>
<a name="l00056"></a>00056 <span class="comment">   Therefore, we set a few single-inclusion defines manually before including</span>
<a name="l00057"></a>00057 <span class="comment">   ugincludes.hh again.</span>
<a name="l00058"></a>00058 <span class="comment">*/</span>
<a name="l00059"></a>00059 <span class="preprocessor">#define UGTYPES_H</span>
<a name="l00060"></a>00060 <span class="preprocessor"></span><span class="preprocessor">#define __HEAPS__</span>
<a name="l00061"></a>00061 <span class="preprocessor"></span><span class="preprocessor">#define __UGENV__</span>
<a name="l00062"></a>00062 <span class="preprocessor"></span><span class="preprocessor">#define __PARGM_H__</span>
<a name="l00063"></a>00063 <span class="preprocessor"></span><span class="preprocessor">#define __DEVICESH__</span>
<a name="l00064"></a>00064 <span class="preprocessor"></span><span class="preprocessor">#define __SM__</span>
<a name="l00065"></a>00065 <span class="preprocessor"></span>
<a name="l00066"></a>00066 <span class="preprocessor">#define _3</span>
<a name="l00067"></a>00067 <span class="preprocessor"></span><span class="preprocessor">#include "uggrid/ugincludes.hh"</span>
<a name="l00068"></a>00068 
<a name="l00069"></a>00069 <span class="comment">// Wrap a few large UG macros by functions before they get undef'ed away.</span>
<a name="l00070"></a>00070 <span class="comment">// This time it's the 3d-versions.</span>
<a name="l00071"></a>00071 <span class="preprocessor">#define UG_DIM 3</span>
<a name="l00072"></a>00072 <span class="preprocessor"></span><span class="preprocessor">#include "uggrid/ugwrapper.hh"</span>
<a name="l00073"></a>00073 <span class="preprocessor">#undef UG_DIM</span>
<a name="l00074"></a>00074 <span class="preprocessor"></span>
<a name="l00075"></a>00075 <span class="comment">// undef all macros defined by UG</span>
<a name="l00076"></a>00076 <span class="preprocessor">#ifdef UG_LGMDOMAIN</span>
<a name="l00077"></a>00077 <span class="preprocessor"></span><span class="preprocessor">#include "uggrid/ug_undefs_lgm_seq.hh"</span>
<a name="l00078"></a>00078 <span class="preprocessor">#else</span>
<a name="l00079"></a>00079 <span class="preprocessor"></span><span class="preprocessor">#include "uggrid/ug_undefs.hh"</span>
<a name="l00080"></a>00080 <span class="preprocessor">#endif</span>
<a name="l00081"></a>00081 <span class="preprocessor"></span>
<a name="l00082"></a>00082 <span class="preprocessor">#undef _3</span>
<a name="l00083"></a>00083 <span class="preprocessor"></span><span class="preprocessor">#undef FOR_DUNE</span>
<a name="l00084"></a>00084 <span class="preprocessor"></span>
<a name="l00085"></a>00085 <span class="comment">// The components of the UGGrid interface</span>
<a name="l00086"></a>00086 <span class="preprocessor">#include "uggrid/uggridgeometry.hh"</span>
<a name="l00087"></a>00087 <span class="preprocessor">#include "uggrid/uggridentity.hh"</span>
<a name="l00088"></a>00088 <span class="preprocessor">#include "uggrid/uggridentitypointer.hh"</span>
<a name="l00089"></a>00089 <span class="preprocessor">#include "uggrid/ugintersectionit.hh"</span>
<a name="l00090"></a>00090 <span class="preprocessor">#include "uggrid/uggridleveliterator.hh"</span>
<a name="l00091"></a>00091 <span class="preprocessor">#include "uggrid/uggridleafiterator.hh"</span>
<a name="l00092"></a>00092 <span class="preprocessor">#include "uggrid/uggridhieriterator.hh"</span>
<a name="l00093"></a>00093 <span class="preprocessor">#include "uggrid/uggridindexsets.hh"</span>
<a name="l00094"></a>00094 
<a name="l00095"></a>00095 <span class="keyword">namespace </span>Dune {
<a name="l00096"></a>00096 
<a name="l00097"></a>00097 <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> dimworld&gt;
<a name="l00098"></a>00098 <span class="keyword">struct </span>UGGridFamily
<a name="l00099"></a>00099 {
<a name="l00100"></a>00100   <span class="keyword">typedef</span> GridTraits&lt;dim,dimworld,Dune::UGGrid&lt;dim&gt;,
<a name="l00101"></a>00101                      UGGridGeometry,
<a name="l00102"></a>00102                      UGGridEntity,
<a name="l00103"></a>00103                      UGGridEntityPointer,
<a name="l00104"></a>00104                      UGGridLevelIterator,
<a name="l00105"></a>00105                      UGGridLeafIntersectionIterator, <span class="comment">// leaf  intersection iterartor</span>
<a name="l00106"></a>00106                      UGGridLevelIntersectionIterator, <span class="comment">// level intersection iterartor</span>
<a name="l00107"></a>00107                      UGGridHierarchicIterator,
<a name="l00108"></a>00108                      UGGridLeafIterator,
<a name="l00109"></a>00109                      UGGridLevelIndexSet&lt; const UGGrid&lt;dim&gt; &gt;,
<a name="l00110"></a>00110                      UGGridLevelIndexSetTypes&lt; const UGGrid&lt;dim&gt; &gt;,
<a name="l00111"></a>00111                      UGGridLeafIndexSet&lt; const UGGrid&lt;dim&gt; &gt;,
<a name="l00112"></a>00112                      UGGridLeafIndexSetTypes&lt; const UGGrid&lt;dim&gt; &gt;,
<a name="l00113"></a>00113                      UGGridIdSet&lt; const UGGrid&lt;dim&gt;, <span class="keyword">false</span> &gt;,
<a name="l00114"></a>00114                      <span class="keywordtype">unsigned</span> int,
<a name="l00115"></a>00115                      UGGridIdSet&lt; const UGGrid&lt;dim&gt;, <span class="keyword">true</span> &gt;,
<a name="l00116"></a>00116                      <span class="keywordtype">unsigned</span> int,
<a name="l00117"></a>00117                      CollectiveCommunication&lt;Dune::UGGrid&lt;dim&gt; &gt; &gt; 
<a name="l00118"></a>00118   Traits;
<a name="l00119"></a>00119 };
<a name="l00120"></a>00120 
<a name="l00121"></a>00121 
<a name="l00122"></a>00122 <span class="comment">//**********************************************************************</span>
<a name="l00123"></a>00123 <span class="comment">//</span>
<a name="l00124"></a>00124 <span class="comment">// --UGGrid</span>
<a name="l00125"></a>00125 <span class="comment">//</span>
<a name="l00126"></a>00126 <span class="comment">//**********************************************************************</span>
<a name="l00127"></a>00127 
<a name="l00161"></a>00161 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;
<a name="l00162"></a><a class="code" href="a00284.html">00162</a> <span class="keyword">class </span><a class="code" href="a00284.html" title="[ provides Dune::Grid ]">UGGrid</a> : <span class="keyword">public</span> <a class="code" href="a00103.html">GridDefaultImplementation</a>  &lt;dim, dim, double, UGGridFamily&lt;dim,dim&gt; &gt;
<a name="l00163"></a>00163 {
<a name="l00164"></a>00164     <span class="keyword">friend</span> <span class="keyword">class </span>UGGridGeometry&lt;0,dim,const UGGrid&lt;dim&gt; &gt;;
<a name="l00165"></a>00165     <span class="keyword">friend</span> <span class="keyword">class </span>UGGridGeometry&lt;dim,dim,const UGGrid&lt;dim&gt; &gt;;
<a name="l00166"></a>00166     <span class="keyword">friend</span> <span class="keyword">class </span>UGGridGeometry&lt;1,2,const UGGrid&lt;dim&gt; &gt;;
<a name="l00167"></a>00167     <span class="keyword">friend</span> <span class="keyword">class </span>UGGridGeometry&lt;2,3,const UGGrid&lt;dim&gt; &gt;;
<a name="l00168"></a>00168 
<a name="l00169"></a>00169     <span class="keyword">friend</span> <span class="keyword">class </span>UGGridEntity &lt;0,dim,const UGGrid&lt;dim&gt; &gt;;
<a name="l00170"></a>00170     <span class="keyword">friend</span> <span class="keyword">class </span>UGGridEntity &lt;dim,dim,const UGGrid&lt;dim&gt; &gt;;
<a name="l00171"></a>00171     <span class="keyword">friend</span> <span class="keyword">class </span>UGGridHierarchicIterator&lt;const UGGrid&lt;dim&gt; &gt;;
<a name="l00172"></a>00172     <span class="keyword">friend</span> <span class="keyword">class </span>UGGridLeafIntersectionIterator&lt;const UGGrid&lt;dim&gt; &gt;;
<a name="l00173"></a>00173     <span class="keyword">friend</span> <span class="keyword">class </span>UGGridLevelIntersectionIterator&lt;const UGGrid&lt;dim&gt; &gt;;
<a name="l00174"></a>00174 
<a name="l00175"></a>00175     <span class="keyword">friend</span> <span class="keyword">class </span>UGGridLevelIndexSet&lt;const UGGrid&lt;dim&gt; &gt;;
<a name="l00176"></a>00176     <span class="keyword">friend</span> <span class="keyword">class </span>UGGridLeafIndexSet&lt;const UGGrid&lt;dim&gt; &gt;;
<a name="l00177"></a>00177     <span class="keyword">friend</span> <span class="keyword">class </span>UGGridIdSet&lt;const UGGrid&lt;dim&gt;, false &gt;;
<a name="l00178"></a>00178     <span class="keyword">friend</span> <span class="keyword">class </span>UGGridIdSet&lt;const UGGrid&lt;dim&gt;, true &gt;;
<a name="l00179"></a>00179 
<a name="l00180"></a>00180     <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> codim_, PartitionIteratorType PiType_, <span class="keyword">class</span> Gr<span class="keywordtype">id</span>Imp_&gt;
<a name="l00181"></a>00181     <span class="keyword">friend</span> <span class="keyword">class </span>UGGridLeafIterator;
<a name="l00182"></a>00182     <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> codim_, <span class="keywordtype">int</span> dim_, <span class="keyword">class</span> Gr<span class="keywordtype">id</span>Imp_, <span class="keyword">template</span>&lt;<span class="keywordtype">int</span>,<span class="keywordtype">int</span>,<span class="keyword">class</span>&gt; <span class="keyword">class </span>EntityImp_&gt;
<a name="l00183"></a>00183     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="a00082.html" title="Wrapper class for entities.">Entity</a>;
<a name="l00184"></a>00184 
<a name="l00186"></a>00186     dune_static_assert(dim==2 || dim==3, <span class="stringliteral">"Use UGGrid only for 2d and 3d!"</span>);
<a name="l00187"></a>00187 
<a name="l00188"></a>00188     <span class="comment">// The different instantiations are mutual friends so they can access</span>
<a name="l00189"></a>00189     <span class="comment">// each others numOfUGGrids field</span>
<a name="l00190"></a>00190     <span class="keyword">friend</span> <span class="keyword">class </span>UGGrid&lt;2&gt;;
<a name="l00191"></a>00191     <span class="keyword">friend</span> <span class="keyword">class </span>UGGrid&lt;3&gt;;
<a name="l00192"></a>00192     <span class="comment">//**********************************************************</span>
<a name="l00193"></a>00193       <span class="comment">// The Interface Methods</span>
<a name="l00194"></a>00194       <span class="comment">//**********************************************************</span>
<a name="l00195"></a>00195 <span class="keyword">public</span>:  
<a name="l00197"></a><a class="code" href="a00284.html#ba4d63644d89142e6ff77ee6dfa62f31">00197</a>       <span class="keyword">typedef</span> UGGridFamily&lt;dim,dim&gt;  <a class="code" href="a00284.html#ba4d63644d89142e6ff77ee6dfa62f31" title="type of the used GridFamily for this grid">GridFamily</a>;
<a name="l00198"></a>00198 
<a name="l00200"></a><a class="code" href="a00284.html#7a8a3ac2af2f3aace50c5d2d31e9730b">00200</a>     <span class="keyword">typedef</span> <span class="keyword">typename</span> UGGridFamily&lt;dim,dim&gt;::Traits <a class="code" href="a00284.html#7a8a3ac2af2f3aace50c5d2d31e9730b" title="the Traits">Traits</a>;
<a name="l00201"></a>00201 
<a name="l00203"></a><a class="code" href="a00284.html#8bcdb7069f49ac6cade41e3a23d5f50c">00203</a>     <span class="keyword">typedef</span> UG::DOUBLE <a class="code" href="a00284.html#8bcdb7069f49ac6cade41e3a23d5f50c" title="The type used to store coordinates.">ctype</a>;
<a name="l00204"></a>00204 
<a name="l00209"></a>00209     <a class="code" href="a00284.html#a43e6430cfd56802e9a571669658571b" title="Constructor with control over UG&amp;#39;s memory requirements.">UGGrid</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> heapSize=500);
<a name="l00210"></a>00210 
<a name="l00218"></a>00218     <a class="code" href="a00284.html#a43e6430cfd56802e9a571669658571b" title="Constructor with control over UG&amp;#39;s memory requirements.">UGGrid</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> heapSize, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> envHeapSize) DUNE_DEPRECATED;
<a name="l00219"></a>00219 
<a name="l00221"></a>00221     <a class="code" href="a00284.html#0a9d17ff3b681cf2dd76a97e71bf969c" title="Destructor.">~UGGrid</a>();
<a name="l00222"></a>00222    
<a name="l00225"></a>00225      <span class="keywordtype">int</span> <a class="code" href="a00284.html#40a0a86611bbf1bb5cdd9f2fea7e0357">maxLevel</a>() <span class="keyword">const</span>;
<a name="l00226"></a>00226      
<a name="l00228"></a>00228     <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> codim&gt;
<a name="l00229"></a>00229     <span class="keyword">typename</span> Traits::template <a class="code" href="a00101.html" title="A Traits struct that collects all associated types of one implementation.">Codim&lt;codim&gt;::LevelIterator</a> <a class="code" href="a00284.html#b85088f3dedb9a27a9a63037a0b88d9e" title="Iterator to first entity of given codim on level.">lbegin</a> (<span class="keywordtype">int</span> level) <span class="keyword">const</span>;
<a name="l00230"></a>00230 
<a name="l00232"></a>00232     <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> codim&gt;
<a name="l00233"></a>00233     <span class="keyword">typename</span> Traits::template <a class="code" href="a00101.html" title="A Traits struct that collects all associated types of one implementation.">Codim&lt;codim&gt;::LevelIterator</a> <a class="code" href="a00284.html#31dc1bd7748ed3fb2e55238c93ab9ecf" title="one past the end on this level">lend</a> (<span class="keywordtype">int</span> level) <span class="keyword">const</span>;
<a name="l00234"></a>00234 
<a name="l00236"></a>00236     <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> codim, PartitionIteratorType PiType&gt;
<a name="l00237"></a>00237     <span class="keyword">typename</span> Traits::template <a class="code" href="a00101.html" title="A Traits struct that collects all associated types of one implementation.">Codim&lt;codim&gt;::template</a> Partition&lt;PiType&gt;::LevelIterator <a class="code" href="a00284.html#b85088f3dedb9a27a9a63037a0b88d9e" title="Iterator to first entity of given codim on level.">lbegin</a> (<span class="keywordtype">int</span> level) <span class="keyword">const</span>;
<a name="l00238"></a>00238 
<a name="l00240"></a>00240     <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> codim, PartitionIteratorType PiType&gt;
<a name="l00241"></a>00241     <span class="keyword">typename</span> Traits::template <a class="code" href="a00101.html" title="A Traits struct that collects all associated types of one implementation.">Codim&lt;codim&gt;::template</a> Partition&lt;PiType&gt;::LevelIterator <a class="code" href="a00284.html#31dc1bd7748ed3fb2e55238c93ab9ecf" title="one past the end on this level">lend</a> (<span class="keywordtype">int</span> level) <span class="keyword">const</span>;
<a name="l00242"></a>00242 
<a name="l00244"></a>00244     <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> codim&gt;
<a name="l00245"></a><a class="code" href="a00284.html#7e57079a302a386025f372e1a5f10196">00245</a>     <span class="keyword">typename</span> Traits::template <a class="code" href="a00101.html" title="A Traits struct that collects all associated types of one implementation.">Codim&lt;codim&gt;::LeafIterator</a> <a class="code" href="a00284.html#7e57079a302a386025f372e1a5f10196" title="Iterator to first leaf entity of given codim.">leafbegin</a>()<span class="keyword"> const </span>{
<a name="l00246"></a>00246         <span class="keywordflow">return</span> <span class="keyword">typename</span> Traits::template <a class="code" href="a00101.html" title="A Traits struct that collects all associated types of one implementation.">Codim&lt;codim&gt;::template</a> Partition&lt;All_Partition&gt;::LeafIterator(*<span class="keyword">this</span>);
<a name="l00247"></a>00247     }
<a name="l00248"></a>00248 
<a name="l00250"></a>00250     <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> codim&gt;
<a name="l00251"></a><a class="code" href="a00284.html#f949864e9c03e363016f7d837a7950f1">00251</a>     <span class="keyword">typename</span> Traits::template <a class="code" href="a00101.html" title="A Traits struct that collects all associated types of one implementation.">Codim&lt;codim&gt;::LeafIterator</a> <a class="code" href="a00284.html#f949864e9c03e363016f7d837a7950f1" title="one past the end of the sequence of leaf entities">leafend</a>()<span class="keyword"> const </span>{
<a name="l00252"></a>00252         <span class="keywordflow">return</span> UGGridLeafIterator&lt;codim,All_Partition, const UGGrid&lt;dim&gt; &gt;();
<a name="l00253"></a>00253     }
<a name="l00254"></a>00254 
<a name="l00256"></a>00256     <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> codim, PartitionIteratorType PiType&gt;
<a name="l00257"></a><a class="code" href="a00284.html#27b59785d55baa6a7be1b5d454114ba4">00257</a>     <span class="keyword">typename</span> Traits::template <a class="code" href="a00101.html" title="A Traits struct that collects all associated types of one implementation.">Codim&lt;codim&gt;::template</a> Partition&lt;PiType&gt;::LeafIterator <a class="code" href="a00284.html#7e57079a302a386025f372e1a5f10196" title="Iterator to first leaf entity of given codim.">leafbegin</a>()<span class="keyword"> const </span>{
<a name="l00258"></a>00258         <span class="keywordflow">return</span> <span class="keyword">typename</span> Traits::template <a class="code" href="a00101.html" title="A Traits struct that collects all associated types of one implementation.">Codim&lt;codim&gt;::template</a> Partition&lt;PiType&gt;::LeafIterator(*<span class="keyword">this</span>);
<a name="l00259"></a>00259     }
<a name="l00260"></a>00260 
<a name="l00262"></a>00262     <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> codim, PartitionIteratorType PiType&gt;
<a name="l00263"></a><a class="code" href="a00284.html#d7d6a37f33ce10058dd906b238046ff8">00263</a>     <span class="keyword">typename</span> Traits::template <a class="code" href="a00101.html" title="A Traits struct that collects all associated types of one implementation.">Codim&lt;codim&gt;::template</a> Partition&lt;PiType&gt;::LeafIterator <a class="code" href="a00284.html#f949864e9c03e363016f7d837a7950f1" title="one past the end of the sequence of leaf entities">leafend</a>()<span class="keyword"> const </span>{
<a name="l00264"></a>00264         <span class="keywordflow">return</span> UGGridLeafIterator&lt;codim,PiType, const UGGrid&lt;dim&gt; &gt;();
<a name="l00265"></a>00265     }
<a name="l00266"></a>00266 
<a name="l00269"></a>00269     <span class="keywordtype">int</span> <a class="code" href="a00284.html#5e9c4991fa901ed0c0f927d986609c7c" title="Number of grid entities per level and codim.">size</a> (<span class="keywordtype">int</span> level, <span class="keywordtype">int</span> codim) <span class="keyword">const</span>;
<a name="l00270"></a>00270 
<a name="l00272"></a><a class="code" href="a00284.html#2c858fcd33de08fc144290d77370957d">00272</a>   <span class="keywordtype">int</span> <a class="code" href="a00284.html#5e9c4991fa901ed0c0f927d986609c7c" title="Number of grid entities per level and codim.">size</a> (<span class="keywordtype">int</span> codim)<span class="keyword"> const</span>
<a name="l00273"></a>00273 <span class="keyword">  </span>{
<a name="l00274"></a>00274       <span class="keywordflow">return</span> <a class="code" href="a00284.html#67600160c3b30dbc30d0ef512ffea577" title="Access to the LeafIndexSet.">leafIndexSet</a>().size(codim);
<a name="l00275"></a>00275   }
<a name="l00276"></a>00276 
<a name="l00278"></a><a class="code" href="a00284.html#6e15e098a3b0a74899dff74369d1f8a9">00278</a>   <span class="keywordtype">int</span> <a class="code" href="a00284.html#5e9c4991fa901ed0c0f927d986609c7c" title="Number of grid entities per level and codim.">size</a> (<span class="keywordtype">int</span> level, GeometryType type)<span class="keyword"> const</span>
<a name="l00279"></a>00279 <span class="keyword">  </span>{
<a name="l00280"></a>00280         <span class="keywordflow">return</span> this-&gt;<a class="code" href="a00284.html#7fc9e2baddbe89cdb3b259ffc5d5dc78" title="Access to the LevelIndexSets.">levelIndexSet</a>(level).size(type);
<a name="l00281"></a>00281   }
<a name="l00282"></a>00282 
<a name="l00284"></a><a class="code" href="a00284.html#8bcbbfc3f8b172c588e78fc0b43257d1">00284</a>   <span class="keywordtype">int</span> <a class="code" href="a00284.html#5e9c4991fa901ed0c0f927d986609c7c" title="Number of grid entities per level and codim.">size</a> (GeometryType type)<span class="keyword"> const</span>
<a name="l00285"></a>00285 <span class="keyword">  </span>{
<a name="l00286"></a>00286         <span class="keywordflow">return</span> this-&gt;<a class="code" href="a00284.html#67600160c3b30dbc30d0ef512ffea577" title="Access to the LeafIndexSet.">leafIndexSet</a>().size(type);
<a name="l00287"></a>00287   }
<a name="l00288"></a>00288 
<a name="l00290"></a><a class="code" href="a00284.html#612a2ee53aef71d35ac141c371b95749">00290</a>     <span class="keyword">const</span> <span class="keyword">typename</span> Traits::GlobalIdSet&amp; <a class="code" href="a00284.html#612a2ee53aef71d35ac141c371b95749" title="Access to the GlobalIdSet.">globalIdSet</a>()<span class="keyword"> const</span>
<a name="l00291"></a>00291 <span class="keyword">    </span>{
<a name="l00292"></a>00292         <span class="keywordflow">return</span> globalIdSet_;
<a name="l00293"></a>00293     }
<a name="l00294"></a>00294     
<a name="l00296"></a><a class="code" href="a00284.html#2b7cc2d5213b5765a0fdd318ae244a07">00296</a>     <span class="keyword">const</span> <span class="keyword">typename</span> Traits::LocalIdSet&amp; <a class="code" href="a00284.html#2b7cc2d5213b5765a0fdd318ae244a07" title="Access to the LocalIdSet.">localIdSet</a>()<span class="keyword"> const</span>
<a name="l00297"></a>00297 <span class="keyword">    </span>{
<a name="l00298"></a>00298         <span class="keywordflow">return</span> localIdSet_;
<a name="l00299"></a>00299     }
<a name="l00300"></a>00300     
<a name="l00302"></a><a class="code" href="a00284.html#7fc9e2baddbe89cdb3b259ffc5d5dc78">00302</a>     <span class="keyword">const</span> <span class="keyword">typename</span> Traits::LevelIndexSet&amp; <a class="code" href="a00284.html#7fc9e2baddbe89cdb3b259ffc5d5dc78" title="Access to the LevelIndexSets.">levelIndexSet</a>(<span class="keywordtype">int</span> level)<span class="keyword"> const</span>
<a name="l00303"></a>00303 <span class="keyword">    </span>{
<a name="l00304"></a>00304         <span class="keywordflow">if</span> (level&lt;0 || level&gt;<a class="code" href="a00284.html#40a0a86611bbf1bb5cdd9f2fea7e0357">maxLevel</a>())
<a name="l00305"></a>00305             DUNE_THROW(<a class="code" href="a00105.html" title="Base class for exceptions in Dune grid modules.">GridError</a>, <span class="stringliteral">"levelIndexSet of nonexisting level "</span> &lt;&lt; level &lt;&lt; <span class="stringliteral">" requested!"</span>);
<a name="l00306"></a>00306         <span class="keywordflow">return</span> *levelIndexSets_[level];
<a name="l00307"></a>00307     }
<a name="l00308"></a>00308     
<a name="l00310"></a><a class="code" href="a00284.html#67600160c3b30dbc30d0ef512ffea577">00310</a>     <span class="keyword">const</span> <span class="keyword">typename</span> Traits::LeafIndexSet&amp; <a class="code" href="a00284.html#67600160c3b30dbc30d0ef512ffea577" title="Access to the LeafIndexSet.">leafIndexSet</a>()<span class="keyword"> const</span>
<a name="l00311"></a>00311 <span class="keyword">    </span>{
<a name="l00312"></a>00312         <span class="keywordflow">return</span> leafIndexSet_;
<a name="l00313"></a>00313     }
<a name="l00314"></a>00314 
<a name="l00317"></a>00317 
<a name="l00330"></a>00330     <span class="keywordtype">bool</span> <a class="code" href="a00284.html#36c19f0d34bebce784df64719483f26f" title="Mark element for refinement.">mark</a>(<span class="keywordtype">int</span> refCount, <span class="keyword">const</span> <span class="keyword">typename</span> Traits::template Codim&lt;0&gt;::EntityPointer &amp; e );
<a name="l00331"></a>00331 
<a name="l00339"></a>00339     <span class="keywordtype">bool</span> <a class="code" href="a00284.html#36c19f0d34bebce784df64719483f26f" title="Mark element for refinement.">mark</a>(<span class="keyword">const</span> <span class="keyword">typename</span> Traits::template Codim&lt;0&gt;::EntityPointer &amp; e, 
<a name="l00340"></a>00340               <span class="keyword">typename</span> UG_NS&lt;dim&gt;::RefinementRule rule,
<a name="l00341"></a>00341               <span class="keywordtype">int</span> side=0);
<a name="l00342"></a>00342 
<a name="l00344"></a>00344     <span class="keywordtype">int</span> <a class="code" href="a00284.html#e0db418e9f08afff50b9d0616be6d4a0" title="Query whether element is marked for refinement.">getMark</a>(<span class="keyword">const</span> <span class="keyword">typename</span> Traits::template Codim&lt;0&gt;::EntityPointer&amp; e) <span class="keyword">const</span>;
<a name="l00345"></a>00345 
<a name="l00348"></a>00348     <span class="keywordtype">bool</span> <a class="code" href="a00284.html#d8049428931bf4e04a2d18fdcdff3b70" title="returns true, if some elements might be coarsend during grid adaption, here always...">preAdapt</a>();
<a name="l00349"></a>00349     
<a name="l00351"></a>00351     <span class="keywordtype">bool</span> <a class="code" href="a00284.html#a3fe65d750889dc3e875dcc8b3981f0c" title="Triggers the grid refinement process.">adapt</a>();
<a name="l00352"></a>00352 
<a name="l00354"></a>00354     <span class="keywordtype">void</span> <a class="code" href="a00284.html#0baec872b4bbe8132eb62fe10d5219e6" title="Clean up refinement markers.">postAdapt</a>();
<a name="l00358"></a><a class="code" href="a00284.html#01fbcf93504bf34b62fa1857ae7fcb72">00358</a>     std::string <a class="code" href="a00284.html#01fbcf93504bf34b62fa1857ae7fcb72" title="return name of the grid">name</a> ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">"UGGrid"</span>; };
<a name="l00359"></a>00359 
<a name="l00361"></a><a class="code" href="a00284.html#78a5380498056a5b7ac831f64cc38b52">00361</a>     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="a00284.html#78a5380498056a5b7ac831f64cc38b52" title="Size of the overlap on the leaf level.">overlapSize</a>(<span class="keywordtype">int</span> codim)<span class="keyword"> const </span>{
<a name="l00362"></a>00362         <span class="keywordflow">return</span> 0;
<a name="l00363"></a>00363     }
<a name="l00364"></a>00364 
<a name="l00366"></a><a class="code" href="a00284.html#07e9eb71d156adf5017d1bf5bf634155">00366</a>     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="a00284.html#07e9eb71d156adf5017d1bf5bf634155" title="Size of the ghost cell layer on the leaf level.">ghostSize</a>(<span class="keywordtype">int</span> codim)<span class="keyword"> const </span>{
<a name="l00367"></a>00367         <span class="keywordflow">return</span> (codim==0) ? 1 : 0;
<a name="l00368"></a>00368     }
<a name="l00369"></a>00369 
<a name="l00371"></a><a class="code" href="a00284.html#f4c3a2a28ba8ce3ddd86560f4bc03e9e">00371</a>     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="a00284.html#78a5380498056a5b7ac831f64cc38b52" title="Size of the overlap on the leaf level.">overlapSize</a>(<span class="keywordtype">int</span> level, <span class="keywordtype">int</span> codim)<span class="keyword"> const </span>{
<a name="l00372"></a>00372         <span class="keywordflow">return</span> 0;
<a name="l00373"></a>00373     }
<a name="l00374"></a>00374 
<a name="l00376"></a><a class="code" href="a00284.html#737d047af114cf7ce8ad333cc11dc030">00376</a>     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="a00284.html#07e9eb71d156adf5017d1bf5bf634155" title="Size of the ghost cell layer on the leaf level.">ghostSize</a>(<span class="keywordtype">int</span> level, <span class="keywordtype">int</span> codim)<span class="keyword"> const </span>{
<a name="l00377"></a>00377         <span class="keywordflow">return</span> (codim==0) ? 1 : 0;
<a name="l00378"></a>00378     }
<a name="l00379"></a>00379     
<a name="l00385"></a>00385     <span class="keywordtype">void</span> <a class="code" href="a00103.html#e0ed8cbb63b8740a5e7b1a112eebe5af" title="default implementation of load balance does nothing and returns false">loadBalance</a>(<span class="keywordtype">int</span> strategy, <span class="keywordtype">int</span> minlevel, <span class="keywordtype">int</span> depth, <span class="keywordtype">int</span> maxlevel, <span class="keywordtype">int</span> minelement);
<a name="l00386"></a>00386 
<a name="l00387"></a>00387     <span class="keyword">typedef</span> <a class="code" href="a00103.html">GridDefaultImplementation</a>  &lt;dim, dim, double,
<a name="l00388"></a>00388             UGGridFamily&lt;dim,dim&gt; &gt; GridDefaultImplementationType; 
<a name="l00389"></a>00389 
<a name="l00391"></a>00391     <span class="keyword">using</span> <a class="code" href="a00103.html#e0ed8cbb63b8740a5e7b1a112eebe5af" title="default implementation of load balance does nothing and returns false">GridDefaultImplementationType :: loadBalance</a>;
<a name="l00392"></a>00392 
<a name="l00404"></a>00404     <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">template</span>&lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>P, <span class="keywordtype">int</span> codim&gt;
<a name="l00405"></a>00405     <span class="keywordtype">void</span> <a class="code" href="a00284.html#0b0a5a5eadaf4bebc1eb4bcf147501c4" title="The communication interface.">communicate</a> (T&amp; t, <a class="code" href="a00492.html#ge799a4296824c1d4ae0d82e71287b722" title="Parameter to be used for the communication functions.">InterfaceType</a> iftype, <a class="code" href="a00492.html#gcf00ef51e7964e5797de12e1bdf8d755" title="Define a type for communication direction parameter.">CommunicationDirection</a> dir, <span class="keywordtype">int</span> level);
<a name="l00406"></a>00406 
<a name="l00411"></a>00411     <span class="keyword">template</span>&lt;<span class="keyword">class</span> DataHandle&gt;
<a name="l00412"></a><a class="code" href="a00284.html#33ac50afd278f4f3abeb098a2e786f1c">00412</a>     <span class="keywordtype">void</span> <a class="code" href="a00284.html#0b0a5a5eadaf4bebc1eb4bcf147501c4" title="The communication interface.">communicate</a> (DataHandle&amp; data, <a class="code" href="a00492.html#ge799a4296824c1d4ae0d82e71287b722" title="Parameter to be used for the communication functions.">InterfaceType</a> iftype, <a class="code" href="a00492.html#gcf00ef51e7964e5797de12e1bdf8d755" title="Define a type for communication direction parameter.">CommunicationDirection</a> dir, <span class="keywordtype">int</span> level)<span class="keyword"> const  </span>
<a name="l00413"></a>00413 <span class="keyword">    </span>{}
<a name="l00414"></a>00414 
<a name="l00415"></a>00415     <span class="keyword">template</span>&lt;<span class="keyword">class</span> DataHandle&gt;
<a name="l00416"></a>00416     <span class="keywordtype">void</span> <a class="code" href="a00284.html#0b0a5a5eadaf4bebc1eb4bcf147501c4" title="The communication interface.">communicate</a> (DataHandle&amp; data, <a class="code" href="a00492.html#ge799a4296824c1d4ae0d82e71287b722" title="Parameter to be used for the communication functions.">InterfaceType</a> iftype, <a class="code" href="a00492.html#gcf00ef51e7964e5797de12e1bdf8d755" title="Define a type for communication direction parameter.">CommunicationDirection</a> dir)<span class="keyword"> const  </span>
<a name="l00417"></a>00417 <span class="keyword">    </span>{}
<a name="l00418"></a>00418 
<a name="l00420"></a><a class="code" href="a00284.html#a786beb10d1eb232d4af1ba26b3f5c4c">00420</a>         <span class="keyword">const</span> CollectiveCommunication&lt;UGGrid&gt;&amp; <a class="code" href="a00284.html#a786beb10d1eb232d4af1ba26b3f5c4c">comm</a> ()<span class="keyword"> const</span>
<a name="l00421"></a>00421 <span class="keyword">        </span>{
<a name="l00422"></a>00422           <span class="keywordflow">return</span> ccobj;
<a name="l00423"></a>00423         }
<a name="l00424"></a>00424 
<a name="l00425"></a>00425     <span class="comment">// **********************************************************</span>
<a name="l00426"></a>00426     <span class="comment">// End of Interface Methods</span>
<a name="l00427"></a>00427     <span class="comment">// **********************************************************</span>
<a name="l00428"></a>00428     
<a name="l00431"></a>00431     
<a name="l00435"></a>00435     <span class="keywordtype">void</span> <a class="code" href="a00284.html#99bc00560172962c1116875bc5f6bfcb" title="Start the coarse grid creation process.">createBegin</a>();
<a name="l00436"></a>00436 
<a name="l00438"></a>00438     <span class="keywordtype">void</span> <a class="code" href="a00284.html#9526fb9b81909672e7700c4b1f92022f" title="End the coarse grid creation process.">createEnd</a>();
<a name="l00439"></a>00439 
<a name="l00443"></a>00443     <span class="keywordtype">void</span> <a class="code" href="a00284.html#a6ccfbf79659027a65622b80e2b16682" title="When UGGrid has been configured to use the LGM domain manager, this routine sets...">createLGMGrid</a>(<span class="keyword">const</span> std::string&amp; <a class="code" href="a00284.html#01fbcf93504bf34b62fa1857ae7fcb72" title="return name of the grid">name</a>);
<a name="l00444"></a>00444 
<a name="l00450"></a>00450     <span class="keywordtype">void</span> <a class="code" href="a00284.html#65c9ad60d3a5ea517f24fb8af8b4db73" title="Method to insert an arbitrarily shaped boundary segment into a coarse grid.">insertBoundarySegment</a>(<span class="keyword">const</span> std::vector&lt;unsigned int&gt; vertices,
<a name="l00451"></a>00451                                <span class="keyword">const</span> <a class="code" href="a00062.html" title="Base class for classes implementing geometries of boundary segments.">BoundarySegment&lt;dim&gt;</a>* boundarySegment);
<a name="l00452"></a>00452 
<a name="l00454"></a>00454     <span class="keywordtype">void</span> <a class="code" href="a00284.html#c53a63f882c091768a2d4716456b2dcd" title="Insert a vertex into the coarse grid.">insertVertex</a>(<span class="keyword">const</span> FieldVector&lt;double,dim&gt;&amp; pos);
<a name="l00455"></a>00455 
<a name="l00460"></a>00460     <span class="keywordtype">void</span> <a class="code" href="a00284.html#e9dc411fa1efa0a4e96c5023c530e0ee" title="Insert an element into the coarse grid.">insertElement</a>(GeometryType type,
<a name="l00461"></a>00461                        <span class="keyword">const</span> std::vector&lt;unsigned int&gt;&amp; vertices);
<a name="l00462"></a>00462     
<a name="l00470"></a>00470     <span class="keywordtype">void</span> <a class="code" href="a00284.html#9bf9d33656589b2d53ea77643802af19" title="Rudimentary substitute for a hierarchic iterator on faces.">getChildrenOfSubface</a>(<span class="keyword">typename</span> Traits::template Codim&lt;0&gt;::EntityPointer &amp; e,
<a name="l00471"></a>00471                               <span class="keywordtype">int</span> elementSide,
<a name="l00472"></a>00472                               <span class="keywordtype">int</span> maxl, 
<a name="l00473"></a>00473                               std::vector&lt;<span class="keyword">typename</span> Traits::template Codim&lt;0&gt;::EntityPointer&gt;&amp; childElements,
<a name="l00474"></a>00474                               std::vector&lt;unsigned char&gt;&amp; childElementSides) <span class="keyword">const</span>;
<a name="l00475"></a>00475     
<a name="l00477"></a><a class="code" href="a00284.html#77f385a0019e340ffe3ecd7509bbc3fb">00477</a>     <span class="keyword">enum</span> <a class="code" href="a00284.html#77f385a0019e340ffe3ecd7509bbc3fb" title="The different forms of grid refinement that UG supports.">RefinementType</a> {
<a name="l00479"></a><a class="code" href="a00284.html#77f385a0019e340ffe3ecd7509bbc3fbe06c5d78b1b104ce8c12bc065fc0ede2">00479</a>         <a class="code" href="a00284.html#77f385a0019e340ffe3ecd7509bbc3fbe06c5d78b1b104ce8c12bc065fc0ede2" title="New level consists only of the refined elements and the closure.">LOCAL</a>, 
<a name="l00481"></a><a class="code" href="a00284.html#77f385a0019e340ffe3ecd7509bbc3fb27d7f8aa313fd4d8bde04746370b9a74">00481</a>         <a class="code" href="a00284.html#77f385a0019e340ffe3ecd7509bbc3fb27d7f8aa313fd4d8bde04746370b9a74" title="New level consists of the refined elements and the unrefined ones, too.">COPY</a>};
<a name="l00482"></a>00482 
<a name="l00484"></a><a class="code" href="a00284.html#e0b21dc1efd8553d4fa4ff9c6ee20c08">00484</a>     <span class="keyword">enum</span> <a class="code" href="a00284.html#e0b21dc1efd8553d4fa4ff9c6ee20c08" title="Decide whether to add a green closure to locally refined grid sections or not.">ClosureType</a> {
<a name="l00486"></a><a class="code" href="a00284.html#e0b21dc1efd8553d4fa4ff9c6ee20c08291003834b7f001bf74eb7bb0da6d5ab">00486</a>         <a class="code" href="a00284.html#e0b21dc1efd8553d4fa4ff9c6ee20c08291003834b7f001bf74eb7bb0da6d5ab" title="Standard red/green refinement.">GREEN</a>,
<a name="l00488"></a><a class="code" href="a00284.html#e0b21dc1efd8553d4fa4ff9c6ee20c08b36a704df45a683f4f7d4cb5e473649c">00488</a>         <a class="code" href="a00284.html#e0b21dc1efd8553d4fa4ff9c6ee20c08b36a704df45a683f4f7d4cb5e473649c" title="No closure, results in nonconforming meshes.">NONE</a>};
<a name="l00489"></a>00489 
<a name="l00491"></a><a class="code" href="a00284.html#0f6da85df8d4df8d3c8c19f5fe2d74b1">00491</a>     <span class="keywordtype">void</span> <a class="code" href="a00284.html#0f6da85df8d4df8d3c8c19f5fe2d74b1" title="Sets the type of grid refinement.">setRefinementType</a>(<a class="code" href="a00284.html#77f385a0019e340ffe3ecd7509bbc3fb" title="The different forms of grid refinement that UG supports.">RefinementType</a> type) {
<a name="l00492"></a>00492         refinementType_ = type;
<a name="l00493"></a>00493     }
<a name="l00494"></a>00494 
<a name="l00496"></a><a class="code" href="a00284.html#6c1309f835cd9698ddb42fa8bf0ac25c">00496</a>     <span class="keywordtype">void</span> <a class="code" href="a00284.html#6c1309f835cd9698ddb42fa8bf0ac25c" title="Sets the type of grid refinement closure.">setClosureType</a>(<a class="code" href="a00284.html#e0b21dc1efd8553d4fa4ff9c6ee20c08" title="Decide whether to add a green closure to locally refined grid sections or not.">ClosureType</a> type) {
<a name="l00497"></a>00497         closureType_ = type;
<a name="l00498"></a>00498     }
<a name="l00499"></a>00499 
<a name="l00501"></a><a class="code" href="a00284.html#54e8188017730ff4342d100c1c49af5e">00501</a>     <span class="keywordtype">void</span> <a class="code" href="a00284.html#54e8188017730ff4342d100c1c49af5e" title="Collapses the grid hierarchy into a single grid level.">collapse</a>() {
<a name="l00502"></a>00502         <span class="keywordflow">if</span> (Collapse(multigrid_))
<a name="l00503"></a>00503             DUNE_THROW(<a class="code" href="a00105.html" title="Base class for exceptions in Dune grid modules.">GridError</a>, <span class="stringliteral">"UG"</span> &lt;&lt; dim &lt;&lt; <span class="stringliteral">"d::Collapse() returned error code!"</span>);
<a name="l00504"></a>00504 
<a name="l00505"></a>00505         setIndices();
<a name="l00506"></a>00506     }
<a name="l00507"></a>00507 
<a name="l00511"></a>00511     <span class="keywordtype">void</span> <a class="code" href="a00284.html#685a4c3c8cc5806e9f0529a406cb8693" title="Sets a vertex to a new position.">setPosition</a>(<span class="keyword">typename</span> Traits::template Codim&lt;dim&gt;::EntityPointer&amp; e,
<a name="l00512"></a>00512                      <span class="keyword">const</span> FieldVector&lt;double, dim&gt;&amp; pos);
<a name="l00513"></a>00513 
<a name="l00515"></a>00515     FieldVector&lt;ctype,dim&gt; <a class="code" href="a00284.html#e09c5a60144da302116f5d2aab355750" title="For a point on the grid boundary return its position on the domain boundary.">getBoundaryPosition</a>(<span class="keyword">const</span> <a class="code" href="a00154.html" title="Mesh entities of codimension 0 (&amp;quot;elements&amp;quot;) allow to visit all intersections...">IntersectionIterator</a>&lt;<span class="keyword">const</span> <a class="code" href="a00284.html" title="[ provides Dune::Grid ]">UGGrid&lt;dim&gt;</a>, UGGridLevelIntersectionIterator&gt;&amp; iIt,
<a name="l00516"></a>00516                                                <span class="keyword">const</span> FieldVector&lt;ctype,dim-1&gt;&amp; localPos) <span class="keyword">const</span>;
<a name="l00517"></a>00517 
<a name="l00522"></a>00522     <span class="keywordtype">void</span> <a class="code" href="a00284.html#d8a86eb51c3aba71eee7650d90898835" title="Does uniform refinement.">globalRefine</a>(<span class="keywordtype">int</span> n);
<a name="l00523"></a>00523 
<a name="l00524"></a>00524     <span class="keywordtype">void</span> saveState(<span class="keyword">const</span> std::string&amp; filename) <span class="keyword">const</span>;
<a name="l00525"></a>00525 
<a name="l00526"></a>00526     <span class="keywordtype">void</span> loadState(<span class="keyword">const</span> std::string&amp; filename);
<a name="l00527"></a>00527 
<a name="l00528"></a>00528 <span class="keyword">private</span>:
<a name="l00530"></a>00530     <span class="keyword">typename</span> UG_NS&lt;dim&gt;::MultiGrid* multigrid_;
<a name="l00531"></a>00531 
<a name="l00533"></a>00533     std::vector&lt;const BoundarySegment&lt;dim&gt;*&gt; boundarySegments_;
<a name="l00534"></a>00534 
<a name="l00536"></a>00536     std::vector&lt;array&lt;<span class="keywordtype">unsigned</span> int, dim*2-2&gt; &gt; boundarySegmentVertices_;
<a name="l00537"></a>00537 
<a name="l00538"></a>00538   CollectiveCommunication&lt;UGGrid&gt; ccobj;
<a name="l00539"></a>00539 
<a name="l00540"></a>00540     <span class="comment">// Recomputes entity indices after the grid was changed</span>
<a name="l00541"></a>00541     <span class="keywordtype">void</span> setIndices();
<a name="l00542"></a>00542 
<a name="l00543"></a>00543     <span class="comment">// Each UGGrid object has a unique name to identify it in the</span>
<a name="l00544"></a>00544     <span class="comment">// UG environment structure</span>
<a name="l00545"></a>00545     std::string name_;
<a name="l00546"></a>00546 
<a name="l00547"></a>00547     <span class="comment">// Our set of level indices</span>
<a name="l00548"></a>00548     std::vector&lt;UGGridLevelIndexSet&lt;const UGGrid&lt;dim&gt; &gt;*&gt; levelIndexSets_;
<a name="l00549"></a>00549 
<a name="l00550"></a>00550     UGGridLeafIndexSet&lt;const UGGrid&lt;dim&gt; &gt; leafIndexSet_;
<a name="l00551"></a>00551 
<a name="l00552"></a>00552     UGGridIdSet&lt;const UGGrid&lt;dim&gt;, <span class="keyword">false</span> &gt; globalIdSet_;
<a name="l00553"></a>00553 
<a name="l00554"></a>00554     UGGridIdSet&lt;const UGGrid&lt;dim&gt;, <span class="keyword">true</span> &gt; localIdSet_;
<a name="l00555"></a>00555 
<a name="l00557"></a>00557     <a class="code" href="a00284.html#77f385a0019e340ffe3ecd7509bbc3fb" title="The different forms of grid refinement that UG supports.">RefinementType</a> refinementType_;
<a name="l00558"></a>00558 
<a name="l00560"></a>00560     <a class="code" href="a00284.html#e0b21dc1efd8553d4fa4ff9c6ee20c08" title="Decide whether to add a green closure to locally refined grid sections or not.">ClosureType</a> closureType_;
<a name="l00561"></a>00561 
<a name="l00564"></a>00564     std::vector&lt;unsigned char&gt; elementTypes_;
<a name="l00565"></a>00565 
<a name="l00568"></a>00568     std::vector&lt;unsigned int&gt; elementVertices_;
<a name="l00569"></a>00569 
<a name="l00571"></a>00571     std::vector&lt;FieldVector&lt;double, dim&gt; &gt; vertexPositions_;
<a name="l00572"></a>00572 
<a name="l00580"></a>00580     <span class="keyword">static</span> <span class="keywordtype">int</span> numOfUGGrids;
<a name="l00581"></a>00581 
<a name="l00587"></a>00587     <span class="keywordtype">bool</span> someElementHasBeenMarkedForRefinement_;
<a name="l00588"></a>00588 
<a name="l00593"></a>00593     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> heapsize;
<a name="l00594"></a>00594 
<a name="l00595"></a>00595 
<a name="l00596"></a>00596 }; <span class="comment">// end Class UGGrid</span>
<a name="l00597"></a>00597 
<a name="l00598"></a>00598 <span class="keyword">namespace </span>Capabilities
<a name="l00599"></a>00599 {
<a name="l00615"></a>00615   <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;
<a name="l00616"></a><a class="code" href="a00122.html">00616</a>   <span class="keyword">struct </span><a class="code" href="a00115.html" title="Specialize with &amp;#39;true&amp;#39; for all codims that a grid implements entities for...">hasEntity</a>&lt; <a class="code" href="a00284.html" title="[ provides Dune::Grid ]">UGGrid</a>&lt;dim&gt;, 0&gt;
<a name="l00617"></a>00617   {
<a name="l00618"></a>00618     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> v = <span class="keyword">true</span>;
<a name="l00619"></a>00619   };
<a name="l00620"></a>00620 
<a name="l00624"></a>00624   <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;
<a name="l00625"></a><a class="code" href="a00123.html">00625</a>   <span class="keyword">struct </span><a class="code" href="a00115.html" title="Specialize with &amp;#39;true&amp;#39; for all codims that a grid implements entities for...">hasEntity</a>&lt; <a class="code" href="a00284.html" title="[ provides Dune::Grid ]">UGGrid</a>&lt;dim&gt;, dim&gt;
<a name="l00626"></a>00626   {
<a name="l00627"></a>00627     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> v = <span class="keyword">true</span>;
<a name="l00628"></a>00628   };
<a name="l00629"></a>00629   
<a name="l00633"></a>00633   <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;
<a name="l00634"></a><a class="code" href="a00178.html">00634</a>   <span class="keyword">struct </span><a class="code" href="a00173.html" title="Specialize with &amp;#39;true&amp;#39; if implementation supports parallelism. (default=false)...">isParallel</a>&lt; <a class="code" href="a00284.html" title="[ provides Dune::Grid ]">UGGrid</a>&lt;dim&gt; &gt;
<a name="l00635"></a>00635   {
<a name="l00636"></a>00636 <span class="preprocessor">#ifdef ModelP</span>
<a name="l00637"></a>00637 <span class="preprocessor"></span>      <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> v = <span class="keyword">true</span>;
<a name="l00638"></a>00638 <span class="preprocessor">#else</span>
<a name="l00639"></a>00639 <span class="preprocessor"></span>      <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> v = <span class="keyword">false</span>;
<a name="l00640"></a>00640 <span class="preprocessor">#endif</span>
<a name="l00641"></a>00641 <span class="preprocessor"></span>  };
<a name="l00642"></a>00642 
<a name="l00646"></a>00646   <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;
<a name="l00647"></a><a class="code" href="a00171.html">00647</a>   <span class="keyword">struct </span><a class="code" href="a00164.html" title="Specialize with &amp;#39;true&amp;#39; if implementation guarantees conforming level grids...">isLevelwiseConforming</a>&lt; <a class="code" href="a00284.html" title="[ provides Dune::Grid ]">UGGrid</a>&lt;dim&gt; &gt;
<a name="l00648"></a>00648   {
<a name="l00649"></a>00649     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> v = <span class="keyword">true</span>;
<a name="l00650"></a>00650   };
<a name="l00651"></a>00651 
<a name="l00655"></a>00655   <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;
<a name="l00656"></a><a class="code" href="a00162.html">00656</a>   <span class="keyword">struct </span><a class="code" href="a00158.html" title="Specialize with &amp;#39;true&amp;#39; if implementation guarantees a conforming leaf grid...">isLeafwiseConforming</a>&lt; <a class="code" href="a00284.html" title="[ provides Dune::Grid ]">UGGrid</a>&lt;dim&gt; &gt;
<a name="l00657"></a>00657   {
<a name="l00658"></a>00658     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> v = <span class="keyword">false</span>;
<a name="l00659"></a>00659   };
<a name="l00660"></a>00660 
<a name="l00664"></a>00664   <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dim&gt;
<a name="l00665"></a><a class="code" href="a00133.html">00665</a>   <span class="keyword">struct </span><a class="code" href="a00126.html" title="Specialize with &amp;#39;true&amp;#39; if implementation provides grids with hanging nodes...">hasHangingNodes</a>&lt; <a class="code" href="a00284.html" title="[ provides Dune::Grid ]">UGGrid</a>&lt;dim&gt; &gt;
<a name="l00666"></a>00666   {
<a name="l00667"></a>00667     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> v = <span class="keyword">true</span>;
<a name="l00668"></a>00668   };
<a name="l00669"></a>00669   
<a name="l00670"></a>00670 }
<a name="l00671"></a>00671 
<a name="l00672"></a>00672 } <span class="comment">// namespace Dune</span>
<a name="l00673"></a>00673 
<a name="l00674"></a>00674 <span class="preprocessor">#endif</span>
</pre></div></div>
</div> <!-- end doxygen -->
</div> <!-- end main -->
<div class="foot">

<p class="foot">
  Generated on 6 Nov 2008 with <a
  href="http://www.doxygen.org/">Doxygen</a> (ver 1.5.6)  
  [<a href="doxygen.log">logfile</a>].
</p>

</div>

</body>
</html>
