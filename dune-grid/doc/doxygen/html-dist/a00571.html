<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN""http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>dune-grid: dgfparserblocks.hh Source File (dune-grid )</title>
  <link rel="stylesheet" type="text/css" href="./dune-doxy.css">
  <link rel="stylesheet" type="text/css" href="./tabs.css">
</head>
<div class="main">
<div class="doxygen">
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_5edca94048dae04696b7e65d07cd8e9c.html">grid</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_3cbbda19b620c3b02e4a6bd399f608fa.html">io</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_65252ab1f1f5370a7d40c0347a12070d.html">file</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_4cee72c778d9005e899e49441c1b0610.html">dgfparser</a>
  </div>
</div>
<div class="contents">
<h1>dgfparserblocks.hh</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef DUNE_MACROGRIDPARSERBLOCKS_HH</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define DUNE_MACROGRIDPARSERBLOCKS_HH</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="preprocessor">#include &lt;set&gt;</span>
<a name="l00005"></a>00005 
<a name="l00006"></a>00006 <span class="keyword">namespace </span>Dune {
<a name="l00007"></a>00007 
<a name="l00008"></a>00008 <span class="comment">// *************************************************************</span>
<a name="l00009"></a>00009 <span class="comment">// Read one block with given identifier from disk</span>
<a name="l00010"></a>00010 <span class="comment">// and allows the line-wise extraction from this block</span>
<a name="l00011"></a>00011 <span class="comment">// *************************************************************</span>
<a name="l00012"></a>00012 <span class="keyword">namespace </span>{
<a name="l00013"></a>00013 
<a name="l00014"></a>00014 <span class="keyword">inline</span> <span class="keywordtype">void</span> makeupcase(std::string &amp;s) 
<a name="l00015"></a>00015 {
<a name="l00016"></a>00016   <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0;i&lt;s.size();i++) 
<a name="l00017"></a>00017     s[i]=toupper(s[i]);
<a name="l00018"></a>00018 }
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="keyword">class </span>BasicBlock {
<a name="l00021"></a>00021   <span class="keywordtype">int</span> pos;                   <span class="comment">// line number</span>
<a name="l00022"></a>00022   <span class="keywordtype">bool</span> active;               <span class="comment">// block was found</span>
<a name="l00023"></a>00023   <span class="keywordtype">bool</span> empty;                <span class="comment">// block was found but was empty</span>
<a name="l00024"></a>00024   std::string identifier;    <span class="comment">// identifier of this block</span>
<a name="l00025"></a>00025   <span class="keywordtype">int</span> linecount;             <span class="comment">// total number of lines in the block</span>
<a name="l00026"></a>00026   std::stringstream block;   <span class="comment">// the block itself</span>
<a name="l00027"></a>00027   std::string oneline;       <span class="comment">// the active line in the block</span>
<a name="l00028"></a>00028   <span class="comment">// get the block (if it exists)</span>
<a name="l00029"></a>00029   <span class="keywordtype">void</span> getblock(std::istream &amp;in) {
<a name="l00030"></a>00030     std::string id;
<a name="l00031"></a>00031     getline(in,<span class="keywordtype">id</span>);
<a name="l00032"></a>00032     <span class="keywordflow">while</span> (in.good()) {
<a name="l00033"></a>00033       std::stringstream idstream(<span class="keywordtype">id</span>);
<a name="l00034"></a>00034       std::string upcaseid;
<a name="l00035"></a>00035       idstream &gt;&gt; upcaseid;
<a name="l00036"></a>00036       makeupcase(upcaseid);
<a name="l00037"></a>00037       <span class="keywordflow">if</span> (upcaseid==identifier) 
<a name="l00038"></a>00038       {
<a name="l00039"></a>00039         active=<span class="keyword">true</span>;
<a name="l00040"></a>00040         <span class="keywordflow">break</span>;
<a name="l00041"></a>00041       }
<a name="l00042"></a>00042       getline(in,<span class="keywordtype">id</span>);
<a name="l00043"></a>00043     }
<a name="l00044"></a>00044     <span class="keywordflow">if</span> (active) {
<a name="l00045"></a>00045       <span class="keywordtype">bool</span> blockend=<span class="keyword">false</span>;
<a name="l00046"></a>00046       <span class="keywordflow">while</span> (in.good()) {
<a name="l00047"></a>00047         getline(in,oneline);
<a name="l00048"></a>00048         <span class="keywordflow">if</span> (oneline.size()==0)
<a name="l00049"></a>00049           <span class="keywordflow">continue</span>;
<a name="l00050"></a>00050         std::stringstream onelinestream(oneline);
<a name="l00051"></a>00051         std::string test;
<a name="l00052"></a>00052         onelinestream &gt;&gt; test;
<a name="l00053"></a>00053         <span class="keywordflow">if</span> (test[0] == <span class="charliteral">'#'</span>) {
<a name="l00054"></a>00054           blockend=<span class="keyword">true</span>;
<a name="l00055"></a>00055           <span class="keywordflow">break</span>;
<a name="l00056"></a>00056         }
<a name="l00057"></a>00057         empty=<span class="keyword">false</span>;
<a name="l00058"></a>00058         block &lt;&lt; oneline &lt;&lt; <span class="stringliteral">"\n"</span>; 
<a name="l00059"></a>00059       }
<a name="l00060"></a>00060       <span class="keywordflow">if</span> (!blockend) {
<a name="l00061"></a>00061         DUNE_THROW(DGFException,
<a name="l00062"></a>00062                    <span class="stringliteral">"Error: block must end with a #-line"</span>);
<a name="l00063"></a>00063       }
<a name="l00064"></a>00064     }
<a name="l00065"></a>00065     <span class="keywordflow">else</span> {
<a name="l00066"></a>00066       <span class="comment">// std::cerr &lt;&lt; "Warning: Block " &lt;&lt; identifier &lt;&lt; " not found" &lt;&lt; std::endl;</span>
<a name="l00067"></a>00067     }
<a name="l00068"></a>00068   }
<a name="l00069"></a>00069   <span class="comment">// count the number of lines in the block</span>
<a name="l00070"></a>00070   <span class="keywordtype">int</span> countlines() {
<a name="l00071"></a>00071     <span class="keywordflow">if</span> (empty) 
<a name="l00072"></a>00072       <span class="keywordflow">return</span> 0;
<a name="l00073"></a>00073     <span class="keywordtype">int</span> ret=0;
<a name="l00074"></a>00074     <span class="keywordflow">while</span> (1) {
<a name="l00075"></a>00075       getnextline();
<a name="l00076"></a>00076       <span class="keywordflow">if</span> (oneline.size()==0)
<a name="l00077"></a>00077         <span class="keywordflow">break</span>;
<a name="l00078"></a>00078       ret++;
<a name="l00079"></a>00079     } 
<a name="l00080"></a>00080     <span class="keywordflow">return</span> ret;
<a name="l00081"></a>00081   }
<a name="l00082"></a>00082  <span class="keyword">protected</span>:
<a name="l00083"></a>00083   std::stringstream line; <span class="comment">// the active line as string buffer </span>
<a name="l00084"></a>00084                           <span class="comment">// for use in the derived classes</span>
<a name="l00085"></a>00085   <span class="comment">// go back to beginning of block</span>
<a name="l00086"></a>00086   <span class="keywordtype">void</span> reset() {
<a name="l00087"></a>00087     pos=-1;
<a name="l00088"></a>00088     block.clear();
<a name="l00089"></a>00089     block.seekg(0);
<a name="l00090"></a>00090     linecount=countlines();
<a name="l00091"></a>00091     pos=-1;
<a name="l00092"></a>00092     block.clear();
<a name="l00093"></a>00093     block.seekg(0);
<a name="l00094"></a>00094   }
<a name="l00095"></a>00095   <span class="comment">// get next line and store in string stream</span>
<a name="l00096"></a>00096   <span class="keywordtype">void</span> getnextline() {
<a name="l00097"></a>00097     line.clear();
<a name="l00098"></a>00098     oneline.clear();
<a name="l00099"></a>00099     getline(block,oneline);
<a name="l00100"></a>00100     <span class="keywordflow">if</span> (oneline.size()&gt;0) {
<a name="l00101"></a>00101       std::size_t comment=oneline.find(<span class="stringliteral">"%"</span>);
<a name="l00102"></a>00102       <span class="keywordflow">if</span> (comment!=std::string::npos) {
<a name="l00103"></a>00103         oneline.erase(comment);
<a name="l00104"></a>00104         <span class="keywordflow">if</span> (oneline.size()==0) {
<a name="l00105"></a>00105           getnextline();
<a name="l00106"></a>00106           <span class="keywordflow">return</span>;
<a name="l00107"></a>00107         }
<a name="l00108"></a>00108       }
<a name="l00109"></a>00109     }
<a name="l00110"></a>00110     line.str(oneline); 
<a name="l00111"></a>00111     pos++;
<a name="l00112"></a>00112   }
<a name="l00113"></a>00113   <span class="comment">// get next entry in line</span>
<a name="l00114"></a>00114   <span class="keyword">template</span> &lt;<span class="keyword">class</span> ENTRY&gt;
<a name="l00115"></a>00115   <span class="keywordtype">bool</span> getnextentry(ENTRY &amp;entry) {
<a name="l00116"></a>00116     line &gt;&gt; entry;
<a name="l00117"></a>00117     <span class="keywordflow">return</span> line;
<a name="l00118"></a>00118   }
<a name="l00119"></a>00119   <span class="keywordtype">bool</span> gettokenparam(std::string token,std::string&amp; entry) {
<a name="l00120"></a>00120     makeupcase(token);
<a name="l00121"></a>00121     std::string ltoken;
<a name="l00122"></a>00122     reset();
<a name="l00123"></a>00123     <span class="keywordflow">do</span> {
<a name="l00124"></a>00124       getnextline();
<a name="l00125"></a>00125       <span class="keywordflow">if</span> (oneline.size()==0)
<a name="l00126"></a>00126         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00127"></a>00127       line &gt;&gt; ltoken;
<a name="l00128"></a>00128       makeupcase(ltoken);
<a name="l00129"></a>00129     } <span class="keywordflow">while</span> (ltoken!=token);
<a name="l00130"></a>00130     getline(line,entry);
<a name="l00131"></a>00131     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00132"></a>00132   }
<a name="l00133"></a>00133   <span class="keywordtype">bool</span> findtoken(std::string token) {
<a name="l00134"></a>00134     makeupcase(token);
<a name="l00135"></a>00135     std::string ltoken;
<a name="l00136"></a>00136     reset();
<a name="l00137"></a>00137     <span class="keywordflow">do</span> {
<a name="l00138"></a>00138       getnextline();
<a name="l00139"></a>00139       <span class="keywordflow">if</span> (oneline.size()==0)
<a name="l00140"></a>00140         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00141"></a>00141       line &gt;&gt; ltoken;
<a name="l00142"></a>00142       makeupcase(ltoken);
<a name="l00143"></a>00143     } <span class="keywordflow">while</span> (ltoken!=token);
<a name="l00144"></a>00144     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00145"></a>00145   }
<a name="l00146"></a>00146  <span class="keyword">public</span>:
<a name="l00147"></a>00147   <span class="comment">// search for block in file and store in buffer</span>
<a name="l00148"></a>00148   BasicBlock(std::istream&amp; in, <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keywordtype">id</span>) :
<a name="l00149"></a>00149     pos(-1),
<a name="l00150"></a>00150     active(false),
<a name="l00151"></a>00151     empty(true),
<a name="l00152"></a>00152     identifier(id),
<a name="l00153"></a>00153     linecount(0)
<a name="l00154"></a>00154   {
<a name="l00155"></a>00155     makeupcase(identifier);
<a name="l00156"></a>00156     in.clear();
<a name="l00157"></a>00157     in.seekg(0);
<a name="l00158"></a>00158     <span class="keywordflow">if</span> (!in) {
<a name="l00159"></a>00159       DUNE_THROW(DGFException,
<a name="l00160"></a>00160                  <span class="stringliteral">"file not found in BasicBlock::BasicBlock"</span>);
<a name="l00161"></a>00161     }
<a name="l00162"></a>00162     getblock(in);
<a name="l00163"></a>00163     <span class="keywordflow">if</span> (active &amp;&amp; !empty) {
<a name="l00164"></a>00164       linecount=countlines();
<a name="l00165"></a>00165       reset();
<a name="l00166"></a>00166     }
<a name="l00167"></a>00167     in.clear();
<a name="l00168"></a>00168     in.seekg(0);
<a name="l00169"></a>00169   }
<a name="l00170"></a>00170   <span class="comment">// some information on this block</span>
<a name="l00171"></a>00171   <span class="keywordtype">bool</span> isactive() {
<a name="l00172"></a>00172     <span class="keywordflow">return</span> active;
<a name="l00173"></a>00173   }
<a name="l00174"></a>00174   <span class="keywordtype">bool</span> isempty() {
<a name="l00175"></a>00175     <span class="keywordflow">return</span> empty;
<a name="l00176"></a>00176   }
<a name="l00177"></a>00177   <span class="keywordtype">int</span>&amp; noflines() {
<a name="l00178"></a>00178     <span class="keywordflow">return</span> linecount;
<a name="l00179"></a>00179   }
<a name="l00180"></a>00180   <span class="keywordtype">int</span> linenumber() {
<a name="l00181"></a>00181     <span class="keywordflow">return</span> pos;
<a name="l00182"></a>00182   }
<a name="l00183"></a>00183   <span class="comment">// for error messages</span>
<a name="l00184"></a>00184   <span class="keyword">friend</span> std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, <span class="keyword">const</span> BasicBlock &amp;b) {
<a name="l00185"></a>00185     <span class="keywordflow">return</span> os 
<a name="l00186"></a>00186       &lt;&lt; <span class="stringliteral">"block "</span> &lt;&lt; b.identifier 
<a name="l00187"></a>00187       &lt;&lt; <span class="stringliteral">" on line "</span> &lt;&lt; b.pos &lt;&lt; std::endl;
<a name="l00188"></a>00188   }
<a name="l00189"></a>00189 };
<a name="l00190"></a>00190 <span class="comment">// *************************************************************</span>
<a name="l00191"></a>00191 <span class="comment">// derived classes for each block in grid file</span>
<a name="l00192"></a>00192 <span class="comment">// *************************************************************</span>
<a name="l00193"></a>00193 <span class="keyword">class </span>VertexBlock : <span class="keyword">public</span> BasicBlock {
<a name="l00194"></a>00194   <span class="keywordtype">int</span> dimworld;          <span class="comment">// the dimesnsion of the vertices (is given from user)</span>
<a name="l00195"></a>00195   <span class="keywordtype">bool</span> goodline;         <span class="comment">// active line describes a vertex</span>
<a name="l00196"></a>00196   std::vector&lt;double&gt; p; <span class="comment">// active vertex</span>
<a name="l00197"></a>00197   <span class="keywordtype">int</span> vtxoffset;
<a name="l00198"></a>00198   <span class="keywordtype">int</span> nofParam;
<a name="l00199"></a>00199   std::vector&lt;double&gt; vtxparam;
<a name="l00200"></a>00200  <span class="keyword">public</span>:
<a name="l00201"></a>00201   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* ID;
<a name="l00202"></a>00202   <span class="comment">// initialize vertex block and get first vertex</span>
<a name="l00203"></a>00203   VertexBlock(std::istream&amp; in,<span class="keywordtype">int</span> &amp;pdimworld) :
<a name="l00204"></a>00204     BasicBlock(in,ID),
<a name="l00205"></a>00205     dimworld(pdimworld),
<a name="l00206"></a>00206     goodline(true),
<a name="l00207"></a>00207     p(0),
<a name="l00208"></a>00208     vtxoffset(0),
<a name="l00209"></a>00209     nofParam(0),
<a name="l00210"></a>00210     vtxparam(0)
<a name="l00211"></a>00211   {
<a name="l00212"></a>00212     <span class="keywordflow">if</span> (!isactive())
<a name="l00213"></a>00213       <span class="keywordflow">return</span>;
<a name="l00214"></a>00214     <span class="keywordflow">if</span> (dimworld&lt;0) 
<a name="l00215"></a>00215       dimworld=0;
<a name="l00216"></a>00216     { 
<a name="l00217"></a>00217       <span class="keywordtype">int</span> x;
<a name="l00218"></a>00218       <span class="keywordflow">if</span> (findtoken(<span class="stringliteral">"firstindex"</span>)) {
<a name="l00219"></a>00219         <span class="keywordflow">if</span> (getnextentry(x)) {
<a name="l00220"></a>00220           vtxoffset=x;
<a name="l00221"></a>00221         }
<a name="l00222"></a>00222       }
<a name="l00223"></a>00223     }
<a name="l00224"></a>00224     { 
<a name="l00225"></a>00225       <span class="keywordtype">int</span> x;
<a name="l00226"></a>00226       <span class="keywordflow">if</span> (findtoken(<span class="stringliteral">"parameters"</span>)) {
<a name="l00227"></a>00227         <span class="keywordflow">if</span> (getnextentry(x)) {
<a name="l00228"></a>00228           nofParam=x;
<a name="l00229"></a>00229           vtxparam.resize(nofParam);
<a name="l00230"></a>00230         }
<a name="l00231"></a>00231       }
<a name="l00232"></a>00232     }
<a name="l00233"></a>00233     dimworld=getDimW();
<a name="l00234"></a>00234     <span class="keywordflow">if</span> (dimworld&gt;0) {
<a name="l00235"></a>00235       p.resize(dimworld);
<a name="l00236"></a>00236     } <span class="keywordflow">else</span> {
<a name="l00237"></a>00237       DUNE_THROW(DGFException,
<a name="l00238"></a>00238                  <span class="stringliteral">"ERROR in "</span> &lt;&lt; *<span class="keyword">this</span>
<a name="l00239"></a>00239                  &lt;&lt; <span class="stringliteral">"      no line with enough entries found"</span>);
<a name="l00240"></a>00240     }
<a name="l00241"></a>00241     reset();
<a name="l00242"></a>00242     next();
<a name="l00243"></a>00243     pdimworld=dimworld;
<a name="l00244"></a>00244   }
<a name="l00245"></a>00245   ~VertexBlock() {
<a name="l00246"></a>00246   }
<a name="l00247"></a>00247   <span class="keywordtype">int</span> offset() {
<a name="l00248"></a>00248     <span class="keywordflow">return</span> vtxoffset;
<a name="l00249"></a>00249   }
<a name="l00250"></a>00250   <span class="keywordtype">int</span> <span class="keyword">get</span>(std::vector&lt;std::vector&lt;double&gt; &gt;&amp; vtx,
<a name="l00251"></a>00251           std::vector&lt;std::vector&lt;double&gt; &gt;&amp; param,<span class="keywordtype">int</span>&amp; nofp) {
<a name="l00252"></a>00252     nofp=nofParam;
<a name="l00253"></a>00253     <span class="keywordtype">size_t</span> nofvtx;
<a name="l00254"></a>00254     <span class="keywordtype">size_t</span> old_size = vtx.size();
<a name="l00255"></a>00255     <span class="comment">// vtx.resize(old_size+nofvertex());</span>
<a name="l00256"></a>00256     <span class="keywordflow">for</span> (nofvtx=old_size;ok();next(),nofvtx++) {
<a name="l00257"></a>00257       vtx.push_back(p);
<a name="l00258"></a>00258       <span class="keywordflow">if</span> (nofParam&gt;0)
<a name="l00259"></a>00259         param.push_back(vtxparam);
<a name="l00260"></a>00260     }
<a name="l00261"></a>00261     <span class="keywordflow">return</span> nofvtx;
<a name="l00262"></a>00262   }
<a name="l00263"></a>00263   <span class="comment">// some information</span>
<a name="l00264"></a>00264   <span class="keywordtype">bool</span> ok() {
<a name="l00265"></a>00265     <span class="keywordflow">return</span> goodline;
<a name="l00266"></a>00266   }
<a name="l00267"></a>00267  <span class="keyword">private</span>:
<a name="l00268"></a>00268   <span class="comment">// get dimworld</span>
<a name="l00269"></a>00269   <span class="keywordtype">int</span> getDimW() {
<a name="l00270"></a>00270     reset();
<a name="l00271"></a>00271     <span class="keywordtype">int</span> dimworld=0;
<a name="l00272"></a>00272     getnextline();
<a name="l00273"></a>00273     <span class="keywordflow">while</span> (dimworld&lt;1 &amp;&amp; linenumber()&lt;noflines()) {
<a name="l00274"></a>00274       dimworld = 0;
<a name="l00275"></a>00275       <span class="keywordtype">double</span> x;
<a name="l00276"></a>00276       <span class="keywordflow">while</span> (getnextentry(x)) {
<a name="l00277"></a>00277         dimworld++;
<a name="l00278"></a>00278       }
<a name="l00279"></a>00279       dimworld-=nofParam;
<a name="l00280"></a>00280       getnextline();
<a name="l00281"></a>00281     }
<a name="l00282"></a>00282     <span class="keywordflow">return</span> dimworld;
<a name="l00283"></a>00283   }
<a name="l00284"></a>00284   <span class="comment">// get next vertex</span>
<a name="l00285"></a>00285   <span class="keywordtype">bool</span> next() {
<a name="l00286"></a>00286     assert(ok());
<a name="l00287"></a>00287     <span class="keywordtype">int</span> n=0;
<a name="l00288"></a>00288     getnextline();
<a name="l00289"></a>00289     <span class="keywordflow">if</span> (linenumber()==noflines()) {
<a name="l00290"></a>00290       goodline=<span class="keyword">false</span>;
<a name="l00291"></a>00291       <span class="keywordflow">return</span> goodline;
<a name="l00292"></a>00292     }
<a name="l00293"></a>00293     <span class="keywordtype">double</span> x;
<a name="l00294"></a>00294     <span class="keywordflow">while</span> (getnextentry(x)){
<a name="l00295"></a>00295       <span class="keywordflow">if</span> (n&lt;dimworld) 
<a name="l00296"></a>00296         p[n]=x;
<a name="l00297"></a>00297       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (n-dimworld&lt;nofParam) {
<a name="l00298"></a>00298         vtxparam[n-dimworld]=x;
<a name="l00299"></a>00299       }
<a name="l00300"></a>00300       n++;
<a name="l00301"></a>00301     }
<a name="l00302"></a>00302     <span class="keywordflow">if</span> (n&gt;0 &amp;&amp; n!=dimworld+nofParam) {
<a name="l00303"></a>00303       <span class="keywordflow">return</span> next();
<a name="l00304"></a>00304       <span class="comment">/*</span>
<a name="l00305"></a>00305 <span class="comment">      DUNE_THROW(DGFException,</span>
<a name="l00306"></a>00306 <span class="comment">                 "ERROR in " &lt;&lt; *this</span>
<a name="l00307"></a>00307 <span class="comment">                 &lt;&lt; "      wrong number of coordinates and parameters: "</span>
<a name="l00308"></a>00308 <span class="comment">                 &lt;&lt; n &lt;&lt; " read but expected " &lt;&lt; dimworld+nofParam);</span>
<a name="l00309"></a>00309 <span class="comment">      */</span>
<a name="l00310"></a>00310     }
<a name="l00311"></a>00311     <span class="keywordflow">if</span> (n==0) {
<a name="l00312"></a>00312       <span class="keywordflow">return</span> next();
<a name="l00313"></a>00313     }
<a name="l00314"></a>00314     goodline=<span class="keyword">true</span>;
<a name="l00315"></a>00315     <span class="keywordflow">if</span> (!goodline) {
<a name="l00316"></a>00316       DUNE_THROW(DGFException,
<a name="l00317"></a>00317                  <span class="stringliteral">"ERROR in "</span> &lt;&lt; *<span class="keyword">this</span>
<a name="l00318"></a>00318                  &lt;&lt; <span class="stringliteral">"      wrong number of coordinates: "</span>
<a name="l00319"></a>00319                  &lt;&lt; n &lt;&lt; <span class="stringliteral">" read but expected "</span> &lt;&lt; dimworld);
<a name="l00320"></a>00320     }
<a name="l00321"></a>00321     <span class="keywordflow">return</span> goodline;
<a name="l00322"></a>00322   }
<a name="l00323"></a>00323   <span class="comment">// get coordinates of active vertex</span>
<a name="l00324"></a>00324   <span class="keywordtype">double</span> operator[](<span class="keywordtype">int</span> i) {
<a name="l00325"></a>00325     assert(ok());
<a name="l00326"></a>00326     assert(linenumber()&gt;=0);
<a name="l00327"></a>00327     assert(0&lt;=i &amp;&amp; i&lt;dimworld);
<a name="l00328"></a>00328     <span class="keywordflow">return</span> p[i];
<a name="l00329"></a>00329   }
<a name="l00330"></a>00330 };
<a name="l00331"></a>00331 <span class="keyword">const</span> <span class="keywordtype">char</span> *VertexBlock::ID = <span class="stringliteral">"Vertex"</span>;
<a name="l00332"></a>00332 <span class="comment">// *************************************************************</span>
<a name="l00333"></a>00333 <span class="keyword">class </span>SimplexGenerationBlock : <span class="keyword">public</span> BasicBlock {
<a name="l00334"></a>00334   <span class="keywordtype">double</span> area_;
<a name="l00335"></a>00335   <span class="keywordtype">double</span> angle_;
<a name="l00336"></a>00336   <span class="keywordtype">bool</span> display_;
<a name="l00337"></a>00337   std::string path_;
<a name="l00338"></a>00338   <span class="keywordtype">bool</span> haspath_;
<a name="l00339"></a>00339   std::string filename_;
<a name="l00340"></a>00340   std::string filetype_;
<a name="l00341"></a>00341   std::string parameter_;
<a name="l00342"></a>00342   <span class="keywordtype">bool</span> hasfile_;
<a name="l00343"></a>00343   <span class="keywordtype">int</span> dimension_;
<a name="l00344"></a>00344  <span class="keyword">public</span>:
<a name="l00345"></a>00345   <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">char</span>* ID;
<a name="l00346"></a>00346   SimplexGenerationBlock(std::istream&amp; in) :
<a name="l00347"></a>00347     BasicBlock(in,ID),
<a name="l00348"></a>00348     area_(-1),
<a name="l00349"></a>00349     angle_(-1),
<a name="l00350"></a>00350     display_(false),
<a name="l00351"></a>00351     haspath_(false),
<a name="l00352"></a>00352     filetype_(),
<a name="l00353"></a>00353     parameter_(),
<a name="l00354"></a>00354     hasfile_(false),
<a name="l00355"></a>00355     dimension_(-1)
<a name="l00356"></a>00356   {
<a name="l00357"></a>00357     <span class="keywordtype">double</span> x;
<a name="l00358"></a>00358     <span class="keywordtype">bool</span> b;
<a name="l00359"></a>00359     <span class="keywordtype">int</span> i;
<a name="l00360"></a>00360     std::string p;
<a name="l00361"></a>00361     <span class="keywordflow">if</span> (findtoken(<span class="stringliteral">"max-area"</span>))
<a name="l00362"></a>00362       <span class="keywordflow">if</span> (getnextentry(x))
<a name="l00363"></a>00363         area_=x;
<a name="l00364"></a>00364     <span class="keywordflow">if</span> (findtoken(<span class="stringliteral">"min-angle"</span>))
<a name="l00365"></a>00365       <span class="keywordflow">if</span> (getnextentry(x))
<a name="l00366"></a>00366         angle_=x;
<a name="l00367"></a>00367     <span class="keywordflow">if</span> (findtoken(<span class="stringliteral">"display"</span>)) 
<a name="l00368"></a>00368       <span class="keywordflow">if</span> (getnextentry(b))
<a name="l00369"></a>00369         display_=b;
<a name="l00370"></a>00370     <span class="keywordflow">if</span> (findtoken(<span class="stringliteral">"path"</span>)) 
<a name="l00371"></a>00371       <span class="keywordflow">if</span> (getnextentry(p)) {
<a name="l00372"></a>00372         path_=p;
<a name="l00373"></a>00373         haspath_=<span class="keyword">true</span>;
<a name="l00374"></a>00374       }
<a name="l00375"></a>00375     <span class="keywordflow">if</span> (findtoken(<span class="stringliteral">"file"</span>)) {
<a name="l00376"></a>00376       <span class="keywordflow">if</span> (getnextentry(p)) {
<a name="l00377"></a>00377         filename_=p;
<a name="l00378"></a>00378         hasfile_=<span class="keyword">true</span>;
<a name="l00379"></a>00379       }
<a name="l00380"></a>00380       <span class="keywordflow">if</span> (getnextentry(p)) {
<a name="l00381"></a>00381         filetype_=p;
<a name="l00382"></a>00382       }
<a name="l00383"></a>00383       <span class="keywordflow">if</span> (findtoken(<span class="stringliteral">"dimension"</span>))
<a name="l00384"></a>00384         <span class="keywordflow">if</span> (getnextentry(i)) {
<a name="l00385"></a>00385           dimension_=i;
<a name="l00386"></a>00386         }
<a name="l00387"></a>00387       gettokenparam(<span class="stringliteral">"parameter"</span>,parameter_);
<a name="l00388"></a>00388     }
<a name="l00389"></a>00389   }
<a name="l00390"></a>00390   <span class="keywordtype">double</span> maxArea() {
<a name="l00391"></a>00391     <span class="keywordflow">return</span> area_;
<a name="l00392"></a>00392   }
<a name="l00393"></a>00393   <span class="keywordtype">double</span> minAngle() {
<a name="l00394"></a>00394     <span class="keywordflow">return</span> angle_;
<a name="l00395"></a>00395   }
<a name="l00396"></a>00396   <span class="keywordtype">bool</span> display() {
<a name="l00397"></a>00397     <span class="keywordflow">return</span> display_;
<a name="l00398"></a>00398   }
<a name="l00399"></a>00399   <span class="keywordtype">bool</span> haspath() {
<a name="l00400"></a>00400     <span class="keywordflow">return</span> haspath_;
<a name="l00401"></a>00401   }
<a name="l00402"></a>00402   std::string path() {
<a name="l00403"></a>00403     <span class="keywordflow">return</span> path_;
<a name="l00404"></a>00404   }
<a name="l00405"></a>00405   <span class="keywordtype">bool</span> hasfile() {
<a name="l00406"></a>00406     <span class="keywordflow">return</span> hasfile_;
<a name="l00407"></a>00407   }
<a name="l00408"></a>00408   std::string filename() {
<a name="l00409"></a>00409     <span class="keywordflow">return</span> filename_;
<a name="l00410"></a>00410   }
<a name="l00411"></a>00411   std::string filetype() {
<a name="l00412"></a>00412     <span class="keywordflow">return</span> filetype_;
<a name="l00413"></a>00413   }
<a name="l00414"></a>00414   <span class="keywordtype">int</span> dimension() {
<a name="l00415"></a>00415     <span class="keywordflow">return</span> dimension_;
<a name="l00416"></a>00416   }
<a name="l00417"></a>00417   std::string parameter() {
<a name="l00418"></a>00418     <span class="keywordflow">return</span> parameter_;
<a name="l00419"></a>00419   }
<a name="l00420"></a>00420 };
<a name="l00421"></a>00421 <span class="keyword">const</span> <span class="keywordtype">char</span>* SimplexGenerationBlock::ID = <span class="stringliteral">"Simplexgenerator"</span>;
<a name="l00422"></a>00422 <span class="comment">// *************************************************************</span>
<a name="l00423"></a>00423 <span class="keyword">class </span>SimplexBlock : <span class="keyword">public</span> BasicBlock {
<a name="l00424"></a>00424   <span class="keywordtype">int</span> nofvtx;        
<a name="l00425"></a>00425   <span class="keywordtype">int</span> vtxoffset;
<a name="l00426"></a>00426   <span class="keywordtype">int</span> dimworld;  
<a name="l00427"></a>00427   <span class="keywordtype">bool</span> goodline;      <span class="comment">// active line describes a vertex</span>
<a name="l00428"></a>00428   std::vector&lt;int&gt; p; <span class="comment">// active vertex</span>
<a name="l00429"></a>00429   <span class="keywordtype">int</span> nofparams;      <span class="comment">// nof parameters</span>
<a name="l00430"></a>00430   std::vector&lt;double&gt; psimpl; <span class="comment">// active parameters</span>
<a name="l00431"></a>00431 <span class="keyword">public</span>:
<a name="l00432"></a>00432   <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">char</span>* ID;
<a name="l00433"></a>00433   SimplexBlock(std::istream&amp; in,<span class="keywordtype">int</span> pnofvtx, <span class="keywordtype">int</span> pvtxoffset, <span class="keywordtype">int</span> adimworld) :
<a name="l00434"></a>00434     BasicBlock(in,ID),
<a name="l00435"></a>00435     nofvtx(pnofvtx),
<a name="l00436"></a>00436     vtxoffset(pvtxoffset),
<a name="l00437"></a>00437     dimworld(adimworld),
<a name="l00438"></a>00438     goodline(true),
<a name="l00439"></a>00439     p(adimworld+1),
<a name="l00440"></a>00440     nofparams(0),
<a name="l00441"></a>00441     psimpl(0)
<a name="l00442"></a>00442   {
<a name="l00443"></a>00443     <span class="keywordflow">if</span> (!isactive()) <span class="keywordflow">return</span>;
<a name="l00444"></a>00444     assert((dimworld+1)&gt;0);
<a name="l00445"></a>00445     <span class="keywordflow">if</span> (findtoken(<span class="stringliteral">"parameters"</span>)) {
<a name="l00446"></a>00446       <span class="keywordtype">int</span> x=0;
<a name="l00447"></a>00447       <span class="keywordflow">if</span> (getnextentry(x)) {
<a name="l00448"></a>00448         <span class="keywordflow">if</span> (x&gt;0) {
<a name="l00449"></a>00449           nofparams = x;
<a name="l00450"></a>00450           psimpl.resize(nofparams);
<a name="l00451"></a>00451         }
<a name="l00452"></a>00452       }
<a name="l00453"></a>00453       <span class="keywordflow">if</span> (x&lt;=0) {
<a name="l00454"></a>00454         DUNE_THROW(DGFException,
<a name="l00455"></a>00455                    <span class="stringliteral">"ERROR in "</span> &lt;&lt; *<span class="keyword">this</span>
<a name="l00456"></a>00456                    &lt;&lt; <span class="stringliteral">"      parameter key found with no or non-positive value "</span>
<a name="l00457"></a>00457                    &lt;&lt; x);
<a name="l00458"></a>00458       }
<a name="l00459"></a>00459     }
<a name="l00460"></a>00460     reset();
<a name="l00461"></a>00461     next();
<a name="l00462"></a>00462   }
<a name="l00463"></a>00463   ~SimplexBlock() {
<a name="l00464"></a>00464   }
<a name="l00465"></a>00465   <span class="keywordtype">int</span> <span class="keyword">get</span>(std::vector&lt;std::vector&lt;int&gt; &gt;&amp; simplex,
<a name="l00466"></a>00466           std::vector&lt;std::vector&lt;double&gt; &gt;&amp;params,<span class="keywordtype">int</span>&amp; nofp) {
<a name="l00467"></a>00467     nofp=nofparams;
<a name="l00468"></a>00468     <span class="keywordtype">int</span> nofsimpl;
<a name="l00469"></a>00469     <span class="keywordflow">for</span> (nofsimpl=0; ok(); next(), nofsimpl++) {
<a name="l00470"></a>00470       simplex.push_back(p); 
<a name="l00471"></a>00471       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j=0;j&lt;p.size();j++) {
<a name="l00472"></a>00472         simplex[nofsimpl][j] = p[j];
<a name="l00473"></a>00473       }
<a name="l00474"></a>00474       <span class="keywordflow">if</span> (nofparams&gt;0) {
<a name="l00475"></a>00475         params.push_back(psimpl);
<a name="l00476"></a>00476       }
<a name="l00477"></a>00477     }
<a name="l00478"></a>00478     <span class="comment">/*</span>
<a name="l00479"></a>00479 <span class="comment">    // make numbering starting from zero </span>
<a name="l00480"></a>00480 <span class="comment">    // not matter whether offset is positive or negative </span>
<a name="l00481"></a>00481 <span class="comment">    offset = vtxoffset;</span>
<a name="l00482"></a>00482 <span class="comment">    if(offset != 0) {</span>
<a name="l00483"></a>00483 <span class="comment">      for (int i=0; i&lt;nofsimpl; ++i) {</span>
<a name="l00484"></a>00484 <span class="comment">        for (size_t j=0;j&lt;simplex[i].size();++j) {</span>
<a name="l00485"></a>00485 <span class="comment">          simplex[i][j] -= offset; </span>
<a name="l00486"></a>00486 <span class="comment">        }</span>
<a name="l00487"></a>00487 <span class="comment">      }</span>
<a name="l00488"></a>00488 <span class="comment">    }</span>
<a name="l00489"></a>00489 <span class="comment">    */</span>
<a name="l00490"></a>00490     <span class="keywordflow">return</span> nofsimpl;
<a name="l00491"></a>00491   }
<a name="l00492"></a>00492   <span class="comment">// cubes -&gt; simplex</span>
<a name="l00493"></a>00493   <span class="keyword">static</span> <span class="keywordtype">int</span> cube2simplex(std::vector&lt;std::vector&lt;double&gt; &gt;&amp; vtx,
<a name="l00494"></a>00494                           std::vector&lt;std::vector&lt;int&gt; &gt;&amp; elements,
<a name="l00495"></a>00495                           std::vector&lt;std::vector&lt;double&gt; &gt;&amp; params) {
<a name="l00496"></a>00496     <span class="keyword">static</span> <span class="keywordtype">int</span> offset3[6][4][3] = {{{0,0,0},{1,1,1},{1,0,0},{1,1,0}},
<a name="l00497"></a>00497                                    {{0,0,0},{1,1,1},{1,0,1},{1,0,0}},
<a name="l00498"></a>00498                                    {{0,0,0},{1,1,1},{0,0,1},{1,0,1}},
<a name="l00499"></a>00499                                    {{0,0,0},{1,1,1},{1,1,0},{0,1,0}},
<a name="l00500"></a>00500                                    {{0,0,0},{1,1,1},{0,1,0},{0,1,1}},
<a name="l00501"></a>00501                                    {{0,0,0},{1,1,1},{0,1,1},{0,0,1}} };
<a name="l00502"></a>00502     <span class="keyword">static</span> <span class="keywordtype">int</span> offset2[2][3][2] = {{{0,0},{1,0},{0,1}},
<a name="l00503"></a>00503                                    {{1,1},{0,1},{1,0}}};
<a name="l00504"></a>00504     <span class="keywordflow">if</span> (vtx.size()==0)
<a name="l00505"></a>00505       DUNE_THROW(DGFException, <span class="stringliteral">"Converting Cune- to Simplexgrid with no vertices given"</span>);
<a name="l00506"></a>00506     <span class="keywordtype">int</span> dimworld = vtx[0].size();
<a name="l00507"></a>00507     dverb &lt;&lt; <span class="stringliteral">"generating simplices..."</span>;
<a name="l00508"></a>00508     dverb.flush();
<a name="l00509"></a>00509     std::vector&lt;std::vector&lt;int&gt; &gt; cubes = elements;
<a name="l00510"></a>00510     std::vector&lt;std::vector&lt;double&gt; &gt; cubeparams = params;
<a name="l00511"></a>00511     <span class="keywordflow">if</span>(dimworld == 3) {
<a name="l00512"></a>00512       elements.resize(6*cubes.size()); 
<a name="l00513"></a>00513       <span class="keywordflow">if</span> (cubeparams.size()&gt;0)
<a name="l00514"></a>00514         params.resize(6*cubes.size());
<a name="l00515"></a>00515       <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> countsimpl=0;countsimpl &lt; elements.size(); countsimpl++) 
<a name="l00516"></a>00516         elements[countsimpl].resize(4);
<a name="l00517"></a>00517       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> c=0;c&lt;cubes.size();c++)  {
<a name="l00518"></a>00518         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> tetra=0; tetra &lt; 6 ; tetra++) {
<a name="l00519"></a>00519           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> v=0;v&lt;4;v++) {
<a name="l00520"></a>00520             elements[c*6+tetra][v]=
<a name="l00521"></a>00521               cubes[c][offset3[tetra][v][0]+
<a name="l00522"></a>00522                        offset3[tetra][v][1]*2+
<a name="l00523"></a>00523                        offset3[tetra][v][2]*4];
<a name="l00524"></a>00524           }
<a name="l00525"></a>00525           <span class="keywordflow">if</span> (cubeparams.size()&gt;0)
<a name="l00526"></a>00526             params[c*6+tetra] = cubeparams[c];
<a name="l00527"></a>00527         }
<a name="l00528"></a>00528       }
<a name="l00529"></a>00529     }
<a name="l00530"></a>00530     <span class="keywordflow">else</span> {
<a name="l00531"></a>00531       elements.resize(2*cubes.size() ); 
<a name="l00532"></a>00532       <span class="keywordflow">if</span> (cubeparams.size()&gt;0)
<a name="l00533"></a>00533         params.resize(2*cubes.size());
<a name="l00534"></a>00534       <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> countsimpl=0;countsimpl &lt; elements.size(); countsimpl++)
<a name="l00535"></a>00535         elements[countsimpl].resize(3);
<a name="l00536"></a>00536       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> c=0;c&lt;cubes.size();c++) {
<a name="l00537"></a>00537         <span class="keywordtype">int</span> diag = 0;
<a name="l00538"></a>00538         <span class="keywordtype">double</span> mind = 0;
<a name="l00539"></a>00539         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> d=0;d&lt;2;d++) {
<a name="l00540"></a>00540           <span class="keywordtype">double</span> diaglen = 
<a name="l00541"></a>00541             pow(vtx[cubes[c][d]][0]-vtx[cubes[c][2+((d+1)%2)]][0],2) +
<a name="l00542"></a>00542             pow(vtx[cubes[c][d]][1]-vtx[cubes[c][2+((d+1)%2)]][1],2);
<a name="l00543"></a>00543           <span class="keywordflow">if</span> (diaglen&lt;mind) {
<a name="l00544"></a>00544             mind=diaglen;
<a name="l00545"></a>00545             diag = d;
<a name="l00546"></a>00546           }
<a name="l00547"></a>00547         }
<a name="l00548"></a>00548         
<a name="l00549"></a>00549         <span class="keywordflow">if</span> (diag == 0) {
<a name="l00550"></a>00550           <span class="keywordtype">int</span> tmp0 = cubes[c][0];
<a name="l00551"></a>00551           cubes[c][0] = cubes[c][1];
<a name="l00552"></a>00552           cubes[c][1] = cubes[c][3];
<a name="l00553"></a>00553           cubes[c][3] = cubes[c][2];
<a name="l00554"></a>00554           cubes[c][2] = tmp0;
<a name="l00555"></a>00555         }
<a name="l00556"></a>00556         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> tetra=0; tetra &lt; 2 ; tetra++) {
<a name="l00557"></a>00557           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> v=0;v&lt;3;v++) {
<a name="l00558"></a>00558             elements[c*2+tetra][v]=
<a name="l00559"></a>00559               cubes[c][offset2[tetra][v][0]+
<a name="l00560"></a>00560                        offset2[tetra][v][1]*2];
<a name="l00561"></a>00561           }
<a name="l00562"></a>00562           <span class="keywordflow">if</span> (cubeparams.size()&gt;0)
<a name="l00563"></a>00563             params[c*2+tetra] = cubeparams[c];
<a name="l00564"></a>00564         }
<a name="l00565"></a>00565       }
<a name="l00566"></a>00566     }
<a name="l00567"></a>00567     <span class="keywordflow">return</span> elements.size();
<a name="l00568"></a>00568   }
<a name="l00569"></a>00569   <span class="comment">// some information</span>
<a name="l00570"></a>00570   <span class="keywordtype">bool</span> ok() {
<a name="l00571"></a>00571     <span class="keywordflow">return</span> goodline;
<a name="l00572"></a>00572   }
<a name="l00573"></a>00573   <span class="keywordtype">int</span> nofsimplex() {
<a name="l00574"></a>00574     <span class="keywordflow">return</span> noflines();
<a name="l00575"></a>00575   }
<a name="l00576"></a>00576 <span class="keyword">private</span>:
<a name="l00577"></a>00577   <span class="comment">// get next simplex</span>
<a name="l00578"></a>00578   <span class="keywordtype">bool</span> next() {
<a name="l00579"></a>00579     assert(ok());
<a name="l00580"></a>00580     <span class="keywordtype">int</span> n=0;
<a name="l00581"></a>00581     getnextline();
<a name="l00582"></a>00582     <span class="keywordflow">if</span> (linenumber()==noflines()) {
<a name="l00583"></a>00583       goodline=<span class="keyword">false</span>;
<a name="l00584"></a>00584       <span class="keywordflow">return</span> goodline;
<a name="l00585"></a>00585     }
<a name="l00586"></a>00586     <span class="keywordtype">double</span> x;
<a name="l00587"></a>00587     <span class="keywordflow">while</span> (getnextentry(x)){
<a name="l00588"></a>00588       <span class="keywordflow">if</span> (n&lt;(<span class="keywordtype">int</span>)p.size()) { 
<a name="l00589"></a>00589         p[n]=int(x)-vtxoffset;
<a name="l00590"></a>00590         <span class="keywordflow">if</span> (p[n]&lt;0 || p[n]&gt;=nofvtx) {
<a name="l00591"></a>00591           DUNE_THROW(DGFException,
<a name="l00592"></a>00592                      <span class="stringliteral">"ERROR in "</span> &lt;&lt; *<span class="keyword">this</span>
<a name="l00593"></a>00593                      &lt;&lt; <span class="stringliteral">"      wrong index of vertices: "</span>
<a name="l00594"></a>00594                      &lt;&lt; x &lt;&lt; <span class="stringliteral">" read but expected value between "</span>
<a name="l00595"></a>00595                      &lt;&lt; vtxoffset &lt;&lt; <span class="stringliteral">" and "</span>
<a name="l00596"></a>00596                      &lt;&lt; nofvtx+vtxoffset);
<a name="l00597"></a>00597         }
<a name="l00598"></a>00598       } 
<a name="l00599"></a>00599       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (n-<span class="keywordtype">int</span>(p.size())&lt;nofparams) {
<a name="l00600"></a>00600         psimpl[n-p.size()]=x;
<a name="l00601"></a>00601       }
<a name="l00602"></a>00602       n++;
<a name="l00603"></a>00603     }
<a name="l00604"></a>00604     <span class="comment">// tests if the written block is ok in its size</span>
<a name="l00605"></a>00605     <span class="keywordflow">if</span> (n!=(<span class="keywordtype">int</span>)p.size()+nofparams) {
<a name="l00606"></a>00606       <span class="keywordflow">return</span> next();
<a name="l00607"></a>00607     }
<a name="l00608"></a>00608     <span class="comment">// tests if the written block is ok in its size</span>
<a name="l00609"></a>00609     goodline=(n==(int)p.size()+nofparams);
<a name="l00610"></a>00610     <span class="keywordflow">return</span> goodline;
<a name="l00611"></a>00611   }
<a name="l00612"></a>00612   <span class="comment">// get coordinates of active simplex</span>
<a name="l00613"></a>00613   <span class="keywordtype">int</span> operator[](<span class="keywordtype">int</span> i) {
<a name="l00614"></a>00614     assert(ok());
<a name="l00615"></a>00615     assert(linenumber()&gt;=0);
<a name="l00616"></a>00616     assert(0&lt;=i &amp;&amp; i&lt;(dimworld+1));
<a name="l00617"></a>00617     <span class="keywordflow">return</span> p[i];
<a name="l00618"></a>00618   }
<a name="l00619"></a>00619 };
<a name="l00620"></a>00620 <span class="keyword">const</span> <span class="keywordtype">char</span>* SimplexBlock::ID = <span class="stringliteral">"Simplex"</span>;
<a name="l00622"></a>00622 <span class="keyword">class </span>CubeBlock : <span class="keyword">public</span> BasicBlock {
<a name="l00623"></a>00623   <span class="keywordtype">int</span> nofvtx;        
<a name="l00624"></a>00624   <span class="keywordtype">int</span> dimworld;  
<a name="l00625"></a>00625   <span class="keywordtype">bool</span> goodline;        <span class="comment">// active line describes a vertex</span>
<a name="l00626"></a>00626   std::vector&lt;int&gt; p;   <span class="comment">// active vertex</span>
<a name="l00627"></a>00627   std::vector&lt;int&gt; map; <span class="comment">// active vertex</span>
<a name="l00628"></a>00628   <span class="keywordtype">int</span> nofparams;
<a name="l00629"></a>00629   <span class="keywordtype">int</span> vtxoffset;
<a name="l00630"></a>00630   std::vector&lt;double&gt; psimpl; <span class="comment">// active parameters</span>
<a name="l00631"></a>00631  <span class="keyword">public</span>:
<a name="l00632"></a>00632   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* ID;
<a name="l00633"></a>00633   CubeBlock(std::istream&amp; in,<span class="keywordtype">int</span> pnofvtx, <span class="keywordtype">int</span> pvtxoffset, <span class="keywordtype">int</span> adimworld) :
<a name="l00634"></a>00634     BasicBlock(in,ID),
<a name="l00635"></a>00635     nofvtx(pnofvtx),
<a name="l00636"></a>00636     dimworld(adimworld),
<a name="l00637"></a>00637     goodline(true),
<a name="l00638"></a>00638     p(0),
<a name="l00639"></a>00639     map(0),
<a name="l00640"></a>00640     nofparams(0),
<a name="l00641"></a>00641     vtxoffset(pvtxoffset),
<a name="l00642"></a>00642     psimpl(0)
<a name="l00643"></a>00643   {
<a name="l00644"></a>00644     <span class="keywordflow">if</span> (!isactive()) <span class="keywordflow">return</span>;
<a name="l00645"></a>00645     assert((dimworld+1)&gt;0);
<a name="l00646"></a>00646     p.resize(1&lt;&lt;dimworld);
<a name="l00647"></a>00647     map.resize(1&lt;&lt;dimworld);
<a name="l00648"></a>00648     <span class="keywordtype">int</span> x;
<a name="l00649"></a>00649     <span class="keywordflow">if</span> (findtoken(<span class="stringliteral">"map"</span>)) {
<a name="l00650"></a>00650       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0;i&lt;map.size();i++) {
<a name="l00651"></a>00651         <span class="keywordflow">if</span> (getnextentry(x)) {
<a name="l00652"></a>00652           map[i]=x;
<a name="l00653"></a>00653         } <span class="keywordflow">else</span> {
<a name="l00654"></a>00654           DUNE_THROW(DGFException,
<a name="l00655"></a>00655                      <span class="stringliteral">"ERROR in "</span> &lt;&lt; *<span class="keyword">this</span>
<a name="l00656"></a>00656                      &lt;&lt; <span class="stringliteral">"      reference maping not complete "</span>
<a name="l00657"></a>00657                      &lt;&lt; i
<a name="l00658"></a>00658                      &lt;&lt; <span class="stringliteral">" entries read but expected "</span> 
<a name="l00659"></a>00659                      &lt;&lt; map.size());
<a name="l00660"></a>00660         }
<a name="l00661"></a>00661       }
<a name="l00662"></a>00662     } <span class="keywordflow">else</span> {
<a name="l00663"></a>00663       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0;i&lt;map.size();i++) {
<a name="l00664"></a>00664         map[i]=i;
<a name="l00665"></a>00665       }
<a name="l00666"></a>00666     }
<a name="l00667"></a>00667     <span class="keywordflow">if</span> (findtoken(<span class="stringliteral">"parameters"</span>)) {
<a name="l00668"></a>00668       <span class="keywordtype">int</span> x=0;
<a name="l00669"></a>00669       <span class="keywordflow">if</span> (getnextentry(x)) {
<a name="l00670"></a>00670         <span class="keywordflow">if</span> (x&gt;0) {
<a name="l00671"></a>00671           nofparams = x;
<a name="l00672"></a>00672           psimpl.resize(nofparams);
<a name="l00673"></a>00673         }
<a name="l00674"></a>00674       }
<a name="l00675"></a>00675       <span class="keywordflow">if</span> (x&lt;=0){
<a name="l00676"></a>00676         DUNE_THROW(DGFException,
<a name="l00677"></a>00677                    <span class="stringliteral">"ERROR in "</span> &lt;&lt; *<span class="keyword">this</span>
<a name="l00678"></a>00678                    &lt;&lt; <span class="stringliteral">"      parameter key found with no or non-positive value "</span>
<a name="l00679"></a>00679                    &lt;&lt; x);
<a name="l00680"></a>00680       }
<a name="l00681"></a>00681     }
<a name="l00682"></a>00682     reset();
<a name="l00683"></a>00683     next();
<a name="l00684"></a>00684   }
<a name="l00685"></a>00685   ~CubeBlock() {
<a name="l00686"></a>00686   }
<a name="l00687"></a>00687   <span class="keywordtype">int</span> <span class="keyword">get</span>(std::vector&lt;std::vector&lt;int&gt; &gt;&amp; simplex,
<a name="l00688"></a>00688           std::vector&lt;std::vector&lt;double&gt; &gt;&amp;params,<span class="keywordtype">int</span>&amp; nofp) {
<a name="l00689"></a>00689     nofp=nofparams;
<a name="l00690"></a>00690     <span class="keywordtype">int</span> nofsimpl;
<a name="l00691"></a>00691     <span class="comment">// simplex.resize(nofsimplex());</span>
<a name="l00692"></a>00692     <span class="keywordflow">for</span> (nofsimpl=0; ok(); next(), nofsimpl++) {
<a name="l00693"></a>00693       simplex.push_back(p); 
<a name="l00694"></a>00694       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j=0;j&lt;p.size();j++) {
<a name="l00695"></a>00695         simplex[nofsimpl][map[j]] = p[j];
<a name="l00696"></a>00696       }
<a name="l00697"></a>00697       <span class="keywordflow">if</span> (nofparams&gt;0) {
<a name="l00698"></a>00698         params.push_back(psimpl);
<a name="l00699"></a>00699       }
<a name="l00700"></a>00700     }
<a name="l00701"></a>00701     <span class="comment">/*</span>
<a name="l00702"></a>00702 <span class="comment">    int offset = vtxoffset;</span>
<a name="l00703"></a>00703 <span class="comment">    if(offset != 0) </span>
<a name="l00704"></a>00704 <span class="comment">    {</span>
<a name="l00705"></a>00705 <span class="comment">      for (int i=0; i&lt;nofsimpl; ++i) </span>
<a name="l00706"></a>00706 <span class="comment">      {</span>
<a name="l00707"></a>00707 <span class="comment">        for (size_t j=0;j&lt;simplex[i].size();++j) </span>
<a name="l00708"></a>00708 <span class="comment">        {</span>
<a name="l00709"></a>00709 <span class="comment">          simplex[i][j] -= offset; </span>
<a name="l00710"></a>00710 <span class="comment">        }</span>
<a name="l00711"></a>00711 <span class="comment">      }</span>
<a name="l00712"></a>00712 <span class="comment">    }</span>
<a name="l00713"></a>00713 <span class="comment">    */</span>
<a name="l00714"></a>00714     <span class="keywordflow">return</span> nofsimpl;
<a name="l00715"></a>00715   }
<a name="l00716"></a>00716   <span class="comment">// some information</span>
<a name="l00717"></a>00717   <span class="keywordtype">bool</span> ok() {
<a name="l00718"></a>00718     <span class="keywordflow">return</span> goodline;
<a name="l00719"></a>00719   }
<a name="l00720"></a>00720   <span class="keywordtype">int</span> nofsimplex() {
<a name="l00721"></a>00721     <span class="keywordflow">return</span> noflines();
<a name="l00722"></a>00722   }
<a name="l00723"></a>00723  <span class="keyword">private</span>:
<a name="l00724"></a>00724   <span class="comment">// get next simplex</span>
<a name="l00725"></a>00725   <span class="keywordtype">bool</span> next() {
<a name="l00726"></a>00726     assert(ok());
<a name="l00727"></a>00727     <span class="keywordtype">int</span> n=0;
<a name="l00728"></a>00728     getnextline();
<a name="l00729"></a>00729     <span class="keywordflow">if</span> (linenumber()==noflines()) {
<a name="l00730"></a>00730       goodline=<span class="keyword">false</span>;
<a name="l00731"></a>00731       <span class="keywordflow">return</span> goodline;
<a name="l00732"></a>00732     }
<a name="l00733"></a>00733     <span class="keywordtype">double</span> x;
<a name="l00734"></a>00734     <span class="keywordflow">while</span> (getnextentry(x))
<a name="l00735"></a>00735     {
<a name="l00736"></a>00736       <span class="keywordflow">if</span> (n&lt;(<span class="keywordtype">int</span>)p.size())
<a name="l00737"></a>00737       { 
<a name="l00738"></a>00738         p[n]=int(x)-vtxoffset;
<a name="l00739"></a>00739         <span class="keywordflow">if</span> (p[n]&lt;0 || p[n]&gt;=nofvtx)
<a name="l00740"></a>00740         {
<a name="l00741"></a>00741           DUNE_THROW(DGFException,
<a name="l00742"></a>00742                      <span class="stringliteral">"ERROR in "</span> &lt;&lt; *<span class="keyword">this</span>
<a name="l00743"></a>00743                      &lt;&lt; <span class="stringliteral">"      wrong index of vertices: "</span>
<a name="l00744"></a>00744                      &lt;&lt; x &lt;&lt; <span class="stringliteral">" read but expected value between "</span>
<a name="l00745"></a>00745                      &lt;&lt; vtxoffset &lt;&lt; <span class="stringliteral">" and "</span>
<a name="l00746"></a>00746                      &lt;&lt; nofvtx+vtxoffset);
<a name="l00747"></a>00747         }
<a name="l00748"></a>00748       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (n-<span class="keywordtype">int</span>(p.size())&lt;nofparams) {
<a name="l00749"></a>00749         psimpl[n-p.size()]=x;
<a name="l00750"></a>00750       }
<a name="l00751"></a>00751       n++;
<a name="l00752"></a>00752     }
<a name="l00753"></a>00753     <span class="comment">// tests if the written block is ok in its size</span>
<a name="l00754"></a>00754     <span class="keywordflow">if</span> (n!=(<span class="keywordtype">int</span>)p.size()+nofparams) {
<a name="l00755"></a>00755       <span class="keywordflow">return</span> next();
<a name="l00756"></a>00756     }
<a name="l00757"></a>00757     goodline=(n==(int)p.size()+nofparams);
<a name="l00758"></a>00758     <span class="keywordflow">return</span> goodline;
<a name="l00759"></a>00759   }
<a name="l00760"></a>00760   <span class="comment">// get coordinates of active simplex</span>
<a name="l00761"></a>00761   <span class="keywordtype">int</span> operator[](<span class="keywordtype">int</span> i) {
<a name="l00762"></a>00762     assert(ok());
<a name="l00763"></a>00763     assert(linenumber()&gt;=0);
<a name="l00764"></a>00764     assert(0&lt;=i &amp;&amp; i&lt; (<span class="keywordtype">int</span>)p.size());
<a name="l00765"></a>00765     <span class="keywordflow">return</span> p[i];
<a name="l00766"></a>00766   }
<a name="l00767"></a>00767 };
<a name="l00768"></a>00768 <span class="keyword">const</span> <span class="keywordtype">char</span>* CubeBlock::ID = <span class="stringliteral">"Cube"</span>;
<a name="l00769"></a>00769 <span class="comment">// *************************************************************</span>
<a name="l00770"></a>00770 <span class="comment">// the block BoundaryDomBlock looks for a domain which is characterized by two points in R^dimworld</span>
<a name="l00771"></a>00771 <span class="keyword">class </span>BoundaryDomBlock : <span class="keyword">public</span> BasicBlock {
<a name="l00772"></a>00772   <span class="keywordtype">int</span> dimworld;        <span class="comment">// the dimesnsion of the vertices (is given  from user)</span>
<a name="l00773"></a>00773   <span class="keywordtype">bool</span> goodline;       <span class="comment">// active line describes a vertex</span>
<a name="l00774"></a>00774   std::vector&lt;double&gt; p1,p2;    <span class="comment">// active vertex</span>
<a name="l00775"></a>00775   <span class="keywordtype">int</span> bndid;
<a name="l00776"></a>00776   <span class="keywordtype">bool</span> withdefault;
<a name="l00777"></a>00777   <span class="keywordtype">int</span> defaultvalue;
<a name="l00778"></a>00778  <span class="keyword">public</span>:
<a name="l00779"></a>00779   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* ID;
<a name="l00780"></a>00780   <span class="comment">// initialize vertex block and get first vertex</span>
<a name="l00781"></a>00781   BoundaryDomBlock(std::istream&amp; in,<span class="keywordtype">int</span> cdimworld ) :
<a name="l00782"></a>00782     BasicBlock(in,ID),
<a name="l00783"></a>00783     dimworld(cdimworld),
<a name="l00784"></a>00784     goodline(true),
<a name="l00785"></a>00785     p1(cdimworld),
<a name="l00786"></a>00786     p2(cdimworld),
<a name="l00787"></a>00787     bndid(0),
<a name="l00788"></a>00788     withdefault(false),
<a name="l00789"></a>00789     defaultvalue(0)
<a name="l00790"></a>00790   {
<a name="l00791"></a>00791     <span class="keywordflow">if</span> (!isactive())
<a name="l00792"></a>00792       <span class="keywordflow">return</span>;
<a name="l00793"></a>00793     assert(cdimworld&gt;0);
<a name="l00794"></a>00794     { 
<a name="l00795"></a>00795       <span class="keywordtype">int</span> x;
<a name="l00796"></a>00796       <span class="keywordflow">if</span> (findtoken(<span class="stringliteral">"default"</span>))
<a name="l00797"></a>00797       {
<a name="l00798"></a>00798         <span class="keywordflow">if</span> (getnextentry(x)) 
<a name="l00799"></a>00799         {
<a name="l00800"></a>00800           <span class="keywordflow">if</span>( x &lt;= 0 )
<a name="l00801"></a>00801           {
<a name="l00802"></a>00802             DUNE_THROW(DGFException,
<a name="l00803"></a>00803                            <span class="stringliteral">"ERROR in "</span> &lt;&lt; *<span class="keyword">this</span>
<a name="l00804"></a>00804                           &lt;&lt; <span class="stringliteral">"      non-positive boundary id ("</span> &lt;&lt; x &lt;&lt; <span class="stringliteral">") read!"</span>);
<a name="l00805"></a>00805           }
<a name="l00806"></a>00806           defaultvalue=x;
<a name="l00807"></a>00807           withdefault = <span class="keyword">true</span>;
<a name="l00808"></a>00808               }
<a name="l00809"></a>00809       }
<a name="l00810"></a>00810     }
<a name="l00811"></a>00811     reset();
<a name="l00812"></a>00812     next();
<a name="l00813"></a>00813   }
<a name="l00814"></a>00814   ~BoundaryDomBlock() {
<a name="l00815"></a>00815   }
<a name="l00816"></a>00816   <span class="keywordtype">bool</span> next() {
<a name="l00817"></a>00817     assert(ok());
<a name="l00818"></a>00818     getnextline();
<a name="l00819"></a>00819     <span class="keywordflow">if</span> (linenumber()==noflines()) {
<a name="l00820"></a>00820       goodline=<span class="keyword">false</span>;
<a name="l00821"></a>00821       <span class="keywordflow">return</span> goodline;
<a name="l00822"></a>00822     }
<a name="l00823"></a>00823     <span class="keywordtype">int</span> id;
<a name="l00824"></a>00824     <span class="keywordflow">if</span> (getnextentry(<span class="keywordtype">id</span>)) 
<a name="l00825"></a>00825     {
<a name="l00826"></a>00826       <span class="keywordflow">if</span>( <span class="keywordtype">id</span> &lt;= 0 )
<a name="l00827"></a>00827       {
<a name="l00828"></a>00828         DUNE_THROW(DGFException,
<a name="l00829"></a>00829                       <span class="stringliteral">"ERROR in "</span> &lt;&lt; *<span class="keyword">this</span>
<a name="l00830"></a>00830                     &lt;&lt; <span class="stringliteral">"      non-positive boundary id ("</span> &lt;&lt; <span class="keywordtype">id</span> &lt;&lt; <span class="stringliteral">") read!"</span>);
<a name="l00831"></a>00831       }
<a name="l00832"></a>00832       bndid = id;
<a name="l00833"></a>00833       <span class="keywordtype">double</span> x;
<a name="l00834"></a>00834       <span class="keywordtype">int</span> n=0;
<a name="l00835"></a>00835       <span class="keywordflow">while</span> (getnextentry(x))
<a name="l00836"></a>00836       {
<a name="l00837"></a>00837         <span class="keywordflow">if</span> (0&lt;=n &amp;&amp; n&lt;dimworld) 
<a name="l00838"></a>00838           p1.at(n)=x;
<a name="l00839"></a>00839         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dimworld&lt;=n &amp;&amp; n&lt;2*dimworld) 
<a name="l00840"></a>00840         {
<a name="l00841"></a>00841           p2.at(n-dimworld)=x;
<a name="l00842"></a>00842           <span class="keywordflow">if</span> (p2.at(n-dimworld)&lt;p1.at(n-dimworld)) 
<a name="l00843"></a>00843         {
<a name="l00844"></a>00844             DUNE_THROW(DGFException,
<a name="l00845"></a>00845                    <span class="stringliteral">"ERROR in "</span> &lt;&lt; *<span class="keyword">this</span>
<a name="l00846"></a>00846                    &lt;&lt; <span class="stringliteral">"      second coordinate smaller than first coordinate: "</span>
<a name="l00847"></a>00847                    &lt;&lt; p2.at(n-dimworld) 
<a name="l00848"></a>00848                    &lt;&lt; <span class="stringliteral">" read but expected value larger or equal to "</span> 
<a name="l00849"></a>00849                    &lt;&lt; p1.at(n-dimworld));
<a name="l00850"></a>00850               }
<a name="l00851"></a>00851             }
<a name="l00852"></a>00852             n++;
<a name="l00853"></a>00853     }
<a name="l00854"></a>00854 
<a name="l00855"></a>00855     goodline=(n==dimworld*2);
<a name="l00856"></a>00856     <span class="keywordflow">if</span> (!goodline) 
<a name="l00857"></a>00857     {
<a name="l00858"></a>00858       DUNE_THROW(DGFException,
<a name="l00859"></a>00859                    <span class="stringliteral">"ERROR in "</span> &lt;&lt; *<span class="keyword">this</span>
<a name="l00860"></a>00860                    &lt;&lt; <span class="stringliteral">"      wrong number of coordinates: "</span>
<a name="l00861"></a>00861                    &lt;&lt; n &lt;&lt; <span class="stringliteral">" read but expected "</span> &lt;&lt; dimworld);
<a name="l00862"></a>00862       }
<a name="l00863"></a>00863     }
<a name="l00864"></a>00864     <span class="keywordflow">else</span> 
<a name="l00865"></a>00865       next();
<a name="l00866"></a>00866     <span class="keywordflow">return</span> goodline;
<a name="l00867"></a>00867   }
<a name="l00868"></a>00868   <span class="keywordtype">bool</span> inside(<span class="keyword">const</span> std::vector&lt;double&gt;&amp; v)<span class="keyword"> const </span>{
<a name="l00869"></a>00869     assert(v.size()==(size_t)dimworld);
<a name="l00870"></a>00870     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;dimworld;i++) 
<a name="l00871"></a>00871       <span class="keywordflow">if</span> (v[i]&lt;p1[i] || v[i]&gt;p2[i]) 
<a name="l00872"></a>00872         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00873"></a>00873     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00874"></a>00874   }
<a name="l00875"></a>00875   <span class="keywordtype">int</span> id()<span class="keyword"> const </span>{
<a name="l00876"></a>00876     <span class="keywordflow">return</span> bndid;
<a name="l00877"></a>00877   }
<a name="l00878"></a>00878   <span class="keywordtype">bool</span> defaultValueGiven() {
<a name="l00879"></a>00879     <span class="keywordflow">return</span> withdefault;
<a name="l00880"></a>00880   }
<a name="l00881"></a>00881   <span class="keywordtype">int</span> defaultValue() {
<a name="l00882"></a>00882     <span class="keywordflow">return</span> defaultvalue;
<a name="l00883"></a>00883   }
<a name="l00884"></a>00884   <span class="comment">// some information</span>
<a name="l00885"></a>00885   <span class="keywordtype">bool</span> ok() {
<a name="l00886"></a>00886     <span class="keywordflow">return</span> goodline;
<a name="l00887"></a>00887   }
<a name="l00888"></a>00888   <span class="keywordtype">int</span> nofdombound() {
<a name="l00889"></a>00889     <span class="keywordflow">return</span> noflines();
<a name="l00890"></a>00890   }
<a name="l00891"></a>00891     
<a name="l00892"></a>00892 };
<a name="l00893"></a>00893 <span class="keyword">const</span> <span class="keywordtype">char</span> *BoundaryDomBlock::ID = <span class="stringliteral">"boundarydomain"</span>;
<a name="l00894"></a>00894 <span class="comment">// *************************************************************</span>
<a name="l00895"></a>00895 <span class="comment">// the BoundarySegBlock looks for given boundary values unless they aren't given they got the value zero </span>
<a name="l00896"></a>00896 <span class="keyword">class </span>BoundarySegBlock : <span class="keyword">public</span> BasicBlock {
<a name="l00897"></a>00897   <span class="keywordtype">int</span> dimworld;          <span class="comment">// the dimesnsion of the vertices (is given  from user)</span>
<a name="l00898"></a>00898   <span class="keywordtype">bool</span> goodline;         <span class="comment">// active line describes a vertex</span>
<a name="l00899"></a>00899   std::vector&lt;int&gt; p; <span class="comment">// active vertex</span>
<a name="l00900"></a>00900   <span class="keywordtype">int</span> bndid;
<a name="l00901"></a>00901   <span class="keywordtype">bool</span> simplexgrid;
<a name="l00902"></a>00902  <span class="keyword">public</span>:
<a name="l00903"></a>00903   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* ID;
<a name="l00904"></a>00904   <span class="comment">// initialize vertex block and get first vertex</span>
<a name="l00905"></a>00905   BoundarySegBlock(std::istream&amp; in,<span class="keywordtype">int</span> pnofvtx, 
<a name="l00906"></a>00906                    <span class="keywordtype">int</span> pdimworld,<span class="keywordtype">bool</span> psimplexgrid ) :
<a name="l00907"></a>00907     BasicBlock(in,ID),
<a name="l00908"></a>00908     dimworld(pdimworld),
<a name="l00909"></a>00909     goodline(true),
<a name="l00910"></a>00910     p(),
<a name="l00911"></a>00911     bndid(-1),
<a name="l00912"></a>00912     simplexgrid(psimplexgrid)
<a name="l00913"></a>00913   {
<a name="l00914"></a>00914     <span class="keywordflow">if</span> (!isactive())
<a name="l00915"></a>00915       <span class="keywordflow">return</span>;
<a name="l00916"></a>00916     assert(dimworld&gt;0);
<a name="l00917"></a>00917     next();
<a name="l00918"></a>00918   }
<a name="l00919"></a>00919 
<a name="l00920"></a>00920   ~BoundarySegBlock() {
<a name="l00921"></a>00921   }
<a name="l00922"></a>00922 
<a name="l00923"></a>00923   <span class="comment">// some information</span>
<a name="l00924"></a>00924   <span class="keywordtype">int</span> <span class="keyword">get</span>(std::map&lt;DGFEntityKey&lt;int&gt;,<span class="keywordtype">int</span>&gt;&amp; facemap,<span class="keywordtype">bool</span> fixedsize,<span class="keywordtype">int</span> vtxoffset) {
<a name="l00925"></a>00925     <span class="keyword">static</span> <span class="keywordtype">int</span> cube2simplex[3][3] = { 
<a name="l00926"></a>00926       {0,1,3},
<a name="l00927"></a>00927       {0,2,3},
<a name="l00928"></a>00928       {1,2,3} 
<a name="l00929"></a>00929     };
<a name="l00930"></a>00930 
<a name="l00931"></a>00931     <span class="keywordtype">int</span> lnofbound;
<a name="l00932"></a>00932     <span class="keywordtype">int</span> face = ElementFaceUtil::faceSize(dimworld,simplexgrid);
<a name="l00933"></a>00933     <span class="keywordflow">for</span> (lnofbound=0; ok(); next()) 
<a name="l00934"></a>00934     {
<a name="l00935"></a>00935       <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0;i&lt;p.size();i++) 
<a name="l00936"></a>00936       {
<a name="l00937"></a>00937         p[i] -= vtxoffset;
<a name="l00938"></a>00938       }
<a name="l00939"></a>00939       <span class="keywordflow">if</span> (fixedsize) 
<a name="l00940"></a>00940       {
<a name="l00941"></a>00941               <span class="keywordflow">if</span> ((dimworld==2 &amp;&amp; size()&lt; 2) ||
<a name="l00942"></a>00942                   (dimworld==3 &amp;&amp; simplexgrid &amp;&amp; size()!=3 &amp;&amp; size()!=4) ||
<a name="l00943"></a>00943                 (dimworld==3 &amp;&amp; !simplexgrid &amp;&amp; size()!=4)) 
<a name="l00944"></a>00944               <span class="keywordflow">continue</span>;
<a name="l00945"></a>00945         std::vector&lt;int&gt; bound(face);
<a name="l00946"></a>00946         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0;j&lt;face;j++) {
<a name="l00947"></a>00947           bound[j] = p[j];
<a name="l00948"></a>00948         }
<a name="l00949"></a>00949 
<a name="l00950"></a>00950         DGFEntityKey&lt;int&gt; key(bound,<span class="keyword">false</span>); 
<a name="l00951"></a>00951 
<a name="l00952"></a>00952               facemap[key] = bndid;
<a name="l00953"></a>00953               ++lnofbound;
<a name="l00954"></a>00954         
<a name="l00955"></a>00955         <span class="keywordflow">if</span> (size()&gt;face) 
<a name="l00956"></a>00956         {
<a name="l00957"></a>00957           assert(dimworld==2 || face==3);
<a name="l00958"></a>00958             <span class="keywordflow">if</span> (dimworld==3) {
<a name="l00959"></a>00959                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;3;i++) 
<a name="l00960"></a>00960           {
<a name="l00961"></a>00961                   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0;j&lt;face;j++) 
<a name="l00962"></a>00962             {
<a name="l00963"></a>00963                     bound[j] = p[cube2simplex[i][j]];
<a name="l00964"></a>00964                   }
<a name="l00965"></a>00965             
<a name="l00966"></a>00966                   DGFEntityKey&lt;int&gt; key(bound,<span class="keyword">false</span>); 
<a name="l00967"></a>00967                   facemap[key] = bndid;
<a name="l00968"></a>00968                   ++lnofbound;
<a name="l00969"></a>00969                 }
<a name="l00970"></a>00970               } 
<a name="l00971"></a>00971         <span class="keywordflow">else</span> 
<a name="l00972"></a>00972         {
<a name="l00973"></a>00973                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=2; i&lt;=size();i++) 
<a name="l00974"></a>00974           {
<a name="l00975"></a>00975                   bound[0] = p[i-1];
<a name="l00976"></a>00976                   bound[1] = p[i%size()];
<a name="l00977"></a>00977                   DGFEntityKey&lt;int&gt; key(bound,<span class="keyword">false</span>); 
<a name="l00978"></a>00978                   facemap[key] = bndid;
<a name="l00979"></a>00979                   ++lnofbound;
<a name="l00980"></a>00980                 }
<a name="l00981"></a>00981               }
<a name="l00982"></a>00982             }
<a name="l00983"></a>00983     }
<a name="l00984"></a>00984     <span class="keywordflow">else</span> {
<a name="l00985"></a>00985         <span class="keywordflow">if</span> (dimworld==3) {
<a name="l00986"></a>00986           DGFEntityKey&lt;int&gt; key(p,<span class="keyword">false</span>); 
<a name="l00987"></a>00987           facemap[key] = bndid;
<a name="l00988"></a>00988           ++lnofbound;
<a name="l00989"></a>00989         } <span class="keywordflow">else</span> {
<a name="l00990"></a>00990           std::vector&lt;int&gt; k(2);
<a name="l00991"></a>00991           <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0;i&lt;p.size()-1;i++) {
<a name="l00992"></a>00992             k[0]=p[i];
<a name="l00993"></a>00993             k[1]=p[(i+1)%p.size()];
<a name="l00994"></a>00994             DGFEntityKey&lt;int&gt; key(k,<span class="keyword">false</span>); 
<a name="l00995"></a>00995             facemap[key] = bndid;
<a name="l00996"></a>00996             ++lnofbound;
<a name="l00997"></a>00997           }
<a name="l00998"></a>00998         }
<a name="l00999"></a>00999       }
<a name="l01000"></a>01000     }
<a name="l01001"></a>01001     <span class="keywordflow">return</span> lnofbound;
<a name="l01002"></a>01002   }
<a name="l01003"></a>01003   <span class="keywordtype">bool</span> ok() {
<a name="l01004"></a>01004     <span class="keywordflow">return</span> goodline;
<a name="l01005"></a>01005   }
<a name="l01006"></a>01006   <span class="keywordtype">int</span> nofbound() {
<a name="l01007"></a>01007     <span class="keywordflow">return</span> noflines();
<a name="l01008"></a>01008   }
<a name="l01009"></a>01009   <span class="keyword">private</span>:
<a name="l01010"></a>01010   <span class="keywordtype">bool</span> next() {
<a name="l01011"></a>01011     assert(ok());
<a name="l01012"></a>01012     <span class="keywordtype">int</span> n=0;
<a name="l01013"></a>01013     getnextline();
<a name="l01014"></a>01014     <span class="keywordflow">if</span> (linenumber()==noflines()) {
<a name="l01015"></a>01015       goodline=<span class="keyword">false</span>;
<a name="l01016"></a>01016       <span class="keywordflow">return</span> goodline;
<a name="l01017"></a>01017     }
<a name="l01018"></a>01018     p.clear();
<a name="l01019"></a>01019     <span class="keywordtype">int</span> x;
<a name="l01020"></a>01020     <span class="keywordflow">if</span> (getnextentry(x)) {
<a name="l01021"></a>01021       bndid = x;
<a name="l01022"></a>01022       <span class="keywordflow">if</span> (bndid&lt;=0) 
<a name="l01023"></a>01023       {
<a name="l01024"></a>01024         DUNE_THROW(DGFException,
<a name="l01025"></a>01025                        <span class="stringliteral">"ERROR in "</span> &lt;&lt; *<span class="keyword">this</span>
<a name="l01026"></a>01026                       &lt;&lt; <span class="stringliteral">"      non-positive boundary id ("</span> &lt;&lt; bndid &lt;&lt; <span class="stringliteral">") read!"</span>);
<a name="l01027"></a>01027       }
<a name="l01028"></a>01028       <span class="keywordflow">while</span> (getnextentry(x))
<a name="l01029"></a>01029       {
<a name="l01030"></a>01030         p.push_back(x);
<a name="l01031"></a>01031               n++;
<a name="l01032"></a>01032       }
<a name="l01033"></a>01033       <span class="comment">// goodline=(n==dimworld+1);</span>
<a name="l01034"></a>01034       goodline=<span class="keyword">true</span>;
<a name="l01035"></a>01035       <span class="keywordflow">return</span> goodline;
<a name="l01036"></a>01036     } <span class="keywordflow">else</span> <span class="keywordflow">return</span> next();
<a name="l01037"></a>01037   }
<a name="l01038"></a>01038   <span class="comment">// get coordinates of active vertex</span>
<a name="l01039"></a>01039   <span class="keywordtype">int</span> operator[](<span class="keywordtype">int</span> i) {
<a name="l01040"></a>01040     assert(ok());
<a name="l01041"></a>01041     assert(linenumber()&gt;=0);
<a name="l01042"></a>01042     assert(0&lt;=i &amp;&amp; i&lt;dimworld+1);
<a name="l01043"></a>01043     <span class="keywordflow">return</span> p[i];
<a name="l01044"></a>01044   }
<a name="l01045"></a>01045   <span class="keywordtype">int</span> size() {
<a name="l01046"></a>01046     <span class="keywordflow">return</span> p.size();
<a name="l01047"></a>01047   }
<a name="l01048"></a>01048 };
<a name="l01049"></a>01049 <span class="keyword">const</span> <span class="keywordtype">char</span> *BoundarySegBlock::ID = <span class="stringliteral">"boundarysegments"</span>;
<a name="l01050"></a>01050 <span class="comment">// *************************************************************</span>
<a name="l01051"></a>01051 <span class="keyword">class </span>DimBlock : <span class="keyword">public</span> BasicBlock {
<a name="l01052"></a>01052   <span class="keywordtype">int</span> _dimworld;     <span class="comment">// dimension of world</span>
<a name="l01053"></a>01053   <span class="keywordtype">int</span> _dim;          <span class="comment">// dimension of grid</span>
<a name="l01054"></a>01054  <span class="keyword">public</span>:
<a name="l01055"></a>01055   <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">char</span>* ID;
<a name="l01056"></a>01056   <span class="comment">// initialize block and get dimension of world</span>
<a name="l01057"></a>01057   DimBlock(std::istream&amp; in) :
<a name="l01058"></a>01058   BasicBlock(in,ID)
<a name="l01059"></a>01059   {
<a name="l01060"></a>01060     <span class="keywordflow">if</span> (isempty()) {
<a name="l01061"></a>01061       DUNE_THROW(DGFException,
<a name="l01062"></a>01062                  <span class="stringliteral">"no dimension of world specified!"</span>);
<a name="l01063"></a>01063     } <span class="keywordflow">else</span> {
<a name="l01064"></a>01064       getnextline();
<a name="l01065"></a>01065       line &gt;&gt; _dim;
<a name="l01066"></a>01066       <span class="keywordflow">if</span> (_dim&lt;1) {
<a name="l01067"></a>01067         DUNE_THROW(DGFException,
<a name="l01068"></a>01068                    <span class="stringliteral">"negative dimension of world specified!"</span>);
<a name="l01069"></a>01069       }
<a name="l01070"></a>01070       <span class="keywordflow">else</span> {
<a name="l01071"></a>01071         <span class="keywordflow">if</span> (noflines()==1)
<a name="l01072"></a>01072           _dimworld=_dim;
<a name="l01073"></a>01073         <span class="keywordflow">else</span> {
<a name="l01074"></a>01074           getnextline();
<a name="l01075"></a>01075           line &gt;&gt; _dimworld;
<a name="l01076"></a>01076           <span class="keywordflow">if</span> (_dimworld &lt; _dim) {
<a name="l01077"></a>01077             DUNE_THROW(DGFException,
<a name="l01078"></a>01078                        <span class="stringliteral">"negative dimension of world smaller than dim!"</span>);
<a name="l01079"></a>01079           }
<a name="l01080"></a>01080         }
<a name="l01081"></a>01081       }
<a name="l01082"></a>01082     }
<a name="l01083"></a>01083   }
<a name="l01084"></a>01084   <span class="comment">// get dimension of world found in block</span>
<a name="l01085"></a>01085   <span class="keywordtype">int</span> dim() {
<a name="l01086"></a>01086     <span class="keywordflow">return</span> _dim;
<a name="l01087"></a>01087   }
<a name="l01088"></a>01088   <span class="keywordtype">int</span> dimworld() {
<a name="l01089"></a>01089     <span class="keywordflow">return</span> _dimworld;
<a name="l01090"></a>01090   }
<a name="l01091"></a>01091   <span class="comment">// some information </span>
<a name="l01092"></a>01092   <span class="keywordtype">bool</span> ok() {
<a name="l01093"></a>01093     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01094"></a>01094   }
<a name="l01095"></a>01095 };
<a name="l01096"></a>01096 <span class="keyword">const</span> <span class="keywordtype">char</span>* DimBlock::ID = <span class="stringliteral">"Dimensions"</span>;
<a name="l01097"></a>01097 
<a name="l01098"></a>01098 <span class="comment">// *************************************************************</span>
<a name="l01099"></a>01099 <span class="keyword">class </span>GridParameterBlock : <span class="keyword">public</span> BasicBlock 
<a name="l01100"></a>01100 {
<a name="l01101"></a>01101  <span class="keyword">protected</span>:  
<a name="l01102"></a>01102   std::set&lt;int&gt; _periodic; <span class="comment">// periodic grid </span>
<a name="l01103"></a>01103   <span class="keywordtype">int</span> _overlap;     <span class="comment">// overlap for YaspGrid</span>
<a name="l01104"></a>01104   <span class="keywordtype">bool</span> _noClosure;  <span class="comment">// no closure for UGGrid </span>
<a name="l01105"></a>01105  <span class="keyword">private</span>:
<a name="l01106"></a>01106   <span class="comment">// copy not implemented</span>
<a name="l01107"></a>01107   GridParameterBlock(<span class="keyword">const</span> GridParameterBlock&amp;);
<a name="l01108"></a>01108  <span class="keyword">public</span>:
<a name="l01109"></a>01109   <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">char</span>* ID;
<a name="l01110"></a>01110   <span class="comment">// initialize block and get dimension of world</span>
<a name="l01111"></a>01111   GridParameterBlock(std::istream&amp; in, 
<a name="l01112"></a>01112                      <span class="keyword">const</span> <span class="keywordtype">bool</span> readOverlapAndBnd)
<a name="l01113"></a>01113     : BasicBlock(in,ID) 
<a name="l01114"></a>01114     , _periodic()
<a name="l01115"></a>01115     , _overlap(0) <span class="comment">// default value</span>
<a name="l01116"></a>01116     , _noClosure(false) <span class="comment">// default value </span>
<a name="l01117"></a>01117   {
<a name="l01118"></a>01118     <span class="keywordflow">if</span> (! isempty() ) 
<a name="l01119"></a>01119     {
<a name="l01120"></a>01120       <span class="keywordflow">if</span>( readOverlapAndBnd  )
<a name="l01121"></a>01121       {
<a name="l01122"></a>01122         <span class="comment">// check overlap </span>
<a name="l01123"></a>01123         <span class="keywordflow">if</span> (findtoken(<span class="stringliteral">"overlap"</span>))
<a name="l01124"></a>01124         {
<a name="l01125"></a>01125           <span class="keywordtype">int</span> x;
<a name="l01126"></a>01126           <span class="keywordflow">if</span>( getnextentry(x) ) _overlap = x;
<a name="l01127"></a>01127           <span class="keywordflow">else</span> 
<a name="l01128"></a>01128           {
<a name="l01129"></a>01129             dwarn &lt;&lt; <span class="stringliteral">"GridParameterBlock: found keyword `overlap' but no value, defaulting to `"</span> &lt;&lt;  _overlap  &lt;&lt;<span class="stringliteral">"' !\n"</span>;
<a name="l01130"></a>01130           }
<a name="l01131"></a>01131 
<a name="l01132"></a>01132           <span class="keywordflow">if</span> (_overlap &lt; 0) 
<a name="l01133"></a>01133           {
<a name="l01134"></a>01134             DUNE_THROW(DGFException,<span class="stringliteral">"Negative overlap specified!"</span>);
<a name="l01135"></a>01135           }
<a name="l01136"></a>01136         }
<a name="l01137"></a>01137         <span class="keywordflow">else</span> 
<a name="l01138"></a>01138         {
<a name="l01139"></a>01139           dwarn &lt;&lt; <span class="stringliteral">"GridParameterBlock: could not find keyword `overlap' in DGF file, defaulting to `"</span>&lt;&lt;_overlap&lt;&lt;<span class="stringliteral">"' !\n"</span>;
<a name="l01140"></a>01140         }
<a name="l01141"></a>01141         
<a name="l01142"></a>01142         <span class="comment">// check periodic grid </span>
<a name="l01143"></a>01143         <span class="keywordflow">if</span> (findtoken(<span class="stringliteral">"periodic"</span>))
<a name="l01144"></a>01144         {
<a name="l01145"></a>01145           <span class="keywordtype">int</span> x;
<a name="l01146"></a>01146           <span class="keywordflow">while</span> (getnextentry(x)) 
<a name="l01147"></a>01147           {
<a name="l01148"></a>01148             _periodic.insert(x);
<a name="l01149"></a>01149           }
<a name="l01150"></a>01150         }
<a name="l01151"></a>01151         <span class="keywordflow">else</span> 
<a name="l01152"></a>01152         {
<a name="l01153"></a>01153           dwarn &lt;&lt; <span class="stringliteral">"GridParameterBlock: could not find keyword `periodic' in DGF file, defaulting to no periodic boundary! \n"</span>;
<a name="l01154"></a>01154         }
<a name="l01155"></a>01155       }
<a name="l01156"></a>01156       <span class="keywordflow">else</span> 
<a name="l01157"></a>01157       {
<a name="l01158"></a>01158         <span class="comment">// check closure </span>
<a name="l01159"></a>01159         <span class="keywordflow">if</span> (findtoken(<span class="stringliteral">"closure"</span>))
<a name="l01160"></a>01160         {
<a name="l01161"></a>01161           std::string clo;
<a name="l01162"></a>01162           <span class="keywordflow">if</span>(getnextentry(clo)) 
<a name="l01163"></a>01163           {
<a name="l01164"></a>01164             makeupcase(clo);
<a name="l01165"></a>01165             <span class="keywordflow">if</span>(clo == <span class="stringliteral">"NONE"</span>)
<a name="l01166"></a>01166             {
<a name="l01167"></a>01167               _noClosure = <span class="keyword">true</span>; 
<a name="l01168"></a>01168             }
<a name="l01169"></a>01169           }
<a name="l01170"></a>01170         }
<a name="l01171"></a>01171         <span class="keywordflow">else</span> 
<a name="l01172"></a>01172         {
<a name="l01173"></a>01173           dwarn &lt;&lt; <span class="stringliteral">"GridParameterBlock: could not find keyword `closure' in DGF file, defaulting to `GREEN' !\n"</span>;
<a name="l01174"></a>01174         }
<a name="l01175"></a>01175       }
<a name="l01176"></a>01176     }
<a name="l01177"></a>01177   }
<a name="l01178"></a>01178   
<a name="l01179"></a>01179   <span class="comment">// get dimension of world found in block</span>
<a name="l01180"></a>01180   <span class="keywordtype">int</span> overlap()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _overlap;  }
<a name="l01181"></a>01181 
<a name="l01182"></a>01182   <span class="comment">// returns true if no closure should be used for UGGrid </span>
<a name="l01183"></a>01183   <span class="keywordtype">bool</span> noClosure()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _noClosure; }
<a name="l01184"></a>01184 
<a name="l01185"></a>01185   <span class="comment">// returns true if dimension is periodic </span>
<a name="l01186"></a>01186   <span class="keywordtype">bool</span> isPeriodic(<span class="keyword">const</span> <span class="keywordtype">int</span> dim)<span class="keyword"> const </span>
<a name="l01187"></a>01187 <span class="keyword">  </span>{
<a name="l01188"></a>01188     <span class="keywordflow">return</span> (_periodic.find(dim) != _periodic.end());
<a name="l01189"></a>01189   }
<a name="l01190"></a>01190   
<a name="l01191"></a>01191   <span class="comment">// some information </span>
<a name="l01192"></a>01192   <span class="keywordtype">bool</span> ok() 
<a name="l01193"></a>01193   {
<a name="l01194"></a>01194     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01195"></a>01195   }
<a name="l01196"></a>01196 };
<a name="l01197"></a>01197 <span class="keyword">const</span> <span class="keywordtype">char</span>* GridParameterBlock::ID = <span class="stringliteral">"GridParameter"</span>;
<a name="l01198"></a>01198 
<a name="l01199"></a>01199 <span class="comment">// *************************************************************</span>
<a name="l01200"></a>01200 <span class="keyword">class </span>IntervalBlock : <span class="keyword">public</span> BasicBlock {
<a name="l01201"></a>01201   std::vector&lt;double&gt; p0_,p1_;     <span class="comment">//lower and upper boundary points</span>
<a name="l01202"></a>01202   std::vector&lt;double&gt; h_;          <span class="comment">// width of the cells in every direction </span>
<a name="l01203"></a>01203   std::vector&lt;int&gt; nofcells_;      <span class="comment">// number of cells in every direction</span>
<a name="l01204"></a>01204   <span class="keywordtype">bool</span> good_;                      <span class="comment">//data read correctly</span>
<a name="l01205"></a>01205   <span class="keywordtype">int</span> dimw_;                       <span class="comment">//dimension of world</span>
<a name="l01206"></a>01206  <span class="keyword">public</span>:
<a name="l01207"></a>01207   <span class="keyword">const</span> <span class="keyword">static</span> <span class="keywordtype">char</span>* ID;
<a name="l01208"></a>01208   IntervalBlock(std::istream&amp; in) :
<a name="l01209"></a>01209     BasicBlock(in,ID),
<a name="l01210"></a>01210     p0_(0),
<a name="l01211"></a>01211     p1_(0),
<a name="l01212"></a>01212     h_(0),
<a name="l01213"></a>01213     nofcells_(0),
<a name="l01214"></a>01214     good_(false),
<a name="l01215"></a>01215     dimw_(0)
<a name="l01216"></a>01216   {
<a name="l01217"></a>01217     <span class="keywordflow">if</span>(isactive()) {
<a name="l01218"></a>01218       getnextline();
<a name="l01219"></a>01219       <span class="keywordtype">double</span> x;
<a name="l01220"></a>01220       <span class="keywordflow">while</span> (getnextentry(x)) {
<a name="l01221"></a>01221               dimw_++;
<a name="l01222"></a>01222       }
<a name="l01223"></a>01223       <span class="keywordflow">if</span> (dimw_==0) {
<a name="l01224"></a>01224               DUNE_THROW(DGFException,
<a name="l01225"></a>01225                     <span class="stringliteral">"Too few coordinates for point p0 in IntervalBlock"</span>);
<a name="l01226"></a>01226       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dimw_&gt;3) {
<a name="l01227"></a>01227               DUNE_THROW(DGFException,
<a name="l01228"></a>01228                     <span class="stringliteral">"Interval block only implemented for dimension 1,2, and 3"</span>);
<a name="l01229"></a>01229       }
<a name="l01230"></a>01230       p0_.resize(dimw_);
<a name="l01231"></a>01231       p1_.resize(dimw_);
<a name="l01232"></a>01232       h_.resize(dimw_);
<a name="l01233"></a>01233       nofcells_.resize(dimw_);
<a name="l01234"></a>01234       reset();
<a name="l01235"></a>01235       next();
<a name="l01236"></a>01236     }
<a name="l01237"></a>01237   }
<a name="l01238"></a>01238   <span class="keywordtype">void</span> <span class="keyword">get</span>(std::vector&lt;std::vector&lt;double&gt; &gt;&amp; vtx,<span class="keywordtype">int</span>&amp; nofvtx,
<a name="l01239"></a>01239            std::vector&lt;std::vector&lt;int&gt; &gt;&amp; simplex,<span class="keywordtype">int</span>&amp; nofsimpl) {
<a name="l01240"></a>01240     <span class="keywordflow">do</span> {
<a name="l01241"></a>01241       <span class="keywordtype">int</span> oldvtx = nofvtx;
<a name="l01242"></a>01242       nofvtx  +=getVtx(vtx);
<a name="l01243"></a>01243       nofsimpl+=getHexa(simplex,oldvtx);
<a name="l01244"></a>01244     } <span class="keywordflow">while</span> (next());
<a name="l01245"></a>01245   }
<a name="l01246"></a>01246   <span class="keywordtype">void</span> <span class="keyword">get</span>(std::vector&lt;std::vector&lt;double&gt; &gt;&amp; vtx,<span class="keywordtype">int</span>&amp; nofvtx) {
<a name="l01247"></a>01247     <span class="keywordflow">do</span> {
<a name="l01248"></a>01248       <span class="comment">// int oldvtx = nofvtx;</span>
<a name="l01249"></a>01249       nofvtx  +=getVtx(vtx);
<a name="l01250"></a>01250     } <span class="keywordflow">while</span> (next());
<a name="l01251"></a>01251   }
<a name="l01252"></a>01252   <span class="keywordtype">int</span> getVtx(std::vector&lt;std::vector&lt;double&gt; &gt;&amp; vtx) {
<a name="l01253"></a>01253     <span class="keywordtype">size_t</span> countvtx;
<a name="l01254"></a>01254     <span class="keywordtype">size_t</span> old_size = vtx.size();
<a name="l01255"></a>01255     <span class="comment">//fill vtx </span>
<a name="l01256"></a>01256     dverb &lt;&lt; <span class="stringliteral">"reading vertices..."</span>; 
<a name="l01257"></a>01257     vtx.resize(vtx.size()+nofvtx());
<a name="l01258"></a>01258     <span class="keywordflow">for</span> (countvtx=old_size;countvtx &lt; vtx.size(); countvtx++)
<a name="l01259"></a>01259       vtx[countvtx].resize(dimw_);
<a name="l01260"></a>01260     <span class="keywordtype">int</span> m = old_size;
<a name="l01261"></a>01261     <span class="keywordflow">if</span>(dimw_ == 3) {
<a name="l01262"></a>01262             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k &lt; nofcells_[2]+1; k++)  <span class="comment">// z-dir </span>
<a name="l01263"></a>01263               <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j &lt; nofcells_[1]+1; j++) <span class="comment">// y-dir</span>
<a name="l01264"></a>01264           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i =0; i &lt; nofcells_[0]+1; i++) <span class="comment">// x-dir </span>
<a name="l01265"></a>01265           {
<a name="l01266"></a>01266                   vtx[m][0] = p0_[0] + i*h_[0];
<a name="l01267"></a>01267                   vtx[m][1] = p0_[1] + j*h_[1];
<a name="l01268"></a>01268                   vtx[m][2] = p0_[2] + k*h_[2];
<a name="l01269"></a>01269                   m++;
<a name="l01270"></a>01270                 }
<a name="l01271"></a>01271     }
<a name="l01272"></a>01272     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dimw_==2) 
<a name="l01273"></a>01273     {
<a name="l01274"></a>01274             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j &lt; nofcells_[1]+1; j++) 
<a name="l01275"></a>01275         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i =0; i &lt; nofcells_[0]+1; i++)
<a name="l01276"></a>01276         {
<a name="l01277"></a>01277                 vtx[m][0] = p0_[0] + i*h_[0];
<a name="l01278"></a>01278                 vtx[m][1] = p0_[1] + j*h_[1];
<a name="l01279"></a>01279                 m++;
<a name="l01280"></a>01280               }
<a name="l01281"></a>01281     } <span class="keywordflow">else</span> {
<a name="l01282"></a>01282             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j &lt; nofcells_[0]+1; j++) {
<a name="l01283"></a>01283               vtx[m][0] = p0_[0] + j*h_[0];
<a name="l01284"></a>01284               m++;
<a name="l01285"></a>01285             }
<a name="l01286"></a>01286     }
<a name="l01287"></a>01287     dverb &lt;&lt; <span class="stringliteral">"done"</span> &lt;&lt; std::endl;
<a name="l01288"></a>01288     <span class="keywordflow">return</span>  nofvtx();
<a name="l01289"></a>01289   }
<a name="l01290"></a>01290   <span class="keywordtype">int</span> getHexa(std::vector&lt;std::vector&lt;int&gt; &gt;&amp; simplex,
<a name="l01291"></a>01291               <span class="keywordtype">int</span> offset=0) {
<a name="l01292"></a>01292     <span class="keywordtype">int</span> oldsize=simplex.size();
<a name="l01293"></a>01293     <span class="comment">//fill simplex with Hexaeder</span>
<a name="l01294"></a>01294     <span class="keywordtype">size_t</span> counthexa;
<a name="l01295"></a>01295     <span class="keywordtype">int</span> verticesPerCube = -1;
<a name="l01296"></a>01296     <span class="keywordtype">int</span> m=oldsize;  
<a name="l01297"></a>01297     <span class="keywordflow">if</span>(dimw_ == 3)
<a name="l01298"></a>01298       verticesPerCube = 8;
<a name="l01299"></a>01299     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dimw_ == 2)
<a name="l01300"></a>01300       verticesPerCube = 4;
<a name="l01301"></a>01301     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dimw_ == 1)
<a name="l01302"></a>01302       verticesPerCube = 2;
<a name="l01303"></a>01303     <span class="keywordflow">else</span> 
<a name="l01304"></a>01304             DUNE_THROW(DGFException,
<a name="l01305"></a>01305                              <span class="stringliteral">"Invalid dimension world "</span>&lt;&lt; dimw_ &lt;&lt; <span class="stringliteral">" in IntervalBlock::getHexa!"</span>);
<a name="l01306"></a>01306 
<a name="l01307"></a>01307     dverb &lt;&lt; <span class="stringliteral">"generating hexaeder..."</span>;
<a name="l01308"></a>01308     simplex.resize(oldsize+nofhexa());
<a name="l01309"></a>01309     <span class="keywordflow">for</span> (counthexa=m;counthexa &lt; simplex.size();counthexa++)
<a name="l01310"></a>01310       simplex[counthexa].resize(verticesPerCube);
<a name="l01311"></a>01311       <span class="keywordflow">if</span>(dimw_ == 3) {
<a name="l01312"></a>01312               <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k=0; k &lt; nofcells_[2]; k++) 
<a name="l01313"></a>01313                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j &lt; nofcells_[1]; j++)
<a name="l01314"></a>01314             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i =0; i &lt; nofcells_[0]; i++)
<a name="l01315"></a>01315             {
<a name="l01316"></a>01316                     simplex[m][0] = offset+getIndex(i,j,k);
<a name="l01317"></a>01317                     simplex[m][1] = offset+getIndex(i+1,j,k);
<a name="l01318"></a>01318                     simplex[m][2] = offset+getIndex(i,j+1,k);
<a name="l01319"></a>01319                     simplex[m][3] = offset+getIndex(i+1,j+1,k);
<a name="l01320"></a>01320                     simplex[m][4] = offset+getIndex(i,j,k+1);
<a name="l01321"></a>01321                     simplex[m][5] = offset+getIndex(i+1,j,k+1);
<a name="l01322"></a>01322                     simplex[m][6] = offset+getIndex(i,j+1,k+1);
<a name="l01323"></a>01323                     simplex[m][7] = offset+getIndex(i+1,j+1,k+1);
<a name="l01324"></a>01324                     m++;
<a name="l01325"></a>01325                   }
<a name="l01326"></a>01326     }
<a name="l01327"></a>01327     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dimw_==2) 
<a name="l01328"></a>01328     {
<a name="l01329"></a>01329             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j &lt; nofcells_[1]; j++) 
<a name="l01330"></a>01330       {
<a name="l01331"></a>01331         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i =0; i &lt; nofcells_[0]; i++)
<a name="l01332"></a>01332         {
<a name="l01333"></a>01333                 simplex[m][0] = offset+getIndex(i,j);
<a name="l01334"></a>01334                 simplex[m][1] = offset+getIndex(i+1,j);
<a name="l01335"></a>01335                 simplex[m][2] = offset+getIndex(i,j+1);
<a name="l01336"></a>01336                 simplex[m][3] = offset+getIndex(i+1,j+1);
<a name="l01337"></a>01337                 m++;
<a name="l01338"></a>01338               }
<a name="l01339"></a>01339       }
<a name="l01340"></a>01340     } 
<a name="l01341"></a>01341     <span class="keywordflow">else</span> 
<a name="l01342"></a>01342     {
<a name="l01343"></a>01343       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i =0; i &lt; nofcells_[0]; i++) 
<a name="l01344"></a>01344       {
<a name="l01345"></a>01345               simplex[m][0] = offset+getIndex(i);
<a name="l01346"></a>01346               simplex[m][1] = offset+getIndex(i+1);
<a name="l01347"></a>01347               m++;
<a name="l01348"></a>01348             }
<a name="l01349"></a>01349     }
<a name="l01350"></a>01350     dverb &lt;&lt; <span class="stringliteral">"done"</span> &lt;&lt; std::endl;
<a name="l01351"></a>01351     assert((<span class="keywordtype">size_t</span>)m==simplex.size());
<a name="l01352"></a>01352     <span class="keywordflow">return</span> nofhexa();
<a name="l01353"></a>01353   }
<a name="l01354"></a>01354 
<a name="l01355"></a>01355   <span class="keywordtype">int</span> nofvtx() {
<a name="l01356"></a>01356     <span class="keywordflow">if</span>(dimw_ == 3)
<a name="l01357"></a>01357       <span class="keywordflow">return</span> (nofcells_[0]+1)*(nofcells_[1]+1)*(nofcells_[2]+1);
<a name="l01358"></a>01358     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dimw_ == 2)
<a name="l01359"></a>01359       <span class="keywordflow">return</span> (nofcells_[0]+1)*(nofcells_[1]+1);
<a name="l01360"></a>01360     <span class="keywordflow">else</span>
<a name="l01361"></a>01361       <span class="keywordflow">return</span> nofcells_[0]+1;
<a name="l01362"></a>01362   }
<a name="l01363"></a>01363 
<a name="l01364"></a>01364   <span class="keywordtype">int</span> nofhexa() {
<a name="l01365"></a>01365     <span class="keywordflow">if</span>(dimw_ == 3)
<a name="l01366"></a>01366       <span class="keywordflow">return</span> (nofcells_[0])*(nofcells_[1])*(nofcells_[2]);
<a name="l01367"></a>01367     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dimw_ == 2)
<a name="l01368"></a>01368       <span class="keywordflow">return</span> (nofcells_[0])*(nofcells_[1]);
<a name="l01369"></a>01369     <span class="keywordflow">else</span>
<a name="l01370"></a>01370       <span class="keywordflow">return</span> nofcells_[0];
<a name="l01371"></a>01371   }
<a name="l01372"></a>01372   <span class="keywordtype">int</span> segments(<span class="keywordtype">int</span> i) {
<a name="l01373"></a>01373     <span class="keywordflow">return</span> nofcells_[i];
<a name="l01374"></a>01374   }
<a name="l01375"></a>01375   <span class="keywordtype">double</span> length(<span class="keywordtype">int</span> i) {
<a name="l01376"></a>01376     <span class="keywordflow">return</span> p1_[i]-p0_[i]; 
<a name="l01377"></a>01377   }
<a name="l01378"></a>01378   <span class="keywordtype">double</span> start(<span class="keywordtype">int</span> i) {
<a name="l01379"></a>01379     <span class="keywordflow">return</span> p0_[i];
<a name="l01380"></a>01380   }
<a name="l01381"></a>01381   <span class="keywordtype">double</span> end(<span class="keywordtype">int</span> i) {
<a name="l01382"></a>01382     <span class="keywordflow">return</span> p1_[i];
<a name="l01383"></a>01383   }
<a name="l01384"></a>01384   <span class="comment">/*</span>
<a name="l01385"></a>01385 <span class="comment">  bool ok() {</span>
<a name="l01386"></a>01386 <span class="comment">    return good_;</span>
<a name="l01387"></a>01387 <span class="comment">  }</span>
<a name="l01388"></a>01388 <span class="comment">  */</span>
<a name="l01389"></a>01389   <span class="keywordtype">int</span> dimw() {
<a name="l01390"></a>01390     <span class="keywordflow">return</span> dimw_;
<a name="l01391"></a>01391   }
<a name="l01392"></a>01392 
<a name="l01393"></a>01393   <span class="keywordtype">int</span> getIndex(<span class="keywordtype">int</span> i,<span class="keywordtype">int</span> j = 0, <span class="keywordtype">int</span> k = 0) 
<a name="l01394"></a>01394   {
<a name="l01395"></a>01395     <span class="keywordflow">if</span>(dimw_ == 3)
<a name="l01396"></a>01396       <span class="keywordflow">return</span>  k*(nofcells_[1]+1)*(nofcells_[0]+1) + j*(nofcells_[0]+1) + i;
<a name="l01397"></a>01397     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dimw_ == 2)
<a name="l01398"></a>01398       <span class="keywordflow">return</span>  j * (nofcells_[0]+1) + i;
<a name="l01399"></a>01399     <span class="keywordflow">else</span> 
<a name="l01400"></a>01400       <span class="keywordflow">return</span> i;
<a name="l01401"></a>01401   }
<a name="l01402"></a>01402  <span class="keyword">private</span>:
<a name="l01403"></a>01403   <span class="keywordtype">bool</span> next() {
<a name="l01404"></a>01404     <span class="keywordflow">if</span> (linenumber()==noflines()-1) {
<a name="l01405"></a>01405       good_=<span class="keyword">false</span>;
<a name="l01406"></a>01406       <span class="keywordflow">return</span> good_;
<a name="l01407"></a>01407     }
<a name="l01408"></a>01408     <span class="comment">//read p0_ </span>
<a name="l01409"></a>01409     getnextline();
<a name="l01410"></a>01410     <span class="keywordtype">double</span> x;
<a name="l01411"></a>01411     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0;i&lt;dimw_;i++) 
<a name="l01412"></a>01412       <span class="keywordflow">if</span>(getnextentry(x))
<a name="l01413"></a>01413               p0_[i] = x;
<a name="l01414"></a>01414       <span class="keywordflow">else</span>  {
<a name="l01415"></a>01415         DUNE_THROW(DGFException,
<a name="l01416"></a>01416                    <span class="stringliteral">"ERROR in "</span> &lt;&lt; *<span class="keyword">this</span>
<a name="l01417"></a>01417                    &lt;&lt; <span class="stringliteral">"Too few coordinates for point p0"</span>);
<a name="l01418"></a>01418       }
<a name="l01419"></a>01419     <span class="comment">//read p1_</span>
<a name="l01420"></a>01420     getnextline();
<a name="l01421"></a>01421     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0;i&lt;dimw_;i++) 
<a name="l01422"></a>01422       <span class="keywordflow">if</span>(getnextentry(x))
<a name="l01423"></a>01423               p1_[i] = x;
<a name="l01424"></a>01424       <span class="keywordflow">else</span>  {
<a name="l01425"></a>01425         DUNE_THROW(DGFException,
<a name="l01426"></a>01426                    <span class="stringliteral">"ERROR in "</span> &lt;&lt; *<span class="keyword">this</span>
<a name="l01427"></a>01427                    &lt;&lt; <span class="stringliteral">"Too few coordinates for point p1"</span>);
<a name="l01428"></a>01428       }
<a name="l01429"></a>01429     
<a name="l01430"></a>01430     <span class="comment">//find real upper and lower edge</span>
<a name="l01431"></a>01431     std::vector&lt;double&gt; p0h(dimw_),p1h(dimw_);  <span class="comment">//help variables</span>
<a name="l01432"></a>01432     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i&lt;dimw_;i++) {
<a name="l01433"></a>01433       p0h[i] = p0_[i] &lt; p1_[i] ? p0_[i] : p1_[i];
<a name="l01434"></a>01434       p1h[i] = p0_[i] &gt; p1_[i] ? p0_[i] : p1_[i];       
<a name="l01435"></a>01435     }
<a name="l01436"></a>01436     p0_ = p0h;
<a name="l01437"></a>01437     p1_ = p1h;
<a name="l01438"></a>01438     <span class="comment">//get numbers of cells for every direction</span>
<a name="l01439"></a>01439     getnextline();
<a name="l01440"></a>01440     <span class="keywordtype">int</span> number;
<a name="l01441"></a>01441     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0;i&lt;dimw_;i++) 
<a name="l01442"></a>01442       <span class="keywordflow">if</span>(getnextentry(number))
<a name="l01443"></a>01443               nofcells_[i] = number;
<a name="l01444"></a>01444       <span class="keywordflow">else</span> {
<a name="l01445"></a>01445         DUNE_THROW(DGFException,
<a name="l01446"></a>01446                    <span class="stringliteral">"ERROR in "</span> &lt;&lt; *<span class="keyword">this</span>            
<a name="l01447"></a>01447                    &lt;&lt; <span class="stringliteral">"Couldn't detect a number of cells for every direction"</span>);
<a name="l01448"></a>01448       }
<a name="l01449"></a>01449     good_ = <span class="keyword">true</span>;
<a name="l01450"></a>01450     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i =0; i &lt; dimw_; i++)
<a name="l01451"></a>01451       h_[i] = (p1_[i] - p0_[i])/double(nofcells_[i]);
<a name="l01452"></a>01452     <span class="comment">//Printing Data on screen</span>
<a name="l01453"></a>01453     dverb &lt;&lt; <span class="stringliteral">"p0 = ("</span>; 
<a name="l01454"></a>01454     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0;i&lt;dimw_-1;i++)
<a name="l01455"></a>01455       dverb &lt;&lt; p0_[i]  &lt;&lt;<span class="stringliteral">","</span>;
<a name="l01456"></a>01456     dverb &lt;&lt; p0_[dimw_-1] &lt;&lt;<span class="stringliteral">") \n"</span>;
<a name="l01457"></a>01457     dverb &lt;&lt; <span class="stringliteral">"p1 = ("</span>; 
<a name="l01458"></a>01458     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0;i&lt;dimw_-1;i++)
<a name="l01459"></a>01459       dverb &lt;&lt; p1_[i]  &lt;&lt;<span class="stringliteral">","</span>;
<a name="l01460"></a>01460     dverb &lt;&lt; p1_[dimw_-1] &lt;&lt;<span class="stringliteral">") \n"</span>;             
<a name="l01461"></a>01461     dverb &lt;&lt; <span class="stringliteral">"n = ("</span>; 
<a name="l01462"></a>01462     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0;i&lt;dimw_-1;i++)
<a name="l01463"></a>01463       dverb &lt;&lt; nofcells_[i]  &lt;&lt;<span class="stringliteral">","</span>;
<a name="l01464"></a>01464     dverb &lt;&lt; nofcells_[dimw_-1] &lt;&lt;<span class="stringliteral">") \n"</span>;               
<a name="l01465"></a>01465     dverb &lt;&lt; std::endl;
<a name="l01466"></a>01466     <span class="keywordflow">return</span> good_;
<a name="l01467"></a>01467   }
<a name="l01468"></a>01468 };
<a name="l01469"></a>01469 <span class="keyword">const</span> <span class="keywordtype">char</span>* IntervalBlock::ID = <span class="stringliteral">"Interval"</span>;
<a name="l01470"></a>01470 }
<a name="l01471"></a>01471 }
<a name="l01472"></a>01472 <span class="preprocessor">#endif</span>
</pre></div></div>
</div> <!-- end doxygen -->
</div> <!-- end main -->
<div class="foot">

<p class="foot">
  Generated on 6 Nov 2008 with <a
  href="http://www.doxygen.org/">Doxygen</a> (ver 1.5.6)  
  [<a href="doxygen.log">logfile</a>].
</p>

</div>

</body>
</html>
