<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN""http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>dune-grid: Virtual Refinement (dune-grid )</title>
  <link rel="stylesheet" type="text/css" href="./dune-doxy.css">
  <link rel="stylesheet" type="text/css" href="./tabs.css">
</head>
<div class="main">
<div class="doxygen">
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Virtual Refinement<br>
<small>
[<a class="el" href="a00522.html">Refinement</a>]</small>
</h1>Please have a look on the non-virtual <a class="el" href="a00522.html">Refinement</a> documentation.<h2><a class="anchor" name="General">
General</a></h2>
<a class="el" href="a00522.html">Refinement</a> can only be used when you know the geometryType of your entities at compile time. You could circumvent this by using a switch(geometryType), but each case would look very much the same. If you have many such switch() statements, or each case contains lots of code, or you simply have many possible geometryTypes, this can be quiet annoying.<p>
VirtualRefinement does all of this switch() statements for you. It defines a common virtual base class per dimension, and derives one class for each geometryType and coerceTo from that class. The derived classes simply wrap the non-virtual classes from <a class="el" href="a00522.html">Refinement</a>. This makes it possible to treat each geometryType (of a given dimension) the same, and thus eleminates the many repetitions of lots of code.<p>
But the case statements are not totally gone yet. VirtualRefinement does these statements once and for all by wrapping them into the <a class="el" href="a00441.html#483e48cec01d2ca2552b6004eafe7c2f" title="return a reference to the VirtualRefinement according to the parameters">buildRefinement()</a> function.<h2><a class="anchor" name="User_interface">
The user interface</a></h2>
<h3><a class="anchor" name="VirtualRefinement">
The VirtualRefinement class</a></h3>
VirtualRefinement is not a set of unrelated specialisations of the same template class. VirtualRefinement is a base class with several virtual methods, which are overloaded by the concrete VirtualRefinement implementation classes. Each implementation class wraps one of the non-virtual <a class="el" href="a00522.html">Refinement</a> classes.<p>
The user interface is modelled closely after the the <a class="el" href="a00522.html">Refinement</a> interface. The main differences are:<p>
<ul>
<li>VirtualRefinement is not a static class, but a singleton. Thus each VirtualRefinement implementation has to be instanciated before use. This is done with the template function buildRefinement (see below).</li><li>Since the methods of VirtualRefinement are virtual (or use virtual methods themself) they have to be called like <div class="fragment"><pre class="fragment">  refinementInstace.nElements(level);
</pre></div> instead of <div class="fragment"><pre class="fragment">  RefinementTypedef::nElements(level);
</pre></div></li></ul>
<p>
<ul>
<li>IndexVector is a std::vector instead of a FieldVector since the number of corners of different geometry types may be different at runtime. The user is responsible to always pass the same coerceTo parameter to <a class="el" href="a00441.html#483e48cec01d2ca2552b6004eafe7c2f" title="return a reference to the VirtualRefinement according to the parameters">buildRefinement()</a> so he always gets the same number of corners.</li></ul>
<p>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dimension&gt;
  <span class="keyword">class </span>VirtualRefinement
  {
  <span class="keyword">public</span>:
    <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> Codimension&gt;
    <span class="keyword">struct </span>Codim {
      <span class="keyword">class </span>SubEntityIterator;
    };
    <span class="keyword">typedef</span> VertexIterator; <span class="comment">// These are aliases for Codim&lt;codim&gt;::SubEntityIterator</span>
    <span class="keyword">typedef</span> ElementIterator;

    <span class="keyword">typedef</span> IndexVector; <span class="comment">// This is a std::vector</span>
    <span class="keyword">typedef</span> CoordVector; <span class="comment">// This is a FieldVector</span>

    <span class="keyword">virtual</span> <span class="keywordtype">int</span> nVertices(<span class="keywordtype">int</span> level) <span class="keyword">const</span>;
    VertexIterator vBegin(<span class="keywordtype">int</span> level) <span class="keyword">const</span>;
    VertexIterator vEnd(<span class="keywordtype">int</span> level) <span class="keyword">const</span>;
    <span class="keyword">virtual</span> <span class="keywordtype">int</span> nElements(<span class="keywordtype">int</span> level) <span class="keyword">const</span>;
    ElementIterator eBegin(<span class="keywordtype">int</span> level) <span class="keyword">const</span>;
    ElementIterator eEnd(<span class="keywordtype">int</span> level) <span class="keyword">const</span>;
  };
</pre></div><p>
The iterators have the same interface as the <a class="el" href="a00522.html">Refinement</a> iterators except that IndexVector is a std::vector instead of a FieldVector (see above). Also the restriction that the Iterators are not derefencable applies.<p>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dimension&gt;
  <span class="keyword">class </span>VertexIterator
  {
  <span class="keyword">public</span>:
    <span class="keyword">typedef</span> VirtualRefinement&lt;dimension&gt; Refinement;

    <span class="keywordtype">int</span> index() <span class="keyword">const</span>;
    Refinement::CoordVector coords() <span class="keyword">const</span>;
  };

  <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dimension&gt;
  <span class="keyword">class </span>ElementIterator
  {
  <span class="keyword">public</span>:
    <span class="keyword">typedef</span> VirtualRefinement&lt;dimension&gt; Refinement;

    <span class="keywordtype">int</span> index() <span class="keyword">const</span>;
    Refinement::IndexVector vertexIndices() <span class="keyword">const</span>;
  };
</pre></div><h3><a class="anchor" name="buildRefinement">
buildRefinement()</a></h3>
The declaration for buildRefinement is<p>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> dimension, <span class="keyword">class</span> CoordType&gt;
  VirtualRefinement&lt;dimension, CoordType&gt; &amp;<a class="code" href="a00441.html#483e48cec01d2ca2552b6004eafe7c2f" title="return a reference to the VirtualRefinement according to the parameters">buildRefinement</a>(GeometryType geometryType, GeometryType coerceTo);
</pre></div><p>
It is expected that you know the dimension and the coordinate type of the elements you want to refine at compile time.<p>
The simple case is that you want to refine, say, quadrilaterals and the subentities should look like quadrilaterals as well. In that case you would call <a class="el" href="a00441.html#483e48cec01d2ca2552b6004eafe7c2f" title="return a reference to the VirtualRefinement according to the parameters">buildRefinement()</a> like<p>
<div class="fragment"><pre class="fragment">  VirtualRefinement&lt;2, CoordType&gt; &amp;refinement = buildRefinement&lt;2, CoordType&gt;(quadrilateral, quadrilateral);
</pre></div><p>
The more complicated case is that your entity is a quadrilateral, but the subentities should look like triangles. In this case call <a class="el" href="a00441.html#483e48cec01d2ca2552b6004eafe7c2f" title="return a reference to the VirtualRefinement according to the parameters">buildRefinement()</a> like<p>
<div class="fragment"><pre class="fragment">  VirtualRefinement&lt;2, CoordType&gt; &amp;refinement = buildRefinement&lt;2, CoordType&gt;(quadrilateral, triangle);
</pre></div><p>
Summary: geometryType is the geometry type of the entity you want to refine, while coerceTo is the geometry type of the subentities.<h2><a class="anchor" name="Implementing">
Implementing a new Refinement type</a></h2>
When you write a Refinement implementation for a new combination of geometryType and coerceTo, you have to tell <a class="el" href="a00441.html#483e48cec01d2ca2552b6004eafe7c2f" title="return a reference to the VirtualRefinement according to the parameters">buildRefinement()</a> about it.<p>
<ul>
<li>First, you have to implement the non-virtual part in <a class="el" href="a00522.html">Refinement</a>, if you have not done so yet.</li><li>Second, visit the end of refinementvirtual.cc, and look for the specialisations of template&lt;int dimension, class CoordType&gt; class RefinementBuilder. There is one specialisation for each dimension, containing the single method build().</li><li>The build() contains two levels of switch statements, the outer for geomentryType and the inner for coerceTo. Each case will either return the correct VirtualRefinement or fall throught to the end of the method and throw an error. Insert the cases for your refinement.</li></ul>
<p>
Everything else has been done for you automatically.<h3><a class="anchor" name="Namespaces">
Namespaces</a></h3>
VirtualRefinement does not use a complicated namespace scheme like <a class="el" href="a00522.html">Refinement</a>. The complete VirtualRefinement stuff simply lives directly in namespace <a class="el" href="a00441.html">Dune</a>.<h3><a class="anchor" name="Layers">
Conceptual layers</a></h3>
VirtualRefinement adds to more layers to the ones already defined in <a class="el" href="a00522.html">Refinement</a>:<p>
<ul>
<li><b>Layer 3</b> makes it easy to use several Refinement implementations in the same code, when you only know at run-time, which Refinement implementation you need. It wraps class Refinement and it's iterators into a Proxy class, retaining it's interface but all deriving from a virtual base class VirtualRefinement&lt;dimension, CoordType&gt;. This is located in refinementvirtual.cc.</li><li><b>Layer 4</b> defines function buildRefinement(geometryType, coerceTo), which returns the right refinement for a runtime-determined GeometryType. It is also located in refinementvirtual.cc</li></ul>
<h2><a class="anchor" name="Implementation">
Implementation</a></h2>
The interface is defined by the template class VirtualRefinement. It simply defines the CoordVectors and IndexVectors appropriate for this dimension and CoordType, defines which iterators to use, and provides some proxy or pure virtual functions.<p>
For each class Refinement&lt;geometryType, CoordType, coercTo, dim&gt; we provide a class VirtualRefinementImp&lt;geometryType, CoordType, coercTo, dim&gt;, which wraps the matching class Refinement&lt;geometryType, CoordType, coercTo, dim&gt; and derives from the matching base class VirtualRefinement&lt;dimension, CoordType&gt;. Each VirtualRefinementImp is a singleton and has a static instance() method which will return this instance as a reference to the base class VirtualRefinement. All this is done in a single template class.<h3><a class="anchor" name="Iterators">
The Iterators</a></h3>
We can't do the same thing with the iterators as we do with class VirtualRefinement. Since they are polymorph we cannot simply pass them into user code. They are not singletons, so we also cannot pass references to them. Passing pointers to iterators would work, but then the programmer has to remember to explecitely delete them. Also, it is uncommon for iterators to be handled by their pointers.<p>
What we do instead is having a wrapper class which conforms to the iterator interface and is the same for all VirtualRefinementIterators of a given dimension. This class contains a pointer to a polymorph backend object implementing the iterator. The various VirtualRefinementImps then derive from the abstract backend class and pass a pointer to a concrete backend object when instantiating an iterator.<h3><a class="anchor" name="buildRefinement">
buildRefinement()</a></h3>
The template function <a class="el" href="a00441.html#483e48cec01d2ca2552b6004eafe7c2f" title="return a reference to the VirtualRefinement according to the parameters">buildRefinement()</a> has to be specialized for each dimension. It makes no sense to test for geometryType==GeometryTypeprism when dimension==2. But this way we run into a limitation of C++: we can't do partial function specialisation.<p>
The workaround is to create a class RefinementBuilder with a lone static method build() and to call that from <a class="el" href="a00441.html#483e48cec01d2ca2552b6004eafe7c2f" title="return a reference to the VirtualRefinement according to the parameters">buildRefinement()</a>. Since RefinementBuilder is a class and not a function we can do partial specialisations.<p>
It is probably possible to automatically generate the switch statements with linked lists of template structs, functions implementing the cases, and a recursive template function that will iterate over the list, but it is probably not worth the effort, as long as <a class="el" href="a00441.html#483e48cec01d2ca2552b6004eafe7c2f" title="return a reference to the VirtualRefinement according to the parameters">buildRefinement()</a> is enough for the job. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
</table>
</div>
</div> <!-- end doxygen -->
</div> <!-- end main -->
<div class="foot">

<p class="foot">
  Generated on 6 Nov 2008 with <a
  href="http://www.doxygen.org/">Doxygen</a> (ver 1.5.6)  
  [<a href="doxygen.log">logfile</a>].
</p>

</div>

</body>
</html>
