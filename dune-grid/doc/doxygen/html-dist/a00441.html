<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN""http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>dune-grid: Dune Namespace Reference (dune-grid )</title>
  <link rel="stylesheet" type="text/css" href="./dune-doxy.css">
  <link rel="stylesheet" type="text/css" href="./tabs.css">
</head>
<div class="main">
<div class="doxygen">
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Dune Namespace Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
put vtk io intro here ... 
<p>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00067.html">CommunicatorInterface</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00001.html">AGMemoryProvider</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">organize the memory management for entitys used by the NeighborIterator  <a href="a00001.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html">AlbertaMarkerVector</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00006.html">AlbertaGridGeometry</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html">AlbertaGridEntity</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html">AlbertaGridEntity&lt; 0, dim, GridImp &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html">AlbertaGridEntityPointer</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html">AlbertaGridHierarchicIterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00011.html">AlbertaGridIntersectionIterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html">AlbertaGridTreeIterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html">AlbertaGridLevelIterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html">AlbertaGridLeafIterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="a00193.html" title="Enables iteration over all leaf entities of a codimension zero of a grid. See also...">LeafIterator</a> which is just a hull for the <a class="el" href="a00206.html" title="Enables iteration over all entities of a given codimension and level of a grid. See...">LevelIterator</a>.  <a href="a00012.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html">AlbertaGrid</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">[<em> provides <a class="el" href="a00100.html">Dune::Grid</a> </em>]  <a href="a00002.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html">AlbertaGridHierarchicIteratorTypes</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">HierarchicIndexSet uses <a class="el" href="a00193.html" title="Enables iteration over all leaf entities of a codimension zero of a grid. See also...">LeafIterator</a> types for all codims and partition types.  <a href="a00008.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html">AlbertaGridIdSet</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">hierarchic index set of <a class="el" href="a00002.html" title="[ provides Dune::Grid ]">AlbertaGrid</a>  <a href="a00010.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html">ALU2dGridEntity</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00018.html">ALU2dGridEntity&lt; 0, dim, GridImp &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html">ALU2dGridEntityPointer</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html">ALU2dGridGeometry</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html">ALU2dGrid</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">[<em> provides <a class="el" href="a00100.html">Dune::Grid</a> </em>]  <a href="a00016.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html">ALU2dGridHierarchicIteratorTypes</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">HierarchicIndexSet uses <a class="el" href="a00193.html" title="Enables iteration over all leaf entities of a codimension zero of a grid. See also...">LeafIterator</a> tpyes for all codims and partition types.  <a href="a00023.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00021.html">ALU2dGridHierarchicIndexSet</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">hierarchic index set of <a class="el" href="a00016.html" title="[ provides Dune::Grid ]">ALU2dGrid</a>  <a href="a00021.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html">ALU2dGridLocalIdSet</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">hierarchic index set of <a class="el" href="a00027.html" title="[ provides Dune::Grid ]">ALU3dGrid</a>  <a href="a00026.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00025.html">ALU2dGridIntersectionBase</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html">ALU2dGridHierarchicIterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Hierarichic Iterator of <a class="el" href="a00016.html" title="[ provides Dune::Grid ]">ALU2dGrid</a>.  <a href="a00022.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html">ALU3dGridVertexList</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html">ALU3dGridLeafVertexList</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00028.html">ALU3dGridEntity</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00029.html">ALU3dGridEntity&lt; 0, dim, GridImp &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00031.html">ALU3dGridEntityPointerBase</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00030.html">ALU3dGridEntityPointer&lt; 0, GridImp &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00032.html">ALU3dGridGeometricFaceInfoBase</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00034.html">ALU3dGridGeometricFaceInfoTetra</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00033.html">ALU3dGridGeometricFaceInfoHexa</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html">ALU3dGridGeometry</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html">ALU3dGridGeometry&lt; mydim, cdim, const ALU3dGrid&lt; 3, 3, tetra &gt; &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialisation for tetrahedra.  <a href="a00037.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html">ALU3dGridGeometry&lt; mydim, cdim, const ALU3dGrid&lt; 3, 3, hexa &gt; &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialisation for hexahedra.  <a href="a00036.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00027.html">ALU3dGrid</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">[<em> provides <a class="el" href="a00100.html">Dune::Grid</a> </em>]  <a href="a00027.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00040.html">ALU3dGridHierarchicIteratorTypes</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">HierarchicIndexSet uses <a class="el" href="a00193.html" title="Enables iteration over all leaf entities of a codimension zero of a grid. See also...">LeafIterator</a> tpyes for all codims and partition types.  <a href="a00040.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00039.html">ALU3dGridHierarchicIndexSet</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">hierarchic index set of <a class="el" href="a00027.html" title="[ provides Dune::Grid ]">ALU3dGrid</a>  <a href="a00039.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00038.html">ALU3dGridGlobalIdSet</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">global id set for <a class="el" href="a00027.html" title="[ provides Dune::Grid ]">ALU3dGrid</a>  <a href="a00038.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00046.html">ALU3dGridLocalIdSet</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">hierarchic index set of <a class="el" href="a00027.html" title="[ provides Dune::Grid ]">ALU3dGrid</a>  <a href="a00046.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00042.html">ALU3dGridIntersectionIterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html">ALU3dGridLevelIterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00043.html">ALU3dGridLeafIterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Leaf iterator.  <a href="a00043.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00283.html">TrilinearMapping</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html">BilinearSurfaceMapping</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A bilinear surface mapping.  <a href="a00061.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00221.html">NonConformingFaceMapping</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00223.html">NonConformingFaceMapping&lt; tetra &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Non-conforming face mappings for tetrahedra.  <a href="a00223.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00222.html">NonConformingFaceMapping&lt; hexa &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Non-conforming face mappings for hexahedra.  <a href="a00222.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html">ALUFastMemoryProvider</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">organize the memory management for entitys used by the NeighborIterator  <a href="a00052.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html">ALUMemoryProvider</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">organize the memory management for entitys used by the NeighborIterator  <a href="a00053.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00081.html">ElementTopologyMapping</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00089.html">FaceTopologyMapping</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00050.html">ALUCubeGrid</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">[<em> provides <a class="el" href="a00100.html">Dune::Grid</a> </em>]  <a href="a00050.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00051.html">ALUCubeGrid&lt; 3, 3 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">[<em> provides <a class="el" href="a00100.html">Dune::Grid</a> </em>]  <a href="a00051.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00054.html">ALUSimplexGrid</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">[<em> provides <a class="el" href="a00100.html">Dune::Grid</a> </em>]  <a href="a00054.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00056.html">ALUSimplexGrid&lt; 3, 3 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">[<em> provides <a class="el" href="a00100.html">Dune::Grid</a> </em>]  <a href="a00056.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html">ALUSimplexGrid&lt; 2, 2 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">[<em> provides <a class="el" href="a00100.html">Dune::Grid</a> </em>]  <a href="a00055.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00048.html">ALUConformGrid</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">[<em> provides <a class="el" href="a00100.html">Dune::Grid</a> </em>]  <a href="a00048.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00049.html">ALUConformGrid&lt; 2, 2 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">[<em> provides <a class="el" href="a00100.html">Dune::Grid</a> </em>]  <a href="a00049.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html">BoundarySegment</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for classes implementing geometries of boundary segments.  <a href="a00062.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00217.html">MessageBufferIF</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Communication message buffer interface. This class describes the interface for reading and writing data to the communication message buffer. As message buffers might be deeply implemented in various packages the message buffers implementations cannot be derived from this interface class. Therefore we just apply the engine concept to wrap the message buffer call and make sure that the interface is fulfilled.  <a href="a00217.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00066.html">CommDataHandleIF</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="a00066.html" title="CommDataHandleIF describes the features of a data handle for communication in parallel...">CommDataHandleIF</a> describes the features of a data handle for communication in parallel runs using the <a class="el" href="a00100.html#6ca2df2b811db924bd6d071347bb6308" title="Communicate information on distributed entities on a given level Template parameter...">Grid::communicate</a> methods. Here the Barton-Nackman trick is used to interprete data handle objects as it's interface. Therefore usable data handle classes need to be derived from this class.  <a href="a00066.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00072.html">DefaultEmptyIndexSet</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00151.html">IndexSetWrapper</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00073.html">DefaultGridIndexSetBase</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">default base class for index set implementations for FR numerics  <a href="a00073.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00293.html">WrappedLevelIndexSet</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wraps LevelIndexSet for use with LagrangeFunctionSpace.  <a href="a00293.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00139.html">HierarchicIndexSetSelector</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compile time chooser for hierarchic or leaf index set  <a href="a00139.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00291.html">WrappedHierarchicIndexSet</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wraps HierarchicIndex Sets of <a class="el" href="a00002.html" title="[ provides Dune::Grid ]">AlbertaGrid</a> and ALUGrid.  <a href="a00291.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00292.html">WrappedLeafIndexSet</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wraps LeafIndexSet of <a class="el" href="a00441.html">Dune</a> Grids for use with LagrangeFunctionSpace.  <a href="a00292.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html">CheckLevelForCodim</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="a00077.html" title="DefaultLevelIndexSet creates a LevelIndexSet for a Grid by using its HierarchicIndexSet...">DefaultLevelIndexSet</a> generates a level index set for a grid out of a grids hierarchic index set by storing for each entity in the grid a number in an array.  <a href="a00063.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00077.html">DefaultLevelIndexSet</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="a00077.html" title="DefaultLevelIndexSet creates a LevelIndexSet for a Grid by using its HierarchicIndexSet...">DefaultLevelIndexSet</a> creates a LevelIndexSet for a <a class="el" href="a00100.html" title="Grid abstract base classThis class is the base class for all grid implementations...">Grid</a> by using its HierarchicIndexSet.  <a href="a00077.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00075.html">DefaultLeafIteratorTypes</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="a00193.html" title="Enables iteration over all leaf entities of a codimension zero of a grid. See also...">LeafIterator</a> tpyes for all codims and partition types.  <a href="a00075.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00074.html">DefaultLeafIndexSet</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default LeafIndexSet.  <a href="a00074.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00064.html">CombinedAdaptProlongRestrict</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">class for combining 2 index sets together for adaptation process  <a href="a00064.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00082.html">Entity</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper class for entities.  <a href="a00082.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00083.html">Entity&lt; 0, dim, GridImp, EntityImp &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Template specialization of <a class="el" href="a00082.html" title="Wrapper class for entities.">Dune::Entity</a> for Elements (codim==0).  <a href="a00083.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html">EntityDefaultImplementation</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default Implementations for EntityImp.  <a href="a00085.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00086.html">EntityDefaultImplementation&lt; 0, dim, GridImp, EntityImp &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default Implementations for EntityImp (Elements [cd=0]).  <a href="a00086.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00087.html">EntityPointer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper class for pointers to entities.  <a href="a00087.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html">EntityPointerDefaultImplementation</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default implementation of <a class="el" href="a00087.html" title="Wrapper class for pointers to entities.">EntityPointer</a>.  <a href="a00088.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00094.html">Geometry</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper class for geometries.  <a href="a00094.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00095.html">GeometryDefaultImplementation</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default implementation for class <a class="el" href="a00094.html" title="Wrapper class for geometries.">Geometry</a>.  <a href="a00095.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00105.html">GridError</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for exceptions in <a class="el" href="a00441.html">Dune</a> grid modules.  <a href="a00105.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00100.html">Grid</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="a00100.html" title="Grid abstract base classThis class is the base class for all grid implementations...">Grid</a> abstract base class<p>
This class is the base class for all grid implementations. Although no virtual functions are used we call it abstract since its methods do not contain an implementation but forward to the methods of the derived class via the Barton-Nackman trick.  <a href="a00100.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html">GridDefaultImplementation</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html">GridTraits</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A traits struct that collects all associated types of one grid model.  <a href="a00109.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00214.html">MakeableInterfaceObject</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00107.html">GridPartInterface</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interface for the GridPart classes A GridPart class allows to access only a specific subset of a grid's entities. A GridPart implementation provides the corresponding index set and a begin/end iterator pair for accessing those entities, the corresponding intersection iterators and a appropriate communication method. GridParts are used to parametrize spaces (see DiscreteFunctionSpaceDefault [in dune-fem]).  <a href="a00107.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00106.html">GridPartDefault</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default implementation for the GridPart classes.  <a href="a00106.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00201.html">LevelGridPart</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Selects a specific level of a grid.  <a href="a00201.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00203.html">LevelGridPartTraits</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type definitions for the <a class="el" href="a00201.html" title="Selects a specific level of a grid.">LevelGridPart</a> class.  <a href="a00203.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00188.html">LeafGridPart</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Selects the leaf level of a grid.  <a href="a00188.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00190.html">LeafGridPartTraits</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type definitions for the <a class="el" href="a00188.html" title="Selects the leaf level of a grid.">LeafGridPart</a> class.  <a href="a00190.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00135.html">HierarchicGridPart</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Selects the leaf level of a grid together with the HierarchicIndexSet available for ALUGrid and <a class="el" href="a00002.html" title="[ provides Dune::Grid ]">AlbertaGrid</a>. The HierarchicIndexSet is basically the LocalIdSet of the grid extended by a size method to implement the <a class="el" href="a00145.html" title="Index Set Interface base class.">IndexSet</a> interface. For all other grids the default LeafIndexSet is selected.  <a href="a00135.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html">HierarchicGridPartTraits</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type definitions for the <a class="el" href="a00135.html" title="Selects the leaf level of a grid together with the HierarchicIndexSet available for...">HierarchicGridPart</a> class.  <a href="a00137.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00140.html">HierarchicIterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables iteration over all codim zero entities in a subtree See also the documentation of <a class="el" href="a00087.html" title="Wrapper class for pointers to entities.">Dune::EntityPointer</a>.  <a href="a00140.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00141.html">HierarchicIteratorDefaultImplementation</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default Implementations for HierarchicIteratorImp.  <a href="a00141.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00145.html">IndexSet</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Index Set Interface base class.  <a href="a00145.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html">IndexSetDefaultImplementation</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provide default implementation of method if <a class="el" href="a00145.html" title="Index Set Interface base class.">IndexSet</a>.  <a href="a00148.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00143.html">IdSet</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Id Set Interface.  <a href="a00143.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html">IdSetDefaultImplementation</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Id Set DefaultImplementation.  <a href="a00144.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00153.html">IndexStack</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00154.html">IntersectionIterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mesh entities of codimension 0 ("elements") allow to visit all intersections with "neighboring" elements and with the domain boundary.  <a href="a00154.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html">IntersectionIteratorDefaultImplementation</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default Implementations for IntersectionIteratorImp.  <a href="a00155.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00157.html">IntersectionIteratorWrapper</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class that wraps IntersectionIteratorImp of a grid and gets it's internal object from a object stack hold by the grid.  <a href="a00157.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00192.html">LeafIntersectionIteratorWrapper</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class that wraps IntersectionIteratorImp of a grid and gets it's internal object from a object stack hold by the grid.  <a href="a00192.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00205.html">LevelIntersectionIteratorWrapper</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class that wraps IntersectionIteratorImp of a grid and gets it's internal object from a object stack hold by the grid.  <a href="a00205.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00193.html">LeafIterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables iteration over all leaf entities of a codimension zero of a grid. See also the documentation of <a class="el" href="a00087.html" title="Wrapper class for pointers to entities.">Dune::EntityPointer</a>.  <a href="a00193.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00194.html">LeafIteratorDefaultImplementation</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default Implementations for LevelIteratorImp.  <a href="a00194.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00206.html">LevelIterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables iteration over all entities of a given codimension and level of a grid. See also the documentation of <a class="el" href="a00087.html" title="Wrapper class for pointers to entities.">Dune::EntityPointer</a>.  <a href="a00206.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00207.html">LevelIteratorDefaultImplementation</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default Implementations for LevelIteratorImp.  <a href="a00207.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00216.html">Mapper</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="a00216.html" title="Mapper interface.">Mapper</a> interface.  <a href="a00216.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00218.html">MultipleCodimMultipleGeomTypeMapper</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation class for a multiple codim and multiple geometry type mapper.  <a href="a00218.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html">LeafMultipleCodimMultipleGeomTypeMapper</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiple codim and multiple geometry type mapper for leaf entities.  <a href="a00195.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00208.html">LevelMultipleCodimMultipleGeomTypeMapper</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Multiple codim and multiple geometry type mapper for entities of one level.  <a href="a00208.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00268.html">SimplexQuadraturePointsSingleton</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00233.html">QuadratureOrderOutOfRange</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception thrown if an desired <a class="el" href="a00235.html" title="Abstract base class for quadrature rules.">QuadratureRule</a> is not available, because the order is to high.  <a href="a00233.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00234.html">QuadraturePoint</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Single evaluation point in a quadrature rule.  <a href="a00234.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00235.html">QuadratureRule</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract base class for quadrature rules.  <a href="a00235.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00237.html">QuadratureRules</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A container for all quadrature rules of dimension <code>dim</code>.  <a href="a00237.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html">CubeQuadratureRule</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gauss quadrature for the n-dimensional cube.  <a href="a00069.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html">CubeQuadratureRule&lt; ct, 0 &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html">CubeQuadratureRule&lt; ct, 1 &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00183.html">Jacobi1QuadratureRule&lt; ct, 1 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Jacobi-Gauss quadrature for alpha=1, beta=0.  <a href="a00183.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00184.html">Jacobi2QuadratureRule&lt; ct, 1 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Jacobi-Gauss quadrature for alpha=2, beta=0.  <a href="a00184.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00269.html">SimplexQuadratureRule&lt; ct, 2 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Quadrature rules for triangles.  <a href="a00269.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00270.html">SimplexQuadratureRule&lt; ct, 3 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Quadrature rules for tetrahedra.  <a href="a00270.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html">PrismQuadraturePoints&lt; 3 &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00226.html">PrismQuadraturePointsSingleton</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Singleton holding the Prism Quadrature points.  <a href="a00226.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00227.html">PrismQuadraturePointsSingleton&lt; 3 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Singleton holding the Prism Quadrature points.  <a href="a00227.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00228.html">PrismQuadratureRule&lt; ct, 3 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Quadrature rules for prisms.  <a href="a00228.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00229.html">PyramidQuadraturePoints</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00230.html">PyramidQuadraturePointsSingleton</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Singleton holding the pyramid quadrature points.  <a href="a00230.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00231.html">PyramidQuadraturePointsSingleton&lt; 3 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Singleton holding the pyramid quadrature points.  <a href="a00231.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00232.html">PyramidQuadratureRule&lt; ct, 3 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Quadrature rules for Pyramids.  <a href="a00232.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00236.html">QuadratureRuleFactory</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory class for creation of quadrature rules, depending on GeometryType, order and <a class="el" href="a00477.html" title="Defines an enum for currently available quadrature rules.">QuadratureType</a>.  <a href="a00236.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00241.html">ReferenceElement</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the abstract base class for reference elements.  <a href="a00241.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00244.html">ReferenceElementWrapper</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The wrapper allows Imp to be used as a reference element without making methods of Imp virtual.  <a href="a00244.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00238.html">ReferenceCube</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the reference cube without virtual functions.  <a href="a00238.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00239.html">ReferenceCube&lt; ctype, 0 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">specialization for d=0  <a href="a00239.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00240.html">ReferenceCubeContainer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make the reference cube accessible as a container.  <a href="a00240.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00247.html">ReferenceSimplex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reference simplex.  <a href="a00247.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00248.html">ReferenceSimplex&lt; ctype, 0 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">specialization for d=0  <a href="a00248.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00249.html">ReferenceSimplexContainer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make the reference simplex accessible as a container.  <a href="a00249.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html">ReferencePrismContainer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make the reference Prism accessible as a container.  <a href="a00245.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00246.html">ReferencePyramidContainer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make the reference Pyramid accessible as a container.  <a href="a00246.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00242.html">ReferenceElementContainer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combines all reference elements.  <a href="a00242.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html">ReferenceElementContainer&lt; ctype, 3 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combines all reference elements for dim==3.  <a href="a00243.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00250.html">Refinement</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrap each <a class="el" href="a00522.html">Refinement</a> implementation to get a consistent interface.  <a href="a00250.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00271.html">SingleCodimSingleGeomTypeMapper</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation class for a single codim and single geometry type mapper.  <a href="a00271.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00196.html">LeafSingleCodimSingleGeomTypeMapper</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Single codim and single geometry type mapper for leaf entities.  <a href="a00196.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00209.html">LevelSingleCodimSingleGeomTypeMapper</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Single codim and single geometry type mapper for entities of one level.  <a href="a00209.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00272.html">SingleTypeSizeCache</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">organizes the caching of sizes for one grid and one GeometryType  <a href="a00272.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00274.html">SizeCache</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">oranizes the caching of sizes for one grid  <a href="a00274.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00285.html">UniversalMapper</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implements a mapper for an arbitrary subset of entities.  <a href="a00285.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html">GlobalUniversalMapper</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Universal mapper based on global ids.  <a href="a00096.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00213.html">LocalUniversalMapper</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Universal mapper based on local ids.  <a href="a00213.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00286.html">VirtualRefinement</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="a00286.html" title="VirtualRefinement base class.">VirtualRefinement</a> base class.  <a href="a00286.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00059.html">AmiraMeshReader&lt; UGGrid&lt; 3 &gt; &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a 3d coarse grid from an AmiraMesh file into a <a class="el" href="a00284.html" title="[ provides Dune::Grid ]">UGGrid</a>.  <a href="a00059.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00058.html">AmiraMeshReader&lt; UGGrid&lt; 2 &gt; &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a 2d coarse grid from an AmiraMesh file into a <a class="el" href="a00284.html" title="[ provides Dune::Grid ]">UGGrid</a>.  <a href="a00058.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html">AmiraMeshReader</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides file reading facilities in the AmiraMesh format.  <a href="a00057.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00060.html">AmiraMeshWriter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides file writing facilities in the AmiraMesh format.  <a href="a00060.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00199.html">LevelAmiraMeshWriter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides file writing facilities in the AmiraMesh format for level grids.  <a href="a00199.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00186.html">LeafAmiraMeshWriter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides file writing facilities in the AmiraMesh format for leaf grids.  <a href="a00186.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00079.html">DGFException</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">exception class for IO errors in the DGF parser  <a href="a00079.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html">GridPtr</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for constructing grids from DGF files.  <a href="a00108.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html">DGFGridInfo</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Some simple static information for a given GridType.  <a href="a00080.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00097.html">GnuplotWriter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writer for 1D grids in gnuplot format.  <a href="a00097.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00187.html">LeafGnuplotWriter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="a00097.html" title="Writer for 1D grids in gnuplot format.">GnuplotWriter</a> on the leaf grid.  <a href="a00187.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00200.html">LevelGnuplotWriter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="a00097.html" title="Writer for 1D grids in gnuplot format.">GnuplotWriter</a> on a given level grid.  <a href="a00200.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00276.html">StarCDReader</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">File reader for the Star-CD format.  <a href="a00276.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00288.html">VTKOptions</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">options for VTK output  <a href="a00288.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00289.html">VTKWriter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writer for the ouput of grid functions in the vtk format.<p>
Writes arbitrary grid functions (living on cells or vertices of a grid) to a file suitable for easy visualization with <a href="http://public.kitware.com/VTK/">The Visualization Toolkit (VTK)</a>.  <a href="a00289.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00198.html">LeafVTKWriter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="a00289.html" title="Writer for the ouput of grid functions in the vtk format.Writes arbitrary grid functions...">VTKWriter</a> on the leaf grid.  <a href="a00198.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00211.html">LevelVTKWriter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="a00289.html" title="Writer for the ouput of grid functions in the vtk format.Writes arbitrary grid functions...">VTKWriter</a> on a given level grid.  <a href="a00211.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00065.html">CombinedGrapeDisplay</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Combines GrapeDataDisplays to one so that visualisation for parallel grid is more easy to handle.  <a href="a00065.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00098.html">GrapeDataDisplay</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00099.html">GrapeGridDisplay</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html">OneDGrid</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">[<em> provides <a class="el" href="a00100.html">Dune::Grid</a> </em>] Onedimensional adaptive grid<p>
This implementation of the grid interface provides one-dimensional grids only. No matter what the values of dim and dimworld may be, you'll always get a 1D-grid in a 1D-world. Unlike <a class="el" href="a00262.html" title="[ provides Dune::Grid ]">SGrid</a>, however, which can also be instantiated in 1D, the <a class="el" href="a00224.html" title="[ provides Dune::Grid ] Onedimensional adaptive gridThis implementation of the grid...">OneDGrid</a> is nonuniform and provides local mesh refinement and coarsening.  <a href="a00224.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00212.html">LexOrder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">generate lexicographic ordering in a cube of dimension dim with arbitry size per direction  <a href="a00212.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html">JoinOrder</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">generate consecutive numbering of dim sets of size N_i  <a href="a00185.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00068.html">CubeMapper</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00260.html">SGeometry</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00261.html">SGeometry&lt; 0, cdim, GridImp &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">specialization for dim=0, this is a vertex  <a href="a00261.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00258.html">SEntityBase</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00255.html">SEntity</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00256.html">SEntity&lt; 0, dim, GridImp &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00257.html">SEntity&lt; dim, dim, GridImp &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00267.html">SHierarchicStackElem</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00273.html">SIntersectionIterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00259.html">SEntityPointer</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00275.html">SLevelIterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00265.html">SGridLevelIndexSetTypes</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">implementation of index set  <a href="a00265.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00263.html">SGridGlobalIdSet</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">persistent, globally unique Ids  <a href="a00263.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html">SGrid</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">[<em> provides <a class="el" href="a00100.html">Dune::Grid</a> </em>]  <a href="a00262.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00284.html">UGGrid</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">[<em> provides <a class="el" href="a00100.html">Dune::Grid</a> </em>]  <a href="a00284.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00142.html">HierarchicSearch</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Search an <a class="el" href="a00145.html" title="Index Set Interface base class.">IndexSet</a> for an <a class="el" href="a00082.html" title="Wrapper class for entities.">Entity</a> containing a given point.  <a href="a00142.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00210.html">LevelTag</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A tag to identify that we work on a level of a grid.  <a href="a00210.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html">LeafTag</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A tag to identify that we work on the leaf of a grid.  <a href="a00197.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html">IntersectionIteratorGetter</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Utility class to get the Intersection Iterator the right way.  <a href="a00156.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00308.html">YGrid</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00277.html">SubYGrid</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00280.html">Torus</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00219.html">MultiYGrid</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00307.html">YaspSpecialGeometry</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00295.html">YaspGeometry</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The general version implements dimworld==dimworld. If this is not the case an error is thrown.  <a href="a00295.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00297.html">YaspGeometry&lt; mydim, mydim, GridImp &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">specialize for dim=dimworld, i.e. a volume element  <a href="a00297.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00296.html">YaspGeometry&lt; 0, cdim, GridImp &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">specialization for dim=0, this is a vertex  <a href="a00296.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00306.html">YaspSpecialEntity</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00301.html">YaspIntersectionIterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00300.html">YaspHierarchicIterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00294.html">YaspEntityPointer</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00305.html">YaspLevelIterator</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00303.html">YaspLevelIndexSetTypes</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">level-wise, non-persistent, consecutive index  <a href="a00303.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00298.html">YaspGlobalIdSet</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">persistent, globally unique Ids  <a href="a00298.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00299.html">YaspGrid</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">[<em> provides <a class="el" href="a00100.html">Dune::Grid</a> </em>]  <a href="a00299.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00476.html">Capabilities</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Contains all capabilities classes. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00477.html">QuadratureType</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Defines an <code>enum</code> for currently available quadrature rules. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00478.html">RefinementImp</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This namespace contains the implementation of <a class="el" href="a00522.html">Refinement</a>. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00441.html#a2a12e0d35af55595a81465ce46c87cb">sgrid_ctype</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00441.html#d016d1f6fa9e1ff20aa2cb90b929b633">yaspgrid_ctype</a></td></tr>

<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00492.html#gbd89b77709db1d9e56bb17cd0aa44c3d">PartitionType</a> { <br>
&nbsp;&nbsp;<a class="el" href="a00492.html#ggbd89b77709db1d9e56bb17cd0aa44c3d1cdad324759fb0e56c7f035d91f7e4b8">InteriorEntity</a> = 0, 
<a class="el" href="a00492.html#ggbd89b77709db1d9e56bb17cd0aa44c3d5886f9fc2fac0eb986874fb2e682fb80">BorderEntity</a> = 1, 
<a class="el" href="a00492.html#ggbd89b77709db1d9e56bb17cd0aa44c3dec5e1e5ba1c055301aae842f46640850">OverlapEntity</a> = 2, 
<a class="el" href="a00492.html#ggbd89b77709db1d9e56bb17cd0aa44c3d0eb7fb9965359955e50690291d9f6d9a">FrontEntity</a> = 3, 
<br>
&nbsp;&nbsp;<a class="el" href="a00492.html#ggbd89b77709db1d9e56bb17cd0aa44c3d4db612fa448bc15ef7581235c17e17ea">GhostEntity</a> = 4
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attributes used in the generic overlap model.  <a href="a00492.html#gbd89b77709db1d9e56bb17cd0aa44c3d">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00492.html#ge799a4296824c1d4ae0d82e71287b722">InterfaceType</a> { <br>
&nbsp;&nbsp;<a class="el" href="a00492.html#gge799a4296824c1d4ae0d82e71287b7228b8e3364d9c34ed2e31f038479012f4f">InteriorBorder_InteriorBorder_Interface</a> = 0, 
<a class="el" href="a00492.html#gge799a4296824c1d4ae0d82e71287b72205cadca133ee23c967950c19bcbe4b85">InteriorBorder_All_Interface</a> = 1, 
<a class="el" href="a00492.html#gge799a4296824c1d4ae0d82e71287b72263cd8ac44d5a4cbb8cd1a4176e6b2965">Overlap_OverlapFront_Interface</a> = 2, 
<a class="el" href="a00492.html#gge799a4296824c1d4ae0d82e71287b72241fd52a5f00a85c7df011f9c532ed98f">Overlap_All_Interface</a> = 3, 
<br>
&nbsp;&nbsp;<a class="el" href="a00492.html#gge799a4296824c1d4ae0d82e71287b72222b151c5173503a7f39a3bd93ed6300d">All_All_Interface</a> = 4
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parameter to be used for the communication functions.  <a href="a00492.html#ge799a4296824c1d4ae0d82e71287b722">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00492.html#ga5b9e8102d7f70f3f4178182629d98b6">PartitionIteratorType</a> { <br>
&nbsp;&nbsp;<a class="el" href="a00492.html#gga5b9e8102d7f70f3f4178182629d98b6842081c435caefdae9580c93720e35b0">Interior_Partition</a> = 0, 
<a class="el" href="a00492.html#gga5b9e8102d7f70f3f4178182629d98b68da384ab42a2918b7cf88220328cff19">InteriorBorder_Partition</a> = 1, 
<a class="el" href="a00492.html#gga5b9e8102d7f70f3f4178182629d98b6906b14970777b3ed8927c95029f6158d">Overlap_Partition</a> = 2, 
<a class="el" href="a00492.html#gga5b9e8102d7f70f3f4178182629d98b65fc7e992b7cd9112ef84af4daa417a84">OverlapFront_Partition</a> = 3, 
<br>
&nbsp;&nbsp;<a class="el" href="a00492.html#gga5b9e8102d7f70f3f4178182629d98b63026c69cd558fe3687c11f45966905e9">All_Partition</a> = 4, 
<a class="el" href="a00492.html#gga5b9e8102d7f70f3f4178182629d98b690c5b1d5dc07ddecbf0fc09db7544216">Ghost_Partition</a> = 5
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parameter to be used for the parallel level- and leaf iterators.  <a href="a00492.html#ga5b9e8102d7f70f3f4178182629d98b6">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00492.html#gcf00ef51e7964e5797de12e1bdf8d755">CommunicationDirection</a> { <a class="el" href="a00492.html#ggcf00ef51e7964e5797de12e1bdf8d75516096429617fc1e0db063aa7d0539703">ForwardCommunication</a>, 
<a class="el" href="a00492.html#ggcf00ef51e7964e5797de12e1bdf8d755109be42b107eef1f3de8fdcf3df59dd0">BackwardCommunication</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Define a type for communication direction parameter.  <a href="a00492.html#gcf00ef51e7964e5797de12e1bdf8d755">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00441.html#dfd4a3dda10d26ca19c05a97a5f91950">GrapePartitionIteratorType</a> </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the internal grape partition iterator types <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00441.html#0b8ad089a7874a2a23c7f7fa5ed42e9b">GrapeIteratorType</a> </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the internal grape partition iterator types need to be these exact values to associate with combo button value. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00441.html#71ee5db4cda90b4be804e93e2de8363e">GrapeIOFileFormatType</a> { <a class="el" href="a00441.html#71ee5db4cda90b4be804e93e2de8363ed191f6d1136459d7f10ee3e0ad5ad825">ascii</a> =  0, 
<a class="el" href="a00441.html#71ee5db4cda90b4be804e93e2de8363e88a1167e77499efa37ce73e054707329">xdr</a> =  1
 }</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g93b58eeb427bbeafe9bd7d460a1603cc"></a><!-- doxytag: member="Dune::PartitionName" ref="g93b58eeb427bbeafe9bd7d460a1603cc" args="(PartitionType type)" -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00492.html#g93b58eeb427bbeafe9bd7d460a1603cc">PartitionName</a> (<a class="el" href="a00492.html#gbd89b77709db1d9e56bb17cd0aa44c3d">PartitionType</a> type)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provide names for the partition types. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gf73200fbf816ae9e68d34cbc8ecb4d08"></a><!-- doxytag: member="Dune::gridinfo" ref="gf73200fbf816ae9e68d34cbc8ecb4d08" args="(const G &amp;grid, std::string prefix=&quot;&quot;)" -->
template&lt;class G&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00490.html#gf73200fbf816ae9e68d34cbc8ecb4d08">gridinfo</a> (const G &amp;grid, std::string prefix=&quot;&quot;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A function to print some information about the grid as a whole. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g51a00c55773823eb1df74532c18435e2"></a><!-- doxytag: member="Dune::gridlevellist" ref="g51a00c55773823eb1df74532c18435e2" args="(const G &amp;grid, int level, std::string prefix)" -->
template&lt;class G&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00490.html#g51a00c55773823eb1df74532c18435e2">gridlevellist</a> (const G &amp;grid, int level, std::string prefix)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A function to print info about a grid level and its entities. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g5c63edfe5b8b70ae90668ce483756bfe"></a><!-- doxytag: member="Dune::gridleaflist" ref="g5c63edfe5b8b70ae90668ce483756bfe" args="(const G &amp;grid, std::string prefix)" -->
template&lt;class G&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00490.html#g5c63edfe5b8b70ae90668ce483756bfe">gridleaflist</a> (const G &amp;grid, std::string prefix)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A function to print info about a leaf grid and its entities. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class RT, int codim&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">FieldVector&lt; typename <br>
RT::CoordType, RT::d &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00441.html#b3c110fce1f0f08a1006725fb4371c07">mapGlobal</a> (const RT &amp;refElem, const FieldVector&lt; typename RT::CoordType, RT::d-codim &gt; &amp;l, int i, int cdim)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;int dimension, class CoordType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00286.html">VirtualRefinement</a>&lt; dimension, <br>
CoordType &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00441.html#483e48cec01d2ca2552b6004eafe7c2f">buildRefinement</a> (GeometryType geometryType, GeometryType coerceTo)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return a reference to the <a class="el" href="a00286.html" title="VirtualRefinement base class.">VirtualRefinement</a> according to the parameters  <a href="#483e48cec01d2ca2552b6004eafe7c2f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;int dimension, class CoordType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00286.html">VirtualRefinement</a>&lt; dimension, <br>
CoordType &gt; &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00441.html#2413bcae9eba606eae6a1d6b83f8ebba">buildRefinement</a> (GeometryType::BasicType geometryType, GeometryType::BasicType coerceTo)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return a reference to the <a class="el" href="a00286.html" title="VirtualRefinement base class.">VirtualRefinement</a> according to the parameters  <a href="#2413bcae9eba606eae6a1d6b83f8ebba"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a23322ff42a9a741363da73a2ba7d727"></a><!-- doxytag: member="Dune::convertToGrapeType" ref="a23322ff42a9a741363da73a2ba7d727" args="(GeometryType type, int dim)" -->
static GRAPE_ElementType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00441.html#a23322ff42a9a741363da73a2ba7d727">convertToGrapeType</a> (GeometryType type, int dim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">convert dune geometry types to grape geometry types with numbers <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="17177170e35ddaae6803156d040d4dde"></a><!-- doxytag: member="Dune::typeIdentifier" ref="17177170e35ddaae6803156d040d4dde" args="()" -->
template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">GrapeIOStringType&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00441.html#17177170e35ddaae6803156d040d4dde">typeIdentifier</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">convert type to string <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="f3a75cb4bc5c775f660d41e7a42be433"></a><!-- doxytag: member="Dune::operator&lt;&lt;" ref="f3a75cb4bc5c775f660d41e7a42be433" args="(std::ostream &amp;s, YGrid&lt; d, ct &gt; e)" -->
template&lt;int d, typename ct&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00441.html#f3a75cb4bc5c775f660d41e7a42be433">operator&lt;&lt;</a> (std::ostream &amp;s, <a class="el" href="a00308.html">YGrid</a>&lt; d, ct &gt; e)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output operator for grids. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="d7005816fb87d6ad2f3b04a5996262d0"></a><!-- doxytag: member="Dune::operator&lt;&lt;" ref="d7005816fb87d6ad2f3b04a5996262d0" args="(std::ostream &amp;s, typename YGrid&lt; d, ct &gt;::Iterator &amp;e)" -->
template&lt;int d, typename ct&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00441.html#d7005816fb87d6ad2f3b04a5996262d0">operator&lt;&lt;</a> (std::ostream &amp;s, typename <a class="el" href="a00308.html">YGrid</a>&lt; d, ct &gt;::Iterator &amp;e)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output operator for Iterators. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="817ffe0aeb2d5dffc56c7142967f4ead"></a><!-- doxytag: member="Dune::operator&lt;&lt;" ref="817ffe0aeb2d5dffc56c7142967f4ead" args="(std::ostream &amp;s, SubYGrid&lt; d, ct &gt; e)" -->
template&lt;int d, typename ct&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00441.html#817ffe0aeb2d5dffc56c7142967f4ead">operator&lt;&lt;</a> (std::ostream &amp;s, <a class="el" href="a00277.html">SubYGrid</a>&lt; d, ct &gt; e)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output operator for subgrids. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="0c1ecc11cba07b527df174ef18530aaa"></a><!-- doxytag: member="Dune::operator&lt;&lt;" ref="0c1ecc11cba07b527df174ef18530aaa" args="(std::ostream &amp;s, typename SubYGrid&lt; d, ct &gt;::TransformingSubIterator &amp;e)" -->
template&lt;int d, typename ct&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00441.html#0c1ecc11cba07b527df174ef18530aaa">operator&lt;&lt;</a> (std::ostream &amp;s, typename <a class="el" href="a00277.html">SubYGrid</a>&lt; d, ct &gt;::TransformingSubIterator &amp;e)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output operator for subgrids. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="a780c9d679729ac736ec2151398ddda0"></a><!-- doxytag: member="Dune::operator&lt;&lt;" ref="a780c9d679729ac736ec2151398ddda0" args="(std::ostream &amp;s, const Torus&lt; d &gt; &amp;t)" -->
template&lt;int d&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00441.html#a780c9d679729ac736ec2151398ddda0">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="a00280.html">Torus</a>&lt; d &gt; &amp;t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output operator for <a class="el" href="a00280.html">Torus</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="7d611caf63221ff20b78384857a4c893"></a><!-- doxytag: member="Dune::operator&lt;&lt;" ref="7d611caf63221ff20b78384857a4c893" args="(std::ostream &amp;s, MultiYGrid&lt; d, ct &gt; &amp;mg)" -->
template&lt;int d, class ct&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00441.html#7d611caf63221ff20b78384857a4c893">operator&lt;&lt;</a> (std::ostream &amp;s, <a class="el" href="a00219.html">MultiYGrid</a>&lt; d, ct &gt; &amp;mg)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output operator for multigrids. <br></td></tr>
</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="a2a12e0d35af55595a81465ce46c87cb"></a><!-- doxytag: member="Dune::sgrid_ctype" ref="a2a12e0d35af55595a81465ce46c87cb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double <a class="el" href="a00441.html#a2a12e0d35af55595a81465ce46c87cb">Dune::sgrid_ctype</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
define name for floating point type used for coordinates in sgrid. You can change the type for coordinates by changing this single typedef. 
</div>
</div><p>
<a class="anchor" name="d016d1f6fa9e1ff20aa2cb90b929b633"></a><!-- doxytag: member="Dune::yaspgrid_ctype" ref="d016d1f6fa9e1ff20aa2cb90b929b633" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double <a class="el" href="a00441.html#d016d1f6fa9e1ff20aa2cb90b929b633">Dune::yaspgrid_ctype</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
define name for floating point type used for coordinates in yaspgrid. You can change the type for coordinates by changing this single typedef. 
</div>
</div><p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="71ee5db4cda90b4be804e93e2de8363e"></a><!-- doxytag: member="Dune::GrapeIOFileFormatType" ref="71ee5db4cda90b4be804e93e2de8363e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00441.html#71ee5db4cda90b4be804e93e2de8363e">Dune::GrapeIOFileFormatType</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Specify the format to store grid and vector data <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="71ee5db4cda90b4be804e93e2de8363ed191f6d1136459d7f10ee3e0ad5ad825"></a><!-- doxytag: member="ascii" ref="71ee5db4cda90b4be804e93e2de8363ed191f6d1136459d7f10ee3e0ad5ad825" args="" -->ascii</em>&nbsp;</td><td>
store data in a human readable form </td></tr>
<tr><td valign="top"><em><a class="anchor" name="71ee5db4cda90b4be804e93e2de8363e88a1167e77499efa37ce73e054707329"></a><!-- doxytag: member="xdr" ref="71ee5db4cda90b4be804e93e2de8363e88a1167e77499efa37ce73e054707329" args="" -->xdr</em>&nbsp;</td><td>
store data in SUN's library routines for external data representation (xdr) </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="2413bcae9eba606eae6a1d6b83f8ebba"></a><!-- doxytag: member="Dune::buildRefinement" ref="2413bcae9eba606eae6a1d6b83f8ebba" args="(GeometryType::BasicType geometryType, GeometryType::BasicType coerceTo)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension, class CoordType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00286.html">VirtualRefinement</a>&lt;dimension, CoordType&gt;&amp; Dune::buildRefinement           </td>
          <td>(</td>
          <td class="paramtype">GeometryType::BasicType&nbsp;</td>
          <td class="paramname"> <em>geometryType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GeometryType::BasicType&nbsp;</td>
          <td class="paramname"> <em>coerceTo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
return a reference to the <a class="el" href="a00286.html" title="VirtualRefinement base class.">VirtualRefinement</a> according to the parameters 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dimension</em>&nbsp;</td><td>Dimension of the element to refine </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CoordType</em>&nbsp;</td><td>C++ type of the coordinates</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NotImplemented</em>&nbsp;</td><td>There is no <a class="el" href="a00250.html" title="Wrap each Refinement implementation to get a consistent interface.">Refinement</a> implementation for the specified parameters. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>geometryType</em>&nbsp;</td><td>
geometry type of the refined element </td></tr>
<tr><td valign="top"><em>coerceTo</em>&nbsp;</td><td>
geometry type of the subelements </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="483e48cec01d2ca2552b6004eafe7c2f"></a><!-- doxytag: member="Dune::buildRefinement" ref="483e48cec01d2ca2552b6004eafe7c2f" args="(GeometryType geometryType, GeometryType coerceTo)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension, class CoordType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00286.html">VirtualRefinement</a>&lt; dimension, CoordType &gt; &amp; Dune::buildRefinement           </td>
          <td>(</td>
          <td class="paramtype">GeometryType&nbsp;</td>
          <td class="paramname"> <em>geometryType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GeometryType&nbsp;</td>
          <td class="paramname"> <em>coerceTo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
return a reference to the <a class="el" href="a00286.html" title="VirtualRefinement base class.">VirtualRefinement</a> according to the parameters 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dimension</em>&nbsp;</td><td>Dimension of the element to refine </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CoordType</em>&nbsp;</td><td>C++ type of the coordinates</td></tr>
  </table>
</dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NotImplemented</em>&nbsp;</td><td>There is no <a class="el" href="a00250.html" title="Wrap each Refinement implementation to get a consistent interface.">Refinement</a> implementation for the specified parameters. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em>geometryType</em>&nbsp;</td><td>
geometry type of the refined element </td></tr>
<tr><td valign="top"><em>coerceTo</em>&nbsp;</td><td>
geometry type of the subelements </td></tr>
</table>
</dl>
</div>
</div><p>
<a class="anchor" name="b3c110fce1f0f08a1006725fb4371c07"></a><!-- doxytag: member="Dune::mapGlobal" ref="b3c110fce1f0f08a1006725fb4371c07" args="(const RT &amp;refElem, const FieldVector&lt; typename RT::CoordType, RT::d-codim &gt; &amp;l, int i, int cdim)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RT, int codim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">FieldVector&lt;typename RT::CoordType, RT::d&gt; Dune::@74::mapGlobal           </td>
          <td>(</td>
          <td class="paramtype">const RT &amp;&nbsp;</td>
          <td class="paramname"> <em>refElem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FieldVector&lt; typename RT::CoordType, RT::d-codim &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>cdim</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000023">Todo:</a></b></dt><dd>Please doc me! </dd></dl>

</div>
</div><p>
</div>
</div> <!-- end doxygen -->
</div> <!-- end main -->
<div class="foot">

<p class="foot">
  Generated on 6 Nov 2008 with <a
  href="http://www.doxygen.org/">Doxygen</a> (ver 1.5.6)  
  [<a href="doxygen.log">logfile</a>].
</p>

</div>

</body>
</html>
