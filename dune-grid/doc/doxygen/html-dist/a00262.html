<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN""http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>dune-grid: Dune::SGrid&lt; dim, dimworld &gt; Class Template Reference (dune-grid )</title>
  <link rel="stylesheet" type="text/css" href="./dune-doxy.css">
  <link rel="stylesheet" type="text/css" href="./tabs.css">
</head>
<div class="main">
<div class="doxygen">
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="a00441.html">Dune</a>::<a class="el" href="a00262.html">SGrid</a>
  </div>
</div>
<div class="contents">
<h1>Dune::SGrid&lt; dim, dimworld &gt; Class Template Reference<br>
<small>
[<a class="el" href="a00504.html">Grid Implementations</a>]</small>
</h1><!-- doxytag: class="Dune::SGrid" --><!-- doxytag: inherits="Dune::GridDefaultImplementation" --><code>#include &lt;<a class="el" href="a00664.html">sgrid.hh</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for Dune::SGrid&lt; dim, dimworld &gt;:</div>
<div class="dynsection">

<p><center><img src="a00262.png" usemap="#Dune::SGrid< dim, dimworld >_map" border="0" alt=""></center>
<map name="Dune::SGrid< dim, dimworld >_map">
<area href="a00103.html" alt="Dune::GridDefaultImplementation< dim, dimworld, ct, GridFamily >" shape="rect" coords="0,56,559,80">
<area href="a00100.html" alt="Dune::Grid< dim, dimworld, ct, GridFamily >" shape="rect" coords="0,0,559,24">
</map>
</div>

<p>
<a href="a00891.html">List of all members.</a><hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;int dim, int dimworld&gt;<br>
 class Dune::SGrid&lt; dim, dimworld &gt;</h3>

[<em> provides <a class="el" href="a00100.html">Dune::Grid</a> </em>] 
<p>
A structured mesh in d dimensions consisting of "cubes" (pilot implementation of the Dune grid interface, for debugging only).<p>
This module describes the pilot implementation of the Dune grid interface. It implements the grid interface for simple structured meshes. <dl class="warning" compact><dt><b>Warning:</b></dt><dd><a class="el" href="a00262.html" title="[ provides Dune::Grid ]">SGrid</a> is slow. It is intended for debugging only.</dd></dl>
The following class diagram shows how the classes are related with each other:<p>
<div align="center">
<img src="sgridclasses.png" alt="sgridclasses.png">
<p><strong>Class diagram for classes in the grid interface</strong></p></div>
 <p>
Short description of the classes:<p>
<ul>
<li><a class="el" href="a00260.html">SGeometry</a> is a class template providing the geometric part of a grid entity, i.e. a general polyhedron with a mapping from a reference polyhedron to the actual polyhedron.</li></ul>
<p>
<ul>
<li><a class="el" href="a00275.html">SLevelIterator</a> is a class template which allows to iterate over all grid entities of a given codimension and level.</li></ul>
<p>
<ul>
<li><a class="el" href="a00255.html">SEntity</a> is a class template realizing the grid entities. <a class="el" href="a00100.html" title="Grid abstract base classThis class is the base class for all grid implementations...">Grid</a> entities are the constituents of a grid. <a class="el" href="a00100.html" title="Grid abstract base classThis class is the base class for all grid implementations...">Grid</a> entities of codimension 0 and codimension dim are defines through specialization. Entities can be used as template parameters to generic algorithms. Each entity must therefore provide the nested classes <a class="el" href="a00094.html" title="Wrapper class for geometries.">Geometry</a>, <a class="el" href="a00206.html" title="Enables iteration over all entities of a given codimension and level of a grid. See...">LevelIterator</a>, <a class="el" href="a00140.html" title="Enables iteration over all codim zero entities in a subtree See also the documentation...">HierarchicIterator</a> and <a class="el" href="a00154.html" title="Mesh entities of codimension 0 (&quot;elements&quot;) allow to visit all intersections...">IntersectionIterator</a>. <a class="el" href="a00094.html" title="Wrapper class for geometries.">Geometry</a> and <a class="el" href="a00206.html" title="Enables iteration over all entities of a given codimension and level of a grid. See...">LevelIterator</a> are derived from the classes SELement and <a class="el" href="a00275.html">SLevelIterator</a>. Note that entities of codimension 0 and dim have an extended interface.</li></ul>
<p>
<ul>
<li>SEntity::IntersectionIterator provides access to all entities of codimension 0 sharing an object of codimension 1 with the given entity of codimension 0. This interface covers nonmatching grids.</li></ul>
<p>
<ul>
<li>SEntity::HierarchicIterator provides access to the sons of an entity of codimension 0.</li></ul>
<p>
<ul>
<li><a class="el" href="a00262.html" title="[ provides Dune::Grid ]">SGrid</a> is conceptualized as a container of grid entities of various codimensions. Since grids are used as template parameters to generic algorithms they must include the nested classes <a class="el" href="a00206.html" title="Enables iteration over all entities of a given codimension and level of a grid. See...">LevelIterator</a> and <a class="el" href="a00082.html" title="Wrapper class for entities.">Entity</a> which are derived from <a class="el" href="a00275.html">SLevelIterator</a> and <a class="el" href="a00255.html">SEntity</a>.</li></ul>
<p>
A <a class="el" href="a00100.html" title="Grid abstract base classThis class is the base class for all grid implementations...">Grid</a> is a container of grid entities. Given a dimension dim these entities have a codimension codim with 0 &lt;= codim &lt;= dim.<p>
The <a class="el" href="a00100.html" title="Grid abstract base classThis class is the base class for all grid implementations...">Grid</a> is assumed to be hierachically refined and nested. It enables iteration over entities of a given level and codimension.<p>
All information is provided to allocate degrees of freedom in appropriate vector data structures.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>When <a class="el" href="a00262.html" title="[ provides Dune::Grid ]">SGrid</a> is instantiated with dimworld strictly greater than dim, the result is a dim-dimensional structured grid which is embedded in the first dim components of dimworld-dimensional Euclidean space. </dd></dl>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">maximum number of levels allowed <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7414c2a8a4f06d4c46a12c425ddc7833"></a><!-- doxytag: member="Dune::SGrid::Traits" ref="7414c2a8a4f06d4c46a12c425ddc7833" args="" -->
typedef SGridFamily&lt; dim, <br>
dimworld &gt;::<a class="el" href="a00262.html#7414c2a8a4f06d4c46a12c425ddc7833">Traits</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#7414c2a8a4f06d4c46a12c425ddc7833">Traits</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">the traits of this class <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4c7cfa5e8d72cd584891deb39c8e1b87"></a><!-- doxytag: member="Dune::SGrid::ctype" ref="4c7cfa5e8d72cd584891deb39c8e1b87" args="" -->
typedef <a class="el" href="a00441.html#a2a12e0d35af55595a81465ce46c87cb">sgrid_ctype</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#4c7cfa5e8d72cd584891deb39c8e1b87">ctype</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">define type used for coordinates in grid module <br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Exported constants</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="a00100.html#9cd7ecb5cc83c871fe433e8e99b8baa93d6a22a414566af9b4a356f760fce944">dimension</a> = dim
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A constant that exports the template parameter dim.  <a href="a00100.html#9cd7ecb5cc83c871fe433e8e99b8baa9">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="a00100.html#f25e01e5971721e1d01123ccc93831ab7829985ca62f22ec6c57c5feba1e0604">dimensionworld</a> = dimworld
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A constant that exports the template parameter dimworld.  <a href="a00100.html#f25e01e5971721e1d01123ccc93831ab">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1d1c6c5f6e638da1f0ff47a309902641"></a><!-- doxytag: member="Dune::SGrid::name" ref="1d1c6c5f6e638da1f0ff47a309902641" args="() const " -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#1d1c6c5f6e638da1f0ff47a309902641">name</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return the name of this grid <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#0657f6f269a22d3b8a85ffc035b49fd3">SGrid</a> (const int *N_, const <a class="el" href="a00441.html#a2a12e0d35af55595a81465ce46c87cb">sgrid_ctype</a> *H_)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make an <a class="el" href="a00262.html" title="[ provides Dune::Grid ]">SGrid</a> from extend and number of cells per direction.  <a href="#0657f6f269a22d3b8a85ffc035b49fd3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#b5c12f45ed36919bd5c78c696e695682">SGrid</a> (const int *N_, const <a class="el" href="a00441.html#a2a12e0d35af55595a81465ce46c87cb">sgrid_ctype</a> *L_, const <a class="el" href="a00441.html#a2a12e0d35af55595a81465ce46c87cb">sgrid_ctype</a> *H_)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make an <a class="el" href="a00262.html" title="[ provides Dune::Grid ]">SGrid</a> from position, extend and number of cells per direction.  <a href="#b5c12f45ed36919bd5c78c696e695682"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#a42cb51ded4e2b2c72191e4267fb82b9">SGrid</a> (FieldVector&lt; int, dim &gt; N_, FieldVector&lt; <a class="el" href="a00441.html#a2a12e0d35af55595a81465ce46c87cb">sgrid_ctype</a>, dim &gt; L_, FieldVector&lt; <a class="el" href="a00441.html#a2a12e0d35af55595a81465ce46c87cb">sgrid_ctype</a>, dim &gt; H_)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Make an <a class="el" href="a00262.html" title="[ provides Dune::Grid ]">SGrid</a> from position, extend and number of cells per direction.  <a href="#a42cb51ded4e2b2c72191e4267fb82b9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d02a4882a9e3949b68c800ac32f2ffc0"></a><!-- doxytag: member="Dune::SGrid::SGrid" ref="d02a4882a9e3949b68c800ac32f2ffc0" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#d02a4882a9e3949b68c800ac32f2ffc0">SGrid</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">empty constructor making grid of unit square discretized with one cell <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="aa8a4ceb9e4efad33500deae4abc77c6"></a><!-- doxytag: member="Dune::SGrid::~SGrid" ref="aa8a4ceb9e4efad33500deae4abc77c6" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#aa8a4ceb9e4efad33500deae4abc77c6">~SGrid</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="a00262.html" title="[ provides Dune::Grid ]">SGrid</a> destructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#e61127c663cd9f11095fd26ee223077b">maxLevel</a> () const </td></tr>

<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="f8d5629bc7ded11d267c3955b2ae2db7"></a><!-- doxytag: member="Dune::SGrid::lbegin" ref="f8d5629bc7ded11d267c3955b2ae2db7" args="(int level) const " -->
template&lt;int cd, PartitionIteratorType pitype&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Traits::template <a class="el" href="a00101.html">Codim</a>&lt; cd &gt;<br>
::template Partition&lt; pitype &gt;<br>
::<a class="el" href="a00206.html">LevelIterator</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00262.html#f8d5629bc7ded11d267c3955b2ae2db7">lbegin</a> (int level) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator to first entity of given codim on level. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="d1f789d30d8e1c77a44eb2efd83f0a42"></a><!-- doxytag: member="Dune::SGrid::lend" ref="d1f789d30d8e1c77a44eb2efd83f0a42" args="(int level) const " -->
template&lt;int cd, PartitionIteratorType pitype&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Traits::template <a class="el" href="a00101.html">Codim</a>&lt; cd &gt;<br>
::template Partition&lt; pitype &gt;<br>
::<a class="el" href="a00206.html">LevelIterator</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00262.html#d1f789d30d8e1c77a44eb2efd83f0a42">lend</a> (int level) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">one past the end on this level <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="af9ba310ab8d57779f6a340d5496e5df"></a><!-- doxytag: member="Dune::SGrid::lbegin" ref="af9ba310ab8d57779f6a340d5496e5df" args="(int level) const " -->
template&lt;int cd&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Traits::template <a class="el" href="a00101.html">Codim</a>&lt; cd &gt;<br>
::template Partition<br>
&lt; All_Partition &gt;<br>
::<a class="el" href="a00206.html">LevelIterator</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00262.html#af9ba310ab8d57779f6a340d5496e5df">lbegin</a> (int level) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator to first entity of given codim on level. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="37ee4c31a72b454cae2e99538e91770b"></a><!-- doxytag: member="Dune::SGrid::lend" ref="37ee4c31a72b454cae2e99538e91770b" args="(int level) const " -->
template&lt;int cd&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Traits::template <a class="el" href="a00101.html">Codim</a>&lt; cd &gt;<br>
::template Partition<br>
&lt; All_Partition &gt;<br>
::<a class="el" href="a00206.html">LevelIterator</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00262.html#37ee4c31a72b454cae2e99538e91770b">lend</a> (int level) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">one past the end on this level <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="0c9d6ee01dce74c89a6a9cac39c5566d"></a><!-- doxytag: member="Dune::SGrid::leafbegin" ref="0c9d6ee01dce74c89a6a9cac39c5566d" args="() const " -->
template&lt;int cd, PartitionIteratorType pitype&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Traits::template <a class="el" href="a00101.html">Codim</a>&lt; cd &gt;<br>
::template Partition&lt; pitype &gt;<br>
::<a class="el" href="a00193.html">LeafIterator</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00262.html#0c9d6ee01dce74c89a6a9cac39c5566d">leafbegin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return <a class="el" href="a00193.html" title="Enables iteration over all leaf entities of a codimension zero of a grid. See also...">LeafIterator</a> which points to the first entity <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="bf0a7a4ecd1730ac5251de2d28e436ca"></a><!-- doxytag: member="Dune::SGrid::leafend" ref="bf0a7a4ecd1730ac5251de2d28e436ca" args="() const " -->
template&lt;int cd, PartitionIteratorType pitype&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Traits::template <a class="el" href="a00101.html">Codim</a>&lt; cd &gt;<br>
::template Partition&lt; pitype &gt;<br>
::<a class="el" href="a00193.html">LeafIterator</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00262.html#bf0a7a4ecd1730ac5251de2d28e436ca">leafend</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">one past the end on the leaf level <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="90f8c640551443bd4d1d5c5c17649fca"></a><!-- doxytag: member="Dune::SGrid::leafbegin" ref="90f8c640551443bd4d1d5c5c17649fca" args="() const " -->
template&lt;int cd&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Traits::template <a class="el" href="a00101.html">Codim</a>&lt; cd &gt;<br>
::template Partition<br>
&lt; All_Partition &gt;<br>
::<a class="el" href="a00193.html">LeafIterator</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00262.html#90f8c640551443bd4d1d5c5c17649fca">leafbegin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return <a class="el" href="a00193.html" title="Enables iteration over all leaf entities of a codimension zero of a grid. See also...">LeafIterator</a> which points to the first entity <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="310f82090374df6225973358f9f2c422"></a><!-- doxytag: member="Dune::SGrid::leafend" ref="310f82090374df6225973358f9f2c422" args="() const " -->
template&lt;int cd&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Traits::template <a class="el" href="a00101.html">Codim</a>&lt; cd &gt;<br>
::template Partition<br>
&lt; All_Partition &gt;<br>
::<a class="el" href="a00193.html">LeafIterator</a>&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00262.html#310f82090374df6225973358f9f2c422">leafend</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return <a class="el" href="a00193.html" title="Enables iteration over all leaf entities of a codimension zero of a grid. See also...">LeafIterator</a> which points behind the last entity <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T, template&lt; class &gt; class P, int codim&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00262.html#5ee7c0d2139dc418017b6e08b5d30447">communicate</a> (T &amp;t, <a class="el" href="a00492.html#ge799a4296824c1d4ae0d82e71287b722">InterfaceType</a> iftype, <a class="el" href="a00492.html#gcf00ef51e7964e5797de12e1bdf8d755">CommunicationDirection</a> dir, int level)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b471bbb3bd2d6c793def4e26ba6c8489"></a><!-- doxytag: member="Dune::SGrid::size" ref="b471bbb3bd2d6c793def4e26ba6c8489" args="(int level, int codim) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#b471bbb3bd2d6c793def4e26ba6c8489">size</a> (int level, int codim) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">number of grid entities per level and codim <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c74a40fdf3fbf5bd189333c294dac4cb"></a><!-- doxytag: member="Dune::SGrid::size" ref="c74a40fdf3fbf5bd189333c294dac4cb" args="(int codim) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#c74a40fdf3fbf5bd189333c294dac4cb">size</a> (int codim) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">number of leaf entities per codim in this process <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ea5f12a1619fcbbfb42b2decc7476731"></a><!-- doxytag: member="Dune::SGrid::size" ref="ea5f12a1619fcbbfb42b2decc7476731" args="(int level, GeometryType type) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#ea5f12a1619fcbbfb42b2decc7476731">size</a> (int level, GeometryType type) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">number of entities per level and geometry type in this process <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="524247b4f2d2c1fdfc70df6734a52e5c"></a><!-- doxytag: member="Dune::SGrid::size" ref="524247b4f2d2c1fdfc70df6734a52e5c" args="(GeometryType type) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#524247b4f2d2c1fdfc70df6734a52e5c">size</a> (GeometryType type) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">number of leaf entities per codim and geometry type in this process <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="65781a6e55e6cefc1651fc1a3397de93"></a><!-- doxytag: member="Dune::SGrid::global_size" ref="65781a6e55e6cefc1651fc1a3397de93" args="(int codim) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#65781a6e55e6cefc1651fc1a3397de93">global_size</a> (int codim) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">number of grid entities of all level for given codim <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4455c2eb696f6577601eebd46af90888"></a><!-- doxytag: member="Dune::SGrid::overlapSize" ref="4455c2eb696f6577601eebd46af90888" args="(int level, int codim)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#4455c2eb696f6577601eebd46af90888">overlapSize</a> (int level, int codim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return size (= distance in graph) of overlap region <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2aab8f2fcf5e30944d7050805fd96887"></a><!-- doxytag: member="Dune::SGrid::ghostSize" ref="2aab8f2fcf5e30944d7050805fd96887" args="(int level, int codim)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#2aab8f2fcf5e30944d7050805fd96887">ghostSize</a> (int level, int codim)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return size (= distance in graph) of ghost region <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a53fee70fbcbf6bbec0c7273e41a258a"></a><!-- doxytag: member="Dune::SGrid::globalRefine" ref="a53fee70fbcbf6bbec0c7273e41a258a" args="(int refCount)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#a53fee70fbcbf6bbec0c7273e41a258a">globalRefine</a> (int refCount)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Refine mesh globally by one refCount levels. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ae765d9b921a478069cb701f6e60565a"></a><!-- doxytag: member="Dune::SGrid::dims" ref="ae765d9b921a478069cb701f6e60565a" args="(int level) const " -->
const array&lt; int, dim &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#ae765d9b921a478069cb701f6e60565a">dims</a> (int level) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get number of elements in each coordinate direction. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f2e1f31e82f2c5b4913d69adaf186ca3"></a><!-- doxytag: member="Dune::SGrid::lowerLeft" ref="f2e1f31e82f2c5b4913d69adaf186ca3" args="() const " -->
const FieldVector&lt; <a class="el" href="a00441.html#a2a12e0d35af55595a81465ce46c87cb">sgrid_ctype</a>, <br>
dimworld &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#f2e1f31e82f2c5b4913d69adaf186ca3">lowerLeft</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get lower left corner. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="971cf9bb7500b69648ad74ed3a142bee"></a><!-- doxytag: member="Dune::SGrid::upperRight" ref="971cf9bb7500b69648ad74ed3a142bee" args="() const " -->
FieldVector&lt; <a class="el" href="a00441.html#a2a12e0d35af55595a81465ce46c87cb">sgrid_ctype</a>, <br>
dimworld &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#971cf9bb7500b69648ad74ed3a142bee">upperRight</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get upper right corner. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="27bd3499f4146ac296aad0e9b99d6a98"></a><!-- doxytag: member="Dune::SGrid::adapt" ref="27bd3499f4146ac296aad0e9b99d6a98" args="()" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#27bd3499f4146ac296aad0e9b99d6a98">adapt</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">map adapt to global refine <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="956398d1231a50f46c6356d9d75d0a33"></a><!-- doxytag: member="Dune::SGrid::pos" ref="956398d1231a50f46c6356d9d75d0a33" args="(int level, array&lt; int, dim &gt; &amp;z) const " -->
FieldVector&lt; <a class="el" href="a00441.html#a2a12e0d35af55595a81465ce46c87cb">sgrid_ctype</a>, <br>
dimworld &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#956398d1231a50f46c6356d9d75d0a33">pos</a> (int level, array&lt; int, dim &gt; &amp;z) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">map expanded coordinates to position <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b50823eb64536ee11dff5edcab325df8"></a><!-- doxytag: member="Dune::SGrid::calc_codim" ref="b50823eb64536ee11dff5edcab325df8" args="(int level, const array&lt; int, dim &gt; &amp;z) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#b50823eb64536ee11dff5edcab325df8">calc_codim</a> (int level, const array&lt; int, dim &gt; &amp;z) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute codim from coordinate <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="998424fabafee0278e6d7cc06dcba387"></a><!-- doxytag: member="Dune::SGrid::n" ref="998424fabafee0278e6d7cc06dcba387" args="(int level, const array&lt; int, dim &gt; &amp;z) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#998424fabafee0278e6d7cc06dcba387">n</a> (int level, const array&lt; int, dim &gt; &amp;z) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute number from expanded coordinate <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7290fe61ae226357724d02ba28f4c12a"></a><!-- doxytag: member="Dune::SGrid::z" ref="7290fe61ae226357724d02ba28f4c12a" args="(int level, int i, int codim) const " -->
array&lt; int, dim &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#7290fe61ae226357724d02ba28f4c12a">z</a> (int level, int i, int codim) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compute coordinates from number and codimension <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ce350b7457dd848bb929017ee137cc1c"></a><!-- doxytag: member="Dune::SGrid::compress" ref="ce350b7457dd848bb929017ee137cc1c" args="(int level, const array&lt; int, dim &gt; &amp;z) const " -->
array&lt; int, dim &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#ce350b7457dd848bb929017ee137cc1c">compress</a> (int level, const array&lt; int, dim &gt; &amp;z) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">compress from expanded coordinates to grid for a single partition number <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0e1a99564f869a758db090ac6cabbb96"></a><!-- doxytag: member="Dune::SGrid::expand" ref="0e1a99564f869a758db090ac6cabbb96" args="(int level, const array&lt; int, dim &gt; &amp;r, int b) const " -->
array&lt; int, dim &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#0e1a99564f869a758db090ac6cabbb96">expand</a> (int level, const array&lt; int, dim &gt; &amp;r, int b) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">expand with respect to partition number <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#b9aec678a379ed652a9c1a4938e076a6">partition</a> (int level, const array&lt; int, dim &gt; &amp;z) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="288bb6ea170b4f7a457c06ac77c43c92"></a><!-- doxytag: member="Dune::SGrid::exists" ref="288bb6ea170b4f7a457c06ac77c43c92" args="(int level, const array&lt; int, dim &gt; &amp;zred) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#288bb6ea170b4f7a457c06ac77c43c92">exists</a> (int level, const array&lt; int, dim &gt; &amp;zred) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">given reduced coordinates of an element, determine if element is in the grid <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b96a835d70c68d4fa5fe87bbbd0db830"></a><!-- doxytag: member="Dune::SGrid::globalIdSet" ref="b96a835d70c68d4fa5fe87bbbd0db830" args="() const " -->
const Traits::GlobalIdSet &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#b96a835d70c68d4fa5fe87bbbd0db830">globalIdSet</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return const reference to the grids global id set <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6ed399586276e647d0be6cfe8961ba85"></a><!-- doxytag: member="Dune::SGrid::localIdSet" ref="6ed399586276e647d0be6cfe8961ba85" args="() const " -->
const Traits::LocalIdSet &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#6ed399586276e647d0be6cfe8961ba85">localIdSet</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return const reference to the grids local id set <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0e16d410596933de4e7274254a38de5a"></a><!-- doxytag: member="Dune::SGrid::levelIndexSet" ref="0e16d410596933de4e7274254a38de5a" args="(int level) const " -->
const Traits::LevelIndexSet &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#0e16d410596933de4e7274254a38de5a">levelIndexSet</a> (int level) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return const reference to the grids level index set for level level <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9ab4c040c9ca5e9d84a1412162aace6d"></a><!-- doxytag: member="Dune::SGrid::leafIndexSet" ref="9ab4c040c9ca5e9d84a1412162aace6d" args="() const " -->
const Traits::LeafIndexSet &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#9ab4c040c9ca5e9d84a1412162aace6d">leafIndexSet</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return const reference to the grids leaf index set <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b0729b6115d37a5a3a5fcbf1e651df57"></a><!-- doxytag: member="Dune::SGrid::comm" ref="b0729b6115d37a5a3a5fcbf1e651df57" args="() const " -->
const CollectiveCommunication<br>
&lt; <a class="el" href="a00262.html">SGrid</a> &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#b0729b6115d37a5a3a5fcbf1e651df57">comm</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return const reference to a collective communication object. The return type is a model of Dune::CollectiveCommunication. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e54fbeda3ff1711464c3de41a5cd1bf2"></a><!-- doxytag: member="Dune::SGrid::overlapSize" ref="e54fbeda3ff1711464c3de41a5cd1bf2" args="(int level, int codim) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#e54fbeda3ff1711464c3de41a5cd1bf2">overlapSize</a> (int level, int codim) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return size (= distance in graph) of overlap region <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1a9bbe074dfd392531caf635969c6e8f"></a><!-- doxytag: member="Dune::SGrid::overlapSize" ref="1a9bbe074dfd392531caf635969c6e8f" args="(int codim) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#1a9bbe074dfd392531caf635969c6e8f">overlapSize</a> (int codim) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return size (= distance in graph) of overlap region <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e05a1decd8fa872008f87d6ac6614826"></a><!-- doxytag: member="Dune::SGrid::ghostSize" ref="e05a1decd8fa872008f87d6ac6614826" args="(int level, int codim) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#e05a1decd8fa872008f87d6ac6614826">ghostSize</a> (int level, int codim) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return size (= distance in graph) of ghost region <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cbe71d640d152ff5cae7687117ede5ce"></a><!-- doxytag: member="Dune::SGrid::ghostSize" ref="cbe71d640d152ff5cae7687117ede5ce" args="(int codim) const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00262.html#cbe71d640d152ff5cae7687117ede5ce">ghostSize</a> (int codim) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return size (= distance in graph) of ghost region <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#30d76de1e9ddbff5cdb8337b1ce49955">mark</a> (int refCount, const typename Traits::template <a class="el" href="a00101.html">Codim</a>&lt; 0 &gt;::<a class="el" href="a00087.html">EntityPointer</a> &amp;e)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marks an entity to be refined/coarsened in a subsequent adapt.  <a href="#30d76de1e9ddbff5cdb8337b1ce49955"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#378ce24a2bfacfc0e23699423d261fc9">getMark</a> (const typename Traits::template <a class="el" href="a00101.html">Codim</a>&lt; 0 &gt;::<a class="el" href="a00087.html">EntityPointer</a> &amp;) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns adaptation mark for given entity, i.e. here the default implementation returns 0.  <a href="#378ce24a2bfacfc0e23699423d261fc9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9e0b327f80724af8973e96bfe0529789"></a><!-- doxytag: member="Dune::SGrid::preAdapt" ref="9e0b327f80724af8973e96bfe0529789" args="()" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#9e0b327f80724af8973e96bfe0529789">preAdapt</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns true, if at least one entity is marked for adaption <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="435007e96ec4552124ff43f64e1ca6f6"></a><!-- doxytag: member="Dune::SGrid::postAdapt" ref="435007e96ec4552124ff43f64e1ca6f6" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#435007e96ec4552124ff43f64e1ca6f6">postAdapt</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">clean up some markers <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class DataHandleImp, class DataTypeImp&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00103.html#6926ee148b2811f4af370db0deae9100">communicate</a> (<a class="el" href="a00066.html">CommDataHandleIF</a>&lt; DataHandleImp, DataTypeImp &gt; &amp;data, <a class="el" href="a00492.html#ge799a4296824c1d4ae0d82e71287b722">InterfaceType</a> iftype, <a class="el" href="a00492.html#gcf00ef51e7964e5797de12e1bdf8d755">CommunicationDirection</a> dir, int level) const </td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class DataHandleImp, class DataTypeImp&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00103.html#d2134e344a2b13b5072a311d88bf8ddb">communicate</a> (<a class="el" href="a00066.html">CommDataHandleIF</a>&lt; DataHandleImp, DataTypeImp &gt; &amp;data, <a class="el" href="a00492.html#ge799a4296824c1d4ae0d82e71287b722">InterfaceType</a> iftype, <a class="el" href="a00492.html#gcf00ef51e7964e5797de12e1bdf8d755">CommunicationDirection</a> dir) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e0ed8cbb63b8740a5e7b1a112eebe5af"></a><!-- doxytag: member="Dune::SGrid::loadBalance" ref="e0ed8cbb63b8740a5e7b1a112eebe5af" args="()" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#e0ed8cbb63b8740a5e7b1a112eebe5af">loadBalance</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">default implementation of load balance does nothing and returns false <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="f722d82b945c4a73360026240cfa285c"></a><!-- doxytag: member="Dune::SGrid::loadBalance" ref="f722d82b945c4a73360026240cfa285c" args="(DataHandle &amp;data)" -->
template&lt;class DataHandle&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00103.html#f722d82b945c4a73360026240cfa285c">loadBalance</a> (DataHandle &amp;data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">default implementation of load balance does nothing and returns false <br></td></tr>
<tr><td colspan="2"><div class="groupHeader">Adaptivity and grid refinement</div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00100.html#053788e629f304f65513f798363a6eb8">mark</a> (int refCount, const typename <a class="el" href="a00101.html">Codim</a>&lt; 0 &gt;::<a class="el" href="a00087.html">EntityPointer</a> &amp;e)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Marks an entity to be refined/coarsened in a subsequent adapt.  <a href="#053788e629f304f65513f798363a6eb8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00100.html#ed9dc2a7fa61a1ce07e38dd0d5fc8bee">getMark</a> (const typename <a class="el" href="a00101.html">Codim</a>&lt; 0 &gt;::<a class="el" href="a00087.html">EntityPointer</a> &amp;e) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">returns adaptation mark for given entity pointer  <a href="#ed9dc2a7fa61a1ce07e38dd0d5fc8bee"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="373d2438b87aff06e9e50a384737df4f"></a><!-- doxytag: member="Dune::SGrid::getRealImplementation" ref="373d2438b87aff06e9e50a384737df4f" args="(InterfaceType &amp;i) const " -->
template&lt;class InterfaceType&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="a00104.html">ReturnImplementationType</a><br>
&lt; <a class="el" href="a00492.html#ge799a4296824c1d4ae0d82e71287b722">InterfaceType</a> &gt;<br>
::ImplementationType &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00103.html#373d2438b87aff06e9e50a384737df4f">getRealImplementation</a> (<a class="el" href="a00492.html#ge799a4296824c1d4ae0d82e71287b722">InterfaceType</a> &amp;i) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return real implementation of interface class <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d58f58d46a33dc6dfefe6095f1b92ef1"></a><!-- doxytag: member="Dune::SGrid::asImp" ref="d58f58d46a33dc6dfefe6095f1b92ef1" args="()" -->
GridImp &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#d58f58d46a33dc6dfefe6095f1b92ef1">asImp</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Barton-Nackman trick. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6d701322362ecae63649544358fad3f0"></a><!-- doxytag: member="Dune::SGrid::asImp" ref="6d701322362ecae63649544358fad3f0" args="() const " -->
const GridImp &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html#6d701322362ecae63649544358fad3f0">asImp</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Barton-Nackman trick. <br></td></tr>
</table>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="9cd7ecb5cc83c871fe433e8e99b8baa9"></a><!-- doxytag: member="Dune::SGrid::@221" ref="9cd7ecb5cc83c871fe433e8e99b8baa9" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int dimworld, class ct, class GridFamily&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum<code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A constant that exports the template parameter dim. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="9cd7ecb5cc83c871fe433e8e99b8baa93d6a22a414566af9b4a356f760fce944"></a><!-- doxytag: member="dimension" ref="9cd7ecb5cc83c871fe433e8e99b8baa93d6a22a414566af9b4a356f760fce944" args="" -->dimension</em>&nbsp;</td><td>
The dimension of the grid. </td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="f25e01e5971721e1d01123ccc93831ab"></a><!-- doxytag: member="Dune::SGrid::@222" ref="f25e01e5971721e1d01123ccc93831ab" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int dimworld, class ct, class GridFamily&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum<code> [inherited]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A constant that exports the template parameter dimworld. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="f25e01e5971721e1d01123ccc93831ab7829985ca62f22ec6c57c5feba1e0604"></a><!-- doxytag: member="dimensionworld" ref="f25e01e5971721e1d01123ccc93831ab7829985ca62f22ec6c57c5feba1e0604" args="" -->dimensionworld</em>&nbsp;</td><td>
The dimension of the world the grid lives in. </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="0657f6f269a22d3b8a85ffc035b49fd3"></a><!-- doxytag: member="Dune::SGrid::SGrid" ref="0657f6f269a22d3b8a85ffc035b49fd3" args="(const int *N_, const sgrid_ctype *H_)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int dimworld&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00262.html">Dune::SGrid</a>&lt; dim, dimworld &gt;::<a class="el" href="a00262.html">SGrid</a>           </td>
          <td>(</td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>N_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00441.html#a2a12e0d35af55595a81465ce46c87cb">sgrid_ctype</a> *&nbsp;</td>
          <td class="paramname"> <em>H_</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make an <a class="el" href="a00262.html" title="[ provides Dune::Grid ]">SGrid</a> from extend and number of cells per direction. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>N_</em>&nbsp;</td><td>number of cells in each direction on coarsest level </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>H_</em>&nbsp;</td><td>extend of the unit cube in each dimension</td></tr>
  </table>
</dl>
Note: The origin of the cube is always at (0,0,...,0), only the extend is given. 
</div>
</div><p>
<a class="anchor" name="b5c12f45ed36919bd5c78c696e695682"></a><!-- doxytag: member="Dune::SGrid::SGrid" ref="b5c12f45ed36919bd5c78c696e695682" args="(const int *N_, const sgrid_ctype *L_, const sgrid_ctype *H_)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int dimworld&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00262.html">Dune::SGrid</a>&lt; dim, dimworld &gt;::<a class="el" href="a00262.html">SGrid</a>           </td>
          <td>(</td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>N_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00441.html#a2a12e0d35af55595a81465ce46c87cb">sgrid_ctype</a> *&nbsp;</td>
          <td class="paramname"> <em>L_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00441.html#a2a12e0d35af55595a81465ce46c87cb">sgrid_ctype</a> *&nbsp;</td>
          <td class="paramname"> <em>H_</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make an <a class="el" href="a00262.html" title="[ provides Dune::Grid ]">SGrid</a> from position, extend and number of cells per direction. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>N_</em>&nbsp;</td><td>number of cells in each direction on coarsest level </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>L_</em>&nbsp;</td><td>position of origin of the cube </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>H_</em>&nbsp;</td><td>position of the upper right corner of the cube </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a42cb51ded4e2b2c72191e4267fb82b9"></a><!-- doxytag: member="Dune::SGrid::SGrid" ref="a42cb51ded4e2b2c72191e4267fb82b9" args="(FieldVector&lt; int, dim &gt; N_, FieldVector&lt; sgrid_ctype, dim &gt; L_, FieldVector&lt; sgrid_ctype, dim &gt; H_)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int dimworld&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00262.html">Dune::SGrid</a>&lt; dim, dimworld &gt;::<a class="el" href="a00262.html">SGrid</a>           </td>
          <td>(</td>
          <td class="paramtype">FieldVector&lt; int, dim &gt;&nbsp;</td>
          <td class="paramname"> <em>N_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FieldVector&lt; <a class="el" href="a00441.html#a2a12e0d35af55595a81465ce46c87cb">sgrid_ctype</a>, dim &gt;&nbsp;</td>
          <td class="paramname"> <em>L_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FieldVector&lt; <a class="el" href="a00441.html#a2a12e0d35af55595a81465ce46c87cb">sgrid_ctype</a>, dim &gt;&nbsp;</td>
          <td class="paramname"> <em>H_</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Make an <a class="el" href="a00262.html" title="[ provides Dune::Grid ]">SGrid</a> from position, extend and number of cells per direction. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>N_</em>&nbsp;</td><td>number of cells in each direction on coarsest level </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>L_</em>&nbsp;</td><td>position of origin of the cube </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>H_</em>&nbsp;</td><td>position of the upper right corner of the cube</td></tr>
  </table>
</dl>
Note: This constructor uses FieldVectors instead of built-in arrays. This is compatible with the <a class="el" href="a00299.html" title="[ provides Dune::Grid ]">YaspGrid</a> class. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="e61127c663cd9f11095fd26ee223077b"></a><!-- doxytag: member="Dune::SGrid::maxLevel" ref="e61127c663cd9f11095fd26ee223077b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int dimworld&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="a00262.html">Dune::SGrid</a>&lt; dim, dimworld &gt;::maxLevel           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return maximum level defined in this grid. Levels are numbered 0 ... maxLevel with 0 the coarsest level. 
<p>Reimplemented from <a class="el" href="a00100.html#0662995c49ecc20d08fb5e1bd0b8701f">Dune::Grid&lt; dim, dimworld, ct, GridFamily &gt;</a>.</p>

<p>Referenced by <a class="el" href="a00663.html#l00924">Dune::SGrid&lt; dim, dimworld &gt;::global_size()</a>, <a class="el" href="a00663.html#l00865">Dune::SGrid&lt; dim, dimworld &gt;::globalRefine()</a>, <a class="el" href="a00663.html#l00905">Dune::SGrid&lt; dim, dimworld &gt;::leafbegin()</a>, <a class="el" href="a00663.html#l00912">Dune::SGrid&lt; dim, dimworld &gt;::leafend()</a>, <a class="el" href="a00664.html#l01466">Dune::SGrid&lt; dimension, dimension &gt;::levelIndexSet()</a>, and <a class="el" href="a00664.html#l01367">Dune::SGrid&lt; dimension, dimension &gt;::size()</a>.</p>

</div>
</div><p>
<a class="anchor" name="5ee7c0d2139dc418017b6e08b5d30447"></a><!-- doxytag: member="Dune::SGrid::communicate" ref="5ee7c0d2139dc418017b6e08b5d30447" args="(T &amp;t, InterfaceType iftype, CommunicationDirection dir, int level)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int dimworld&gt; </div>
<div class="memtemplate">
template&lt;class T, template&lt; class &gt; class P, int codim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00262.html">Dune::SGrid</a>&lt; dim, dimworld &gt;::communicate           </td>
          <td>(</td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00492.html#ge799a4296824c1d4ae0d82e71287b722">InterfaceType</a>&nbsp;</td>
          <td class="paramname"> <em>iftype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00492.html#gcf00ef51e7964e5797de12e1bdf8d755">CommunicationDirection</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The communication interface <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>T,:</em>&nbsp;</td><td>array class holding data associated with the entities </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>P,:</em>&nbsp;</td><td>type used to gather/scatter data in and out of the message buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>codim,:</em>&nbsp;</td><td>communicate entites of given codim </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>if,:</em>&nbsp;</td><td>one of the predifined interface types, throws error if it is not implemented </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>level,:</em>&nbsp;</td><td>communicate for entities on the given level</td></tr>
  </table>
</dl>
Implements a generic communication function sending an object of type P for each entity in the intersection of two processors. P has two methods gather and scatter that implement the protocol. Therefore P is called the "protocol class". 
</div>
</div><p>
<a class="anchor" name="b9aec678a379ed652a9c1a4938e076a6"></a><!-- doxytag: member="Dune::SGrid::partition" ref="b9aec678a379ed652a9c1a4938e076a6" args="(int level, const array&lt; int, dim &gt; &amp;z) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int dimworld&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="a00262.html">Dune::SGrid</a>&lt; dim, dimworld &gt;::partition           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const array&lt; int, dim &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
There are <img class="formulaInl" alt="$2^d$" src="form_120.png"> possibilities of having even/odd coordinates. The binary representation is called partition number. 
</div>
</div><p>
<a class="anchor" name="30d76de1e9ddbff5cdb8337b1ce49955"></a><!-- doxytag: member="Dune::SGrid::mark" ref="30d76de1e9ddbff5cdb8337b1ce49955" args="(int refCount, const typename Traits::template Codim&lt; 0 &gt;::EntityPointer &amp;e)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int dimworld, class ct, class GridFamily&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00103.html">Dune::GridDefaultImplementation</a>&lt; dim, dimworld, ct, GridFamily &gt;::mark           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>refCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Traits::template <a class="el" href="a00101.html">Codim</a>&lt; 0 &gt;::<a class="el" href="a00087.html">EntityPointer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Marks an entity to be refined/coarsened in a subsequent adapt. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>refCount</em>&nbsp;</td><td>Number of subdivisions that should be applied. Negative value means coarsening. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>e</em>&nbsp;</td><td><a class="el" href="a00087.html" title="Wrapper class for pointers to entities.">EntityPointer</a> to <a class="el" href="a00082.html" title="Wrapper class for entities.">Entity</a> that should be refined</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if <a class="el" href="a00082.html" title="Wrapper class for entities.">Entity</a> was marked, false otherwise.</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd><ul>
<li><b>default</b> <b>implementation</b> is: return false; for grids with no adaptation.</li><li>for the grid programmer: this method is implemented as a template method, because the <a class="el" href="a00082.html" title="Wrapper class for entities.">Entity</a> type is not defined when the class is instantiated You won't need this trick in the implementation. In your implementation you should use it as <div class="fragment"><pre class="fragment">           <span class="keywordtype">bool</span> <a class="code" href="a00103.html#30d76de1e9ddbff5cdb8337b1ce49955" title="Marks an entity to be refined/coarsened in a subsequent adapt.">mark</a>( <span class="keywordtype">int</span> refCount,
                      <span class="keyword">typename</span> Traits::template Codim&lt;0&gt;::EntityPointer &amp; e ).
</pre></div> This template method will vanish due to the inheritance rules. </li></ul>
</dd></dl>

<p>Reimplemented in <a class="el" href="a00016.html#185d5ebd2bec3de2d21b587343e4ae1f">Dune::ALU2dGrid&lt; dim, dimworld &gt;</a>, <a class="el" href="a00027.html#a27f5f583ece76647942c0cf090e2a8c">Dune::ALU3dGrid&lt; dim, dimworld, elType &gt;</a>, <a class="el" href="a00284.html#36c19f0d34bebce784df64719483f26f">Dune::UGGrid&lt; dim &gt;</a>, <a class="el" href="a00016.html#185d5ebd2bec3de2d21b587343e4ae1f">Dune::ALU2dGrid&lt; 2, 2 &gt;</a>, <a class="el" href="a00027.html#a27f5f583ece76647942c0cf090e2a8c">Dune::ALU3dGrid&lt; 3, 3, Dune::hexa &gt;</a>, and <a class="el" href="a00027.html#a27f5f583ece76647942c0cf090e2a8c">Dune::ALU3dGrid&lt; 3, 3, Dune::tetra &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="053788e629f304f65513f798363a6eb8"></a><!-- doxytag: member="Dune::SGrid::mark" ref="053788e629f304f65513f798363a6eb8" args="(int refCount, const typename Codim&lt; 0 &gt;::EntityPointer &amp;e)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int dimworld, class ct, class GridFamily&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00100.html">Dune::Grid</a>&lt; dim, dimworld, ct, GridFamily &gt;::mark           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>refCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="a00101.html">Codim</a>&lt; 0 &gt;::<a class="el" href="a00087.html">EntityPointer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Marks an entity to be refined/coarsened in a subsequent adapt. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>refCount</em>&nbsp;</td><td>Number of subdivisions that should be applied. Negative value means coarsening. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>e</em>&nbsp;</td><td><a class="el" href="a00087.html" title="Wrapper class for pointers to entities.">EntityPointer</a> to <a class="el" href="a00082.html" title="Wrapper class for entities.">Entity</a> that should be refined</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if <a class="el" href="a00082.html" title="Wrapper class for entities.">Entity</a> was marked, false otherwise. </dd></dl>

</div>
</div><p>
<a class="anchor" name="378ce24a2bfacfc0e23699423d261fc9"></a><!-- doxytag: member="Dune::SGrid::getMark" ref="378ce24a2bfacfc0e23699423d261fc9" args="(const typename Traits::template Codim&lt; 0 &gt;::EntityPointer &amp;) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int dimworld, class ct, class GridFamily&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="a00103.html">Dune::GridDefaultImplementation</a>&lt; dim, dimworld, ct, GridFamily &gt;::getMark           </td>
          <td>(</td>
          <td class="paramtype">const typename Traits::template <a class="el" href="a00101.html">Codim</a>&lt; 0 &gt;::<a class="el" href="a00087.html">EntityPointer</a> &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
returns adaptation mark for given entity, i.e. here the default implementation returns 0. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>e</em>&nbsp;</td><td><a class="el" href="a00087.html" title="Wrapper class for pointers to entities.">EntityPointer</a> for which adaptation mark should be determined</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>int adaptation mark, here the default value 0 is returned </dd></dl>

<p>Reimplemented in <a class="el" href="a00002.html#53199225c2056421d4b397b3ee7d3f46">Dune::AlbertaGrid&lt; dim, dimworld &gt;</a>, <a class="el" href="a00016.html#b1869940a7b4ef1c66a165f08d7ae85e">Dune::ALU2dGrid&lt; dim, dimworld &gt;</a>, <a class="el" href="a00027.html#902dd5c1ba5f566efc7e2f2d961cdeea">Dune::ALU3dGrid&lt; dim, dimworld, elType &gt;</a>, <a class="el" href="a00284.html#e0db418e9f08afff50b9d0616be6d4a0">Dune::UGGrid&lt; dim &gt;</a>, <a class="el" href="a00016.html#b1869940a7b4ef1c66a165f08d7ae85e">Dune::ALU2dGrid&lt; 2, 2 &gt;</a>, <a class="el" href="a00027.html#902dd5c1ba5f566efc7e2f2d961cdeea">Dune::ALU3dGrid&lt; 3, 3, Dune::hexa &gt;</a>, and <a class="el" href="a00027.html#902dd5c1ba5f566efc7e2f2d961cdeea">Dune::ALU3dGrid&lt; 3, 3, Dune::tetra &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="ed9dc2a7fa61a1ce07e38dd0d5fc8bee"></a><!-- doxytag: member="Dune::SGrid::getMark" ref="ed9dc2a7fa61a1ce07e38dd0d5fc8bee" args="(const typename Codim&lt; 0 &gt;::EntityPointer &amp;e) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int dimworld, class ct, class GridFamily&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="a00100.html">Dune::Grid</a>&lt; dim, dimworld, ct, GridFamily &gt;::getMark           </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="a00101.html">Codim</a>&lt; 0 &gt;::<a class="el" href="a00087.html">EntityPointer</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>e</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
returns adaptation mark for given entity pointer 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>e</em>&nbsp;</td><td><a class="el" href="a00087.html" title="Wrapper class for pointers to entities.">EntityPointer</a> for which adaptation mark should be determined</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>int adaptation mark currently set for given <a class="el" href="a00087.html" title="Wrapper class for pointers to entities.">EntityPointer</a> e </dd></dl>

</div>
</div><p>
<a class="anchor" name="6926ee148b2811f4af370db0deae9100"></a><!-- doxytag: member="Dune::SGrid::communicate" ref="6926ee148b2811f4af370db0deae9100" args="(CommDataHandleIF&lt; DataHandleImp, DataTypeImp &gt; &amp;data, InterfaceType iftype, CommunicationDirection dir, int level) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int dimworld, class ct, class GridFamily&gt; </div>
<div class="memtemplate">
template&lt;class DataHandleImp, class DataTypeImp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00103.html">Dune::GridDefaultImplementation</a>&lt; dim, dimworld, ct, GridFamily &gt;::communicate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00066.html">CommDataHandleIF</a>&lt; DataHandleImp, DataTypeImp &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00492.html#ge799a4296824c1d4ae0d82e71287b722">InterfaceType</a>&nbsp;</td>
          <td class="paramname"> <em>iftype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00492.html#gcf00ef51e7964e5797de12e1bdf8d755">CommunicationDirection</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
dummy communicate, doing nothing 
<p>Reimplemented from <a class="el" href="a00100.html#6ca2df2b811db924bd6d071347bb6308">Dune::Grid&lt; dim, dimworld, ct, GridFamily &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="a00016.html#585409ac340cb317f1f51746a923f5c9">Dune::ALU2dGrid&lt; 2, 2 &gt;</a>, <a class="el" href="a00027.html#dad2fd80dd11b0261cf9b9b6150e7215">Dune::ALU3dGrid&lt; 3, 3, Dune::hexa &gt;</a>, and <a class="el" href="a00027.html#dad2fd80dd11b0261cf9b9b6150e7215">Dune::ALU3dGrid&lt; 3, 3, Dune::tetra &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="d2134e344a2b13b5072a311d88bf8ddb"></a><!-- doxytag: member="Dune::SGrid::communicate" ref="d2134e344a2b13b5072a311d88bf8ddb" args="(CommDataHandleIF&lt; DataHandleImp, DataTypeImp &gt; &amp;data, InterfaceType iftype, CommunicationDirection dir) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int dimworld, class ct, class GridFamily&gt; </div>
<div class="memtemplate">
template&lt;class DataHandleImp, class DataTypeImp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00103.html">Dune::GridDefaultImplementation</a>&lt; dim, dimworld, ct, GridFamily &gt;::communicate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00066.html">CommDataHandleIF</a>&lt; DataHandleImp, DataTypeImp &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00492.html#ge799a4296824c1d4ae0d82e71287b722">InterfaceType</a>&nbsp;</td>
          <td class="paramname"> <em>iftype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00492.html#gcf00ef51e7964e5797de12e1bdf8d755">CommunicationDirection</a>&nbsp;</td>
          <td class="paramname"> <em>dir</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
dummy communicate, doing nothing 
<p>Reimplemented from <a class="el" href="a00100.html#98010babe296c902c5c8f0f4a5456fd8">Dune::Grid&lt; dim, dimworld, ct, GridFamily &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="a00016.html#76615146fce12c74b691fcb2ec25c450">Dune::ALU2dGrid&lt; 2, 2 &gt;</a>, <a class="el" href="a00027.html#e71dcfc631d7f3f7479936c3230e8f50">Dune::ALU3dGrid&lt; 3, 3, Dune::hexa &gt;</a>, and <a class="el" href="a00027.html#e71dcfc631d7f3f7479936c3230e8f50">Dune::ALU3dGrid&lt; 3, 3, Dune::tetra &gt;</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="a00664.html">sgrid.hh</a><li>sgrid.cc</ul>
</div>
</div> <!-- end doxygen -->
</div> <!-- end main -->
<div class="foot">

<p class="foot">
  Generated on 6 Nov 2008 with <a
  href="http://www.doxygen.org/">Doxygen</a> (ver 1.5.6)  
  [<a href="doxygen.log">logfile</a>].
</p>

</div>

</body>
</html>
