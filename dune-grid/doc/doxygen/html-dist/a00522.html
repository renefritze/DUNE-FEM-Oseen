<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN""http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>dune-grid: Refinement (dune-grid )</title>
  <link rel="stylesheet" type="text/css" href="./dune-doxy.css">
  <link rel="stylesheet" type="text/css" href="./tabs.css">
</head>
<div class="main">
<div class="doxygen">
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Refinement<br>
<small>
[<a class="el" href="a00490.html">dune-grid</a>]</small>
</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
<h2><a class="anchor" name="General">
General</a></h2>
The Refinement system allows to temporarily refine a grid or single entities without changing the grid itself. You may want to do this because you want to write your data to a file and have to do subsampling, but want to continue the calculation with the unmodified grid afterwards.<h3><a class="anchor" name="Can_do">
What Refinement can do for you</a></h3>
For a given geometry type and refinement level, Refinement will<ul>
<li>assign consecutive integer indices starting at 0 to each subvertex,</li><li>assign consecutive integer indices starting at 0 to each subelement,</li><li>calculate the coordinates of the subvertices for you,</li><li>calculate subvertex-indices of the corners of the subelements for you.</li></ul>
<p>
The geometry type of the refined entity and of the subelements may be different, for example you can refine a quadrilateral but get subelements which are triangles.<p>
Currently the following geometry types are supportet:<ul>
<li>hypercubes (quadrilaterals, hexahedrons),</li><li>simplices (triangles, tetrahedrons),</li><li>triangulating hypercubes into simplices (quadrilaterals -&gt; triangles, hexahedrons -&gt; tetrahedrons).</li></ul>
<h3><a class="anchor" name="Cannot_do">
What Refinement can't do for you</a></h3>
<ul>
<li>Refinement does not actually subsample your data, it only tells you <em>where</em> to subsample your data.</li><li>The geometry types need to be known at compile time. See <a class="el" href="a00527.html">VirtualRefinement</a> if you need to calculate the right geometry type at run time.</li><li>No Refinement implementations for anything besides hypercubes and simplices have been written yet.</li></ul>
<h2><a class="anchor" name="User_interface">
The user interface</a></h2>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span>&lt;GeometryType::BasicType geometryType, <span class="keyword">class</span> CoordType, GeometryType::BasicType coerceTo, <span class="keywordtype">int</span> dimension&gt;
  <span class="keyword">class </span>Refinement
  {
  <span class="keyword">public</span>:
    <span class="keyword">enum</span> { dimension };

    <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> codimension&gt;
    <span class="keyword">struct </span>codim {
      <span class="keyword">class </span>SubEntityIterator;
    };
    <span class="keyword">typedef</span> VertexIterator;  <span class="comment">// These are aliases for codim&lt;codim&gt;::SubEntityIterator</span>
    <span class="keyword">typedef</span> ElementIterator;

    <span class="keyword">typedef</span> IndexVector; <span class="comment">// These are FieldVectors</span>
    <span class="keyword">typedef</span> CoordVector;

    <span class="keyword">static</span> <span class="keywordtype">int</span> nVertices(<span class="keywordtype">int</span> level);
    <span class="keyword">static</span> VertexIterator vBegin(<span class="keywordtype">int</span> level);
    <span class="keyword">static</span> VertexIterator vEnd(<span class="keywordtype">int</span> level);

    <span class="keyword">static</span> <span class="keywordtype">int</span> nElements(<span class="keywordtype">int</span> level);
    <span class="keyword">static</span> ElementIterator eBegin(<span class="keywordtype">int</span> level);
    <span class="keyword">static</span> ElementIterator eEnd(<span class="keywordtype">int</span> level);
  }
</pre></div><p>
The Iterators can do all the usual things that Iterators can do, except dereferencing. In addition, to do something useful, they support some additional methods:<p>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span>&lt;GeometryType::BasicType geometryType, <span class="keyword">class</span> CoordType, GeometryType::BasicType coerceTo, <span class="keywordtype">int</span> dimension&gt;
  <span class="keyword">class </span>VertexIterator
  {
  <span class="keyword">public</span>:
    <span class="keyword">typedef</span> Refinement;

    <span class="keywordtype">int</span> index() <span class="keyword">const</span>;
    Refinement::CoordVector coords() <span class="keyword">const</span>;
  }

  <span class="keyword">template</span>&lt;GeometryType::BasicType geometryType, <span class="keyword">class</span> CoordType, GeometryType::BasicType coerceTo, <span class="keywordtype">int</span> dimension&gt;
  <span class="keyword">class </span>ElementIterator
  {
  <span class="keyword">public</span>:
    <span class="keyword">typedef</span> Refinement;

    <span class="keywordtype">int</span> index() <span class="keyword">const</span>;
    Refinement::IndexVector vertexIndices() <span class="keyword">const</span>;
  }
</pre></div><h3><a class="anchor" name="How_to_use_it">
How to use it</a></h3>
Either use VirtualRefinement, or if you don't want to do that, read on.<p>
<div class="fragment"><pre class="fragment">  <span class="comment">// Include the neccessary files</span>
<span class="preprocessor">  #include &lt;dune/grid/common/refinement.hh&gt;</span>

  <span class="comment">// If you know that you are only ever going to need one refinement</span>
  <span class="comment">// backend, you can include the corresponding file directly:</span>
  <span class="comment">//#include &lt;dune/grid/common/refinement/hcube.cc&gt;</span>

  <span class="comment">// Get yourself the Refinement you need:</span>
  <span class="keyword">typedef</span> Refinement&lt;GeometryType::cube, SGrid&lt;2, 2&gt;::ctype, GeometryType::cube, 2&gt; MyRefinement;

  <span class="keywordtype">int</span> main()
  {
    <span class="keyword">const</span> <span class="keywordtype">int</span> refinementlevel = 2;
    cout &lt;&lt; <span class="stringliteral">"Using refinementlevel = "</span> &lt;&lt; refinementlevel &lt;&lt; endl &lt;&lt; endl;

    <span class="comment">// get Number of Vertices</span>
    cout &lt;&lt; <span class="stringliteral">"Number of Vertices: "</span>
         &lt;&lt; MyRefinement::nVertices(refinementlevel)
         &lt;&lt; endl;

    <span class="comment">// Iterate over Vertices</span>
    cout &lt;&lt; <span class="stringliteral">"Index\tx\ty"</span> &lt;&lt; endl;
    MyRefinement::VertexIterator vEnd = MyRefinement::vEnd(refinementlevel);
    <span class="keywordflow">for</span>(MyRefinement::VertexIterator i = MyRefinement::vBegin(refinementlevel); i != vEnd; ++i)
      cout &lt;&lt; i.index() &lt;&lt; <span class="stringliteral">"\t"</span> &lt;&lt; i.coords()[0] &lt;&lt; <span class="stringliteral">"\t"</span> &lt;&lt; i.coords()[1] &lt;&lt; endl;
    cout &lt;&lt; endl;

    <span class="comment">// Iterate over Vertices</span>
    cout &lt;&lt; <span class="stringliteral">"Index\tEcke0\tEcke1\tEcke2\tEcke3"</span> &lt;&lt; endl;
    MyRefinement::ElementIterator eEnd = MyRefinement::eEnd(refinementlevel);
    <span class="keywordflow">for</span>(MyRefinement::ElementIterator i = MyRefinement::eBegin(refinementlevel); i != eEnd; ++i)
      cout &lt;&lt; i.index() &lt;&lt; <span class="stringliteral">"\t"</span>
           &lt;&lt; i.indexVertices()[0] &lt;&lt; <span class="stringliteral">"\t"</span> &lt;&lt; i.indexVertices()[1] &lt;&lt; <span class="stringliteral">"\t"</span>
           &lt;&lt; i.indexVertices()[2] &lt;&lt; <span class="stringliteral">"\t"</span> &lt;&lt; i.indexVertices()[3] &lt;&lt; endl;
    cout &lt;&lt; endl;
  }
</pre></div><h3><a class="anchor" name="Guarantees">
Guarantees</a></h3>
The Refinement system gives this guarantee (besides conforming to the above interface:<ul>
<li>The indices of the subvertices and subelement start at 0 and are consecutive.</li></ul>
<h2><a class="anchor" name="Implementing">
Implementing a new Refinement type</a></h2>
If you want to write a Refinement implementation for a particular geometry type, e.g. SquaringTheCircle (or a particular set of geometry types) here is how:<p>
<ul>
<li>create a file refinement/squaringthecircle.cc and include "base.cc". Your file will be included by others, so don't forget to protect against double inclusion.</li><li>implement a class (or template class) RefinementImp conforming exactly to the user interface above.</li><li>put it (and it's helper stuff as apropriate) into it's own namespace Dune::RefinementImp::SquaringTheCircle.</li><li>define the mapping of geometryType, CoordType and coerceTo to your implementation by specialising template struct RefinementImp::Traits. It should look like this: <div class="fragment"><pre class="fragment">  <span class="keyword">namespace </span>Dune::RefinementImp {
    <span class="comment">// the "dim" template parameter is ignored, since the dimension can be infered</span>
    <span class="keyword">template</span>&lt;<span class="keyword">class</span> CoordType&gt;
    <span class="keyword">struct </span>Traits&lt;GeometryType::sphere, CoordType, GeometryType::cube, 2&gt; {
      <span class="keyword">typedef</span> SquaringTheCircle::RefinementImp&lt;CoordType&gt; <a class="code" href="a00282.html#fa22c420a957872904baa6f351c0e859" title="The implementation this specialisation maps to.">Imp</a>;
    };

    <span class="comment">// we're only implementing this for dim=2</span>
    <span class="keyword">template</span>&lt;<span class="keyword">class</span> CoordType&gt;
    <span class="keyword">struct </span>Traits&lt;GeometryType::sphere, CoordType, GeometryType::cube, 2&gt; {
      <span class="keyword">typedef</span> SquaringTheCircle::RefinementImp&lt;CoordType&gt; <a class="code" href="a00282.html#fa22c420a957872904baa6f351c0e859" title="The implementation this specialisation maps to.">Imp</a>;
    };

    <span class="keyword">template</span>&lt;<span class="keyword">class</span> CoordType&gt;
    <span class="keyword">struct </span>Traits&lt;GeometryType::circle, CoordType, GeometryType::cube, 2&gt; {
      <span class="keyword">typedef</span> SquaringTheCircle::RefinementImp&lt;CoordType&gt; <a class="code" href="a00282.html#fa22c420a957872904baa6f351c0e859" title="The implementation this specialisation maps to.">Imp</a>;
    };

    <span class="keyword">template</span>&lt;<span class="keyword">class</span> CoordType&gt;
    <span class="keyword">struct </span>Traits&lt;GeometryType::sphere, CoordType, GeometryType::quadrilateral, 2&gt; {
      <span class="keyword">typedef</span> SquaringTheCircle::RefinementImp&lt;CoordType&gt; <a class="code" href="a00282.html#fa22c420a957872904baa6f351c0e859" title="The implementation this specialisation maps to.">Imp</a>;
    };
  }
</pre></div> If you implement a template class, you have to specialise struct RefinementImp::Traits for every possible combination of geometryType and coerceTo that your implementation supports.</li><li>include "refinement/squaringthecircle.cc" from <a class="el" href="a00444.html" title="This file simply includes all Refinement implementations so you don&#39;t have to...">refinement.hh</a>.</li></ul>
<p>
This is enough to integrate your implementation into the Refinement system. You probably want to include it into <a class="el" href="a00527.html">VirtualRefinement</a> also.<h3><a class="anchor" name="Namespaces">
Namespaces</a></h3>
The (non-virtual) Refinement namespaces is organized in the following way:<ul>
<li>Only template class Refinement lives directly in namespace <a class="el" href="a00441.html">Dune</a>.</li><li>Use namespace <a class="el" href="a00478.html" title="This namespace contains the implementation of Refinement.">Dune::RefinementImp</a> for all the Implementation.</li><li>Use template struct <a class="el" href="a00282.html" title="Mapping from geometryType, CoordType and coerceTo to a particular Refinement implementation...">Dune::RefinementImp::Traits</a> instead of template struct Dune::RefinementTraits.</li><li>Use namespace <a class="el" href="a00479.html" title="This namespace contains the Refinement implementation for hypercubes (GeometryType::cube)...">Dune::RefinementImp::HCube</a>, namespace <a class="el" href="a00481.html" title="This namespace contains the Refinement implementation for simplices (triangles, tetrahedrons...">Dune::RefinementImp::Simplex</a>, ... for each implementation.</li></ul>
<p>
The complete <a class="el" href="a00527.html">VirtualRefinement</a> stuff is directly in namespace <a class="el" href="a00441.html">Dune</a>.<h3><a class="anchor" name="Layers">
Conceptual layers</a></h3>
<ul>
<li><b>Layer 0</b> declares struct RefinementImp::Traits&lt;geometryType, CoordType, coerceTo, dim&gt;. It's member typedef Imp tells which Refinement implementation to use for a given geometryType (and CoordType). It is located in refinementbase.cc.</li><li><b>Layer 1</b> defines RefinementImp::XXX::RefinementImp. It implements the Refinements for each geometryType, coerceTo (and CoordType). Also in this layer are the definitions of struct RefinementImp::Traits. This layer is located in refinementXXX.cc.</li><li><b>Layer 2</b> puts it all together. It defines class Refinement&lt;geometryType, CoordType, coerceTo, dim&gt; by deriving from the corresponding RefinementImp. It is located in refinementbase.cc.</li><li>There is a dummy <b>layer 2.5</b> which simply includes all the refinementXXX.cc files. It is located in refinement.cc.</li></ul>
<p>
<a class="el" href="a00527.html">VirtualRefinement</a> adds two more layers to the ones defined here. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Modules</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00524.html">Refinement implementation for hypercubes</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00525.html">Refinement implementation for triangulating hypercubes</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00526.html">Refinement implementation for simplices</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00527.html">Virtual Refinement</a></td></tr>

</table>
</div>
</div> <!-- end doxygen -->
</div> <!-- end main -->
<div class="foot">

<p class="foot">
  Generated on 6 Nov 2008 with <a
  href="http://www.doxygen.org/">Doxygen</a> (ver 1.5.6)  
  [<a href="doxygen.log">logfile</a>].
</p>

</div>

</body>
</html>
