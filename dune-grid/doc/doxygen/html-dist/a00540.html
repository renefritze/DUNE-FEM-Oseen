<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN""http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>dune-grid: alu3diterators.hh Source File (dune-grid )</title>
  <link rel="stylesheet" type="text/css" href="./dune-doxy.css">
  <link rel="stylesheet" type="text/css" href="./tabs.css">
</head>
<div class="main">
<div class="doxygen">
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_5edca94048dae04696b7e65d07cd8e9c.html">grid</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_9d26ade7b4f431707081bce9f56e5ade.html">alugrid</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_ff7f0157f1ec63edd550ceb3c6b812db.html">3d</a>
  </div>
</div>
<div class="contents">
<h1>alu3diterators.hh</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef DUNE_ALU3DITERATORS_HH</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define DUNE_ALU3DITERATORS_HH</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="comment">// System includes</span>
<a name="l00005"></a>00005 
<a name="l00006"></a>00006 <span class="comment">// Dune includes</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include &lt;dune/grid/common/grid.hh&gt;</span>
<a name="l00008"></a>00008 
<a name="l00009"></a>00009 <span class="comment">// Local includes</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include "alu3dinclude.hh"</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include "topology.hh"</span>
<a name="l00012"></a>00012 
<a name="l00013"></a>00013 <span class="keyword">namespace </span>ALUGridSpace {
<a name="l00014"></a>00014   <span class="comment">//*************************************************************</span>
<a name="l00015"></a>00015   <span class="comment">//  definition of original LeafIterators of ALUGrid </span>
<a name="l00016"></a>00016   <span class="comment">//</span>
<a name="l00017"></a>00017   <span class="comment">// default is element (codim = 0)</span>
<a name="l00018"></a>00018   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> codim&gt; 
<a name="l00019"></a>00019   <span class="keyword">struct </span>BSMacroIterator 
<a name="l00020"></a>00020   {
<a name="l00021"></a>00021     <span class="keyword">typedef</span> AccessIterator&lt;GitterType::helement_STI&gt;::Handle IteratorType;  
<a name="l00022"></a>00022   };
<a name="l00023"></a>00023 
<a name="l00024"></a>00024   <span class="comment">//******************************************************************</span>
<a name="l00025"></a>00025   <span class="comment">//  LevelIterators </span>
<a name="l00026"></a>00026   <span class="comment">//******************************************************************</span>
<a name="l00027"></a>00027   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> codim&gt; <span class="keyword">struct </span>ALUHElementType
<a name="l00028"></a>00028   {
<a name="l00029"></a>00029     <span class="keyword">typedef</span> GitterType :: helement_STI ElementType;
<a name="l00030"></a>00030   };
<a name="l00031"></a>00031   
<a name="l00032"></a>00032   <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>ALUHElementType&lt;0&gt; {
<a name="l00033"></a>00033     <span class="keyword">typedef</span> GitterType :: helement_STI ElementType;
<a name="l00034"></a>00034   }; 
<a name="l00035"></a>00035   <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>ALUHElementType&lt;1&gt; {
<a name="l00036"></a>00036     <span class="keyword">typedef</span> GitterType :: hface_STI ElementType;
<a name="l00037"></a>00037   }; 
<a name="l00038"></a>00038   <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>ALUHElementType&lt;2&gt; {
<a name="l00039"></a>00039     <span class="keyword">typedef</span> GitterType :: hedge_STI ElementType;
<a name="l00040"></a>00040   }; 
<a name="l00041"></a>00041   <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>ALUHElementType&lt;3&gt; {
<a name="l00042"></a>00042     <span class="keyword">typedef</span> GitterType :: vertex_STI ElementType;
<a name="l00043"></a>00043   }; 
<a name="l00044"></a>00044   
<a name="l00045"></a>00045   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> codim&gt; <span class="keyword">struct </span>BSIMPLElementType
<a name="l00046"></a>00046   {
<a name="l00047"></a>00047     <span class="keyword">typedef</span> GitterImplType::Objects::tetra_IMPL ElementType; <span class="comment">// impl Element</span>
<a name="l00048"></a>00048   };
<a name="l00049"></a>00049 
<a name="l00050"></a>00050   <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>BSIMPLElementType&lt;0&gt; {
<a name="l00051"></a>00051     <span class="keyword">typedef</span> GitterImplType::Objects::tetra_IMPL ElementType; <span class="comment">// impl Element</span>
<a name="l00052"></a>00052   }; 
<a name="l00053"></a>00053   <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>BSIMPLElementType&lt;1&gt; {
<a name="l00054"></a>00054     <span class="keyword">typedef</span> GitterImplType::Objects::hface3_IMPL ElementType; <span class="comment">// impl Element</span>
<a name="l00055"></a>00055   }; 
<a name="l00056"></a>00056   <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>BSIMPLElementType&lt;2&gt; {
<a name="l00057"></a>00057     <span class="keyword">typedef</span> GitterImplType::Objects::hedge1_IMPL ElementType; <span class="comment">// impl Element</span>
<a name="l00058"></a>00058   };
<a name="l00059"></a>00059 
<a name="l00060"></a>00060   <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>BSIMPLElementType&lt;3&gt; {
<a name="l00061"></a>00061     <span class="keyword">typedef</span> GitterType::Geometric::VertexGeo ElementType;
<a name="l00062"></a>00062   };
<a name="l00063"></a>00063 
<a name="l00064"></a>00064   <span class="keyword">typedef</span> Dune :: ALU3dGridVertexList VertexListType;
<a name="l00065"></a>00065   <span class="keyword">typedef</span> Dune :: ALU3dGridLeafVertexList LeafVertexListType;
<a name="l00066"></a>00066 
<a name="l00067"></a>00067   <span class="comment">//*********************************************************</span>
<a name="l00068"></a>00068   <span class="comment">//  LevelIterator Wrapper </span>
<a name="l00069"></a>00069   <span class="comment">//*********************************************************</span>
<a name="l00070"></a>00070   <span class="keyword">template</span> &lt;<span class="keyword">class</span> val_t&gt; 
<a name="l00071"></a>00071   <span class="keyword">class </span>IteratorWrapperInterface : <span class="keyword">public</span> IteratorSTI&lt; val_t &gt; 
<a name="l00072"></a>00072   {
<a name="l00073"></a>00073   <span class="keyword">public</span>:
<a name="l00074"></a>00074     <span class="keyword">virtual</span> ~IteratorWrapperInterface () {}
<a name="l00075"></a>00075     
<a name="l00076"></a>00076     <span class="keyword">virtual</span> <span class="keywordtype">int</span> size  () = 0;
<a name="l00077"></a>00077     <span class="keyword">virtual</span> <span class="keywordtype">void</span> next () = 0;
<a name="l00078"></a>00078     <span class="keyword">virtual</span> <span class="keywordtype">void</span> first() = 0;
<a name="l00079"></a>00079     <span class="keyword">virtual</span> <span class="keywordtype">int</span> done  () <span class="keyword">const</span> = 0;
<a name="l00080"></a>00080     <span class="keyword">virtual</span> val_t &amp; item () <span class="keyword">const</span> = 0;
<a name="l00081"></a>00081     <span class="keyword">virtual</span> IteratorSTI&lt; val_t &gt; * clone ()<span class="keyword"> const </span>{ assert(<span class="keyword">false</span>); abort(); <span class="keywordflow">return</span> 0; } 
<a name="l00082"></a>00082   };
<a name="l00083"></a>00083 
<a name="l00084"></a>00084   <span class="keyword">typedef</span> <a class="code" href="a00492.html#ga5b9e8102d7f70f3f4178182629d98b6" title="Parameter to be used for the parallel level- and leaf iterators.">Dune::PartitionIteratorType</a> <a class="code" href="a00492.html#ga5b9e8102d7f70f3f4178182629d98b6" title="Parameter to be used for the parallel level- and leaf iterators.">PartitionIteratorType</a>;
<a name="l00085"></a>00085   
<a name="l00086"></a>00086   <span class="comment">// defines the pair of element and boundary </span>
<a name="l00087"></a>00087   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> codim&gt;
<a name="l00088"></a>00088   <span class="keyword">struct </span>IteratorElType
<a name="l00089"></a>00089   {
<a name="l00090"></a>00090     <span class="keyword">typedef</span> <span class="keyword">typename</span> ALUHElementType&lt;codim&gt;::ElementType ElType; 
<a name="l00091"></a>00091     <span class="keyword">typedef</span> pair &lt; ElType * , HBndSegType * &gt; val_t;
<a name="l00092"></a>00092   };
<a name="l00093"></a>00093   
<a name="l00094"></a>00094   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> codim, PartitionIteratorType pitype&gt; 
<a name="l00095"></a>00095   <span class="keyword">class </span>ALU3dGridLevelIteratorWrapper;
<a name="l00096"></a>00096   
<a name="l00097"></a>00097   <span class="comment">// the element level iterator </span>
<a name="l00098"></a>00098   <span class="keyword">template</span> &lt;PartitionIteratorType pitype&gt;
<a name="l00099"></a>00099   <span class="keyword">class </span>ALU3dGridLevelIteratorWrapper&lt;0,pitype&gt; 
<a name="l00100"></a>00100     : <span class="keyword">public</span> IteratorWrapperInterface&lt; typename IteratorElType&lt;0&gt;::val_t &gt;
<a name="l00101"></a>00101   {
<a name="l00102"></a>00102     <span class="keyword">typedef</span> ALUHElementType&lt;0&gt;::ElementType ElType; 
<a name="l00103"></a>00103     <span class="keyword">typedef</span> ALU3DSPACE LevelIterator &lt; ElType &gt; IteratorType;
<a name="l00104"></a>00104     
<a name="l00105"></a>00105     <span class="comment">// the iterator </span>
<a name="l00106"></a>00106     IteratorType it_;
<a name="l00107"></a>00107   <span class="keyword">public</span>:
<a name="l00108"></a>00108     <span class="keyword">typedef</span> <span class="keyword">typename</span> IteratorElType&lt;0&gt;::val_t val_t;
<a name="l00109"></a>00109     <span class="keyword">mutable</span> val_t elem_;
<a name="l00110"></a>00110     
<a name="l00111"></a>00111     <span class="comment">// constructor creating iterator </span>
<a name="l00112"></a>00112     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Gr<span class="keywordtype">id</span>Imp&gt; 
<a name="l00113"></a>00113     ALU3dGridLevelIteratorWrapper (<span class="keyword">const</span> GridImp &amp; grid, <span class="keywordtype">int</span> level , <span class="keyword">const</span> <span class="keywordtype">int</span> nlinks ) 
<a name="l00114"></a>00114       : it_(grid.myGrid() , level ) 
<a name="l00115"></a>00115       , elem_(0,0)
<a name="l00116"></a>00116       {}
<a name="l00117"></a>00117    
<a name="l00118"></a>00118     <span class="comment">// copy constructor </span>
<a name="l00119"></a>00119     ALU3dGridLevelIteratorWrapper (<span class="keyword">const</span> ALU3dGridLevelIteratorWrapper &amp; org )
<a name="l00120"></a>00120       : it_( org.it_ ), elem_(org.elem_) 
<a name="l00121"></a>00121     {
<a name="l00122"></a>00122     }
<a name="l00123"></a>00123 
<a name="l00124"></a>00124     <span class="keywordtype">int</span> size  ()    { <span class="keywordflow">return</span> it_-&gt;size(); }
<a name="l00125"></a>00125     <span class="keywordtype">void</span> next ()    { it_-&gt;next();  }
<a name="l00126"></a>00126     <span class="keywordtype">void</span> first()    { it_-&gt;first(); }
<a name="l00127"></a>00127     <span class="keywordtype">int</span> done ()<span class="keyword"> const     </span>{ <span class="keywordflow">return</span> it_-&gt;done(); }
<a name="l00128"></a>00128     val_t &amp; item ()<span class="keyword"> const </span>
<a name="l00129"></a>00129 <span class="keyword">    </span>{ 
<a name="l00130"></a>00130       assert( ! done () );
<a name="l00131"></a>00131       elem_.first  = &amp; it_-&gt;item(); 
<a name="l00132"></a>00132       <span class="keywordflow">return</span> elem_; 
<a name="l00133"></a>00133     }
<a name="l00134"></a>00134   };
<a name="l00135"></a>00135 
<a name="l00136"></a>00136   <span class="comment">// the face level iterator </span>
<a name="l00137"></a>00137   <span class="keyword">template</span> &lt;PartitionIteratorType pitype&gt;
<a name="l00138"></a>00138   <span class="keyword">class </span>ALU3dGridLevelIteratorWrapper&lt;1,pitype&gt;
<a name="l00139"></a>00139     : <span class="keyword">public</span> IteratorWrapperInterface&lt; typename IteratorElType&lt;1&gt;::val_t &gt;
<a name="l00140"></a>00140   {
<a name="l00141"></a>00141     <span class="keyword">typedef</span> ALUHElementType&lt;1&gt;::ElementType ElType; 
<a name="l00142"></a>00142     <span class="keyword">typedef</span> ALU3DSPACE LevelIterator &lt; ElType &gt; IteratorType;
<a name="l00143"></a>00143     
<a name="l00144"></a>00144     <span class="comment">// the iterator </span>
<a name="l00145"></a>00145     IteratorType it_;
<a name="l00146"></a>00146   <span class="keyword">public</span>:
<a name="l00147"></a>00147     <span class="keyword">typedef</span> <span class="keyword">typename</span> IteratorElType&lt;1&gt;::val_t val_t;
<a name="l00148"></a>00148     <span class="keyword">mutable</span> val_t elem_;
<a name="l00149"></a>00149     
<a name="l00150"></a>00150     <span class="comment">// constructor creating iterator </span>
<a name="l00151"></a>00151     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Gr<span class="keywordtype">id</span>Imp&gt; 
<a name="l00152"></a>00152     ALU3dGridLevelIteratorWrapper (<span class="keyword">const</span> GridImp &amp; grid, <span class="keywordtype">int</span> level , <span class="keyword">const</span> <span class="keywordtype">int</span> nlinks ) 
<a name="l00153"></a>00153       : it_(grid.myGrid() , level ) 
<a name="l00154"></a>00154       , elem_(0,0)
<a name="l00155"></a>00155       {}
<a name="l00156"></a>00156     
<a name="l00157"></a>00157     <span class="comment">// copy constructor </span>
<a name="l00158"></a>00158     ALU3dGridLevelIteratorWrapper (<span class="keyword">const</span> ALU3dGridLevelIteratorWrapper &amp; org )
<a name="l00159"></a>00159       : it_( org.it_ ), elem_(org.elem_) 
<a name="l00160"></a>00160     {
<a name="l00161"></a>00161     }
<a name="l00162"></a>00162 
<a name="l00163"></a>00163     <span class="keywordtype">int</span> size  ()    { <span class="keywordflow">return</span> it_-&gt;size(); }
<a name="l00164"></a>00164     <span class="keywordtype">void</span> next ()    { it_-&gt;next();  }
<a name="l00165"></a>00165     <span class="keywordtype">void</span> first()    { it_-&gt;first(); }
<a name="l00166"></a>00166     <span class="keywordtype">int</span> done ()<span class="keyword"> const     </span>{ <span class="keywordflow">return</span> it_-&gt;done(); }
<a name="l00167"></a>00167     val_t &amp; item ()<span class="keyword"> const </span>
<a name="l00168"></a>00168 <span class="keyword">    </span>{ 
<a name="l00169"></a>00169       assert( ! done () );
<a name="l00170"></a>00170       elem_.first  = &amp; it_-&gt;item(); 
<a name="l00171"></a>00171       <span class="keywordflow">return</span> elem_; 
<a name="l00172"></a>00172     }
<a name="l00173"></a>00173   };
<a name="l00174"></a>00174   <span class="comment">// the vertex level iterator, little bit different to the others </span>
<a name="l00175"></a>00175   <span class="comment">// this implementation uses the vertex leaf iterator and runs over all</span>
<a name="l00176"></a>00176   <span class="comment">// vertices with level &lt;= the given iteration level </span>
<a name="l00177"></a>00177   <span class="keyword">template</span> &lt;PartitionIteratorType pitype&gt;
<a name="l00178"></a>00178   <span class="keyword">class </span>ALU3dGridLevelIteratorWrapper&lt;3,pitype&gt;
<a name="l00179"></a>00179     : <span class="keyword">public</span> IteratorWrapperInterface&lt; typename IteratorElType&lt;3&gt;::val_t &gt;
<a name="l00180"></a>00180   {
<a name="l00181"></a>00181     <span class="keyword">typedef</span> VertexListType :: IteratorType IteratorType;
<a name="l00182"></a>00182 
<a name="l00183"></a>00183     VertexListType &amp; vxList_;
<a name="l00184"></a>00184     
<a name="l00185"></a>00185     <span class="keyword">mutable</span> <span class="keywordtype">int</span> count_;
<a name="l00186"></a>00186     <span class="keyword">const</span> <span class="keywordtype">int</span> size_;
<a name="l00187"></a>00187   <span class="keyword">public</span>:
<a name="l00188"></a>00188     <span class="keyword">typedef</span> IteratorElType&lt;3&gt;::val_t val_t;
<a name="l00189"></a>00189     <span class="keyword">mutable</span> val_t elem_;
<a name="l00190"></a>00190     
<a name="l00191"></a>00191     <span class="comment">// constructor creating iterator </span>
<a name="l00192"></a>00192     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Gr<span class="keywordtype">id</span>Imp&gt; 
<a name="l00193"></a>00193     ALU3dGridLevelIteratorWrapper (<span class="keyword">const</span> GridImp &amp; grid, <span class="keywordtype">int</span> level , <span class="keyword">const</span> <span class="keywordtype">int</span> nlinks ) 
<a name="l00194"></a>00194       : vxList_ (grid.getVertexList(level))
<a name="l00195"></a>00195       , count_(0)
<a name="l00196"></a>00196       , size_(vxList_.size())
<a name="l00197"></a>00197       , elem_(0,0)
<a name="l00198"></a>00198     {
<a name="l00199"></a>00199       assert( vxList_.up2Date() );
<a name="l00200"></a>00200     }
<a name="l00201"></a>00201   
<a name="l00202"></a>00202     <span class="comment">// copy constructor </span>
<a name="l00203"></a>00203     ALU3dGridLevelIteratorWrapper (<span class="keyword">const</span> ALU3dGridLevelIteratorWrapper &amp; org )
<a name="l00204"></a>00204       : vxList_(org.vxList_) , count_(org.count_) , size_(org.size_) 
<a name="l00205"></a>00205       , elem_(org.elem_) 
<a name="l00206"></a>00206     {
<a name="l00207"></a>00207     }
<a name="l00208"></a>00208 
<a name="l00209"></a>00209     <span class="comment">// returns size of leaf iterator, wrong here, return leaf size </span>
<a name="l00210"></a>00210     <span class="keywordtype">int</span> size  ()  { <span class="keywordflow">return</span> size_; }
<a name="l00211"></a>00211 
<a name="l00213"></a>00213     <span class="keywordtype">void</span> next ()    
<a name="l00214"></a>00214     {
<a name="l00215"></a>00215       <span class="keywordflow">if</span>( done () ) return ; 
<a name="l00216"></a>00216       ++count_;
<a name="l00217"></a>00217       return ;
<a name="l00218"></a>00218     }
<a name="l00219"></a>00219 
<a name="l00220"></a>00220     <span class="keywordtype">void</span> first()  { count_ = 0; }
<a name="l00221"></a>00221     <span class="keywordtype">int</span> done ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> (count_ &gt;= size_) ? 1 : 0; }
<a name="l00222"></a>00222     val_t &amp; item ()<span class="keyword"> const </span>
<a name="l00223"></a>00223 <span class="keyword">    </span>{ 
<a name="l00224"></a>00224       assert( ! done () );
<a name="l00225"></a>00225       elem_.first = vxList_.getItemList()[count_]; 
<a name="l00226"></a>00226       assert( elem_.first );
<a name="l00227"></a>00227       <span class="keywordflow">return</span> elem_;
<a name="l00228"></a>00228     }
<a name="l00229"></a>00229   };
<a name="l00230"></a>00230  
<a name="l00231"></a>00231   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> codim, PartitionIteratorType pitype&gt; <span class="keyword">class </span>ALU3dGridLeafIteratorWrapper;
<a name="l00232"></a>00232   <span class="keyword">typedef</span> pair &lt;ALUHElementType&lt;0&gt;::ElementType * , HBndSegType * &gt; LeafValType;
<a name="l00233"></a>00233   <span class="keyword">typedef</span> IteratorWrapperInterface&lt;LeafValType&gt; IteratorWrapperInterfaceType;
<a name="l00234"></a>00234 
<a name="l00235"></a>00235   <span class="comment">//**********************************************************</span>
<a name="l00236"></a>00236   <span class="comment">//  LeafIterator Wrapper </span>
<a name="l00237"></a>00237   <span class="comment">//**********************************************************</span>
<a name="l00238"></a>00238   <span class="keyword">template</span> &lt;PartitionIteratorType pitype&gt;
<a name="l00239"></a>00239   <span class="keyword">class </span>ALU3dGridLeafIteratorWrapper&lt;0,pitype&gt; 
<a name="l00240"></a>00240     : <span class="keyword">public</span> IteratorWrapperInterface&lt; typename IteratorElType&lt;0&gt;::val_t &gt;
<a name="l00241"></a>00241   {
<a name="l00242"></a>00242     <span class="comment">// type is helement_STI </span>
<a name="l00243"></a>00243     <span class="keyword">typedef</span> IteratorElType&lt;0&gt;::ElType ElType; 
<a name="l00244"></a>00244     <span class="keyword">typedef</span> LeafIterator &lt; ElType &gt; IteratorType;
<a name="l00245"></a>00245 
<a name="l00246"></a>00246     <span class="comment">// the ALU3dGrid Iterator </span>
<a name="l00247"></a>00247     IteratorType it_;
<a name="l00248"></a>00248 
<a name="l00249"></a>00249   <span class="keyword">public</span>:
<a name="l00250"></a>00250     <span class="keyword">typedef</span> <span class="keyword">typename</span> IteratorElType&lt;0&gt;::val_t val_t;
<a name="l00251"></a>00251   <span class="keyword">private</span>:
<a name="l00252"></a>00252     <span class="keyword">mutable</span> val_t elem_;
<a name="l00253"></a>00253   <span class="keyword">public</span>:
<a name="l00254"></a>00254     <span class="comment">// constructor creating Iterator </span>
<a name="l00255"></a>00255     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Gr<span class="keywordtype">id</span>Imp&gt; 
<a name="l00256"></a>00256     ALU3dGridLeafIteratorWrapper (<span class="keyword">const</span> GridImp &amp; grid, <span class="keywordtype">int</span> level, <span class="keyword">const</span> <span class="keywordtype">int</span> links )
<a name="l00257"></a>00257       : it_(grid.myGrid()), elem_(0,0) {}
<a name="l00258"></a>00258 
<a name="l00259"></a>00259     <span class="comment">// constructor copying iterator </span>
<a name="l00260"></a>00260     ALU3dGridLeafIteratorWrapper (<span class="keyword">const</span> ALU3dGridLeafIteratorWrapper  &amp; org )
<a name="l00261"></a>00261       : it_( org.it_ ), elem_(org.elem_) 
<a name="l00262"></a>00262     {
<a name="l00263"></a>00263     }
<a name="l00264"></a>00264 
<a name="l00265"></a>00265     <span class="keywordtype">int</span> size  ()    { <span class="keywordflow">return</span> it_-&gt;size(); }
<a name="l00266"></a>00266     <span class="keywordtype">void</span> next ()    { it_-&gt;next(); }
<a name="l00267"></a>00267     <span class="keywordtype">void</span> first()    { it_-&gt;first(); }
<a name="l00268"></a>00268     <span class="keywordtype">int</span> done ()<span class="keyword"> const     </span>{ <span class="keywordflow">return</span> it_-&gt;done(); }
<a name="l00269"></a>00269     val_t &amp; item ()<span class="keyword"> const </span>
<a name="l00270"></a>00270 <span class="keyword">    </span>{ 
<a name="l00271"></a>00271       assert( ! done () );
<a name="l00272"></a>00272       elem_.first  = &amp; it_-&gt;item(); 
<a name="l00273"></a>00273       <span class="keywordflow">return</span> elem_; 
<a name="l00274"></a>00274     }
<a name="l00275"></a>00275   };
<a name="l00276"></a>00276 
<a name="l00277"></a>00277   <span class="keyword">template</span> &lt;<span class="keyword">class</span> ElType, PartitionIteratorType pitype&gt; 
<a name="l00278"></a>00278   <span class="keyword">struct </span>LeafStopRule
<a name="l00279"></a>00279   {
<a name="l00280"></a>00280     <span class="keyword">typedef</span> is_leaf_entity&lt; ElType &gt; StopRule_t;
<a name="l00281"></a>00281   };
<a name="l00282"></a>00282 
<a name="l00283"></a>00283   <span class="comment">// only in parallel we need only the interior items, in serial all items</span>
<a name="l00284"></a>00284   <span class="comment">// are interior, to make the check fasterm this is only in parallel</span>
<a name="l00285"></a>00285   <span class="comment">// implemented </span>
<a name="l00286"></a>00286 <span class="preprocessor">#if ALU3DGRID_PARALLEL</span>
<a name="l00287"></a>00287 <span class="preprocessor"></span>  <span class="keyword">template</span> &lt;<span class="keyword">class</span> ElType&gt; 
<a name="l00288"></a>00288   <span class="keyword">struct </span>LeafStopRule&lt;ElType, Dune :: <a class="code" href="a00492.html#gga5b9e8102d7f70f3f4178182629d98b6842081c435caefdae9580c93720e35b0" title="only interior entities">Interior_Partition</a>&gt;
<a name="l00289"></a>00289   {
<a name="l00290"></a>00290     <span class="keyword">typedef</span> is_interior_leaf_entity&lt; ElType &gt; StopRule_t;
<a name="l00291"></a>00291   };
<a name="l00292"></a>00292 <span class="preprocessor">#endif</span>
<a name="l00293"></a>00293 <span class="preprocessor"></span>
<a name="l00294"></a>00294   <span class="keyword">template</span> &lt;PartitionIteratorType pitype&gt;
<a name="l00295"></a>00295   <span class="keyword">class </span>ALU3dGridLeafIteratorWrapper&lt;1,pitype&gt; 
<a name="l00296"></a>00296     : <span class="keyword">public</span> IteratorWrapperInterface &lt; typename IteratorElType&lt;1&gt;::val_t &gt; 
<a name="l00297"></a>00297   {
<a name="l00298"></a>00298     <span class="comment">// type is hface_STI </span>
<a name="l00299"></a>00299     <span class="keyword">typedef</span> IteratorElType&lt;1&gt;::ElType ElType; 
<a name="l00300"></a>00300     <span class="keyword">typedef</span> <span class="keyword">typename</span> LeafStopRule&lt; ElType, pitype &gt; :: StopRule_t StopRule_t;
<a name="l00301"></a>00301     <span class="keyword">typedef</span> GridIterator &lt; ElType , StopRule_t &gt; IteratorType;
<a name="l00302"></a>00302 
<a name="l00303"></a>00303     <span class="comment">// the face iterator </span>
<a name="l00304"></a>00304     IteratorType it_;
<a name="l00305"></a>00305 
<a name="l00306"></a>00306   <span class="keyword">public</span>:
<a name="l00307"></a>00307     <span class="keyword">typedef</span> IteratorElType&lt;1&gt;::val_t val_t;
<a name="l00308"></a>00308   <span class="keyword">private</span>:
<a name="l00309"></a>00309     <span class="keyword">mutable</span> val_t elem_;
<a name="l00310"></a>00310   <span class="keyword">public</span>:  
<a name="l00311"></a>00311     <span class="comment">// constructor creating Iterator </span>
<a name="l00312"></a>00312     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Gr<span class="keywordtype">id</span>Imp&gt; 
<a name="l00313"></a>00313     ALU3dGridLeafIteratorWrapper (<span class="keyword">const</span> GridImp &amp; grid, <span class="keywordtype">int</span> level, <span class="keyword">const</span> <span class="keywordtype">int</span> links )
<a name="l00314"></a>00314       : it_(grid.myGrid(), StopRule_t() ) , elem_(0,0) {}
<a name="l00315"></a>00315 
<a name="l00316"></a>00316     <span class="comment">// constructor copying iterator </span>
<a name="l00317"></a>00317     ALU3dGridLeafIteratorWrapper (<span class="keyword">const</span> ALU3dGridLeafIteratorWrapper  &amp; org )
<a name="l00318"></a>00318       : it_( org.it_ ), elem_(org.elem_) {}
<a name="l00319"></a>00319 
<a name="l00320"></a>00320     ~ALU3dGridLeafIteratorWrapper ()
<a name="l00321"></a>00321     {
<a name="l00322"></a>00322     }
<a name="l00323"></a>00323 
<a name="l00324"></a>00324     <span class="keywordtype">int</span> size  ()    { <span class="keywordflow">return</span> it_-&gt;size(); }
<a name="l00325"></a>00325     <span class="keywordtype">void</span> next ()    { it_-&gt;next(); }
<a name="l00326"></a>00326     <span class="keywordtype">void</span> first()    { it_-&gt;first(); }
<a name="l00327"></a>00327     <span class="keywordtype">int</span> done ()<span class="keyword"> const     </span>{ <span class="keywordflow">return</span> it_-&gt;done(); }
<a name="l00328"></a>00328     val_t &amp; item ()<span class="keyword"> const </span>
<a name="l00329"></a>00329 <span class="keyword">    </span>{ 
<a name="l00330"></a>00330       assert( ! done () );
<a name="l00331"></a>00331       elem_.first  = &amp; it_-&gt;item(); 
<a name="l00332"></a>00332       <span class="keywordflow">return</span> elem_; 
<a name="l00333"></a>00333     }
<a name="l00334"></a>00334   };
<a name="l00335"></a>00335 
<a name="l00336"></a>00336   <span class="keyword">template</span> &lt;PartitionIteratorType pitype&gt;
<a name="l00337"></a>00337   <span class="keyword">class </span>ALU3dGridLeafIteratorWrapper&lt;2,pitype&gt; 
<a name="l00338"></a>00338     : <span class="keyword">public</span> IteratorWrapperInterface &lt; typename IteratorElType&lt;2&gt;::val_t &gt; 
<a name="l00339"></a>00339   {
<a name="l00340"></a>00340     <span class="comment">// type of hedge_STI </span>
<a name="l00341"></a>00341     <span class="keyword">typedef</span> IteratorElType&lt;2&gt;::ElType ElType;
<a name="l00342"></a>00342     <span class="keyword">typedef</span> <span class="keyword">typename</span> LeafStopRule&lt; ElType, pitype &gt; :: StopRule_t StopRule_t;
<a name="l00343"></a>00343     <span class="keyword">typedef</span> GridIterator &lt; ElType , StopRule_t &gt; IteratorType;
<a name="l00344"></a>00344 
<a name="l00345"></a>00345   <span class="keyword">public</span>:
<a name="l00346"></a>00346     <span class="keyword">typedef</span> IteratorElType&lt;2&gt;::val_t val_t;
<a name="l00347"></a>00347   <span class="keyword">private</span>:
<a name="l00348"></a>00348     <span class="comment">// the edge iterator </span>
<a name="l00349"></a>00349     IteratorType it_;
<a name="l00350"></a>00350     
<a name="l00351"></a>00351     <span class="keyword">mutable</span> val_t elem_;
<a name="l00352"></a>00352   <span class="keyword">public</span>:
<a name="l00353"></a>00353     <span class="comment">// constructor creating Iterator </span>
<a name="l00354"></a>00354     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Gr<span class="keywordtype">id</span>Imp&gt; 
<a name="l00355"></a>00355     ALU3dGridLeafIteratorWrapper (<span class="keyword">const</span> GridImp &amp; grid, <span class="keywordtype">int</span> level, <span class="keyword">const</span> <span class="keywordtype">int</span> links )
<a name="l00356"></a>00356       : it_(grid.myGrid(), StopRule_t() ), elem_(0,0) {}
<a name="l00357"></a>00357 
<a name="l00358"></a>00358     <span class="comment">// constructor copying iterator </span>
<a name="l00359"></a>00359     ALU3dGridLeafIteratorWrapper (<span class="keyword">const</span> ALU3dGridLeafIteratorWrapper  &amp; org )
<a name="l00360"></a>00360       : it_( org.it_ ), elem_(org.elem_) {}
<a name="l00361"></a>00361 
<a name="l00362"></a>00362     <span class="keywordtype">int</span> size  ()      { <span class="keywordflow">return</span> it_-&gt;size(); }
<a name="l00363"></a>00363     <span class="keywordtype">void</span> next ()      { it_-&gt;next(); }
<a name="l00364"></a>00364     <span class="keywordtype">void</span> first()      { it_-&gt;first(); }
<a name="l00365"></a>00365     <span class="keywordtype">int</span> done ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> it_-&gt;done(); }
<a name="l00366"></a>00366     val_t &amp; item ()<span class="keyword"> const </span>
<a name="l00367"></a>00367 <span class="keyword">    </span>{ 
<a name="l00368"></a>00368       assert( ! done () );
<a name="l00369"></a>00369       elem_.first  = &amp; it_-&gt;item(); 
<a name="l00370"></a>00370       <span class="keywordflow">return</span> elem_; 
<a name="l00371"></a>00371     }
<a name="l00372"></a>00372   };
<a name="l00373"></a>00373 
<a name="l00374"></a>00374 
<a name="l00375"></a>00375   <span class="comment">// the vertex leaf iterator, little bit different to the others </span>
<a name="l00376"></a>00376   <span class="keyword">template</span> &lt;PartitionIteratorType pitype&gt;
<a name="l00377"></a>00377   <span class="keyword">class </span>ALU3dGridLeafIteratorWrapper&lt;3,pitype&gt;
<a name="l00378"></a>00378     : <span class="keyword">public</span> IteratorWrapperInterface&lt; typename IteratorElType&lt;3&gt;::val_t &gt;
<a name="l00379"></a>00379   {
<a name="l00380"></a>00380     <span class="keyword">typedef</span> LeafVertexListType :: IteratorType IteratorType;
<a name="l00381"></a>00381     <span class="keyword">typedef</span> LeafVertexListType :: ItemType VxItemType;
<a name="l00382"></a>00382     <span class="keyword">typedef</span> IteratorElType&lt;3&gt;::ElType ElType;
<a name="l00383"></a>00383     <span class="keyword">typedef</span> <span class="keyword">typename</span> LeafStopRule&lt; ElType, pitype &gt; :: StopRule_t StopRule_t;
<a name="l00384"></a>00384 
<a name="l00385"></a>00385     LeafVertexListType &amp; vxList_;
<a name="l00386"></a>00386     <span class="keyword">typedef</span> <span class="keyword">typename</span> LeafVertexListType :: IteratorType ListIteratorType;
<a name="l00387"></a>00387     
<a name="l00388"></a>00388     <span class="keyword">mutable</span> <span class="keywordtype">int</span> count_;
<a name="l00389"></a>00389     <span class="keyword">const</span> <span class="keywordtype">int</span> size_;
<a name="l00390"></a>00390 
<a name="l00391"></a>00391   <span class="keyword">public</span>:
<a name="l00392"></a>00392     <span class="keyword">typedef</span> IteratorElType&lt;3&gt;::val_t val_t;
<a name="l00393"></a>00393     <span class="keyword">mutable</span> val_t elem_;
<a name="l00394"></a>00394     <span class="keyword">const</span> StopRule_t rule_;
<a name="l00395"></a>00395     
<a name="l00396"></a>00396     <span class="comment">// constructor creating iterator </span>
<a name="l00397"></a>00397     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Gr<span class="keywordtype">id</span>Imp&gt; 
<a name="l00398"></a>00398     ALU3dGridLeafIteratorWrapper (<span class="keyword">const</span> GridImp &amp; grid, <span class="keywordtype">int</span> level , <span class="keyword">const</span> <span class="keywordtype">int</span> nlinks ) 
<a name="l00399"></a>00399       : vxList_ (grid.getLeafVertexList())
<a name="l00400"></a>00400       , count_(0)
<a name="l00401"></a>00401       , size_(vxList_.size())
<a name="l00402"></a>00402       , elem_(0,0)
<a name="l00403"></a>00403       , rule_()
<a name="l00404"></a>00404     {
<a name="l00405"></a>00405       assert( vxList_.up2Date() );
<a name="l00406"></a>00406     }
<a name="l00407"></a>00407   
<a name="l00408"></a>00408     <span class="comment">// copy constructor </span>
<a name="l00409"></a>00409     ALU3dGridLeafIteratorWrapper (<span class="keyword">const</span> ALU3dGridLeafIteratorWrapper &amp; org )
<a name="l00410"></a>00410       : vxList_(org.vxList_) 
<a name="l00411"></a>00411       , count_(org.count_) , size_(org.size_) 
<a name="l00412"></a>00412       , elem_(org.elem_) 
<a name="l00413"></a>00413       , rule_()
<a name="l00414"></a>00414     {
<a name="l00415"></a>00415     }
<a name="l00416"></a>00416 
<a name="l00417"></a>00417     <span class="comment">// returns size of leaf iterator, wrong here, return leaf size </span>
<a name="l00418"></a>00418     <span class="keywordtype">int</span> size  ()  { <span class="keywordflow">return</span> size_; }
<a name="l00419"></a>00419 
<a name="l00421"></a>00421     <span class="keywordtype">void</span> next ()    
<a name="l00422"></a>00422     {
<a name="l00423"></a>00423       ++count_;
<a name="l00424"></a>00424       goNextValid();
<a name="l00425"></a>00425       return ;
<a name="l00426"></a>00426     }
<a name="l00427"></a>00427 
<a name="l00428"></a>00428     <span class="keywordtype">void</span> first()  
<a name="l00429"></a>00429     { 
<a name="l00430"></a>00430       count_ = 0;
<a name="l00431"></a>00431       goNextValid();
<a name="l00432"></a>00432     }
<a name="l00433"></a>00433     <span class="keywordtype">int</span> done ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> (count_ &gt;= size_) ? 1 : 0; }
<a name="l00434"></a>00434     val_t &amp; item ()<span class="keyword"> const </span>
<a name="l00435"></a>00435 <span class="keyword">    </span>{ 
<a name="l00436"></a>00436       assert( ! done () );
<a name="l00437"></a>00437       assert( elem_.first );
<a name="l00438"></a>00438       <span class="keywordflow">return</span> elem_;
<a name="l00439"></a>00439     }
<a name="l00440"></a>00440   <span class="keyword">private</span>:
<a name="l00441"></a>00441     val_t &amp; getItem ()<span class="keyword"> const </span>
<a name="l00442"></a>00442 <span class="keyword">    </span>{ 
<a name="l00443"></a>00443       <span class="comment">//elem_.first = vxList_.getItemList()[count_].first; </span>
<a name="l00444"></a>00444       assert( ! done () );
<a name="l00445"></a>00445       elem_.first = vxList_.getItemList()[count_].first; 
<a name="l00446"></a>00446       <span class="keywordflow">return</span> elem_;
<a name="l00447"></a>00447     }
<a name="l00448"></a>00448     <span class="keywordtype">void</span> goNextValid() 
<a name="l00449"></a>00449     {
<a name="l00450"></a>00450       <span class="keywordflow">if</span>( done() ) return ;
<a name="l00451"></a>00451       <span class="keywordflow">if</span>( getItem().first == 0) 
<a name="l00452"></a>00452       {
<a name="l00453"></a>00453         ++count_; 
<a name="l00454"></a>00454         goNextValid();
<a name="l00455"></a>00455       }
<a name="l00456"></a>00456       <span class="keywordflow">else</span> 
<a name="l00457"></a>00457       {
<a name="l00458"></a>00458         assert( elem_.first );
<a name="l00459"></a>00459         <span class="keywordflow">if</span>(! rule_( elem_.first ) ) 
<a name="l00460"></a>00460         {
<a name="l00461"></a>00461           ++count_;
<a name="l00462"></a>00462           goNextValid();
<a name="l00463"></a>00463         }
<a name="l00464"></a>00464       }
<a name="l00465"></a>00465     }
<a name="l00466"></a>00466   };
<a name="l00467"></a>00467  
<a name="l00468"></a>00468   <span class="comment">/*</span>
<a name="l00469"></a>00469 <span class="comment">  template &lt;PartitionIteratorType pitype&gt;</span>
<a name="l00470"></a>00470 <span class="comment">  class ALU3dGridLeafIteratorWrapper&lt;3,pitype&gt; </span>
<a name="l00471"></a>00471 <span class="comment">    : public IteratorWrapperInterface &lt; typename IteratorElType&lt;3&gt;::val_t &gt; </span>
<a name="l00472"></a>00472 <span class="comment">  {</span>
<a name="l00473"></a>00473 <span class="comment">    typedef IteratorElType&lt;3&gt;::ElType ElType;</span>
<a name="l00474"></a>00474 <span class="comment">    typedef typename LeafStopRule&lt; ElType, pitype &gt; :: StopRule_t StopRule_t;</span>
<a name="l00475"></a>00475 <span class="comment">    // ElType is vertex_STI </span>
<a name="l00476"></a>00476 <span class="comment">    typedef LeafIterator &lt; ElType &gt; IteratorType;</span>
<a name="l00477"></a>00477 <span class="comment"></span>
<a name="l00478"></a>00478 <span class="comment">    // the vertex iterator </span>
<a name="l00479"></a>00479 <span class="comment">    IteratorType it_;</span>
<a name="l00480"></a>00480 <span class="comment">  </span>
<a name="l00481"></a>00481 <span class="comment">  public:</span>
<a name="l00482"></a>00482 <span class="comment">    typedef IteratorElType&lt;3&gt;::val_t val_t;</span>
<a name="l00483"></a>00483 <span class="comment">  private:  </span>
<a name="l00484"></a>00484 <span class="comment">    mutable val_t elem_;</span>
<a name="l00485"></a>00485 <span class="comment">    const StopRule_t rule_;</span>
<a name="l00486"></a>00486 <span class="comment">  public:</span>
<a name="l00487"></a>00487 <span class="comment">    // constructor creating Iterator </span>
<a name="l00488"></a>00488 <span class="comment">    template &lt;class GridImp&gt; </span>
<a name="l00489"></a>00489 <span class="comment">    ALU3dGridLeafIteratorWrapper (const GridImp &amp; grid, int level, const int links )</span>
<a name="l00490"></a>00490 <span class="comment">      : it_(grid.myGrid()), elem_(0,0) , rule_ () {}</span>
<a name="l00491"></a>00491 <span class="comment"></span>
<a name="l00492"></a>00492 <span class="comment">    // constructor copying iterator </span>
<a name="l00493"></a>00493 <span class="comment">    ALU3dGridLeafIteratorWrapper (const ALU3dGridLeafIteratorWrapper  &amp; org )</span>
<a name="l00494"></a>00494 <span class="comment">      : it_( org.it_ ), elem_(org.elem_) , rule_() {}</span>
<a name="l00495"></a>00495 <span class="comment"></span>
<a name="l00496"></a>00496 <span class="comment">    int size  ()    { return it_-&gt;size(); }</span>
<a name="l00497"></a>00497 <span class="comment">    </span>
<a name="l00498"></a>00498 <span class="comment">    void next ()    </span>
<a name="l00499"></a>00499 <span class="comment">    { </span>
<a name="l00500"></a>00500 <span class="comment">      it_-&gt;next(); </span>
<a name="l00501"></a>00501 <span class="comment">      if (!it_-&gt;done()) </span>
<a name="l00502"></a>00502 <span class="comment">      {</span>
<a name="l00503"></a>00503 <span class="comment">        // take standard walk rule to cehck vertices again, see walk.h</span>
<a name="l00504"></a>00504 <span class="comment">        if(! rule_(it_-&gt;item()) ) next();</span>
<a name="l00505"></a>00505 <span class="comment">      } </span>
<a name="l00506"></a>00506 <span class="comment">    }</span>
<a name="l00507"></a>00507 <span class="comment">    </span>
<a name="l00508"></a>00508 <span class="comment">    void first()     { it_-&gt;first(); }</span>
<a name="l00509"></a>00509 <span class="comment">    int done () const{ return it_-&gt;done(); }</span>
<a name="l00510"></a>00510 <span class="comment">    val_t &amp; item () const </span>
<a name="l00511"></a>00511 <span class="comment">    { </span>
<a name="l00512"></a>00512 <span class="comment">      assert( ! done () );</span>
<a name="l00513"></a>00513 <span class="comment">      elem_.first  = &amp; it_-&gt;item(); </span>
<a name="l00514"></a>00514 <span class="comment">      return elem_; </span>
<a name="l00515"></a>00515 <span class="comment">    }</span>
<a name="l00516"></a>00516 <span class="comment">  };</span>
<a name="l00517"></a>00517 <span class="comment">  */</span>
<a name="l00518"></a>00518 
<a name="l00519"></a>00519 <span class="preprocessor">#if ALU3DGRID_PARALLEL</span>
<a name="l00520"></a>00520 <span class="preprocessor"></span>  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> codim&gt;
<a name="l00521"></a>00521   <span class="keyword">class </span>LeafLevelIteratorTTProxy 
<a name="l00522"></a>00522   {
<a name="l00523"></a>00523     <span class="comment">// type is hface_STI or hedge_STI </span>
<a name="l00524"></a>00524     <span class="keyword">typedef</span> <span class="keyword">typename</span> ALUHElementType&lt;codim&gt;::ElementType ElType; 
<a name="l00525"></a>00525 
<a name="l00526"></a>00526     <span class="keyword">typedef</span> IteratorSTI &lt; ElType &gt; IteratorType; 
<a name="l00527"></a>00527     IteratorType * inner_;
<a name="l00528"></a>00528     IteratorType * outer_;
<a name="l00529"></a>00529   <span class="keyword">public</span>:
<a name="l00530"></a>00530 
<a name="l00531"></a>00531     <span class="comment">// constructor creating leafBorderIteratorTT </span>
<a name="l00532"></a>00532     LeafLevelIteratorTTProxy( GitterImplType &amp; gitter , <span class="keywordtype">int</span> link ) 
<a name="l00533"></a>00533     {
<a name="l00534"></a>00534       pair &lt; IteratorSTI&lt; ElType &gt; * , IteratorSTI&lt; ElType &gt; * &gt; 
<a name="l00535"></a>00535         p = gitter.leafBorderIteratorTT( (ElType *) 0 , link );
<a name="l00536"></a>00536       
<a name="l00537"></a>00537       inner_ = p.first;
<a name="l00538"></a>00538       outer_ = p.second; 
<a name="l00539"></a>00539     }
<a name="l00540"></a>00540 
<a name="l00541"></a>00541     <span class="comment">// constructor creating levelBorderIteratorTT </span>
<a name="l00542"></a>00542     LeafLevelIteratorTTProxy( GitterImplType &amp; gitter , <span class="keywordtype">int</span> link , <span class="keywordtype">int</span> level ) 
<a name="l00543"></a>00543     {
<a name="l00544"></a>00544       pair &lt; IteratorSTI&lt; ElType &gt; * , IteratorSTI&lt; ElType &gt; * &gt; 
<a name="l00545"></a>00545         p = gitter.levelBorderIteratorTT( (ElType *) 0 , link , level );
<a name="l00546"></a>00546       
<a name="l00547"></a>00547       inner_ = p.first;
<a name="l00548"></a>00548       outer_ = p.second; 
<a name="l00549"></a>00549     }
<a name="l00550"></a>00550 
<a name="l00551"></a>00551     LeafLevelIteratorTTProxy( <span class="keyword">const</span> LeafLevelIteratorTTProxy &amp; org ) 
<a name="l00552"></a>00552       : inner_(org.inner_-&gt;clone())
<a name="l00553"></a>00553       , outer_(org.outer_-&gt;clone())
<a name="l00554"></a>00554       {}
<a name="l00555"></a>00555 
<a name="l00556"></a>00556     ~LeafLevelIteratorTTProxy() 
<a name="l00557"></a>00557     {
<a name="l00558"></a>00558       <span class="keyword">delete</span> inner_;
<a name="l00559"></a>00559       <span class="keyword">delete</span> outer_;
<a name="l00560"></a>00560     }
<a name="l00561"></a>00561 
<a name="l00562"></a>00562     IteratorType &amp; inner () { assert(inner_); <span class="keywordflow">return</span> *inner_; }
<a name="l00563"></a>00563     IteratorType &amp; outer () { assert(outer_); <span class="keywordflow">return</span> *outer_; }
<a name="l00564"></a>00564   };
<a name="l00565"></a>00565  
<a name="l00566"></a>00566   <span class="comment">//****************************</span>
<a name="l00567"></a>00567   <span class="comment">//</span>
<a name="l00568"></a>00568   <span class="comment">//  --GhostIterator </span>
<a name="l00569"></a>00569   <span class="comment">//</span>
<a name="l00570"></a>00570   <span class="comment">//****************************</span>
<a name="l00571"></a>00571   <span class="keyword">class </span>ALU3dGridGhostIterator
<a name="l00572"></a>00572     : <span class="keyword">public</span> IteratorWrapperInterface&lt; LeafValType &gt;
<a name="l00573"></a>00573   { 
<a name="l00574"></a>00574   <span class="keyword">protected</span>:  
<a name="l00575"></a>00575     GitterImplType &amp; gitter_; 
<a name="l00576"></a>00576 
<a name="l00577"></a>00577     <span class="comment">// this tpye is hface_STI</span>
<a name="l00578"></a>00578     <span class="keyword">typedef</span> ALUHElementType&lt;1&gt;::ElementType ElType;
<a name="l00579"></a>00579     
<a name="l00580"></a>00580     <span class="keyword">typedef</span> LeafLevelIteratorTTProxy&lt;1&gt; IteratorType;
<a name="l00581"></a>00581 
<a name="l00582"></a>00582     IteratorType * iterTT_;
<a name="l00583"></a>00583       
<a name="l00584"></a>00584     <span class="keyword">typedef</span> IteratorSTI &lt; ElType &gt; InnerIteratorType;
<a name="l00585"></a>00585     InnerIteratorType * it_;
<a name="l00586"></a>00586 
<a name="l00587"></a>00587     <span class="comment">// number of links </span>
<a name="l00588"></a>00588     <span class="keyword">const</span> <span class="keywordtype">int</span> nl_;
<a name="l00589"></a>00589   
<a name="l00590"></a>00590     <span class="comment">// current link </span>
<a name="l00591"></a>00591     <span class="keywordtype">int</span> link_;
<a name="l00592"></a>00592 
<a name="l00593"></a>00593     <span class="keywordtype">bool</span> usingInner_;
<a name="l00594"></a>00594   <span class="keyword">public</span>:
<a name="l00595"></a>00595     <span class="keyword">typedef</span> LeafValType val_t;
<a name="l00596"></a>00596   <span class="keyword">private</span>:
<a name="l00597"></a>00597     <span class="comment">// the pair of elementand boundary face </span>
<a name="l00598"></a>00598     <span class="keyword">mutable</span> val_t elem_;
<a name="l00599"></a>00599   <span class="keyword">public</span>:
<a name="l00600"></a>00600     <span class="keyword">typedef</span> ElementPllXIF_t ItemType;
<a name="l00601"></a>00601 
<a name="l00602"></a>00602     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Gr<span class="keywordtype">id</span>Imp&gt;
<a name="l00603"></a>00603     ALU3dGridGhostIterator (<span class="keyword">const</span> GridImp &amp; grid, <span class="keywordtype">int</span> level , <span class="keyword">const</span> <span class="keywordtype">int</span> nlinks )
<a name="l00604"></a>00604       : gitter_(grid.myGrid()) 
<a name="l00605"></a>00605       , iterTT_(0) , it_(0)
<a name="l00606"></a>00606       , nl_(nlinks) 
<a name="l00607"></a>00607       , link_(nlinks) <span class="comment">// makes default status == done </span>
<a name="l00608"></a>00608       , elem_(0,0)
<a name="l00609"></a>00609     {
<a name="l00610"></a>00610     }
<a name="l00611"></a>00611 
<a name="l00612"></a>00612     ALU3dGridGhostIterator (<span class="keyword">const</span> ALU3dGridGhostIterator &amp; org)
<a name="l00613"></a>00613       : gitter_(org.gitter_) 
<a name="l00614"></a>00614       , iterTT_(0) , it_(0)
<a name="l00615"></a>00615       , nl_(org.nl_)
<a name="l00616"></a>00616       , link_(org.link_) 
<a name="l00617"></a>00617       , usingInner_(false) 
<a name="l00618"></a>00618       , elem_(org.elem_)
<a name="l00619"></a>00619     {
<a name="l00620"></a>00620       <span class="keywordflow">if</span>( org.iterTT_ ) 
<a name="l00621"></a>00621       { 
<a name="l00622"></a>00622         iterTT_ = <span class="keyword">new</span> IteratorType ( *org.iterTT_ );
<a name="l00623"></a>00623         usingInner_ = org.usingInner_;
<a name="l00624"></a>00624         <span class="keywordflow">if</span>( org.it_ ) 
<a name="l00625"></a>00625         {
<a name="l00626"></a>00626           assert( ! org.it_-&gt;done() );
<a name="l00627"></a>00627           it_ = (usingInner_) ? &amp;( iterTT_-&gt;inner() ) : &amp;( iterTT_-&gt;outer() );
<a name="l00628"></a>00628         }
<a name="l00629"></a>00629       }
<a name="l00630"></a>00630     }
<a name="l00631"></a>00631 
<a name="l00632"></a>00632     ~ALU3dGridGhostIterator ()
<a name="l00633"></a>00633     {
<a name="l00634"></a>00634       removeIterators();
<a name="l00635"></a>00635     }
<a name="l00636"></a>00636 
<a name="l00637"></a>00637   <span class="keyword">protected</span>:    
<a name="l00638"></a>00638     <span class="keyword">virtual</span> IteratorType * newIterator() 
<a name="l00639"></a>00639     { 
<a name="l00640"></a>00640       <span class="keywordflow">return</span> <span class="keyword">new</span> IteratorType ( gitter_, link_ );
<a name="l00641"></a>00641     }
<a name="l00642"></a>00642     
<a name="l00643"></a>00643     <span class="keywordtype">void</span> removeIterators() 
<a name="l00644"></a>00644     {
<a name="l00645"></a>00645       <span class="keywordflow">if</span>(iterTT_) <span class="keyword">delete</span> iterTT_; 
<a name="l00646"></a>00646       iterTT_ = 0;
<a name="l00647"></a>00647       it_ = 0;
<a name="l00648"></a>00648       usingInner_ = <span class="keyword">false</span>;
<a name="l00649"></a>00649     }
<a name="l00650"></a>00650 
<a name="l00651"></a>00651     <span class="keywordtype">void</span> createIterator()
<a name="l00652"></a>00652     {
<a name="l00653"></a>00653       <span class="keywordflow">if</span> (usingInner_) checkInnerOuter();
<a name="l00654"></a>00654 
<a name="l00655"></a>00655       <span class="keywordflow">if</span> (!usingInner_)
<a name="l00656"></a>00656       {
<a name="l00657"></a>00657         ++link_;
<a name="l00658"></a>00658 
<a name="l00659"></a>00659         removeIterators();
<a name="l00660"></a>00660         <span class="keywordflow">if</span>(link_ &lt; nl_)
<a name="l00661"></a>00661         {
<a name="l00662"></a>00662           iterTT_ = newIterator();
<a name="l00663"></a>00663           assert(iterTT_);
<a name="l00664"></a>00664           checkInnerOuter();
<a name="l00665"></a>00665           <span class="keywordflow">if</span> (!it_) createIterator();
<a name="l00666"></a>00666         }
<a name="l00667"></a>00667       }
<a name="l00668"></a>00668     }
<a name="l00669"></a>00669 
<a name="l00670"></a>00670     <span class="keywordtype">void</span> checkInnerOuter()
<a name="l00671"></a>00671     {
<a name="l00672"></a>00672       it_ = 0;
<a name="l00673"></a>00673       <span class="keywordflow">if</span> (!usingInner_)
<a name="l00674"></a>00674       {
<a name="l00675"></a>00675         assert(iterTT_);
<a name="l00676"></a>00676         it_ = &amp;( iterTT_-&gt;inner() );
<a name="l00677"></a>00677         InnerIteratorType &amp; it = iterTT_-&gt;inner();
<a name="l00678"></a>00678         it.first();
<a name="l00679"></a>00679         <span class="keywordflow">if</span>(!it.done())
<a name="l00680"></a>00680         {
<a name="l00681"></a>00681           usingInner_ = <span class="keyword">true</span>;
<a name="l00682"></a>00682           pair &lt; ElementPllXIF_t *, int &gt; p = it.item ().accessPllX ().accessOuterPllX () ;
<a name="l00683"></a>00683           pair &lt; HElementType * , HBndSegType * &gt; elems(0,0);
<a name="l00684"></a>00684           p.first-&gt;getAttachedElement(elems);
<a name="l00685"></a>00685 
<a name="l00686"></a>00686           assert( elems.first || elems.second );
<a name="l00687"></a>00687 
<a name="l00688"></a>00688           <span class="keywordflow">if</span>(elems.second)
<a name="l00689"></a>00689           {
<a name="l00690"></a>00690             <span class="keywordflow">return</span>;
<a name="l00691"></a>00691           }
<a name="l00692"></a>00692         }
<a name="l00693"></a>00693       }
<a name="l00694"></a>00694 
<a name="l00695"></a>00695       usingInner_ = <span class="keyword">false</span>;
<a name="l00696"></a>00696       InnerIteratorType &amp; out = iterTT_-&gt;outer();
<a name="l00697"></a>00697       out.first();
<a name="l00698"></a>00698       <span class="keywordflow">if</span>(!out.done())
<a name="l00699"></a>00699       {
<a name="l00700"></a>00700         pair &lt; ElementPllXIF_t *, int &gt; p = out.item ().accessPllX ().accessOuterPllX () ;
<a name="l00701"></a>00701         pair &lt; HElementType * , HBndSegType * &gt; elems(0,0);
<a name="l00702"></a>00702         p.first-&gt;getAttachedElement(elems);
<a name="l00703"></a>00703 
<a name="l00704"></a>00704         assert( elems.second );
<a name="l00705"></a>00705         it_ = &amp;out;
<a name="l00706"></a>00706         return ;
<a name="l00707"></a>00707       }
<a name="l00708"></a>00708 
<a name="l00709"></a>00709       it_ = 0;
<a name="l00710"></a>00710     }
<a name="l00711"></a>00711     
<a name="l00712"></a>00712     <span class="keyword">virtual</span> <span class="keywordtype">void</span> checkLeafEntity ()
<a name="l00713"></a>00713     {
<a name="l00714"></a>00714       <span class="keywordflow">if</span>(it_)
<a name="l00715"></a>00715       {
<a name="l00716"></a>00716         <span class="keywordflow">if</span>(!it_-&gt;done())
<a name="l00717"></a>00717         {
<a name="l00718"></a>00718           val_t &amp; el = item();
<a name="l00719"></a>00719           HBndSegType * pll = el.second;
<a name="l00720"></a>00720           assert( pll );
<a name="l00721"></a>00721 
<a name="l00722"></a>00722           <span class="comment">// this occurs if internal element is leaf but the corresponding </span>
<a name="l00723"></a>00723           <span class="comment">// ghost is not leaf, we have to go next </span>
<a name="l00724"></a>00724           <span class="keywordflow">if</span> ( ! pll-&gt;isLeafEntity() ) next();
<a name="l00725"></a>00725         }
<a name="l00726"></a>00726       }
<a name="l00727"></a>00727     }
<a name="l00728"></a>00728 
<a name="l00729"></a>00729   <span class="keyword">public</span>:  
<a name="l00730"></a>00730     <span class="keywordtype">int</span> size  ()    <span class="comment">// ???? gives size only of small part of ghost cells ????</span>
<a name="l00731"></a>00731     {
<a name="l00732"></a>00732       <span class="comment">// if no iterator then size is zero </span>
<a name="l00733"></a>00733       <span class="comment">// which can happen in the case of parallel grid with 1 processor</span>
<a name="l00734"></a>00734       <span class="keywordflow">if</span>(!it_)
<a name="l00735"></a>00735       {
<a name="l00736"></a>00736         <span class="keywordflow">return</span> 0;
<a name="l00737"></a>00737       }
<a name="l00738"></a>00738       <span class="keywordflow">return</span> it_-&gt;size();
<a name="l00739"></a>00739     }
<a name="l00740"></a>00740 
<a name="l00741"></a>00741     <span class="comment">// go next ghost </span>
<a name="l00742"></a>00742     <span class="keywordtype">void</span> next ()
<a name="l00743"></a>00743     {
<a name="l00744"></a>00744       <span class="keywordflow">if</span>(it_)
<a name="l00745"></a>00745       {
<a name="l00746"></a>00746         <span class="comment">// if not done increment </span>
<a name="l00747"></a>00747         <span class="keywordflow">if</span>( !it_-&gt;done() ) it_-&gt;next();
<a name="l00748"></a>00748         
<a name="l00749"></a>00749         <span class="comment">// if now done, create new iterator </span>
<a name="l00750"></a>00750         <span class="keywordflow">if</span>( it_-&gt;done() ) createIterator();
<a name="l00751"></a>00751 
<a name="l00752"></a>00752         checkLeafEntity();
<a name="l00753"></a>00753       }
<a name="l00754"></a>00754     }
<a name="l00755"></a>00755 
<a name="l00756"></a>00756     <span class="keywordtype">void</span> first()
<a name="l00757"></a>00757     {
<a name="l00758"></a>00758       link_ = -1;
<a name="l00759"></a>00759       usingInner_ = <span class="keyword">false</span>;
<a name="l00760"></a>00760       <span class="comment">// create iterator calls also first of iterators </span>
<a name="l00761"></a>00761       createIterator();
<a name="l00762"></a>00762       checkLeafEntity();
<a name="l00763"></a>00763       <span class="keywordflow">if</span>( it_ ) assert( !it_-&gt;done());
<a name="l00764"></a>00764     }
<a name="l00765"></a>00765 
<a name="l00766"></a>00766     <span class="keywordtype">int</span> done ()<span class="keyword"> const</span>
<a name="l00767"></a>00767 <span class="keyword">    </span>{
<a name="l00768"></a>00768       assert( (link_ &gt;= nl_) ? (it_ == 0) : 1 );
<a name="l00769"></a>00769       <span class="keywordflow">return</span> ((link_ &gt;= nl_ || !it_ ) ? 1 : 0);
<a name="l00770"></a>00770     }
<a name="l00771"></a>00771 
<a name="l00772"></a>00772     val_t &amp; item ()<span class="keyword"> const</span>
<a name="l00773"></a>00773 <span class="keyword">    </span>{
<a name="l00774"></a>00774       assert(it_);
<a name="l00775"></a>00775       pair &lt; ElementPllXIF_t *, int &gt; p = it_-&gt;item ().accessPllX ().accessOuterPllX () ;
<a name="l00776"></a>00776       pair &lt; HElementType  * , HBndSegType * &gt; p2;
<a name="l00777"></a>00777       p.first-&gt;getAttachedElement(p2);
<a name="l00778"></a>00778       assert(p2.second);
<a name="l00779"></a>00779       elem_.second = p2.second;
<a name="l00780"></a>00780       <span class="keywordflow">return</span> elem_;
<a name="l00781"></a>00781     }
<a name="l00782"></a>00782 
<a name="l00783"></a>00783   }; <span class="comment">// end ALU3dGridGhostIterator </span>
<a name="l00784"></a>00784 
<a name="l00785"></a>00785   
<a name="l00786"></a>00786   <span class="comment">// the leaf ghost partition iterator </span>
<a name="l00787"></a>00787   <span class="keyword">template</span> &lt;&gt; 
<a name="l00788"></a>00788   <span class="keyword">class </span>ALU3dGridLeafIteratorWrapper&lt;0,Dune::<a class="code" href="a00492.html#gga5b9e8102d7f70f3f4178182629d98b690c5b1d5dc07ddecbf0fc09db7544216" title="only ghost entities">Ghost_Partition</a>&gt; 
<a name="l00789"></a>00789     : <span class="keyword">public</span> ALU3dGridGhostIterator
<a name="l00790"></a>00790   {
<a name="l00791"></a>00791   <span class="keyword">protected</span>:
<a name="l00792"></a>00792     <span class="keyword">typedef</span> LeafLevelIteratorTTProxy&lt;1&gt; IteratorType;
<a name="l00793"></a>00793     IteratorType * newIterator() 
<a name="l00794"></a>00794     {  
<a name="l00795"></a>00795       <span class="keywordflow">return</span> <span class="keyword">new</span> IteratorType ( this-&gt;gitter_, this-&gt;link_ );
<a name="l00796"></a>00796     }
<a name="l00797"></a>00797     
<a name="l00798"></a>00798     <span class="keywordtype">void</span> checkLeafEntity ()
<a name="l00799"></a>00799     {
<a name="l00800"></a>00800       <span class="keywordflow">if</span>(this-&gt;it_)
<a name="l00801"></a>00801       {
<a name="l00802"></a>00802         <span class="keywordflow">if</span>(! this-&gt;it_-&gt;done())
<a name="l00803"></a>00803         {
<a name="l00804"></a>00804           val_t &amp; el = this-&gt;item();
<a name="l00805"></a>00805           HBndSegType * pll = el.second;
<a name="l00806"></a>00806           assert( pll );
<a name="l00807"></a>00807 
<a name="l00808"></a>00808           <span class="comment">// this occurs if internal element is leaf but the corresponding </span>
<a name="l00809"></a>00809           <span class="comment">// ghost is not leaf, we have to go next </span>
<a name="l00810"></a>00810           <span class="keywordflow">if</span> ( ! pll-&gt;isLeafEntity() ) this-&gt;next();
<a name="l00811"></a>00811         }
<a name="l00812"></a>00812       }
<a name="l00813"></a>00813     }
<a name="l00814"></a>00814 
<a name="l00815"></a>00815   <span class="keyword">public</span>: 
<a name="l00816"></a>00816     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Gr<span class="keywordtype">id</span>Imp&gt;
<a name="l00817"></a>00817     ALU3dGridLeafIteratorWrapper(<span class="keyword">const</span> GridImp &amp; grid, <span class="keywordtype">int</span> level , <span class="keyword">const</span> <span class="keywordtype">int</span> nlinks )
<a name="l00818"></a>00818       : ALU3dGridGhostIterator(grid,level,nlinks) {}
<a name="l00819"></a>00819      
<a name="l00820"></a>00820     ALU3dGridLeafIteratorWrapper(<span class="keyword">const</span> ALU3dGridLeafIteratorWrapper &amp; org)
<a name="l00821"></a>00821       : ALU3dGridGhostIterator(org) {}
<a name="l00822"></a>00822   };
<a name="l00823"></a>00823 
<a name="l00824"></a>00824   <span class="comment">// the level ghost partition iterator </span>
<a name="l00825"></a>00825   <span class="keyword">template</span> &lt;&gt; 
<a name="l00826"></a>00826   <span class="keyword">class </span>ALU3dGridLevelIteratorWrapper&lt;0,Dune::<a class="code" href="a00492.html#gga5b9e8102d7f70f3f4178182629d98b690c5b1d5dc07ddecbf0fc09db7544216" title="only ghost entities">Ghost_Partition</a>&gt; 
<a name="l00827"></a>00827     : <span class="keyword">public</span> ALU3dGridGhostIterator
<a name="l00828"></a>00828   {
<a name="l00829"></a>00829     <span class="keyword">const</span> <span class="keywordtype">int</span> level_;
<a name="l00830"></a>00830     <span class="keyword">const</span> <span class="keywordtype">int</span> mxl_;
<a name="l00831"></a>00831   <span class="keyword">protected</span>:
<a name="l00832"></a>00832     <span class="keyword">typedef</span> LeafLevelIteratorTTProxy&lt;1&gt; IteratorType;
<a name="l00833"></a>00833     IteratorType * newIterator() 
<a name="l00834"></a>00834     {  
<a name="l00835"></a>00835       <span class="comment">// create new level Iterator Proxy </span>
<a name="l00836"></a>00836       <span class="keywordflow">return</span> <span class="keyword">new</span> IteratorType ( this-&gt;gitter_, this-&gt;link_ , level_ );
<a name="l00837"></a>00837     }
<a name="l00838"></a>00838     
<a name="l00839"></a>00839     <span class="comment">// for level iterators don't check leaf entity </span>
<a name="l00840"></a>00840     <span class="keywordtype">void</span> checkLeafEntity ()
<a name="l00841"></a>00841     {
<a name="l00842"></a>00842       <span class="keywordflow">if</span>(this-&gt;it_)
<a name="l00843"></a>00843       {
<a name="l00844"></a>00844         <span class="keywordflow">if</span>(! this-&gt;it_-&gt;done())
<a name="l00845"></a>00845         {
<a name="l00846"></a>00846           val_t &amp; el = this-&gt;item();
<a name="l00847"></a>00847           
<a name="l00848"></a>00848           assert( el.second );
<a name="l00849"></a>00849           HBndSegType &amp; pll = *(el.second);
<a name="l00850"></a>00850 
<a name="l00851"></a>00851           <span class="comment">// this occurs if internal element is leaf but the corresponding </span>
<a name="l00852"></a>00852           <span class="comment">// ghost is not leaf, we have to go next if level of ghost is not</span>
<a name="l00853"></a>00853           <span class="comment">// our level </span>
<a name="l00854"></a>00854           <span class="keywordflow">if</span> ( ! pll.down() )
<a name="l00855"></a>00855           {
<a name="l00856"></a>00856             <span class="keywordflow">if</span>( pll.ghostLevel() != level_ )  this-&gt;next();
<a name="l00857"></a>00857           }
<a name="l00858"></a>00858         }
<a name="l00859"></a>00859       }
<a name="l00860"></a>00860     }
<a name="l00861"></a>00861 
<a name="l00862"></a>00862   <span class="keyword">public</span>: 
<a name="l00863"></a>00863     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Gr<span class="keywordtype">id</span>Imp&gt;
<a name="l00864"></a>00864     ALU3dGridLevelIteratorWrapper(<span class="keyword">const</span> GridImp &amp; grid,<span class="keywordtype">int</span> level , <span class="keyword">const</span> <span class="keywordtype">int</span> nlinks ) 
<a name="l00865"></a>00865       : ALU3dGridGhostIterator(grid,level,nlinks) 
<a name="l00866"></a>00866       , level_(level) , mxl_(grid.maxLevel()){}
<a name="l00867"></a>00867      
<a name="l00868"></a>00868     ALU3dGridLevelIteratorWrapper(<span class="keyword">const</span> ALU3dGridLevelIteratorWrapper &amp; org)
<a name="l00869"></a>00869       : ALU3dGridGhostIterator(org) , level_(org.level_) , mxl_(org.mxl_){}
<a name="l00870"></a>00870   };
<a name="l00871"></a>00871 
<a name="l00873"></a>00873   <span class="comment">//</span>
<a name="l00874"></a>00874   <span class="comment">//  Helper class to get item from Helement </span>
<a name="l00875"></a>00875   <span class="comment">//</span>
<a name="l00877"></a>00877 <span class="comment"></span>  <span class="keyword">template</span>&lt;<span class="keyword">class</span> Gr<span class="keywordtype">id</span>Imp, <span class="keywordtype">int</span> cd&gt; 
<a name="l00878"></a>00878   <span class="keyword">struct </span>GetItem; 
<a name="l00879"></a>00879   
<a name="l00880"></a>00880   <span class="keyword">template</span>&lt;<span class="keyword">class</span> Gr<span class="keywordtype">id</span>Imp&gt; 
<a name="l00881"></a>00881   <span class="keyword">struct </span>GetItem&lt;GridImp,1&gt; 
<a name="l00882"></a>00882   {
<a name="l00883"></a>00883     <span class="keyword">enum</span> { cd = 1 };
<a name="l00884"></a>00884     <span class="keyword">enum</span> { elType = GridImp::elementType };
<a name="l00885"></a>00885 
<a name="l00886"></a>00886     <span class="keyword">typedef</span> <span class="keyword">typename</span> Dune::ALU3dImplTraits&lt;GridImp::elementType&gt;::GEOElementType GEOElementType;
<a name="l00887"></a>00887     <span class="keyword">typedef</span> <span class="keyword">typename</span> IteratorElType&lt;1&gt;::ElType ItemType; 
<a name="l00888"></a>00888 
<a name="l00889"></a>00889     <span class="keyword">static</span> ItemType * getItemFromEl(GEOTetraElementType &amp; el, <span class="keywordtype">int</span> i)
<a name="l00890"></a>00890     {
<a name="l00891"></a>00891       <span class="keywordflow">return</span> el.myhface3(i);
<a name="l00892"></a>00892     }
<a name="l00893"></a>00893    
<a name="l00894"></a>00894     <span class="keyword">static</span> ItemType * getItemFromEl(GEOHexaElementType &amp; el, <span class="keywordtype">int</span> i)
<a name="l00895"></a>00895     {
<a name="l00896"></a>00896       <span class="keywordflow">return</span> el.myhface4(i);
<a name="l00897"></a>00897     }
<a name="l00898"></a>00898     
<a name="l00899"></a>00899     <span class="keyword">static</span> ItemType * getItem(HElementType &amp; el, <span class="keywordtype">int</span> i)
<a name="l00900"></a>00900     {
<a name="l00901"></a>00901       <span class="keywordflow">return</span> getItemFromEl(static_cast&lt;GEOElementType &amp;&gt; (el),i);
<a name="l00902"></a>00902     }
<a name="l00903"></a>00903     
<a name="l00904"></a>00904     <span class="keyword">static</span> <span class="keywordtype">int</span> numItems() 
<a name="l00905"></a>00905     {
<a name="l00906"></a>00906       <span class="keywordflow">return</span> Dune :: EntityCount&lt;elType&gt;::numFaces;
<a name="l00907"></a>00907     }
<a name="l00908"></a>00908   };
<a name="l00909"></a>00909 
<a name="l00910"></a>00910   <span class="keyword">template</span>&lt;<span class="keyword">class</span> Gr<span class="keywordtype">id</span>Imp&gt; 
<a name="l00911"></a>00911   <span class="keyword">struct </span>GetItem&lt;GridImp,2&gt; 
<a name="l00912"></a>00912   {
<a name="l00913"></a>00913     <span class="keyword">enum</span> { cd = 2 };
<a name="l00914"></a>00914     <span class="keyword">enum</span> { elType = GridImp::elementType };
<a name="l00915"></a>00915     <span class="keyword">typedef</span> <span class="keyword">typename</span> Dune::ALU3dImplTraits&lt;GridImp::elementType&gt;::GEOElementType GEOElementType;
<a name="l00916"></a>00916     <span class="keyword">typedef</span> <span class="keyword">typename</span> IteratorElType&lt;2&gt;::ElType ItemType; 
<a name="l00917"></a>00917     <span class="keyword">static</span> ItemType * getItem(HElementType &amp; el, <span class="keywordtype">int</span> i)
<a name="l00918"></a>00918     {
<a name="l00919"></a>00919       <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>GEOElementType &amp;<span class="keyword">&gt;</span> (el).myhedge1(i); 
<a name="l00920"></a>00920     }
<a name="l00921"></a>00921     
<a name="l00922"></a>00922     <span class="keyword">static</span> <span class="keywordtype">int</span> numItems() 
<a name="l00923"></a>00923     {
<a name="l00924"></a>00924       <span class="keywordflow">return</span> Dune :: EntityCount&lt;elType&gt;::numEdges;
<a name="l00925"></a>00925     }
<a name="l00926"></a>00926   };
<a name="l00927"></a>00927 
<a name="l00928"></a>00928   <span class="keyword">template</span>&lt;<span class="keyword">class</span> Gr<span class="keywordtype">id</span>Imp&gt; 
<a name="l00929"></a>00929   <span class="keyword">struct </span>GetItem&lt;GridImp,3&gt; 
<a name="l00930"></a>00930   {
<a name="l00931"></a>00931     <span class="keyword">enum</span> { cd = 3 };
<a name="l00932"></a>00932     <span class="keyword">enum</span> { elType = GridImp::elementType };
<a name="l00933"></a>00933     <span class="keyword">typedef</span> <span class="keyword">typename</span> Dune::ALU3dImplTraits&lt;GridImp::elementType&gt;::GEOElementType GEOElementType;
<a name="l00934"></a>00934     <span class="keyword">typedef</span> <span class="keyword">typename</span> IteratorElType&lt;3&gt;::ElType ItemType; 
<a name="l00935"></a>00935     <span class="keyword">static</span> ItemType * getItem(HElementType &amp; el, <span class="keywordtype">int</span> i)
<a name="l00936"></a>00936     {
<a name="l00937"></a>00937       <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>GEOElementType &amp;<span class="keyword">&gt;</span> (el).myvertex(i); 
<a name="l00938"></a>00938     }
<a name="l00939"></a>00939 
<a name="l00940"></a>00940     <span class="keyword">static</span> <span class="keywordtype">int</span> numItems() 
<a name="l00941"></a>00941     {
<a name="l00942"></a>00942       <span class="keywordflow">return</span> Dune :: EntityCount&lt;elType&gt;::numVertices;
<a name="l00943"></a>00943     }
<a name="l00944"></a>00944   };
<a name="l00945"></a>00945 
<a name="l00946"></a>00946 
<a name="l00948"></a>00948   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> codim&gt; 
<a name="l00949"></a>00949   <span class="keyword">class </span>ALU3dGridGhostIteratorHigherCodim 
<a name="l00950"></a>00950     : <span class="keyword">public</span> IteratorWrapperInterface &lt; typename IteratorElType&lt;codim&gt;::val_t &gt; 
<a name="l00951"></a>00951   { 
<a name="l00952"></a>00952 
<a name="l00953"></a>00953   <span class="keyword">public</span>:  
<a name="l00954"></a>00954     <span class="keyword">typedef</span> <span class="keyword">typename</span> IteratorElType&lt;codim&gt;::ElType ElType; 
<a name="l00955"></a>00955     <span class="keyword">typedef</span> <span class="keyword">typename</span> IteratorElType&lt;codim&gt;::val_t val_t; 
<a name="l00956"></a>00956     
<a name="l00957"></a>00957   <span class="keyword">private</span>:
<a name="l00958"></a>00958     <span class="keyword">template</span>&lt;Dune :: ALU3dGr<span class="keywordtype">id</span>ElementType elType, <span class="keywordtype">int</span> cd&gt; 
<a name="l00959"></a>00959     <span class="keyword">struct </span>SelectVector
<a name="l00960"></a>00960     {
<a name="l00961"></a>00961     };
<a name="l00962"></a>00962 
<a name="l00963"></a>00963     <span class="keyword">template</span>&lt;Dune :: ALU3dGr<span class="keywordtype">id</span>ElementType elType&gt; 
<a name="l00964"></a>00964     <span class="keyword">struct </span>SelectVector&lt;elType,1&gt; 
<a name="l00965"></a>00965     {
<a name="l00966"></a>00966       <span class="keyword">typedef</span> <span class="keyword">typename</span> Dune :: ALU3dImplTraits&lt;elType&gt;::GEOElementType GEOElementType;
<a name="l00967"></a>00967       <span class="keyword">static</span> <span class="keyword">const</span> vector&lt;int&gt; &amp; getNotOnItemVector(<span class="keywordtype">int</span> face)
<a name="l00968"></a>00968       {
<a name="l00969"></a>00969         <span class="keywordflow">return</span> GEOElementType :: facesNotOnFace( face );
<a name="l00970"></a>00970       }
<a name="l00971"></a>00971     };
<a name="l00972"></a>00972 
<a name="l00973"></a>00973     <span class="keyword">template</span>&lt;Dune :: ALU3dGr<span class="keywordtype">id</span>ElementType elType&gt; 
<a name="l00974"></a>00974     <span class="keyword">struct </span>SelectVector&lt;elType,2&gt; 
<a name="l00975"></a>00975     {
<a name="l00976"></a>00976       <span class="keyword">typedef</span> <span class="keyword">typename</span> Dune :: ALU3dImplTraits&lt;elType&gt;::GEOElementType GEOElementType;
<a name="l00977"></a>00977       <span class="keyword">static</span> <span class="keyword">const</span> vector&lt;int&gt; &amp; getNotOnItemVector(<span class="keywordtype">int</span> face)
<a name="l00978"></a>00978       {
<a name="l00979"></a>00979         <span class="keywordflow">return</span> GEOElementType :: edgesNotOnFace( face );
<a name="l00980"></a>00980       }
<a name="l00981"></a>00981     };
<a name="l00982"></a>00982 
<a name="l00983"></a>00983     <span class="keyword">template</span>&lt;Dune :: ALU3dGr<span class="keywordtype">id</span>ElementType elType&gt; 
<a name="l00984"></a>00984     <span class="keyword">struct </span>SelectVector&lt;elType,3&gt; 
<a name="l00985"></a>00985     {
<a name="l00986"></a>00986       <span class="keyword">typedef</span> <span class="keyword">typename</span> Dune :: ALU3dImplTraits&lt;elType&gt;::GEOElementType GEOElementType;
<a name="l00987"></a>00987       <span class="keyword">static</span> <span class="keyword">const</span> vector&lt;int&gt; &amp; getNotOnItemVector(<span class="keywordtype">int</span> face)
<a name="l00988"></a>00988       {
<a name="l00989"></a>00989         <span class="keywordflow">return</span> GEOElementType :: verticesNotOnFace( face );
<a name="l00990"></a>00990       }
<a name="l00991"></a>00991     };
<a name="l00992"></a>00992 
<a name="l00993"></a>00993     <span class="keyword">typedef</span> ElType * getItemFunc_t(HElementType &amp; el, <span class="keywordtype">int</span> i);
<a name="l00994"></a>00994 
<a name="l00995"></a>00995   <span class="keyword">private</span>:  
<a name="l00996"></a>00996     <span class="keyword">typedef</span> Dune :: ALU3dGridItemListType GhostItemListType; 
<a name="l00997"></a>00997     GhostItemListType &amp; ghList_;
<a name="l00998"></a>00998     <span class="keyword">typedef</span> <span class="keyword">typename</span> GhostItemListType :: IteratorType IteratorType; 
<a name="l00999"></a>00999     IteratorType curr_; 
<a name="l01000"></a>01000     IteratorType end_; 
<a name="l01001"></a>01001     <span class="keyword">mutable</span> val_t elem_;
<a name="l01002"></a>01002     <span class="keyword">mutable</span> <span class="keywordtype">int</span> count_;
<a name="l01003"></a>01003   <span class="keyword">public</span>:
<a name="l01004"></a>01004     <span class="keyword">template</span> &lt;<span class="keyword">class</span> GhostElementIteratorImp, <span class="keyword">class</span> Gr<span class="keywordtype">id</span>Imp&gt;
<a name="l01005"></a>01005     ALU3dGridGhostIteratorHigherCodim(GhostElementIteratorImp *, <span class="keyword">const</span> GridImp &amp; grid, 
<a name="l01006"></a>01006                         <span class="keywordtype">int</span> level , <span class="keyword">const</span> <span class="keywordtype">int</span> nlinks, GhostItemListType &amp; ghList) 
<a name="l01007"></a>01007       : ghList_( ghList )
<a name="l01008"></a>01008       , elem_(0,0)
<a name="l01009"></a>01009       , count_(0)
<a name="l01010"></a>01010     {
<a name="l01011"></a>01011       <span class="keywordflow">if</span>( ! ghList_.up2Date() )
<a name="l01012"></a>01012       {
<a name="l01013"></a>01013         GhostElementIteratorImp ghostIter(grid,level,nlinks);
<a name="l01014"></a>01014         updateGhostList(grid,ghostIter,ghList_);
<a name="l01015"></a>01015       }
<a name="l01016"></a>01016     }  
<a name="l01017"></a>01017 
<a name="l01018"></a>01018     ALU3dGridGhostIteratorHigherCodim(<span class="keyword">const</span> ALU3dGridGhostIteratorHigherCodim &amp; org) 
<a name="l01019"></a>01019       : ghList_( org.ghList_ )
<a name="l01020"></a>01020       , elem_(org.elem_)
<a name="l01021"></a>01021       , count_(org.count_)
<a name="l01022"></a>01022     {}
<a name="l01023"></a>01023 
<a name="l01024"></a>01024     <span class="keywordtype">int</span> size  () { <span class="keywordflow">return</span> ghList_.getItemList().size(); }
<a name="l01025"></a>01025     <span class="keywordtype">void</span> first() { count_ = 0; } 
<a name="l01026"></a>01026     <span class="keywordtype">void</span> next () { ++count_; }
<a name="l01027"></a>01027     <span class="keywordtype">int</span> done ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> (count_ &gt;= (<span class="keywordtype">int</span>) ghList_.getItemList().size() ? 1 : 0); } 
<a name="l01028"></a>01028     val_t &amp; item ()<span class="keyword"> const </span>
<a name="l01029"></a>01029 <span class="keyword">    </span>{ 
<a name="l01030"></a>01030       assert( ! done() ); 
<a name="l01031"></a>01031       <span class="keywordtype">void</span> * item = ghList_.getItemList()[count_]; 
<a name="l01032"></a>01032       elem_.first = ((ElType * ) item);
<a name="l01033"></a>01033       assert( elem_.first );
<a name="l01034"></a>01034       <span class="keywordflow">return</span> elem_; 
<a name="l01035"></a>01035     }
<a name="l01036"></a>01036 
<a name="l01037"></a>01037   <span class="keyword">protected</span>:  
<a name="l01038"></a>01038     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Gr<span class="keywordtype">id</span>Imp, <span class="keyword">class</span> GhostElementIteratorImp&gt;
<a name="l01039"></a>01039     <span class="keywordtype">void</span> updateGhostList(<span class="keyword">const</span> GridImp &amp; grid, GhostElementIteratorImp &amp; ghostIter, GhostItemListType &amp; ghList)
<a name="l01040"></a>01040     {
<a name="l01041"></a>01041       <span class="keywordtype">int</span> count = 0;
<a name="l01042"></a>01042       <span class="keywordflow">for</span>( ghostIter.first(); !ghostIter.done(); ghostIter.next() )
<a name="l01043"></a>01043       {
<a name="l01044"></a>01044         ++count;
<a name="l01045"></a>01045       }
<a name="l01046"></a>01046 
<a name="l01047"></a>01047       <span class="keyword">const</span> <span class="keywordtype">int</span> numItems = SelectVector&lt;GridImp::elementType,codim&gt;::getNotOnItemVector(0).size(); 
<a name="l01048"></a>01048       <span class="keyword">const</span> <span class="keywordtype">int</span> maxSize = numItems * count;
<a name="l01049"></a>01049 
<a name="l01050"></a>01050       ghList.getItemList().reserve(maxSize);
<a name="l01051"></a>01051       ghList.getItemList().resize(0);
<a name="l01052"></a>01052       map&lt; int , int &gt; visited; 
<a name="l01053"></a>01053 
<a name="l01054"></a>01054       <span class="keywordflow">for</span>( ghostIter.first(); !ghostIter.done(); ghostIter.next() )
<a name="l01055"></a>01055       {
<a name="l01056"></a>01056         GhostPairType ghPair = ghostIter.item().second-&gt;getGhost();
<a name="l01057"></a>01057         <span class="keyword">const</span> vector&lt;int&gt; &amp; notOnFace = SelectVector&lt;GridImp::elementType,codim&gt;::
<a name="l01058"></a>01058                                           getNotOnItemVector(ghPair.second); 
<a name="l01059"></a>01059         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;numItems; ++i) 
<a name="l01060"></a>01060         {
<a name="l01061"></a>01061           ElType * item = GetItem&lt;GridImp,codim&gt;::getItem( *(ghPair.first) , notOnFace[i] );
<a name="l01062"></a>01062           <span class="keywordtype">int</span> idx = item-&gt;getIndex();
<a name="l01063"></a>01063           <span class="keywordflow">if</span>( visited.find(idx) == visited.end() )
<a name="l01064"></a>01064           {
<a name="l01065"></a>01065             ghList.getItemList().push_back( (<span class="keywordtype">void</span> *) item );
<a name="l01066"></a>01066             visited[idx] = 1;
<a name="l01067"></a>01067           }
<a name="l01068"></a>01068         }
<a name="l01069"></a>01069       }
<a name="l01070"></a>01070       ghList.markAsUp2Date();
<a name="l01071"></a>01071     }
<a name="l01072"></a>01072   };
<a name="l01073"></a>01073   
<a name="l01074"></a>01074   <span class="comment">// the leaf ghost partition iterator </span>
<a name="l01075"></a>01075   <span class="keyword">template</span> &lt;&gt; 
<a name="l01076"></a>01076   <span class="keyword">class </span>ALU3dGridLeafIteratorWrapper&lt;1,Dune::<a class="code" href="a00492.html#gga5b9e8102d7f70f3f4178182629d98b690c5b1d5dc07ddecbf0fc09db7544216" title="only ghost entities">Ghost_Partition</a>&gt; 
<a name="l01077"></a>01077     : <span class="keyword">public</span> ALU3dGridGhostIteratorHigherCodim&lt;1&gt; 
<a name="l01078"></a>01078   {
<a name="l01079"></a>01079     <span class="keyword">enum</span> { codim = 1 };
<a name="l01080"></a>01080     <span class="keyword">typedef</span> ALU3dGridLeafIteratorWrapper&lt;0,Dune::Ghost_Partition&gt; GhostElementIteratorType;
<a name="l01081"></a>01081   <span class="keyword">public</span>:
<a name="l01082"></a>01082     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Gr<span class="keywordtype">id</span>Imp&gt; 
<a name="l01083"></a>01083     ALU3dGridLeafIteratorWrapper (<span class="keyword">const</span> GridImp &amp; grid, <span class="keywordtype">int</span> level , <span class="keyword">const</span> <span class="keywordtype">int</span> nlinks ) 
<a name="l01084"></a>01084       : ALU3dGridGhostIteratorHigherCodim&lt;codim&gt;((GhostElementIteratorType *)0,grid,level,nlinks,grid.getGhostLeafList(codim)) {}
<a name="l01085"></a>01085 
<a name="l01086"></a>01086     ALU3dGridLeafIteratorWrapper (<span class="keyword">const</span> ALU3dGridLeafIteratorWrapper &amp; org ) 
<a name="l01087"></a>01087       : ALU3dGridGhostIteratorHigherCodim&lt;codim&gt;(org) {}
<a name="l01088"></a>01088   };
<a name="l01089"></a>01089   
<a name="l01090"></a>01090   <span class="comment">// the leaf ghost partition iterator </span>
<a name="l01091"></a>01091   <span class="keyword">template</span> &lt;&gt; 
<a name="l01092"></a>01092   <span class="keyword">class </span>ALU3dGridLeafIteratorWrapper&lt;2,Dune::<a class="code" href="a00492.html#gga5b9e8102d7f70f3f4178182629d98b690c5b1d5dc07ddecbf0fc09db7544216" title="only ghost entities">Ghost_Partition</a>&gt; 
<a name="l01093"></a>01093     : <span class="keyword">public</span> ALU3dGridGhostIteratorHigherCodim&lt;2&gt; 
<a name="l01094"></a>01094   {
<a name="l01095"></a>01095     <span class="keyword">enum</span> { codim = 2 };
<a name="l01096"></a>01096     <span class="keyword">typedef</span> ALU3dGridLeafIteratorWrapper&lt;0,Dune::Ghost_Partition&gt; GhostElementIteratorType;
<a name="l01097"></a>01097   <span class="keyword">public</span>:
<a name="l01098"></a>01098     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Gr<span class="keywordtype">id</span>Imp&gt; 
<a name="l01099"></a>01099     ALU3dGridLeafIteratorWrapper (<span class="keyword">const</span> GridImp &amp; grid, <span class="keywordtype">int</span> level , <span class="keyword">const</span> <span class="keywordtype">int</span> nlinks ) 
<a name="l01100"></a>01100       : ALU3dGridGhostIteratorHigherCodim&lt;codim&gt;((GhostElementIteratorType *)0,grid,level,nlinks,grid.getGhostLeafList(codim)) {}
<a name="l01101"></a>01101 
<a name="l01102"></a>01102     ALU3dGridLeafIteratorWrapper (<span class="keyword">const</span> ALU3dGridLeafIteratorWrapper &amp; org ) 
<a name="l01103"></a>01103       : ALU3dGridGhostIteratorHigherCodim&lt;codim&gt;(org) {}
<a name="l01104"></a>01104   };
<a name="l01105"></a>01105   
<a name="l01106"></a>01106   <span class="comment">// the leaf ghost partition iterator </span>
<a name="l01107"></a>01107   <span class="keyword">template</span> &lt;&gt; 
<a name="l01108"></a>01108   <span class="keyword">class </span>ALU3dGridLeafIteratorWrapper&lt;3,Dune::<a class="code" href="a00492.html#gga5b9e8102d7f70f3f4178182629d98b690c5b1d5dc07ddecbf0fc09db7544216" title="only ghost entities">Ghost_Partition</a>&gt; 
<a name="l01109"></a>01109     : <span class="keyword">public</span> ALU3dGridGhostIteratorHigherCodim&lt;3&gt; 
<a name="l01110"></a>01110   {
<a name="l01111"></a>01111     <span class="keyword">enum</span> { codim = 3 };
<a name="l01112"></a>01112     <span class="keyword">typedef</span> ALU3dGridLeafIteratorWrapper&lt;0,Dune::Ghost_Partition&gt; GhostElementIteratorType;
<a name="l01113"></a>01113   <span class="keyword">public</span>:
<a name="l01114"></a>01114     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Gr<span class="keywordtype">id</span>Imp&gt; 
<a name="l01115"></a>01115     ALU3dGridLeafIteratorWrapper (<span class="keyword">const</span> GridImp &amp; grid, <span class="keywordtype">int</span> level , <span class="keyword">const</span> <span class="keywordtype">int</span> nlinks ) 
<a name="l01116"></a>01116       : ALU3dGridGhostIteratorHigherCodim&lt;codim&gt;((GhostElementIteratorType *)0,grid,level,nlinks,grid.getGhostLeafList(codim)) {}
<a name="l01117"></a>01117 
<a name="l01118"></a>01118     ALU3dGridLeafIteratorWrapper (<span class="keyword">const</span> ALU3dGridLeafIteratorWrapper &amp; org ) 
<a name="l01119"></a>01119       : ALU3dGridGhostIteratorHigherCodim&lt;codim&gt;(org) {}
<a name="l01120"></a>01120   };
<a name="l01121"></a>01121   
<a name="l01122"></a>01122   <span class="comment">// the level ghost partition iterator </span>
<a name="l01123"></a>01123   <span class="keyword">template</span> &lt;&gt; 
<a name="l01124"></a>01124   <span class="keyword">class </span>ALU3dGridLevelIteratorWrapper&lt;1,Dune::<a class="code" href="a00492.html#gga5b9e8102d7f70f3f4178182629d98b690c5b1d5dc07ddecbf0fc09db7544216" title="only ghost entities">Ghost_Partition</a>&gt; 
<a name="l01125"></a>01125     : <span class="keyword">public</span> ALU3dGridGhostIteratorHigherCodim&lt;1&gt; 
<a name="l01126"></a>01126   {
<a name="l01127"></a>01127     <span class="keyword">enum</span> { codim = 1 };
<a name="l01128"></a>01128     <span class="keyword">typedef</span> ALU3dGridLevelIteratorWrapper&lt;0,Dune::Ghost_Partition&gt; GhostElementIteratorType;
<a name="l01129"></a>01129   <span class="keyword">public</span>:
<a name="l01130"></a>01130     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Gr<span class="keywordtype">id</span>Imp&gt; 
<a name="l01131"></a>01131     ALU3dGridLevelIteratorWrapper (<span class="keyword">const</span> GridImp &amp; grid, <span class="keywordtype">int</span> level , <span class="keyword">const</span> <span class="keywordtype">int</span> nlinks ) 
<a name="l01132"></a>01132       : ALU3dGridGhostIteratorHigherCodim&lt;codim&gt;((GhostElementIteratorType *)0,grid,level,nlinks,grid.getGhostLevelList(codim,level)) {}
<a name="l01133"></a>01133 
<a name="l01134"></a>01134     ALU3dGridLevelIteratorWrapper (<span class="keyword">const</span> ALU3dGridLevelIteratorWrapper &amp; org ) 
<a name="l01135"></a>01135       : ALU3dGridGhostIteratorHigherCodim&lt;codim&gt;(org) {}
<a name="l01136"></a>01136   };
<a name="l01137"></a>01137   
<a name="l01138"></a>01138   <span class="comment">// the level ghost partition iterator </span>
<a name="l01139"></a>01139   <span class="keyword">template</span> &lt;&gt; 
<a name="l01140"></a>01140   <span class="keyword">class </span>ALU3dGridLevelIteratorWrapper&lt;2,Dune::<a class="code" href="a00492.html#gga5b9e8102d7f70f3f4178182629d98b690c5b1d5dc07ddecbf0fc09db7544216" title="only ghost entities">Ghost_Partition</a>&gt; 
<a name="l01141"></a>01141     : <span class="keyword">public</span> ALU3dGridGhostIteratorHigherCodim&lt;2&gt; 
<a name="l01142"></a>01142   {
<a name="l01143"></a>01143     <span class="keyword">enum</span> { codim = 2 };
<a name="l01144"></a>01144     <span class="keyword">typedef</span> ALU3dGridLevelIteratorWrapper&lt;0,Dune::Ghost_Partition&gt; GhostElementIteratorType;
<a name="l01145"></a>01145   <span class="keyword">public</span>:
<a name="l01146"></a>01146     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Gr<span class="keywordtype">id</span>Imp&gt; 
<a name="l01147"></a>01147     ALU3dGridLevelIteratorWrapper (<span class="keyword">const</span> GridImp &amp; grid, <span class="keywordtype">int</span> level , <span class="keyword">const</span> <span class="keywordtype">int</span> nlinks ) 
<a name="l01148"></a>01148       : ALU3dGridGhostIteratorHigherCodim&lt;codim&gt;((GhostElementIteratorType *)0,grid,level,nlinks,grid.getGhostLevelList(codim,level)) {}
<a name="l01149"></a>01149 
<a name="l01150"></a>01150     ALU3dGridLevelIteratorWrapper (<span class="keyword">const</span> ALU3dGridLevelIteratorWrapper &amp; org ) 
<a name="l01151"></a>01151       : ALU3dGridGhostIteratorHigherCodim&lt;codim&gt;(org) {}
<a name="l01152"></a>01152   };
<a name="l01153"></a>01153   
<a name="l01154"></a>01154   <span class="comment">// the level ghost partition iterator </span>
<a name="l01155"></a>01155   <span class="keyword">template</span> &lt;&gt; 
<a name="l01156"></a>01156   <span class="keyword">class </span>ALU3dGridLevelIteratorWrapper&lt;3,Dune::<a class="code" href="a00492.html#gga5b9e8102d7f70f3f4178182629d98b690c5b1d5dc07ddecbf0fc09db7544216" title="only ghost entities">Ghost_Partition</a>&gt; 
<a name="l01157"></a>01157     : <span class="keyword">public</span> ALU3dGridGhostIteratorHigherCodim&lt;3&gt; 
<a name="l01158"></a>01158   {
<a name="l01159"></a>01159     <span class="keyword">enum</span> { codim = 3 };
<a name="l01160"></a>01160     <span class="keyword">typedef</span> ALU3dGridLevelIteratorWrapper&lt;0,Dune::Ghost_Partition&gt; GhostElementIteratorType;
<a name="l01161"></a>01161   <span class="keyword">public</span>:
<a name="l01162"></a>01162     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Gr<span class="keywordtype">id</span>Imp&gt; 
<a name="l01163"></a>01163     ALU3dGridLevelIteratorWrapper (<span class="keyword">const</span> GridImp &amp; grid, <span class="keywordtype">int</span> level , <span class="keyword">const</span> <span class="keywordtype">int</span> nlinks ) 
<a name="l01164"></a>01164       : ALU3dGridGhostIteratorHigherCodim&lt;codim&gt;((GhostElementIteratorType *)0,grid,level,nlinks,grid.getGhostLevelList(codim,level)) {}
<a name="l01165"></a>01165 
<a name="l01166"></a>01166     ALU3dGridLevelIteratorWrapper (<span class="keyword">const</span> ALU3dGridLevelIteratorWrapper &amp; org ) 
<a name="l01167"></a>01167       : ALU3dGridGhostIteratorHigherCodim&lt;codim&gt;(org) {}
<a name="l01168"></a>01168   };
<a name="l01169"></a>01169   
<a name="l01170"></a>01170   <span class="comment">// the all partition iterator </span>
<a name="l01171"></a>01171   <span class="keyword">template</span> &lt;&gt; 
<a name="l01172"></a>01172   <span class="keyword">class </span>ALU3dGridLeafIteratorWrapper&lt;0,Dune::<a class="code" href="a00492.html#gga5b9e8102d7f70f3f4178182629d98b63026c69cd558fe3687c11f45966905e9" title="all entities">All_Partition</a>&gt; 
<a name="l01173"></a>01173     : <span class="keyword">public</span> IteratorWrapperInterface &lt; IteratorElType&lt;0&gt;::val_t &gt; 
<a name="l01174"></a>01174   {
<a name="l01175"></a>01175     <span class="keyword">enum</span> { codim = 0 };
<a name="l01176"></a>01176     <span class="keyword">typedef</span> ALU3dGridLeafIteratorWrapper&lt;codim,Dune::InteriorBorder_Partition&gt; InteriorIteratorType;
<a name="l01177"></a>01177     <span class="keyword">typedef</span> ALU3dGridLeafIteratorWrapper&lt;codim,Dune::Ghost_Partition&gt; GhostIteratorType;
<a name="l01178"></a>01178 
<a name="l01179"></a>01179   <span class="keyword">public</span>:  
<a name="l01180"></a>01180     <span class="keyword">typedef</span> IteratorElType&lt;codim&gt;::val_t val_t;
<a name="l01181"></a>01181     <span class="comment">// use ALUGrids AlignIterator to combine Interior and Ghost Iterator</span>
<a name="l01182"></a>01182     <span class="keyword">typedef</span> AlignIterator&lt; InteriorIteratorType, GhostIteratorType , val_t &gt; IteratorType; 
<a name="l01183"></a>01183   <span class="keyword">private</span>:
<a name="l01184"></a>01184     IteratorType iter_;
<a name="l01185"></a>01185   <span class="keyword">public</span>:
<a name="l01186"></a>01186     
<a name="l01187"></a>01187     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Gr<span class="keywordtype">id</span>Imp&gt; 
<a name="l01188"></a>01188     ALU3dGridLeafIteratorWrapper (<span class="keyword">const</span> GridImp &amp; grid, <span class="keywordtype">int</span> level , <span class="keyword">const</span> <span class="keywordtype">int</span> nlinks ) 
<a name="l01189"></a>01189       : iter_ ( InteriorIteratorType ( grid, level, nlinks ) ,
<a name="l01190"></a>01190                 GhostIteratorType    ( grid, level, nlinks ) )
<a name="l01191"></a>01191     {
<a name="l01192"></a>01192     }
<a name="l01193"></a>01193     
<a name="l01194"></a>01194     ALU3dGridLeafIteratorWrapper (<span class="keyword">const</span> ALU3dGridLeafIteratorWrapper &amp; org ) 
<a name="l01195"></a>01195       : iter_ (org.iter_) {}
<a name="l01196"></a>01196     
<a name="l01197"></a>01197     <span class="keywordtype">int</span> size  () { <span class="keywordflow">return</span> iter_.size(); }
<a name="l01198"></a>01198     <span class="keywordtype">void</span> next () { iter_.next(); }
<a name="l01199"></a>01199     <span class="keywordtype">void</span> first() { iter_.first(); }
<a name="l01200"></a>01200     <span class="keywordtype">int</span> done ()<span class="keyword"> const </span>{<span class="keywordflow">return</span> iter_.done(); }
<a name="l01201"></a>01201     val_t &amp; item ()<span class="keyword"> const </span>{ assert( ! done() ); <span class="keywordflow">return</span> iter_.item(); }
<a name="l01202"></a>01202   };
<a name="l01203"></a>01203 
<a name="l01204"></a>01204   <span class="comment">// the all partition iterator </span>
<a name="l01205"></a>01205   <span class="keyword">template</span> &lt;&gt; 
<a name="l01206"></a>01206   <span class="keyword">class </span>ALU3dGridLeafIteratorWrapper&lt;1,Dune::<a class="code" href="a00492.html#gga5b9e8102d7f70f3f4178182629d98b63026c69cd558fe3687c11f45966905e9" title="all entities">All_Partition</a>&gt; 
<a name="l01207"></a>01207     : <span class="keyword">public</span> IteratorWrapperInterface &lt; IteratorElType&lt;1&gt;::val_t &gt; 
<a name="l01208"></a>01208   {
<a name="l01209"></a>01209     <span class="keyword">enum</span> { codim = 1 };
<a name="l01210"></a>01210     <span class="keyword">typedef</span> ALU3dGridLeafIteratorWrapper&lt;codim,Dune::InteriorBorder_Partition&gt; InteriorIteratorType;
<a name="l01211"></a>01211     <span class="keyword">typedef</span> ALU3dGridLeafIteratorWrapper&lt;codim,Dune::Ghost_Partition&gt; GhostIteratorType;
<a name="l01212"></a>01212 
<a name="l01213"></a>01213   <span class="keyword">public</span>:  
<a name="l01214"></a>01214     <span class="keyword">typedef</span> IteratorElType&lt;codim&gt;::val_t val_t;
<a name="l01215"></a>01215     <span class="comment">// use ALUGrids AlignIterator to combine Interior and Ghost Iterator</span>
<a name="l01216"></a>01216     <span class="keyword">typedef</span> AlignIterator&lt; InteriorIteratorType, GhostIteratorType , val_t &gt; IteratorType; 
<a name="l01217"></a>01217   <span class="keyword">private</span>:
<a name="l01218"></a>01218     IteratorType iter_;
<a name="l01219"></a>01219   <span class="keyword">public</span>:
<a name="l01220"></a>01220     
<a name="l01221"></a>01221     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Gr<span class="keywordtype">id</span>Imp&gt; 
<a name="l01222"></a>01222     ALU3dGridLeafIteratorWrapper (<span class="keyword">const</span> GridImp &amp; grid, <span class="keywordtype">int</span> level , <span class="keyword">const</span> <span class="keywordtype">int</span> nlinks ) 
<a name="l01223"></a>01223       : iter_ ( InteriorIteratorType ( grid, level, nlinks ) ,
<a name="l01224"></a>01224                 GhostIteratorType    ( grid, level, nlinks ) )
<a name="l01225"></a>01225     {
<a name="l01226"></a>01226     }
<a name="l01227"></a>01227     
<a name="l01228"></a>01228     ALU3dGridLeafIteratorWrapper (<span class="keyword">const</span> ALU3dGridLeafIteratorWrapper &amp; org ) 
<a name="l01229"></a>01229       : iter_ (org.iter_) {}
<a name="l01230"></a>01230     
<a name="l01231"></a>01231     <span class="keywordtype">int</span> size  () { <span class="keywordflow">return</span> iter_.size(); }
<a name="l01232"></a>01232     <span class="keywordtype">void</span> next () { iter_.next(); }
<a name="l01233"></a>01233     <span class="keywordtype">void</span> first() { iter_.first(); }
<a name="l01234"></a>01234     <span class="keywordtype">int</span> done ()<span class="keyword"> const </span>{<span class="keywordflow">return</span> iter_.done(); }
<a name="l01235"></a>01235     val_t &amp; item ()<span class="keyword"> const </span>{ assert( ! done() ); <span class="keywordflow">return</span> iter_.item(); }
<a name="l01236"></a>01236   };
<a name="l01237"></a>01237 
<a name="l01238"></a>01238   <span class="comment">// the all partition iterator </span>
<a name="l01239"></a>01239   <span class="keyword">template</span> &lt;&gt; 
<a name="l01240"></a>01240   <span class="keyword">class </span>ALU3dGridLeafIteratorWrapper&lt;2,Dune::<a class="code" href="a00492.html#gga5b9e8102d7f70f3f4178182629d98b63026c69cd558fe3687c11f45966905e9" title="all entities">All_Partition</a>&gt; 
<a name="l01241"></a>01241     : <span class="keyword">public</span> IteratorWrapperInterface &lt; IteratorElType&lt;2&gt;::val_t &gt; 
<a name="l01242"></a>01242   {
<a name="l01243"></a>01243     <span class="keyword">enum</span> { codim = 2 };
<a name="l01244"></a>01244     <span class="keyword">typedef</span> ALU3dGridLeafIteratorWrapper&lt;codim,Dune::InteriorBorder_Partition&gt; InteriorIteratorType;
<a name="l01245"></a>01245     <span class="keyword">typedef</span> ALU3dGridLeafIteratorWrapper&lt;codim,Dune::Ghost_Partition&gt; GhostIteratorType;
<a name="l01246"></a>01246 
<a name="l01247"></a>01247   <span class="keyword">public</span>:  
<a name="l01248"></a>01248     <span class="keyword">typedef</span> IteratorElType&lt;codim&gt;::val_t val_t;
<a name="l01249"></a>01249     <span class="comment">// use ALUGrids AlignIterator to combine Interior and Ghost Iterator</span>
<a name="l01250"></a>01250     <span class="keyword">typedef</span> AlignIterator&lt; InteriorIteratorType, GhostIteratorType , val_t &gt; IteratorType; 
<a name="l01251"></a>01251   <span class="keyword">private</span>:
<a name="l01252"></a>01252     IteratorType iter_;
<a name="l01253"></a>01253   <span class="keyword">public</span>:
<a name="l01254"></a>01254     
<a name="l01255"></a>01255     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Gr<span class="keywordtype">id</span>Imp&gt; 
<a name="l01256"></a>01256     ALU3dGridLeafIteratorWrapper (<span class="keyword">const</span> GridImp &amp; grid, <span class="keywordtype">int</span> level , <span class="keyword">const</span> <span class="keywordtype">int</span> nlinks ) 
<a name="l01257"></a>01257       : iter_ ( InteriorIteratorType ( grid, level, nlinks ) ,
<a name="l01258"></a>01258                 GhostIteratorType    ( grid, level, nlinks ) )
<a name="l01259"></a>01259     {
<a name="l01260"></a>01260     }
<a name="l01261"></a>01261     
<a name="l01262"></a>01262     ALU3dGridLeafIteratorWrapper (<span class="keyword">const</span> ALU3dGridLeafIteratorWrapper &amp; org ) 
<a name="l01263"></a>01263       : iter_ (org.iter_) {}
<a name="l01264"></a>01264     
<a name="l01265"></a>01265     <span class="keywordtype">int</span> size  () { <span class="keywordflow">return</span> iter_.size(); }
<a name="l01266"></a>01266     <span class="keywordtype">void</span> next () { iter_.next(); }
<a name="l01267"></a>01267     <span class="keywordtype">void</span> first() { iter_.first(); }
<a name="l01268"></a>01268     <span class="keywordtype">int</span> done ()<span class="keyword"> const </span>{<span class="keywordflow">return</span> iter_.done(); }
<a name="l01269"></a>01269     val_t &amp; item ()<span class="keyword"> const </span>{ assert( ! done() ); <span class="keywordflow">return</span> iter_.item(); }
<a name="l01270"></a>01270   };
<a name="l01271"></a>01271 
<a name="l01272"></a>01272   <span class="comment">// the all partition iterator </span>
<a name="l01273"></a>01273   <span class="keyword">template</span> &lt;&gt; 
<a name="l01274"></a>01274   <span class="keyword">class </span>ALU3dGridLeafIteratorWrapper&lt;3,Dune::<a class="code" href="a00492.html#gga5b9e8102d7f70f3f4178182629d98b63026c69cd558fe3687c11f45966905e9" title="all entities">All_Partition</a>&gt; 
<a name="l01275"></a>01275     : <span class="keyword">public</span> IteratorWrapperInterface &lt; IteratorElType&lt;3&gt;::val_t &gt; 
<a name="l01276"></a>01276   {
<a name="l01277"></a>01277     <span class="keyword">enum</span> { codim = 3 };
<a name="l01278"></a>01278     <span class="keyword">typedef</span> ALU3dGridLeafIteratorWrapper&lt;codim,Dune::InteriorBorder_Partition&gt; InteriorIteratorType;
<a name="l01279"></a>01279     <span class="keyword">typedef</span> ALU3dGridLeafIteratorWrapper&lt;codim,Dune::Ghost_Partition&gt; GhostIteratorType;
<a name="l01280"></a>01280 
<a name="l01281"></a>01281   <span class="keyword">public</span>:  
<a name="l01282"></a>01282     <span class="keyword">typedef</span> IteratorElType&lt;codim&gt;::val_t val_t;
<a name="l01283"></a>01283     <span class="comment">// use ALUGrids AlignIterator to combine Interior and Ghost Iterator</span>
<a name="l01284"></a>01284     <span class="keyword">typedef</span> AlignIterator&lt; InteriorIteratorType, GhostIteratorType , val_t &gt; IteratorType; 
<a name="l01285"></a>01285   <span class="keyword">private</span>:
<a name="l01286"></a>01286     IteratorType iter_;
<a name="l01287"></a>01287   <span class="keyword">public</span>:
<a name="l01288"></a>01288     
<a name="l01289"></a>01289     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Gr<span class="keywordtype">id</span>Imp&gt; 
<a name="l01290"></a>01290     ALU3dGridLeafIteratorWrapper (<span class="keyword">const</span> GridImp &amp; grid, <span class="keywordtype">int</span> level , <span class="keyword">const</span> <span class="keywordtype">int</span> nlinks ) 
<a name="l01291"></a>01291       : iter_ ( InteriorIteratorType ( grid, level, nlinks ) ,
<a name="l01292"></a>01292                 GhostIteratorType    ( grid, level, nlinks ) )
<a name="l01293"></a>01293     {
<a name="l01294"></a>01294     }
<a name="l01295"></a>01295     
<a name="l01296"></a>01296     ALU3dGridLeafIteratorWrapper (<span class="keyword">const</span> ALU3dGridLeafIteratorWrapper &amp; org ) 
<a name="l01297"></a>01297       : iter_ (org.iter_) {}
<a name="l01298"></a>01298     
<a name="l01299"></a>01299     <span class="keywordtype">int</span> size  () { <span class="keywordflow">return</span> iter_.size(); }
<a name="l01300"></a>01300     <span class="keywordtype">void</span> next () { iter_.next(); }
<a name="l01301"></a>01301     <span class="keywordtype">void</span> first() { iter_.first(); }
<a name="l01302"></a>01302     <span class="keywordtype">int</span> done ()<span class="keyword"> const </span>{<span class="keywordflow">return</span> iter_.done(); }
<a name="l01303"></a>01303     val_t &amp; item ()<span class="keyword"> const </span>{ assert( ! done() ); <span class="keywordflow">return</span> iter_.item(); }
<a name="l01304"></a>01304   };
<a name="l01305"></a>01305 
<a name="l01306"></a>01306   <span class="comment">// the all partition iterator </span>
<a name="l01307"></a>01307   <span class="keyword">template</span> &lt;&gt; 
<a name="l01308"></a>01308   <span class="keyword">class </span>ALU3dGridLevelIteratorWrapper&lt;0,Dune::<a class="code" href="a00492.html#gga5b9e8102d7f70f3f4178182629d98b63026c69cd558fe3687c11f45966905e9" title="all entities">All_Partition</a>&gt; 
<a name="l01309"></a>01309     : <span class="keyword">public</span> IteratorWrapperInterface&lt; LeafValType &gt;
<a name="l01310"></a>01310   {
<a name="l01311"></a>01311     <span class="keyword">typedef</span> ALU3dGridLevelIteratorWrapper&lt;0,Dune::InteriorBorder_Partition&gt; InteriorIteratorType;
<a name="l01312"></a>01312     <span class="keyword">typedef</span> ALU3dGridLevelIteratorWrapper&lt;0,Dune::Ghost_Partition&gt; GhostIteratorType;
<a name="l01313"></a>01313 
<a name="l01314"></a>01314   <span class="keyword">public</span>:  
<a name="l01315"></a>01315     <span class="keyword">typedef</span> LeafValType val_t;
<a name="l01316"></a>01316     <span class="comment">// use ALUGrids AlignIterator to combine Interior and Ghost Iterator</span>
<a name="l01317"></a>01317     <span class="keyword">typedef</span> AlignIterator&lt; InteriorIteratorType, GhostIteratorType , val_t &gt; IteratorType; 
<a name="l01318"></a>01318   <span class="keyword">private</span>:
<a name="l01319"></a>01319     IteratorType iter_;
<a name="l01320"></a>01320   <span class="keyword">public</span>:
<a name="l01321"></a>01321     
<a name="l01322"></a>01322     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Gr<span class="keywordtype">id</span>Imp&gt; 
<a name="l01323"></a>01323     ALU3dGridLevelIteratorWrapper (<span class="keyword">const</span> GridImp &amp; grid, <span class="keywordtype">int</span> level , <span class="keyword">const</span> <span class="keywordtype">int</span> nlinks ) 
<a name="l01324"></a>01324       : iter_ ( InteriorIteratorType ( grid, level, nlinks ) ,
<a name="l01325"></a>01325                 GhostIteratorType    ( grid, level, nlinks ) )
<a name="l01326"></a>01326     {
<a name="l01327"></a>01327     }
<a name="l01328"></a>01328     
<a name="l01329"></a>01329     ALU3dGridLevelIteratorWrapper (<span class="keyword">const</span> ALU3dGridLevelIteratorWrapper &amp; org) 
<a name="l01330"></a>01330       : iter_(org.iter_) {}
<a name="l01331"></a>01331     
<a name="l01332"></a>01332     <span class="keywordtype">int</span> size  () { <span class="keywordflow">return</span> iter_.size(); }
<a name="l01333"></a>01333     <span class="keywordtype">void</span> next () { iter_.next(); }
<a name="l01334"></a>01334     <span class="keywordtype">void</span> first() { iter_.first(); }
<a name="l01335"></a>01335     <span class="keywordtype">int</span> done ()<span class="keyword"> const </span>{<span class="keywordflow">return</span> iter_.done(); }
<a name="l01336"></a>01336     val_t &amp; item ()<span class="keyword"> const </span>{ assert( ! done() ); <span class="keywordflow">return</span> iter_.item(); }
<a name="l01337"></a>01337   };
<a name="l01338"></a>01338 <span class="preprocessor">#endif // end ALU3DGRID_PARALLEL</span>
<a name="l01339"></a>01339 <span class="preprocessor"></span>
<a name="l01340"></a>01340   <span class="comment">// placed here because we need ALU3dGridLevelIteratorWrapper&lt;0,Dune::All_Partition&gt; here </span>
<a name="l01341"></a>01341   <span class="comment">// the edge level iterator </span>
<a name="l01342"></a>01342   <span class="keyword">template</span> &lt;PartitionIteratorType pitype&gt;
<a name="l01343"></a>01343   <span class="keyword">class </span>ALU3dGridLevelIteratorWrapper&lt;2,pitype&gt;
<a name="l01344"></a>01344     : <span class="keyword">public</span> IteratorWrapperInterface&lt; typename IteratorElType&lt;2&gt;::val_t &gt;
<a name="l01345"></a>01345   {
<a name="l01346"></a>01346   <span class="keyword">public</span>:  
<a name="l01347"></a>01347     <span class="keyword">typedef</span> ALUHElementType&lt;2&gt;::ElementType ElType; 
<a name="l01348"></a>01348     <span class="keyword">typedef</span> ALU3DSPACE GEOEdgeT GEOEdgeType;
<a name="l01349"></a>01349     
<a name="l01350"></a>01350     <span class="keyword">typedef</span> <span class="keyword">typename</span> IteratorElType&lt;2&gt;::val_t val_t;
<a name="l01351"></a>01351   <span class="keyword">private</span>:
<a name="l01352"></a>01352     <span class="keyword">mutable</span> val_t elem_;
<a name="l01353"></a>01353     <span class="keyword">const</span> <span class="keywordtype">int</span> level_;
<a name="l01354"></a>01354 
<a name="l01355"></a>01355     <span class="keyword">typedef</span> Dune :: ALU3dGridItemListType ItemListType; 
<a name="l01356"></a>01356     ItemListType &amp; edgeList_;
<a name="l01357"></a>01357 
<a name="l01358"></a>01358     <span class="keywordtype">size_t</span> count_ ;
<a name="l01359"></a>01359     <span class="keywordtype">bool</span> maxLevel_;
<a name="l01360"></a>01360       
<a name="l01361"></a>01361   <span class="keyword">public</span>:  
<a name="l01362"></a>01362     <span class="comment">// constructor creating iterator </span>
<a name="l01363"></a>01363     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Gr<span class="keywordtype">id</span>Imp&gt; 
<a name="l01364"></a>01364     ALU3dGridLevelIteratorWrapper (<span class="keyword">const</span> GridImp &amp; grid, <span class="keywordtype">int</span> level , <span class="keyword">const</span> <span class="keywordtype">int</span> nlinks ) 
<a name="l01365"></a>01365       : elem_(0,0)
<a name="l01366"></a>01366       , level_(level) 
<a name="l01367"></a>01367       , edgeList_( grid.getEdgeList(level) )
<a name="l01368"></a>01368       , count_(0)
<a name="l01369"></a>01369     {
<a name="l01370"></a>01370       <span class="keywordflow">if</span>( ! edgeList_.up2Date() )
<a name="l01371"></a>01371         updateEdgeList(grid,level,nlinks);
<a name="l01372"></a>01372     }
<a name="l01373"></a>01373 
<a name="l01374"></a>01374     <span class="comment">// copy constructor </span>
<a name="l01375"></a>01375     ALU3dGridLevelIteratorWrapper (<span class="keyword">const</span> ALU3dGridLevelIteratorWrapper &amp; org )
<a name="l01376"></a>01376       : elem_(org.elem_) 
<a name="l01377"></a>01377       , level_(org.level_)
<a name="l01378"></a>01378       , edgeList_( org.edgeList_ )
<a name="l01379"></a>01379       , count_(org.count_)
<a name="l01380"></a>01380     {
<a name="l01381"></a>01381     }
<a name="l01382"></a>01382 
<a name="l01383"></a>01383     <span class="keywordtype">int</span> size  () { <span class="keywordflow">return</span> edgeList_.getItemList().size(); }
<a name="l01384"></a>01384     <span class="keywordtype">void</span> next ()      
<a name="l01385"></a>01385     { 
<a name="l01386"></a>01386       ++count_;
<a name="l01387"></a>01387     }
<a name="l01388"></a>01388 
<a name="l01389"></a>01389     <span class="keywordtype">void</span> first()      
<a name="l01390"></a>01390     { 
<a name="l01391"></a>01391       count_ = 0;
<a name="l01392"></a>01392     }
<a name="l01393"></a>01393     
<a name="l01394"></a>01394     <span class="keywordtype">int</span> done ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> ((count_ &gt;= edgeList_.size()) ? 1: 0); }
<a name="l01395"></a>01395     
<a name="l01396"></a>01396     val_t &amp; item ()<span class="keyword"> const </span>
<a name="l01397"></a>01397 <span class="keyword">    </span>{ 
<a name="l01398"></a>01398       assert( ! done () );
<a name="l01399"></a>01399       elem_.first = ( (ElType *) edgeList_.getItemList()[count_]);
<a name="l01400"></a>01400 
<a name="l01401"></a>01401       assert( elem_.first );
<a name="l01402"></a>01402       <span class="keywordflow">return</span> elem_; 
<a name="l01403"></a>01403     }
<a name="l01404"></a>01404   <span class="keyword">private</span>: 
<a name="l01405"></a>01405     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Gr<span class="keywordtype">id</span>Imp&gt;
<a name="l01406"></a>01406     <span class="keywordtype">void</span> updateEdgeList(<span class="keyword">const</span> GridImp &amp; grid, <span class="keywordtype">int</span> level, <span class="keywordtype">int</span> nlinks) 
<a name="l01407"></a>01407     {
<a name="l01408"></a>01408       <span class="keyword">typedef</span> ALU3dGridLevelIteratorWrapper&lt;0,Dune::All_Partition&gt; ElementLevelIterator;
<a name="l01409"></a>01409       <span class="keyword">typedef</span> <span class="keyword">typename</span> ElementLevelIterator :: val_t el_val_t;
<a name="l01410"></a>01410       ElementLevelIterator iter(grid,level,nlinks);
<a name="l01411"></a>01411 
<a name="l01412"></a>01412       edgeList_.getItemList().resize(0);
<a name="l01413"></a>01413       map &lt; int , int &gt; visited; 
<a name="l01414"></a>01414       
<a name="l01415"></a>01415       <span class="keywordflow">for</span>( iter.first(); ! iter.done(); iter.next() )
<a name="l01416"></a>01416       {
<a name="l01417"></a>01417         <span class="keyword">typedef</span> <span class="keyword">typename</span> Dune :: ALU3dImplTraits&lt;GridImp::elementType&gt;::GEOElementType GEOElementType;
<a name="l01418"></a>01418         <span class="keyword">enum</span> { numEdges = Dune :: EntityCount&lt;GridImp::elementType&gt;::numEdges };
<a name="l01419"></a>01419         
<a name="l01420"></a>01420         GEOElementType * elem = 0;
<a name="l01421"></a>01421         el_val_t &amp; item = iter.item();
<a name="l01422"></a>01422         
<a name="l01423"></a>01423         <span class="keywordflow">if</span>( item.first )
<a name="l01424"></a>01424           elem = <span class="keyword">static_cast&lt;</span>GEOElementType *<span class="keyword">&gt;</span> (item.first);
<a name="l01425"></a>01425         <span class="keywordflow">else</span> <span class="keywordflow">if</span>( item.second )
<a name="l01426"></a>01426           elem = <span class="keyword">static_cast&lt;</span>GEOElementType *<span class="keyword">&gt;</span> (item.second-&gt;getGhost().first);
<a name="l01427"></a>01427 
<a name="l01428"></a>01428         assert( elem );
<a name="l01429"></a>01429         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> e=0; e&lt;numEdges; ++e) 
<a name="l01430"></a>01430         {
<a name="l01431"></a>01431           ElType * edge = elem-&gt;myhedge1(e);
<a name="l01432"></a>01432           <span class="keywordflow">if</span>( edge-&gt;isGhost() ) <span class="keywordflow">continue</span>;
<a name="l01433"></a>01433 
<a name="l01434"></a>01434           <span class="keywordtype">int</span> idx = edge-&gt;getIndex();
<a name="l01435"></a>01435           <span class="keywordflow">if</span>( visited.find(idx) == visited.end() )
<a name="l01436"></a>01436           {
<a name="l01437"></a>01437             edgeList_.getItemList().push_back( (<span class="keywordtype">void</span> *) edge );
<a name="l01438"></a>01438             visited[idx] = 1;
<a name="l01439"></a>01439           }
<a name="l01440"></a>01440         }
<a name="l01441"></a>01441       }
<a name="l01442"></a>01442       edgeList_.markAsUp2Date();
<a name="l01443"></a>01443     }
<a name="l01444"></a>01444   };
<a name="l01445"></a>01445 
<a name="l01446"></a>01446 <span class="preprocessor">#if ALU3DGRID_PARALLEL</span>
<a name="l01447"></a>01447 <span class="preprocessor"></span>  <span class="comment">// the all partition iterator </span>
<a name="l01448"></a>01448   <span class="keyword">template</span> &lt;&gt; 
<a name="l01449"></a>01449   <span class="keyword">class </span>ALU3dGridLevelIteratorWrapper&lt;1,Dune::<a class="code" href="a00492.html#gga5b9e8102d7f70f3f4178182629d98b63026c69cd558fe3687c11f45966905e9" title="all entities">All_Partition</a>&gt; 
<a name="l01450"></a>01450     : <span class="keyword">public</span> IteratorWrapperInterface &lt; IteratorElType&lt;1&gt;::val_t &gt; 
<a name="l01451"></a>01451   {
<a name="l01452"></a>01452     <span class="keyword">enum</span> { codim = 1 };
<a name="l01453"></a>01453     <span class="keyword">typedef</span> ALU3dGridLevelIteratorWrapper&lt;codim,Dune::InteriorBorder_Partition&gt; InteriorIteratorType;
<a name="l01454"></a>01454     <span class="keyword">typedef</span> ALU3dGridLevelIteratorWrapper&lt;codim,Dune::Ghost_Partition&gt; GhostIteratorType;
<a name="l01455"></a>01455 
<a name="l01456"></a>01456   <span class="keyword">public</span>:  
<a name="l01457"></a>01457     <span class="keyword">typedef</span> IteratorElType&lt;codim&gt;::val_t val_t;
<a name="l01458"></a>01458     <span class="comment">// use ALUGrids AlignIterator to combine Interior and Ghost Iterator</span>
<a name="l01459"></a>01459     <span class="keyword">typedef</span> AlignIterator&lt; InteriorIteratorType, GhostIteratorType , val_t &gt; IteratorType; 
<a name="l01460"></a>01460   <span class="keyword">private</span>:
<a name="l01461"></a>01461     IteratorType iter_;
<a name="l01462"></a>01462   <span class="keyword">public</span>:
<a name="l01463"></a>01463     
<a name="l01464"></a>01464     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Gr<span class="keywordtype">id</span>Imp&gt; 
<a name="l01465"></a>01465     ALU3dGridLevelIteratorWrapper (<span class="keyword">const</span> GridImp &amp; grid, <span class="keywordtype">int</span> level , <span class="keyword">const</span> <span class="keywordtype">int</span> nlinks ) 
<a name="l01466"></a>01466       : iter_ ( InteriorIteratorType ( grid, level, nlinks ) ,
<a name="l01467"></a>01467                 GhostIteratorType    ( grid, level, nlinks ) )
<a name="l01468"></a>01468     {
<a name="l01469"></a>01469     }
<a name="l01470"></a>01470     
<a name="l01471"></a>01471     ALU3dGridLevelIteratorWrapper (<span class="keyword">const</span> ALU3dGridLevelIteratorWrapper &amp; org ) 
<a name="l01472"></a>01472       : iter_ (org.iter_) {}
<a name="l01473"></a>01473     
<a name="l01474"></a>01474     <span class="keywordtype">int</span> size  () { <span class="keywordflow">return</span> iter_.size(); }
<a name="l01475"></a>01475     <span class="keywordtype">void</span> next () { iter_.next(); }
<a name="l01476"></a>01476     <span class="keywordtype">void</span> first() { iter_.first(); }
<a name="l01477"></a>01477     <span class="keywordtype">int</span> done ()<span class="keyword"> const </span>{<span class="keywordflow">return</span> iter_.done(); }
<a name="l01478"></a>01478     val_t &amp; item ()<span class="keyword"> const </span>{ assert( ! done() ); <span class="keywordflow">return</span> iter_.item(); }
<a name="l01479"></a>01479   };
<a name="l01480"></a>01480 
<a name="l01481"></a>01481   <span class="comment">// the all partition iterator </span>
<a name="l01482"></a>01482   <span class="keyword">template</span> &lt;&gt; 
<a name="l01483"></a>01483   <span class="keyword">class </span>ALU3dGridLevelIteratorWrapper&lt;2,Dune::<a class="code" href="a00492.html#gga5b9e8102d7f70f3f4178182629d98b63026c69cd558fe3687c11f45966905e9" title="all entities">All_Partition</a>&gt; 
<a name="l01484"></a>01484     : <span class="keyword">public</span> IteratorWrapperInterface &lt; IteratorElType&lt;2&gt;::val_t &gt; 
<a name="l01485"></a>01485   {
<a name="l01486"></a>01486     <span class="keyword">enum</span> { codim = 2 };
<a name="l01487"></a>01487     <span class="keyword">typedef</span> ALU3dGridLevelIteratorWrapper&lt;codim,Dune::InteriorBorder_Partition&gt; InteriorIteratorType;
<a name="l01488"></a>01488     <span class="keyword">typedef</span> ALU3dGridLevelIteratorWrapper&lt;codim,Dune::Ghost_Partition&gt; GhostIteratorType;
<a name="l01489"></a>01489 
<a name="l01490"></a>01490   <span class="keyword">public</span>:  
<a name="l01491"></a>01491     <span class="keyword">typedef</span> IteratorElType&lt;codim&gt;::val_t val_t;
<a name="l01492"></a>01492     <span class="comment">// use ALUGrids AlignIterator to combine Interior and Ghost Iterator</span>
<a name="l01493"></a>01493     <span class="keyword">typedef</span> AlignIterator&lt; InteriorIteratorType, GhostIteratorType , val_t &gt; IteratorType; 
<a name="l01494"></a>01494   <span class="keyword">private</span>:
<a name="l01495"></a>01495     IteratorType iter_;
<a name="l01496"></a>01496   <span class="keyword">public</span>:
<a name="l01497"></a>01497     
<a name="l01498"></a>01498     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Gr<span class="keywordtype">id</span>Imp&gt; 
<a name="l01499"></a>01499     ALU3dGridLevelIteratorWrapper (<span class="keyword">const</span> GridImp &amp; grid, <span class="keywordtype">int</span> level , <span class="keyword">const</span> <span class="keywordtype">int</span> nlinks ) 
<a name="l01500"></a>01500       : iter_ ( InteriorIteratorType ( grid, level, nlinks ) ,
<a name="l01501"></a>01501                 GhostIteratorType    ( grid, level, nlinks ) )
<a name="l01502"></a>01502     {
<a name="l01503"></a>01503     }
<a name="l01504"></a>01504     
<a name="l01505"></a>01505     ALU3dGridLevelIteratorWrapper (<span class="keyword">const</span> ALU3dGridLevelIteratorWrapper &amp; org ) 
<a name="l01506"></a>01506       : iter_ (org.iter_) {}
<a name="l01507"></a>01507     
<a name="l01508"></a>01508     <span class="keywordtype">int</span> size  () { <span class="keywordflow">return</span> iter_.size(); }
<a name="l01509"></a>01509     <span class="keywordtype">void</span> next () { iter_.next(); }
<a name="l01510"></a>01510     <span class="keywordtype">void</span> first() { iter_.first(); }
<a name="l01511"></a>01511     <span class="keywordtype">int</span> done ()<span class="keyword"> const </span>{<span class="keywordflow">return</span> iter_.done(); }
<a name="l01512"></a>01512     val_t &amp; item ()<span class="keyword"> const </span>{ assert( ! done() ); <span class="keywordflow">return</span> iter_.item(); }
<a name="l01513"></a>01513   };
<a name="l01514"></a>01514 
<a name="l01515"></a>01515   <span class="comment">// the all partition iterator </span>
<a name="l01516"></a>01516   <span class="keyword">template</span> &lt;&gt; 
<a name="l01517"></a>01517   <span class="keyword">class </span>ALU3dGridLevelIteratorWrapper&lt;3,Dune::<a class="code" href="a00492.html#gga5b9e8102d7f70f3f4178182629d98b63026c69cd558fe3687c11f45966905e9" title="all entities">All_Partition</a>&gt; 
<a name="l01518"></a>01518     : <span class="keyword">public</span> IteratorWrapperInterface &lt; IteratorElType&lt;3&gt;::val_t &gt; 
<a name="l01519"></a>01519   {
<a name="l01520"></a>01520     <span class="keyword">enum</span> { codim = 3 };
<a name="l01521"></a>01521     <span class="keyword">typedef</span> ALU3dGridLevelIteratorWrapper&lt;codim,Dune::InteriorBorder_Partition&gt; InteriorIteratorType;
<a name="l01522"></a>01522     <span class="keyword">typedef</span> ALU3dGridLevelIteratorWrapper&lt;codim,Dune::Ghost_Partition&gt; GhostIteratorType;
<a name="l01523"></a>01523 
<a name="l01524"></a>01524   <span class="keyword">public</span>:  
<a name="l01525"></a>01525     <span class="keyword">typedef</span> IteratorElType&lt;codim&gt;::val_t val_t;
<a name="l01526"></a>01526     <span class="comment">// use ALUGrids AlignIterator to combine Interior and Ghost Iterator</span>
<a name="l01527"></a>01527     <span class="keyword">typedef</span> AlignIterator&lt; InteriorIteratorType, GhostIteratorType , val_t &gt; IteratorType; 
<a name="l01528"></a>01528   <span class="keyword">private</span>:
<a name="l01529"></a>01529     IteratorType iter_;
<a name="l01530"></a>01530   <span class="keyword">public</span>:
<a name="l01531"></a>01531     
<a name="l01532"></a>01532     <span class="keyword">template</span> &lt;<span class="keyword">class</span> Gr<span class="keywordtype">id</span>Imp&gt; 
<a name="l01533"></a>01533     ALU3dGridLevelIteratorWrapper (<span class="keyword">const</span> GridImp &amp; grid, <span class="keywordtype">int</span> level , <span class="keyword">const</span> <span class="keywordtype">int</span> nlinks ) 
<a name="l01534"></a>01534       : iter_ ( InteriorIteratorType ( grid, level, nlinks ) ,
<a name="l01535"></a>01535                 GhostIteratorType    ( grid, level, nlinks ) )
<a name="l01536"></a>01536     {
<a name="l01537"></a>01537     }
<a name="l01538"></a>01538     
<a name="l01539"></a>01539     ALU3dGridLevelIteratorWrapper (<span class="keyword">const</span> ALU3dGridLevelIteratorWrapper &amp; org ) 
<a name="l01540"></a>01540       : iter_ (org.iter_) {}
<a name="l01541"></a>01541     
<a name="l01542"></a>01542     <span class="keywordtype">int</span> size  () { <span class="keywordflow">return</span> iter_.size(); }
<a name="l01543"></a>01543     <span class="keywordtype">void</span> next () { iter_.next(); }
<a name="l01544"></a>01544     <span class="keywordtype">void</span> first() { iter_.first(); }
<a name="l01545"></a>01545     <span class="keywordtype">int</span> done ()<span class="keyword"> const </span>{<span class="keywordflow">return</span> iter_.done(); }
<a name="l01546"></a>01546     val_t &amp; item ()<span class="keyword"> const </span>{ assert( ! done() ); <span class="keywordflow">return</span> iter_.item(); }
<a name="l01547"></a>01547   };
<a name="l01548"></a>01548 <span class="preprocessor">#endif // end if ALU3DGRID_PARALLEL</span>
<a name="l01549"></a>01549 <span class="preprocessor"></span>
<a name="l01550"></a>01550   <span class="keyword">typedef</span> PureElementLeafIterator &lt; GitterType::helement_STI &gt; BSLeafIteratorMaxLevel; 
<a name="l01551"></a>01551 
<a name="l01552"></a>01552 } <span class="comment">//end namespace ALU3dGrid</span>
<a name="l01553"></a>01553 <span class="preprocessor">#endif</span>
</pre></div></div>
</div> <!-- end doxygen -->
</div> <!-- end main -->
<div class="foot">

<p class="foot">
  Generated on 6 Nov 2008 with <a
  href="http://www.doxygen.org/">Doxygen</a> (ver 1.5.6)  
  [<a href="doxygen.log">logfile</a>].
</p>

</div>

</body>
</html>
