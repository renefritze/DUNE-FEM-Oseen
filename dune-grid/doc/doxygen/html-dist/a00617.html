<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN""http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>dune-grid: grids.hh Source File (dune-grid )</title>
  <link rel="stylesheet" type="text/css" href="./dune-doxy.css">
  <link rel="stylesheet" type="text/css" href="./tabs.css">
</head>
<div class="main">
<div class="doxygen">
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_5edca94048dae04696b7e65d07cd8e9c.html">grid</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_97bcd0756eca957496b4eb1ae12786d0.html">yaspgrid</a>
  </div>
</div>
<div class="contents">
<h1>grids.hh</h1><a href="a00399.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef DUNE_YGRIDS_HH</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define DUNE_YGRIDS_HH</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="comment">// C++ includes</span>
<a name="l00005"></a>00005 <span class="preprocessor">#include&lt;iostream&gt;</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include&lt;cstdlib&gt;</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include&lt;algorithm&gt;</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include&lt;vector&gt;</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include&lt;deque&gt;</span>
<a name="l00010"></a>00010 
<a name="l00011"></a>00011 <span class="comment">// C includes</span>
<a name="l00012"></a>00012 <span class="preprocessor">#if HAVE_MPI</span>
<a name="l00013"></a>00013 <span class="preprocessor"></span><span class="preprocessor">#include&lt;mpi.h&gt;</span>
<a name="l00014"></a>00014 <span class="preprocessor">#endif</span>
<a name="l00015"></a>00015 <span class="preprocessor"></span><span class="preprocessor">#include&lt;string.h&gt;</span>
<a name="l00016"></a>00016 
<a name="l00017"></a>00017 <span class="comment">// local includes</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &lt;dune/common/fvector.hh&gt;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &lt;dune/common/stdstreams.hh&gt;</span>
<a name="l00020"></a>00020 
<a name="l00025"></a>00025 <span class="keyword">namespace </span>Dune {
<a name="l00026"></a>00026 
<a name="l00027"></a>00027   <span class="comment">// forward declarations</span>
<a name="l00028"></a>00028   <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> d, <span class="keyword">typename</span> ct&gt; <span class="keyword">class </span>YGrid;
<a name="l00029"></a>00029   <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> d, <span class="keyword">typename</span> ct&gt; <span class="keyword">class </span>SubYGrid;
<a name="l00030"></a>00030 
<a name="l00031"></a>00031   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">double</span> Ytolerance=1E-13;
<a name="l00032"></a>00032  
<a name="l00066"></a>00066   <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> d, <span class="keyword">typename</span> ct&gt;
<a name="l00067"></a><a class="code" href="a00308.html">00067</a>   <span class="keyword">class </span><a class="code" href="a00308.html">YGrid</a> {
<a name="l00068"></a>00068   <span class="keyword">public</span>:
<a name="l00070"></a><a class="code" href="a00308.html#592fd83e3b3a988964d22258a85d2f87">00070</a>         <span class="keyword">typedef</span> FieldVector&lt;int, d&gt;  <a class="code" href="a00308.html#592fd83e3b3a988964d22258a85d2f87" title="define types used for arguments">iTupel</a>;
<a name="l00071"></a>00071         <span class="keyword">typedef</span> FieldVector&lt;ct, d&gt; fTupel;
<a name="l00072"></a>00072         <span class="keyword">typedef</span> FieldVector&lt;bool, d&gt; bTupel;
<a name="l00073"></a>00073     
<a name="l00075"></a><a class="code" href="a00308.html#ee6125fcae91b9fd949cd7f37704af72">00075</a>     <span class="keyword">virtual</span> <a class="code" href="a00308.html#ee6125fcae91b9fd949cd7f37704af72" title="Destructor.">~YGrid</a>()
<a name="l00076"></a>00076     {}
<a name="l00077"></a>00077     
<a name="l00079"></a><a class="code" href="a00308.html#82a4165820ead6bf8494479e889408ea">00079</a>         <a class="code" href="a00308.html#82a4165820ead6bf8494479e889408ea" title="Make an empty YGrid with origin 0.">YGrid</a> ()
<a name="l00080"></a>00080         {
<a name="l00081"></a>00081           <a class="code" href="a00308.html#f12c4aa62441f20edcde8eb539374674" title="internal representation uses origin/size">_origin</a> = 0;
<a name="l00082"></a>00082           _size = 0;
<a name="l00083"></a>00083           <a class="code" href="a00308.html#3b4c479226b25b2c885d655fd61bb277" title="mesh size per direction">_h</a> = 0.0;
<a name="l00084"></a>00084           <a class="code" href="a00308.html#890dc83636cf8aaf0e33bf152ca001f7" title="shift per direction">_r</a> = 0.0;
<a name="l00085"></a>00085         }
<a name="l00086"></a>00086 
<a name="l00088"></a><a class="code" href="a00308.html#f140bd9239a681f0f588274a3f06fbaf">00088</a>         <a class="code" href="a00308.html#82a4165820ead6bf8494479e889408ea" title="Make an empty YGrid with origin 0.">YGrid</a> (<a class="code" href="a00308.html#592fd83e3b3a988964d22258a85d2f87" title="define types used for arguments">iTupel</a> o, <a class="code" href="a00308.html#592fd83e3b3a988964d22258a85d2f87" title="define types used for arguments">iTupel</a> s, fTupel h, fTupel r)
<a name="l00089"></a>00089         {
<a name="l00090"></a>00090           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i) 
<a name="l00091"></a>00091                 {
<a name="l00092"></a>00092                   <a class="code" href="a00308.html#f12c4aa62441f20edcde8eb539374674" title="internal representation uses origin/size">_origin</a>[i] = o[i];
<a name="l00093"></a>00093                   _size[i] = s[i];
<a name="l00094"></a>00094                   <span class="keywordflow">if</span> (_size[i]&lt;0) {
<a name="l00095"></a>00095                         _size[i] = 0;
<a name="l00096"></a>00096                   }
<a name="l00097"></a>00097                   <a class="code" href="a00308.html#3b4c479226b25b2c885d655fd61bb277" title="mesh size per direction">_h</a>[i] = h[i];
<a name="l00098"></a>00098                   <a class="code" href="a00308.html#890dc83636cf8aaf0e33bf152ca001f7" title="shift per direction">_r</a>[i] = r[i];
<a name="l00099"></a>00099                 }
<a name="l00100"></a>00100         }
<a name="l00101"></a>00101 
<a name="l00103"></a><a class="code" href="a00308.html#321e0bd5abb6d0471e368fbe131b87e5">00103</a>         <span class="keywordtype">int</span> <a class="code" href="a00308.html#d56157b682bf637c2f286facef2ee6e9" title="return reference to origin">origin</a> (<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
<a name="l00104"></a>00104 <span class="keyword">        </span>{
<a name="l00105"></a>00105           <span class="keywordflow">return</span> <a class="code" href="a00308.html#f12c4aa62441f20edcde8eb539374674" title="internal representation uses origin/size">_origin</a>[i];
<a name="l00106"></a>00106         }
<a name="l00107"></a>00107         
<a name="l00109"></a><a class="code" href="a00308.html#dfc7092ffc6daf1406b4dbdda5a90f36">00109</a>         <span class="keywordtype">void</span> <a class="code" href="a00308.html#d56157b682bf637c2f286facef2ee6e9" title="return reference to origin">origin</a> (<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> oi)<span class="keyword"> const</span>
<a name="l00110"></a>00110 <span class="keyword">        </span>{
<a name="l00111"></a>00111           <a class="code" href="a00308.html#f12c4aa62441f20edcde8eb539374674" title="internal representation uses origin/size">_origin</a>[i] = oi;
<a name="l00112"></a>00112         }
<a name="l00113"></a>00113 
<a name="l00115"></a><a class="code" href="a00308.html#d56157b682bf637c2f286facef2ee6e9">00115</a>         <span class="keyword">const</span> <a class="code" href="a00308.html#592fd83e3b3a988964d22258a85d2f87" title="define types used for arguments">iTupel</a>&amp; <a class="code" href="a00308.html#d56157b682bf637c2f286facef2ee6e9" title="return reference to origin">origin</a> ()<span class="keyword"> const</span>
<a name="l00116"></a>00116 <span class="keyword">        </span>{
<a name="l00117"></a>00117           <span class="keywordflow">return</span> <a class="code" href="a00308.html#f12c4aa62441f20edcde8eb539374674" title="internal representation uses origin/size">_origin</a>;
<a name="l00118"></a>00118         }
<a name="l00119"></a>00119 
<a name="l00121"></a><a class="code" href="a00308.html#e672f5b5698739a0d552f28ca50266e5">00121</a>         <span class="keywordtype">int</span> <a class="code" href="a00308.html#7c257903c899929a0c86414d7e4e62b4" title="Return reference to size tupel.">size</a> (<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
<a name="l00122"></a>00122 <span class="keyword">        </span>{
<a name="l00123"></a>00123           <span class="keywordflow">return</span> _size[i];
<a name="l00124"></a>00124         }
<a name="l00125"></a>00125 
<a name="l00127"></a><a class="code" href="a00308.html#be7ca7fb04eb9266eec0739244852a51">00127</a>         <span class="keywordtype">void</span> <a class="code" href="a00308.html#7c257903c899929a0c86414d7e4e62b4" title="Return reference to size tupel.">size</a> (<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> si)<span class="keyword"> const</span>
<a name="l00128"></a>00128 <span class="keyword">        </span>{
<a name="l00129"></a>00129           _size[i] = si;
<a name="l00130"></a>00130           <span class="keywordflow">if</span> (_size[i]&lt;0) _size[i] = 0;
<a name="l00131"></a>00131         }
<a name="l00132"></a>00132         
<a name="l00134"></a><a class="code" href="a00308.html#7c257903c899929a0c86414d7e4e62b4">00134</a>         <span class="keyword">const</span> <a class="code" href="a00308.html#592fd83e3b3a988964d22258a85d2f87" title="define types used for arguments">iTupel</a>&amp; <a class="code" href="a00308.html#7c257903c899929a0c86414d7e4e62b4" title="Return reference to size tupel.">size</a> ()<span class="keyword"> const</span>
<a name="l00135"></a>00135 <span class="keyword">        </span>{
<a name="l00136"></a>00136           <span class="keywordflow">return</span> _size;
<a name="l00137"></a>00137         }
<a name="l00138"></a>00138 
<a name="l00140"></a><a class="code" href="a00308.html#dc66c21bb01f217b711c0e78f88f6302">00140</a>         <span class="keywordtype">int</span> <a class="code" href="a00308.html#dc66c21bb01f217b711c0e78f88f6302" title="Return total size of index set which is the product of all size per direction.">totalsize</a> ()<span class="keyword"> const</span>
<a name="l00141"></a>00141 <span class="keyword">        </span>{
<a name="l00142"></a>00142           <span class="keywordtype">int</span> s=1;
<a name="l00143"></a>00143           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i) s=s*_size[i];
<a name="l00144"></a>00144           <span class="keywordflow">return</span> s;
<a name="l00145"></a>00145         }
<a name="l00146"></a>00146 
<a name="l00148"></a><a class="code" href="a00308.html#31c32fddfc3c89fac70e1faf6f0d459a">00148</a>         <span class="keywordtype">int</span> <a class="code" href="a00308.html#31c32fddfc3c89fac70e1faf6f0d459a" title="Return minimum index in direction i.">min</a> (<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
<a name="l00149"></a>00149 <span class="keyword">        </span>{
<a name="l00150"></a>00150           <span class="keywordflow">return</span> <a class="code" href="a00308.html#f12c4aa62441f20edcde8eb539374674" title="internal representation uses origin/size">_origin</a>[i];
<a name="l00151"></a>00151         }
<a name="l00152"></a>00152 
<a name="l00154"></a><a class="code" href="a00308.html#d0170afd91ec9fbb1728e1244de48e85">00154</a>         <span class="keywordtype">void</span> <a class="code" href="a00308.html#31c32fddfc3c89fac70e1faf6f0d459a" title="Return minimum index in direction i.">min</a> (<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> mi)<span class="keyword"> const</span>
<a name="l00155"></a>00155 <span class="keyword">        </span>{
<a name="l00156"></a>00156           _size[i] = <a class="code" href="a00308.html#eb23a6893a81d54f72fe60e8acd75ad5" title="Return maximum index in direction i.">max</a>(i)-mi+1;
<a name="l00157"></a>00157           <a class="code" href="a00308.html#f12c4aa62441f20edcde8eb539374674" title="internal representation uses origin/size">_origin</a>[i] = mi;
<a name="l00158"></a>00158           <span class="keywordflow">if</span> (_size[i]&lt;0) _size[i] = 0;
<a name="l00159"></a>00159         }
<a name="l00160"></a>00160 
<a name="l00162"></a><a class="code" href="a00308.html#eb23a6893a81d54f72fe60e8acd75ad5">00162</a>         <span class="keywordtype">int</span> <a class="code" href="a00308.html#eb23a6893a81d54f72fe60e8acd75ad5" title="Return maximum index in direction i.">max</a> (<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
<a name="l00163"></a>00163 <span class="keyword">        </span>{
<a name="l00164"></a>00164           <span class="keywordflow">return</span> <a class="code" href="a00308.html#f12c4aa62441f20edcde8eb539374674" title="internal representation uses origin/size">_origin</a>[i]+_size[i]-1;
<a name="l00165"></a>00165         }
<a name="l00166"></a>00166 
<a name="l00168"></a><a class="code" href="a00308.html#68f9c3e1bf7028fb7882bafeedfa94ca">00168</a>         <span class="keywordtype">void</span> <a class="code" href="a00308.html#eb23a6893a81d54f72fe60e8acd75ad5" title="Return maximum index in direction i.">max</a> (<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> mi)<span class="keyword"> const</span>
<a name="l00169"></a>00169 <span class="keyword">        </span>{
<a name="l00170"></a>00170           _size[i] = mi-<a class="code" href="a00308.html#31c32fddfc3c89fac70e1faf6f0d459a" title="Return minimum index in direction i.">min</a>(i)+1;
<a name="l00171"></a>00171           <span class="keywordflow">if</span> (_size[i]&lt;0) _size[i] = 0;
<a name="l00172"></a>00172         }
<a name="l00173"></a>00173 
<a name="l00175"></a><a class="code" href="a00308.html#7bed6643312a1e459af95cdcc69f8fbd">00175</a>         <span class="keyword">const</span> fTupel&amp; <a class="code" href="a00308.html#7bed6643312a1e459af95cdcc69f8fbd" title="Return reference to mesh size tupel for read write access.">meshsize</a> ()<span class="keyword"> const</span>
<a name="l00176"></a>00176 <span class="keyword">        </span>{
<a name="l00177"></a>00177           <span class="keywordflow">return</span> <a class="code" href="a00308.html#3b4c479226b25b2c885d655fd61bb277" title="mesh size per direction">_h</a>;
<a name="l00178"></a>00178         }
<a name="l00179"></a>00179         
<a name="l00181"></a><a class="code" href="a00308.html#f684f459ee0bf12b98e6d9d407539f23">00181</a>         ct <a class="code" href="a00308.html#7bed6643312a1e459af95cdcc69f8fbd" title="Return reference to mesh size tupel for read write access.">meshsize</a> (<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
<a name="l00182"></a>00182 <span class="keyword">        </span>{
<a name="l00183"></a>00183           <span class="keywordflow">return</span> <a class="code" href="a00308.html#3b4c479226b25b2c885d655fd61bb277" title="mesh size per direction">_h</a>[i];
<a name="l00184"></a>00184         }
<a name="l00185"></a>00185         
<a name="l00187"></a><a class="code" href="a00308.html#1760d259dd74ace4cabe70923d250fbb">00187</a>         <span class="keywordtype">void</span> <a class="code" href="a00308.html#7bed6643312a1e459af95cdcc69f8fbd" title="Return reference to mesh size tupel for read write access.">meshsize</a> (<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> hi)<span class="keyword"> const</span>
<a name="l00188"></a>00188 <span class="keyword">        </span>{
<a name="l00189"></a>00189           <a class="code" href="a00308.html#3b4c479226b25b2c885d655fd61bb277" title="mesh size per direction">_h</a>[i] = hi;
<a name="l00190"></a>00190         }
<a name="l00191"></a>00191 
<a name="l00193"></a><a class="code" href="a00308.html#bc763dfd8b05a22a609bae31dfc64b94">00193</a>         <span class="keyword">const</span> fTupel&amp; <a class="code" href="a00308.html#bc763dfd8b05a22a609bae31dfc64b94" title="Return shift tupel.">shift</a> ()<span class="keyword"> const</span>
<a name="l00194"></a>00194 <span class="keyword">        </span>{
<a name="l00195"></a>00195           <span class="keywordflow">return</span> <a class="code" href="a00308.html#890dc83636cf8aaf0e33bf152ca001f7" title="shift per direction">_r</a>;
<a name="l00196"></a>00196         }
<a name="l00197"></a>00197         
<a name="l00199"></a><a class="code" href="a00308.html#b50fd337c2a96d45b7b36940cdc70df5">00199</a>         ct <a class="code" href="a00308.html#bc763dfd8b05a22a609bae31dfc64b94" title="Return shift tupel.">shift</a> (<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
<a name="l00200"></a>00200 <span class="keyword">        </span>{
<a name="l00201"></a>00201           <span class="keywordflow">return</span> <a class="code" href="a00308.html#890dc83636cf8aaf0e33bf152ca001f7" title="shift per direction">_r</a>[i];
<a name="l00202"></a>00202         }
<a name="l00203"></a>00203         
<a name="l00205"></a><a class="code" href="a00308.html#1f76c9e5c0b58c4a543adc2f8a8ab6ef">00205</a>         <span class="keywordtype">void</span> <a class="code" href="a00308.html#bc763dfd8b05a22a609bae31dfc64b94" title="Return shift tupel.">shift</a> (<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> ri)<span class="keyword"> const</span>
<a name="l00206"></a>00206 <span class="keyword">        </span>{
<a name="l00207"></a>00207           <a class="code" href="a00308.html#890dc83636cf8aaf0e33bf152ca001f7" title="shift per direction">_r</a>[i] = ri;
<a name="l00208"></a>00208         }
<a name="l00209"></a>00209 
<a name="l00211"></a><a class="code" href="a00308.html#6b6d9a54e49d415ea27d4dc79dccb08f">00211</a>         <span class="keywordtype">bool</span> <a class="code" href="a00308.html#6b6d9a54e49d415ea27d4dc79dccb08f" title="Return true if YGrid is empty, i.e. has size 0 in all directions.">empty</a> ()<span class="keyword"> const</span>
<a name="l00212"></a>00212 <span class="keyword">        </span>{
<a name="l00213"></a>00213           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i) <span class="keywordflow">if</span> (_size[i]&lt;=0) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00214"></a>00214           <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00215"></a>00215         }
<a name="l00216"></a>00216 
<a name="l00218"></a><a class="code" href="a00308.html#eac8a437f95a8c73c26dd5da4a0a9c15">00218</a>         <span class="keywordtype">int</span> <a class="code" href="a00308.html#eac8a437f95a8c73c26dd5da4a0a9c15" title="given a tupel compute its index in the lexicographic numbering">index</a> (<span class="keyword">const</span> <a class="code" href="a00308.html#592fd83e3b3a988964d22258a85d2f87" title="define types used for arguments">iTupel</a>&amp; coord)<span class="keyword"> const</span>
<a name="l00219"></a>00219 <span class="keyword">        </span>{
<a name="l00220"></a>00220           <span class="keywordtype">int</span> <a class="code" href="a00308.html#eac8a437f95a8c73c26dd5da4a0a9c15" title="given a tupel compute its index in the lexicographic numbering">index</a> = (coord[d-1]-<a class="code" href="a00308.html#f12c4aa62441f20edcde8eb539374674" title="internal representation uses origin/size">_origin</a>[d-1]);
<a name="l00221"></a>00221           
<a name="l00222"></a>00222           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=d-2; i&gt;=0; i--) 
<a name="l00223"></a>00223                 index = index*_size[i] + (coord[i]-<a class="code" href="a00308.html#f12c4aa62441f20edcde8eb539374674" title="internal representation uses origin/size">_origin</a>[i]);
<a name="l00224"></a>00224 
<a name="l00225"></a>00225           <span class="keywordflow">return</span> index;
<a name="l00226"></a>00226         }
<a name="l00227"></a>00227 
<a name="l00229"></a><a class="code" href="a00308.html#da952c894237398350ff66a0774acbad">00229</a>         <span class="keywordtype">bool</span> <a class="code" href="a00308.html#da952c894237398350ff66a0774acbad" title="given a coordinate, return true if it is in the grid">inside</a> (<span class="keyword">const</span> <a class="code" href="a00308.html#592fd83e3b3a988964d22258a85d2f87" title="define types used for arguments">iTupel</a>&amp; coord)<span class="keyword"> const</span>
<a name="l00230"></a>00230 <span class="keyword">        </span>{
<a name="l00231"></a>00231           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; i++)
<a name="l00232"></a>00232                 {
<a name="l00233"></a>00233                   <span class="keywordflow">if</span> (coord[i]&lt;<a class="code" href="a00308.html#f12c4aa62441f20edcde8eb539374674" title="internal representation uses origin/size">_origin</a>[i] || coord[i]&gt;=<a class="code" href="a00308.html#f12c4aa62441f20edcde8eb539374674" title="internal representation uses origin/size">_origin</a>[i]+_size[i]) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00234"></a>00234                 }
<a name="l00235"></a>00235           <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00236"></a>00236         }
<a name="l00237"></a>00237 
<a name="l00239"></a><a class="code" href="a00308.html#01c5feb560363545961570f29426d579">00239</a>         <span class="keyword">virtual</span> <a class="code" href="a00277.html">SubYGrid&lt;d,ct&gt;</a> <a class="code" href="a00308.html#01c5feb560363545961570f29426d579" title="Return new SubYGrid of self which is the intersection of self and another YGrid.">intersection</a> ( <a class="code" href="a00308.html">YGrid&lt;d,ct&gt;</a>&amp; r)<span class="keyword"> const</span>
<a name="l00240"></a>00240 <span class="keyword">        </span>{
<a name="l00241"></a>00241           <span class="comment">// check if the two grids can be intersected, must have same mesh size and shift</span>
<a name="l00242"></a>00242           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; i++)
<a name="l00243"></a>00243                 <span class="keywordflow">if</span> (fabs(<a class="code" href="a00308.html#7bed6643312a1e459af95cdcc69f8fbd" title="Return reference to mesh size tupel for read write access.">meshsize</a>(i)-r.<a class="code" href="a00308.html#7bed6643312a1e459af95cdcc69f8fbd" title="Return reference to mesh size tupel for read write access.">meshsize</a>(i))&gt;Ytolerance) <span class="keywordflow">return</span> <a class="code" href="a00277.html">SubYGrid&lt;d,ct&gt;</a>();
<a name="l00244"></a>00244           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; i++)
<a name="l00245"></a>00245                 <span class="keywordflow">if</span> (fabs(<a class="code" href="a00308.html#bc763dfd8b05a22a609bae31dfc64b94" title="Return shift tupel.">shift</a>(i)-r.<a class="code" href="a00308.html#bc763dfd8b05a22a609bae31dfc64b94" title="Return shift tupel.">shift</a>(i))&gt;Ytolerance) <span class="keywordflow">return</span> <a class="code" href="a00277.html">SubYGrid&lt;d,ct&gt;</a>();
<a name="l00246"></a>00246 
<a name="l00247"></a>00247           <a class="code" href="a00308.html#592fd83e3b3a988964d22258a85d2f87" title="define types used for arguments">iTupel</a> neworigin;
<a name="l00248"></a>00248           <a class="code" href="a00308.html#592fd83e3b3a988964d22258a85d2f87" title="define types used for arguments">iTupel</a> newsize;
<a name="l00249"></a>00249           <a class="code" href="a00308.html#592fd83e3b3a988964d22258a85d2f87" title="define types used for arguments">iTupel</a> offset;
<a name="l00250"></a>00250 
<a name="l00251"></a>00251           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i)
<a name="l00252"></a>00252                 {
<a name="l00253"></a>00253                   <span class="comment">// intersect</span>
<a name="l00254"></a>00254                   neworigin[i] = std::max(<a class="code" href="a00308.html#31c32fddfc3c89fac70e1faf6f0d459a" title="Return minimum index in direction i.">min</a>(i),r.<a class="code" href="a00308.html#31c32fddfc3c89fac70e1faf6f0d459a" title="Return minimum index in direction i.">min</a>(i));
<a name="l00255"></a>00255                   newsize[i] = std::min(<a class="code" href="a00308.html#eb23a6893a81d54f72fe60e8acd75ad5" title="Return maximum index in direction i.">max</a>(i),r.<a class="code" href="a00308.html#eb23a6893a81d54f72fe60e8acd75ad5" title="Return maximum index in direction i.">max</a>(i))-neworigin[i]+1;
<a name="l00256"></a>00256                   <span class="keywordflow">if</span> (newsize[i]&lt;0) {
<a name="l00257"></a>00257                         newsize[i] = 0;
<a name="l00258"></a>00258                         neworigin[i] = <a class="code" href="a00308.html#31c32fddfc3c89fac70e1faf6f0d459a" title="Return minimum index in direction i.">min</a>(i);
<a name="l00259"></a>00259                   }
<a name="l00260"></a>00260 
<a name="l00261"></a>00261                   <span class="comment">// offset to own origin</span>
<a name="l00262"></a>00262                   offset[i] = neworigin[i]-<a class="code" href="a00308.html#f12c4aa62441f20edcde8eb539374674" title="internal representation uses origin/size">_origin</a>[i];
<a name="l00263"></a>00263                 }       
<a name="l00264"></a>00264           <span class="keywordflow">return</span> <a class="code" href="a00277.html">SubYGrid&lt;d,ct&gt;</a>(neworigin,newsize,offset,_size,<a class="code" href="a00308.html#3b4c479226b25b2c885d655fd61bb277" title="mesh size per direction">_h</a>,<a class="code" href="a00308.html#890dc83636cf8aaf0e33bf152ca001f7" title="shift per direction">_r</a>);
<a name="l00265"></a>00265         }
<a name="l00266"></a>00266 
<a name="l00268"></a><a class="code" href="a00308.html#efe67f4ed014f4168db6b0aabf551224">00268</a>         <a class="code" href="a00308.html">YGrid&lt;d,ct&gt;</a> <a class="code" href="a00308.html#efe67f4ed014f4168db6b0aabf551224" title="return grid moved by the vector v">move</a> (<a class="code" href="a00308.html#592fd83e3b3a988964d22258a85d2f87" title="define types used for arguments">iTupel</a> v)<span class="keyword"> const</span>
<a name="l00269"></a>00269 <span class="keyword">        </span>{
<a name="l00270"></a>00270           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; i++) v[i] += <a class="code" href="a00308.html#f12c4aa62441f20edcde8eb539374674" title="internal representation uses origin/size">_origin</a>[i];
<a name="l00271"></a>00271           <span class="keywordflow">return</span> <a class="code" href="a00308.html">YGrid&lt;d,ct&gt;</a>(v,_size,<a class="code" href="a00308.html#3b4c479226b25b2c885d655fd61bb277" title="mesh size per direction">_h</a>,<a class="code" href="a00308.html#890dc83636cf8aaf0e33bf152ca001f7" title="shift per direction">_r</a>);
<a name="l00272"></a>00272         }
<a name="l00273"></a>00273 
<a name="l00280"></a><a class="code" href="a00309.html">00280</a>         <span class="keyword">class </span><a class="code" href="a00309.html">Iterator</a> {
<a name="l00281"></a>00281         <span class="keyword">public</span>:
<a name="l00283"></a><a class="code" href="a00309.html#f8c6eb60e227176f68c6844b99659aa9">00283</a>           <a class="code" href="a00309.html#f8c6eb60e227176f68c6844b99659aa9" title="Make iterator pointing to first cell in a grid.">Iterator</a> (<span class="keyword">const</span> <a class="code" href="a00308.html">YGrid&lt;d,ct&gt;</a>&amp; r)
<a name="l00284"></a>00284           {
<a name="l00285"></a>00285                 <span class="comment">// copy data coming from grid to iterate over </span>
<a name="l00286"></a>00286                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i) _origin[i] = r.<a class="code" href="a00308.html#321e0bd5abb6d0471e368fbe131b87e5" title="Return origin in direction i.">origin</a>(i);
<a name="l00287"></a>00287                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i) _end[i] = r.<a class="code" href="a00308.html#321e0bd5abb6d0471e368fbe131b87e5" title="Return origin in direction i.">origin</a>(i)+r.<a class="code" href="a00308.html#e672f5b5698739a0d552f28ca50266e5" title="Return size in direction i.">size</a>(i)-1;
<a name="l00288"></a>00288                 
<a name="l00289"></a>00289                 <span class="comment">// initialize to first position in index set</span>
<a name="l00290"></a>00290                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i) _coord[i] = _origin[i];
<a name="l00291"></a>00291                 _index = 0;
<a name="l00292"></a>00292                 
<a name="l00293"></a>00293                 <span class="comment">// compute increments;</span>
<a name="l00294"></a>00294                 <span class="keywordtype">int</span> inc = 1;
<a name="l00295"></a>00295                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i)
<a name="l00296"></a>00296                   {
<a name="l00297"></a>00297                         _increment[i] = inc;
<a name="l00298"></a>00298                         inc *= r.<a class="code" href="a00308.html#e672f5b5698739a0d552f28ca50266e5" title="Return size in direction i.">size</a>(i);
<a name="l00299"></a>00299                   }
<a name="l00300"></a>00300           }
<a name="l00301"></a>00301 
<a name="l00303"></a><a class="code" href="a00309.html#9fae817dfa3af0fcf0778bf000ee1758">00303</a>           <a class="code" href="a00309.html#f8c6eb60e227176f68c6844b99659aa9" title="Make iterator pointing to first cell in a grid.">Iterator</a> (<span class="keyword">const</span> <a class="code" href="a00308.html">YGrid&lt;d,ct&gt;</a>&amp; r, <span class="keyword">const</span> <a class="code" href="a00308.html#592fd83e3b3a988964d22258a85d2f87" title="define types used for arguments">iTupel</a>&amp; <a class="code" href="a00309.html#c38a790e7409c951cde186671cf7c99d" title="Return coordinate of the cell as reference (do not modify).">coord</a>)
<a name="l00304"></a>00304           {
<a name="l00305"></a>00305                 <span class="comment">// copy data coming from grid to iterate over </span>
<a name="l00306"></a>00306                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i) _origin[i] = r.<a class="code" href="a00308.html#321e0bd5abb6d0471e368fbe131b87e5" title="Return origin in direction i.">origin</a>(i);
<a name="l00307"></a>00307                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i) _end[i] = r.<a class="code" href="a00308.html#321e0bd5abb6d0471e368fbe131b87e5" title="Return origin in direction i.">origin</a>(i)+r.<a class="code" href="a00308.html#e672f5b5698739a0d552f28ca50266e5" title="Return size in direction i.">size</a>(i)-1;
<a name="l00308"></a>00308                 
<a name="l00309"></a>00309                 <span class="comment">// compute increments;</span>
<a name="l00310"></a>00310                 <span class="keywordtype">int</span> inc = 1;
<a name="l00311"></a>00311                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i)
<a name="l00312"></a>00312                   {
<a name="l00313"></a>00313                         _increment[i] = inc;
<a name="l00314"></a>00314                         inc *= r.<a class="code" href="a00308.html#e672f5b5698739a0d552f28ca50266e5" title="Return size in direction i.">size</a>(i);
<a name="l00315"></a>00315                   }
<a name="l00316"></a>00316 
<a name="l00317"></a>00317                 <span class="comment">// initialize to given position in index set</span>
<a name="l00318"></a>00318                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i) _coord[i] = coord[i];
<a name="l00319"></a>00319                 _index = r.<a class="code" href="a00308.html#eac8a437f95a8c73c26dd5da4a0a9c15" title="given a tupel compute its index in the lexicographic numbering">index</a>(coord);
<a name="l00320"></a>00320           }
<a name="l00321"></a>00321 
<a name="l00323"></a><a class="code" href="a00309.html#d1a4c4e067ab17567901839024d58768">00323</a>           <span class="keywordtype">void</span> <a class="code" href="a00309.html#d1a4c4e067ab17567901839024d58768" title="reinitialize iterator to given position">reinit</a> (<span class="keyword">const</span> <a class="code" href="a00308.html">YGrid&lt;d,ct&gt;</a>&amp; r, <span class="keyword">const</span> <a class="code" href="a00308.html#592fd83e3b3a988964d22258a85d2f87" title="define types used for arguments">iTupel</a>&amp; <a class="code" href="a00309.html#c38a790e7409c951cde186671cf7c99d" title="Return coordinate of the cell as reference (do not modify).">coord</a>)
<a name="l00324"></a>00324           {
<a name="l00325"></a>00325                 <span class="comment">// copy data coming from grid to iterate over </span>
<a name="l00326"></a>00326                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i) _origin[i] = r.<a class="code" href="a00308.html#321e0bd5abb6d0471e368fbe131b87e5" title="Return origin in direction i.">origin</a>(i);
<a name="l00327"></a>00327                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i) _end[i] = r.<a class="code" href="a00308.html#321e0bd5abb6d0471e368fbe131b87e5" title="Return origin in direction i.">origin</a>(i)+r.<a class="code" href="a00308.html#e672f5b5698739a0d552f28ca50266e5" title="Return size in direction i.">size</a>(i)-1;
<a name="l00328"></a>00328                 
<a name="l00329"></a>00329                 <span class="comment">// compute increments;</span>
<a name="l00330"></a>00330                 <span class="keywordtype">int</span> inc = 1;
<a name="l00331"></a>00331                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i)
<a name="l00332"></a>00332                   {
<a name="l00333"></a>00333                         _increment[i] = inc;
<a name="l00334"></a>00334                         inc *= r.<a class="code" href="a00308.html#e672f5b5698739a0d552f28ca50266e5" title="Return size in direction i.">size</a>(i);
<a name="l00335"></a>00335                   }
<a name="l00336"></a>00336 
<a name="l00337"></a>00337                 <span class="comment">// initialize to given position in index set</span>
<a name="l00338"></a>00338                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i) _coord[i] = coord[i];
<a name="l00339"></a>00339                 _index = r.<a class="code" href="a00308.html#eac8a437f95a8c73c26dd5da4a0a9c15" title="given a tupel compute its index in the lexicographic numbering">index</a>(coord);
<a name="l00340"></a>00340           }
<a name="l00341"></a>00341 
<a name="l00343"></a><a class="code" href="a00309.html#fbc5116e8d9c68f2652593348a6d170e">00343</a>           <span class="keywordtype">bool</span> <a class="code" href="a00309.html#fbc5116e8d9c68f2652593348a6d170e" title="Return true when two iterators over the same grid are equal (!).">operator== </a>(<span class="keyword">const</span> <a class="code" href="a00309.html">Iterator</a>&amp; i)<span class="keyword"> const</span>
<a name="l00344"></a>00344 <span class="keyword">          </span>{
<a name="l00345"></a>00345                 <span class="keywordflow">return</span> _index == i.<a class="code" href="a00309.html#cf30dfbef35aaf14772fd930dcd6eaad">_index</a>;
<a name="l00346"></a>00346           }
<a name="l00347"></a>00347 
<a name="l00349"></a><a class="code" href="a00309.html#bfe58b91b28a66ad0b68878a435eb20b">00349</a>           <span class="keywordtype">bool</span> <a class="code" href="a00309.html#bfe58b91b28a66ad0b68878a435eb20b" title="Return true when two iterators over the same grid are not equal (!).">operator!= </a>(<span class="keyword">const</span> <a class="code" href="a00309.html">Iterator</a>&amp; i)<span class="keyword"> const</span>
<a name="l00350"></a>00350 <span class="keyword">          </span>{
<a name="l00351"></a>00351                 <span class="keywordflow">return</span> _index != i.<a class="code" href="a00309.html#cf30dfbef35aaf14772fd930dcd6eaad">_index</a>;
<a name="l00352"></a>00352           }
<a name="l00353"></a>00353         
<a name="l00355"></a><a class="code" href="a00309.html#99c69341678d32f9b2005bacb3d54073">00355</a>           <span class="keywordtype">int</span> <a class="code" href="a00309.html#99c69341678d32f9b2005bacb3d54073" title="Return index of the current cell in the consecutive numbering.">index</a> ()<span class="keyword"> const</span>
<a name="l00356"></a>00356 <span class="keyword">          </span>{
<a name="l00357"></a>00357                 <span class="keywordflow">return</span> _index;
<a name="l00358"></a>00358           }
<a name="l00359"></a>00359           
<a name="l00361"></a><a class="code" href="a00309.html#5811803f7a50f10d50ab9d7f14825510">00361</a>           <span class="keywordtype">int</span> <a class="code" href="a00309.html#c38a790e7409c951cde186671cf7c99d" title="Return coordinate of the cell as reference (do not modify).">coord</a> (<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
<a name="l00362"></a>00362 <span class="keyword">          </span>{
<a name="l00363"></a>00363                 <span class="keywordflow">return</span> _coord[i];
<a name="l00364"></a>00364           }
<a name="l00365"></a>00365 
<a name="l00367"></a><a class="code" href="a00309.html#c38a790e7409c951cde186671cf7c99d">00367</a>           <span class="keyword">const</span> <a class="code" href="a00308.html#592fd83e3b3a988964d22258a85d2f87" title="define types used for arguments">iTupel</a>&amp; <a class="code" href="a00309.html#c38a790e7409c951cde186671cf7c99d" title="Return coordinate of the cell as reference (do not modify).">coord</a> ()<span class="keyword"> const</span>
<a name="l00368"></a>00368 <span class="keyword">          </span>{
<a name="l00369"></a>00369                 <span class="keywordflow">return</span> _coord;
<a name="l00370"></a>00370           }
<a name="l00371"></a>00371 
<a name="l00373"></a><a class="code" href="a00309.html#ba44d4ca8c01801356e7c17b81290d74">00373</a>           <span class="keywordtype">int</span> <a class="code" href="a00309.html#ba44d4ca8c01801356e7c17b81290d74" title="Get index of cell which is dist cells away in direction i.">neighbor</a> (<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> dist)<span class="keyword"> const</span>
<a name="l00374"></a>00374 <span class="keyword">          </span>{
<a name="l00375"></a>00375                 <span class="keywordflow">return</span> _index+dist*_increment[i];
<a name="l00376"></a>00376           }
<a name="l00377"></a>00377 
<a name="l00379"></a><a class="code" href="a00309.html#f1d6b8f36be109c819b78fa30671e6cb">00379</a>           <span class="keywordtype">int</span> <a class="code" href="a00309.html#f1d6b8f36be109c819b78fa30671e6cb" title="Get index of neighboring cell which is -1 away in direction i.">down</a> (<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
<a name="l00380"></a>00380 <span class="keyword">          </span>{
<a name="l00381"></a>00381                 <span class="keywordflow">return</span> _index-_increment[i];
<a name="l00382"></a>00382           }
<a name="l00383"></a>00383 
<a name="l00385"></a><a class="code" href="a00309.html#c137c26f2b55afed783d14a253972cd6">00385</a>           <span class="keywordtype">int</span> <a class="code" href="a00309.html#c137c26f2b55afed783d14a253972cd6" title="Get index of neighboring cell which is +1 away in direction i.">up</a> (<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
<a name="l00386"></a>00386 <span class="keyword">          </span>{
<a name="l00387"></a>00387                 <span class="keywordflow">return</span> _index+_increment[i];
<a name="l00388"></a>00388           }
<a name="l00389"></a>00389 
<a name="l00391"></a><a class="code" href="a00309.html#36288251db470ba5908763374a63d890">00391</a>           <span class="keywordtype">void</span> <a class="code" href="a00309.html#36288251db470ba5908763374a63d890" title="move this iterator dist cells in direction i">move</a> (<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> dist)
<a name="l00392"></a>00392           {
<a name="l00393"></a>00393                 _coord[i] += dist;
<a name="l00394"></a>00394                 _index += dist*_increment[i];
<a name="l00395"></a>00395           }
<a name="l00396"></a>00396 
<a name="l00398"></a><a class="code" href="a00309.html#d782b647f67872f5e542e4760dc4868d">00398</a>           <a class="code" href="a00309.html">Iterator</a>&amp; <a class="code" href="a00309.html#d782b647f67872f5e542e4760dc4868d" title="Increment iterator to next cell.">operator++ </a>()
<a name="l00399"></a>00399           {
<a name="l00400"></a>00400                 ++_index;
<a name="l00401"></a>00401                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; i++)
<a name="l00402"></a>00402                   <span class="keywordflow">if</span> (++(_coord[i])&lt;=_end[i])
<a name="l00403"></a>00403                         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00404"></a>00404                   <span class="keywordflow">else</span> { _coord[i]=_origin[i]; }
<a name="l00405"></a>00405                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00406"></a>00406           }
<a name="l00407"></a>00407           
<a name="l00409"></a><a class="code" href="a00309.html#523f15044abf05434a4bafd176d3fdcd">00409</a>           <span class="keywordtype">void</span> <a class="code" href="a00309.html#523f15044abf05434a4bafd176d3fdcd" title="Print position of iterator.">print</a> (std::ostream&amp; s)<span class="keyword"> const</span>
<a name="l00410"></a>00410 <span class="keyword">          </span>{
<a name="l00411"></a>00411                 s &lt;&lt; <a class="code" href="a00309.html#99c69341678d32f9b2005bacb3d54073" title="Return index of the current cell in the consecutive numbering.">index</a>() &lt;&lt; <span class="stringliteral">" : ["</span>;
<a name="l00412"></a>00412                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d-1; i++) s &lt;&lt; <a class="code" href="a00309.html#c38a790e7409c951cde186671cf7c99d" title="Return coordinate of the cell as reference (do not modify).">coord</a>(i) &lt;&lt; <span class="stringliteral">","</span>;
<a name="l00413"></a>00413                 s &lt;&lt; <a class="code" href="a00309.html#c38a790e7409c951cde186671cf7c99d" title="Return coordinate of the cell as reference (do not modify).">coord</a>(d-1) &lt;&lt; <span class="stringliteral">"]"</span>;
<a name="l00414"></a>00414           }
<a name="l00415"></a>00415 
<a name="l00416"></a>00416         <span class="keyword">protected</span>:
<a name="l00417"></a>00417           <span class="keywordtype">int</span> _index;          <span class="comment">//&lt; current lexicographic position in index set</span>
<a name="l00418"></a>00418           <a class="code" href="a00308.html#592fd83e3b3a988964d22258a85d2f87" title="define types used for arguments">iTupel</a> _coord;       <span class="comment">//&lt; current position in index set </span>
<a name="l00419"></a>00419           <a class="code" href="a00308.html#592fd83e3b3a988964d22258a85d2f87" title="define types used for arguments">iTupel</a> _increment;   <span class="comment">//&lt; increment for next neighbor in direction i </span>
<a name="l00420"></a>00420           <a class="code" href="a00308.html#592fd83e3b3a988964d22258a85d2f87" title="define types used for arguments">iTupel</a> _origin;      <span class="comment">//&lt; origin and</span>
<a name="l00421"></a>00421           <a class="code" href="a00308.html#592fd83e3b3a988964d22258a85d2f87" title="define types used for arguments">iTupel</a> _end;         <span class="comment">//&lt; last index in direction i</span>
<a name="l00422"></a>00422         };
<a name="l00423"></a>00423 
<a name="l00425"></a><a class="code" href="a00308.html#999ab7fb340423f292777671c62193fd">00425</a>         Iterator <a class="code" href="a00308.html#999ab7fb340423f292777671c62193fd" title="return iterator to first element of index set">begin</a> ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> Iterator(*<span class="keyword">this</span>); }
<a name="l00426"></a>00426         
<a name="l00428"></a><a class="code" href="a00308.html#81b2d9f016da7924ebffcd64cbacd9a7">00428</a>         Iterator <a class="code" href="a00308.html#81b2d9f016da7924ebffcd64cbacd9a7" title="return iterator to one past the last element of index set">end</a> ()<span class="keyword"> const </span>{
<a name="l00429"></a>00429           <a class="code" href="a00308.html#592fd83e3b3a988964d22258a85d2f87" title="define types used for arguments">iTupel</a> last;
<a name="l00430"></a>00430           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; i++) last[i] = <a class="code" href="a00308.html#eb23a6893a81d54f72fe60e8acd75ad5" title="Return maximum index in direction i.">max</a>(i);
<a name="l00431"></a>00431           last[0] += 1;
<a name="l00432"></a>00432           <span class="keywordflow">return</span> Iterator(*<span class="keyword">this</span>,last);
<a name="l00433"></a>00433         }
<a name="l00434"></a>00434 
<a name="l00439"></a><a class="code" href="a00310.html">00439</a>         <span class="keyword">class </span><a class="code" href="a00310.html">TransformingIterator</a> : <span class="keyword">public</span> <a class="code" href="a00309.html">Iterator</a> {
<a name="l00440"></a>00440         <span class="keyword">public</span>:
<a name="l00442"></a><a class="code" href="a00310.html#21e04b8d749c616b04d9a2f206c8d717">00442</a>           <a class="code" href="a00310.html#21e04b8d749c616b04d9a2f206c8d717" title="Make iterator pointing to first cell in a grid.">TransformingIterator</a> (<span class="keyword">const</span> <a class="code" href="a00308.html">YGrid&lt;d,ct&gt;</a>&amp; r) : <a class="code" href="a00309.html">Iterator</a>(r)
<a name="l00443"></a>00443           {
<a name="l00444"></a>00444                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i) _h[i] = r.<a class="code" href="a00308.html#7bed6643312a1e459af95cdcc69f8fbd" title="Return reference to mesh size tupel for read write access.">meshsize</a>(i);
<a name="l00445"></a>00445                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i) _begin[i] = r.<a class="code" href="a00308.html#321e0bd5abb6d0471e368fbe131b87e5" title="Return origin in direction i.">origin</a>(i)*r.<a class="code" href="a00308.html#7bed6643312a1e459af95cdcc69f8fbd" title="Return reference to mesh size tupel for read write access.">meshsize</a>(i)+r.<a class="code" href="a00308.html#bc763dfd8b05a22a609bae31dfc64b94" title="Return shift tupel.">shift</a>(i);
<a name="l00446"></a>00446                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i) _position[i] = _begin[i];
<a name="l00447"></a>00447           }
<a name="l00448"></a>00448 
<a name="l00450"></a><a class="code" href="a00310.html#ecd48d19ddc87adcdd41f5df10a8015d">00450</a>           <a class="code" href="a00310.html#21e04b8d749c616b04d9a2f206c8d717" title="Make iterator pointing to first cell in a grid.">TransformingIterator</a> (<span class="keyword">const</span> <a class="code" href="a00308.html">YGrid&lt;d,ct&gt;</a>&amp; r, <a class="code" href="a00308.html#592fd83e3b3a988964d22258a85d2f87" title="define types used for arguments">iTupel</a>&amp; <a class="code" href="a00309.html#c38a790e7409c951cde186671cf7c99d" title="Return coordinate of the cell as reference (do not modify).">coord</a>) : <a class="code" href="a00309.html">Iterator</a>(r,coord)
<a name="l00451"></a>00451           {
<a name="l00452"></a>00452                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i) _h[i] = r.<a class="code" href="a00308.html#7bed6643312a1e459af95cdcc69f8fbd" title="Return reference to mesh size tupel for read write access.">meshsize</a>(i);
<a name="l00453"></a>00453                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i) _begin[i] = r.<a class="code" href="a00308.html#321e0bd5abb6d0471e368fbe131b87e5" title="Return origin in direction i.">origin</a>(i)*r.<a class="code" href="a00308.html#7bed6643312a1e459af95cdcc69f8fbd" title="Return reference to mesh size tupel for read write access.">meshsize</a>(i)+r.<a class="code" href="a00308.html#bc763dfd8b05a22a609bae31dfc64b94" title="Return shift tupel.">shift</a>(i);
<a name="l00454"></a>00454                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i) _position[i] = coord[i]*r.<a class="code" href="a00308.html#7bed6643312a1e459af95cdcc69f8fbd" title="Return reference to mesh size tupel for read write access.">meshsize</a>(i)+r.<a class="code" href="a00308.html#bc763dfd8b05a22a609bae31dfc64b94" title="Return shift tupel.">shift</a>(i);
<a name="l00455"></a>00455           }
<a name="l00456"></a>00456 
<a name="l00458"></a><a class="code" href="a00310.html#28d38603beb6d311c38ba55f90fbf620">00458</a>           <a class="code" href="a00310.html#21e04b8d749c616b04d9a2f206c8d717" title="Make iterator pointing to first cell in a grid.">TransformingIterator</a> (<a class="code" href="a00309.html">Iterator</a> i) : <a class="code" href="a00309.html">Iterator</a>(i)
<a name="l00459"></a>00459           {       }
<a name="l00460"></a>00460 
<a name="l00462"></a><a class="code" href="a00310.html#3d8f4acab68478d1ea4e75a1bcad3c4e">00462</a>           <a class="code" href="a00310.html">TransformingIterator</a>&amp; <a class="code" href="a00310.html#3d8f4acab68478d1ea4e75a1bcad3c4e" title="Increment iterator to next cell with position.">operator++ </a>()
<a name="l00463"></a>00463           {
<a name="l00464"></a>00464                 ++(this-&gt;_index);
<a name="l00465"></a>00465                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; i++)
<a name="l00466"></a>00466                   <span class="keywordflow">if</span> (++(this-&gt;_coord[i])&lt;=this-&gt;_end[i])
<a name="l00467"></a>00467                         {
<a name="l00468"></a>00468                           _position[i] += _h[i];
<a name="l00469"></a>00469                           <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00470"></a>00470                         }
<a name="l00471"></a>00471                   <span class="keywordflow">else</span> 
<a name="l00472"></a>00472                         { 
<a name="l00473"></a>00473                           this-&gt;_coord[i]=this-&gt;_origin[i]; 
<a name="l00474"></a>00474                           _position[i] = _begin[i];
<a name="l00475"></a>00475                         }
<a name="l00476"></a>00476                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00477"></a>00477           }
<a name="l00478"></a>00478           
<a name="l00480"></a><a class="code" href="a00310.html#4feb3af702f47b19471f52958a8f7157">00480</a>           ct <a class="code" href="a00310.html#b02c77cbe51566b591af068dda652125" title="Return position of current cell as reference.">position</a> (<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
<a name="l00481"></a>00481 <span class="keyword">          </span>{
<a name="l00482"></a>00482                 <span class="keywordflow">return</span> _position[i];
<a name="l00483"></a>00483           }
<a name="l00484"></a>00484 
<a name="l00486"></a><a class="code" href="a00310.html#b02c77cbe51566b591af068dda652125">00486</a>           <span class="keyword">const</span> fTupel&amp; <a class="code" href="a00310.html#b02c77cbe51566b591af068dda652125" title="Return position of current cell as reference.">position</a> ()<span class="keyword"> const</span>
<a name="l00487"></a>00487 <span class="keyword">          </span>{
<a name="l00488"></a>00488                 <span class="keywordflow">return</span> _position;
<a name="l00489"></a>00489           }
<a name="l00490"></a>00490 
<a name="l00492"></a><a class="code" href="a00310.html#fe6dd7823430041c62e05b9406f7b0b1">00492</a>           ct <a class="code" href="a00310.html#d0a3835f8650229c66d6d746328a1d3e" title="Return meshsize of current cell as reference.">meshsize</a> (<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
<a name="l00493"></a>00493 <span class="keyword">          </span>{
<a name="l00494"></a>00494                 <span class="keywordflow">return</span> _h[i];
<a name="l00495"></a>00495           }
<a name="l00496"></a>00496 
<a name="l00498"></a><a class="code" href="a00310.html#d0a3835f8650229c66d6d746328a1d3e">00498</a>           <span class="keyword">const</span> fTupel&amp; <a class="code" href="a00310.html#d0a3835f8650229c66d6d746328a1d3e" title="Return meshsize of current cell as reference.">meshsize</a> ()<span class="keyword"> const</span>
<a name="l00499"></a>00499 <span class="keyword">          </span>{
<a name="l00500"></a>00500                 <span class="keywordflow">return</span> _h;
<a name="l00501"></a>00501           }
<a name="l00502"></a>00502 
<a name="l00504"></a><a class="code" href="a00310.html#3a7c489c8be971ed6a56285bf0ed011b">00504</a>           <span class="keywordtype">void</span> <a class="code" href="a00310.html#3a7c489c8be971ed6a56285bf0ed011b" title="Move cell position by dist cells in direction i.">move</a> (<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> dist)
<a name="l00505"></a>00505           {
<a name="l00506"></a>00506                 <a class="code" href="a00309.html#36288251db470ba5908763374a63d890" title="move this iterator dist cells in direction i">Iterator::move</a>(i,dist);
<a name="l00507"></a>00507                 _position[i] += dist*_h[i];
<a name="l00508"></a>00508           }
<a name="l00509"></a>00509 
<a name="l00511"></a><a class="code" href="a00310.html#b4147b33708b5a7bb99c78e94a0b4ba2">00511</a>           <span class="keywordtype">void</span> <a class="code" href="a00310.html#b4147b33708b5a7bb99c78e94a0b4ba2" title="Print contents of iterator.">print</a> (std::ostream&amp; s)<span class="keyword"> const</span>
<a name="l00512"></a>00512 <span class="keyword">          </span>{
<a name="l00513"></a>00513                 <a class="code" href="a00309.html#523f15044abf05434a4bafd176d3fdcd" title="Print position of iterator.">Iterator::print</a>(s);
<a name="l00514"></a>00514                 s &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; _position;
<a name="l00515"></a>00515           }
<a name="l00516"></a>00516 
<a name="l00517"></a>00517         <span class="keyword">private</span>:
<a name="l00518"></a>00518           fTupel _h;        
<a name="l00519"></a>00519           fTupel _begin;    
<a name="l00520"></a>00520           fTupel _position; 
<a name="l00521"></a>00521         };
<a name="l00522"></a>00522 
<a name="l00524"></a><a class="code" href="a00308.html#dab3ba401debd318aaf2423ada5c519a">00524</a>         TransformingIterator <a class="code" href="a00308.html#dab3ba401debd318aaf2423ada5c519a" title="return iterator to first element of index set">tbegin</a> ()<span class="keyword"> const</span>
<a name="l00525"></a>00525 <span class="keyword">        </span>{
<a name="l00526"></a>00526           <span class="keywordflow">return</span> TransformingIterator(*<span class="keyword">this</span>);
<a name="l00527"></a>00527         }
<a name="l00528"></a>00528         
<a name="l00530"></a><a class="code" href="a00308.html#6089b6ac86369d35ad0ff3e4f8b2bdda">00530</a>         TransformingIterator <a class="code" href="a00308.html#6089b6ac86369d35ad0ff3e4f8b2bdda" title="return iterator to one past the last element of the grid">tend</a> ()<span class="keyword"> const</span>
<a name="l00531"></a>00531 <span class="keyword">        </span>{
<a name="l00532"></a>00532           <a class="code" href="a00308.html#592fd83e3b3a988964d22258a85d2f87" title="define types used for arguments">iTupel</a> last;
<a name="l00533"></a>00533           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; i++) last = <a class="code" href="a00308.html#eb23a6893a81d54f72fe60e8acd75ad5" title="Return maximum index in direction i.">max</a>(i);
<a name="l00534"></a>00534           last[0] += 1;
<a name="l00535"></a>00535           <span class="keywordflow">return</span> TransformingIterator(*<span class="keyword">this</span>,last);
<a name="l00536"></a>00536         }
<a name="l00537"></a>00537         
<a name="l00538"></a>00538   <span class="keyword">protected</span>:
<a name="l00540"></a><a class="code" href="a00308.html#f12c4aa62441f20edcde8eb539374674">00540</a>         <a class="code" href="a00308.html#592fd83e3b3a988964d22258a85d2f87" title="define types used for arguments">iTupel</a> <a class="code" href="a00308.html#f12c4aa62441f20edcde8eb539374674" title="internal representation uses origin/size">_origin</a>; 
<a name="l00541"></a>00541         <a class="code" href="a00308.html#592fd83e3b3a988964d22258a85d2f87" title="define types used for arguments">iTupel</a> _size;
<a name="l00542"></a><a class="code" href="a00308.html#3b4c479226b25b2c885d655fd61bb277">00542</a>         fTupel <a class="code" href="a00308.html#3b4c479226b25b2c885d655fd61bb277" title="mesh size per direction">_h</a>;        
<a name="l00543"></a><a class="code" href="a00308.html#890dc83636cf8aaf0e33bf152ca001f7">00543</a>         fTupel <a class="code" href="a00308.html#890dc83636cf8aaf0e33bf152ca001f7" title="shift per direction">_r</a>;        
<a name="l00544"></a>00544   };
<a name="l00545"></a>00545 
<a name="l00547"></a>00547   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> d, <span class="keyword">typename</span> ct&gt;
<a name="l00548"></a><a class="code" href="a00441.html#f3a75cb4bc5c775f660d41e7a42be433">00548</a>   <span class="keyword">inline</span> std::ostream&amp; operator&lt;&lt; (std::ostream&amp; s, YGrid&lt;d,ct&gt; e)
<a name="l00549"></a>00549   {
<a name="l00550"></a>00550         s &lt;&lt; <span class="stringliteral">"{"</span>;
<a name="l00551"></a>00551         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d-1; i++)
<a name="l00552"></a>00552           s &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; e.min(i) &lt;&lt; <span class="stringliteral">","</span> &lt;&lt; e.max(i) &lt;&lt; <span class="stringliteral">"]x"</span>;
<a name="l00553"></a>00553         s &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; e.min(d-1) &lt;&lt; <span class="stringliteral">","</span> &lt;&lt; e.max(d-1) &lt;&lt; <span class="stringliteral">"]"</span>;
<a name="l00554"></a>00554         s &lt;&lt; <span class="stringliteral">" = ["</span>;
<a name="l00555"></a>00555         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d-1; i++) s &lt;&lt; e.origin(i) &lt;&lt; <span class="stringliteral">","</span>;
<a name="l00556"></a>00556         s &lt;&lt; e.origin(d-1) &lt;&lt; <span class="stringliteral">"]x["</span>;
<a name="l00557"></a>00557         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d-1; i++) s &lt;&lt; e.size(i) &lt;&lt; <span class="stringliteral">","</span>;
<a name="l00558"></a>00558         s &lt;&lt; e.size(d-1) &lt;&lt; <span class="stringliteral">"]"</span>;
<a name="l00559"></a>00559         s &lt;&lt; <span class="stringliteral">" h=["</span>;
<a name="l00560"></a>00560         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d-1; i++) s &lt;&lt; e.meshsize(i) &lt;&lt; <span class="stringliteral">","</span>;
<a name="l00561"></a>00561         s &lt;&lt; e.meshsize(d-1) &lt;&lt; <span class="stringliteral">"]"</span>;
<a name="l00562"></a>00562         s &lt;&lt; <span class="stringliteral">" r=["</span>;
<a name="l00563"></a>00563         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d-1; i++) s &lt;&lt; e.shift(i) &lt;&lt; <span class="stringliteral">","</span>;
<a name="l00564"></a>00564         s &lt;&lt; e.shift(d-1) &lt;&lt; <span class="stringliteral">"]"</span>;
<a name="l00565"></a>00565         s &lt;&lt; <span class="stringliteral">"}"</span>;
<a name="l00566"></a>00566         <span class="keywordflow">return</span> s;
<a name="l00567"></a>00567   }
<a name="l00568"></a>00568 
<a name="l00570"></a>00570   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> d, <span class="keyword">typename</span> ct&gt;
<a name="l00571"></a><a class="code" href="a00441.html#d7005816fb87d6ad2f3b04a5996262d0">00571</a>   <span class="keyword">inline</span> std::ostream&amp; operator&lt;&lt; (std::ostream&amp; s, typename YGrid&lt;d,ct&gt;::Iterator&amp; e)
<a name="l00572"></a>00572   {
<a name="l00573"></a>00573         e.print(s);
<a name="l00574"></a>00574         <span class="keywordflow">return</span> s;
<a name="l00575"></a>00575   }
<a name="l00576"></a>00576 
<a name="l00577"></a>00577 
<a name="l00588"></a>00588   <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> d, <span class="keyword">typename</span> ct&gt;
<a name="l00589"></a><a class="code" href="a00277.html">00589</a>   <span class="keyword">class </span><a class="code" href="a00277.html">SubYGrid</a> : <span class="keyword">public</span> <a class="code" href="a00308.html">YGrid</a>&lt;d,ct&gt; {
<a name="l00590"></a>00590   <span class="keyword">public</span>:
<a name="l00591"></a><a class="code" href="a00277.html#69330d9ae40409c44f1b1c0df3b897a2">00591</a>         <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="a00308.html">YGrid&lt;d,ct&gt;::iTupel</a> <a class="code" href="a00277.html#69330d9ae40409c44f1b1c0df3b897a2" title="define types used for arguments">iTupel</a>;
<a name="l00592"></a>00592         <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="a00308.html">YGrid&lt;d,ct&gt;::fTupel</a> fTupel;
<a name="l00593"></a>00593         <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="a00308.html">YGrid&lt;d,ct&gt;::bTupel</a> bTupel;
<a name="l00594"></a>00594 
<a name="l00596"></a><a class="code" href="a00277.html#637a45627942153caa681b9487d5f561">00596</a>     <span class="keyword">virtual</span> <a class="code" href="a00277.html#637a45627942153caa681b9487d5f561" title="Destructor.">~SubYGrid</a>()
<a name="l00597"></a>00597     {}
<a name="l00598"></a>00598     
<a name="l00600"></a><a class="code" href="a00277.html#d4514cb80ec110ea8495760171066b62">00600</a>         <a class="code" href="a00277.html#d4514cb80ec110ea8495760171066b62" title="make uninitialized subgrid">SubYGrid</a> () {}
<a name="l00601"></a>00601 
<a name="l00603"></a><a class="code" href="a00277.html#c4811fe0a52e9db4874237b51d49be95">00603</a>         <a class="code" href="a00277.html#d4514cb80ec110ea8495760171066b62" title="make uninitialized subgrid">SubYGrid</a> (<a class="code" href="a00277.html#69330d9ae40409c44f1b1c0df3b897a2" title="define types used for arguments">iTupel</a> <a class="code" href="a00308.html#d56157b682bf637c2f286facef2ee6e9" title="return reference to origin">origin</a>, <a class="code" href="a00277.html#69330d9ae40409c44f1b1c0df3b897a2" title="define types used for arguments">iTupel</a> <a class="code" href="a00308.html#7c257903c899929a0c86414d7e4e62b4" title="Return reference to size tupel.">size</a>, <a class="code" href="a00277.html#69330d9ae40409c44f1b1c0df3b897a2" title="define types used for arguments">iTupel</a> <a class="code" href="a00277.html#91f3eff13537b6cd6eae4461c38e5ee3" title="Return offset to origin of enclosing grid.">offset</a>, <a class="code" href="a00277.html#69330d9ae40409c44f1b1c0df3b897a2" title="define types used for arguments">iTupel</a> <a class="code" href="a00277.html#863ef41f499870fc20c63eee5e553fd4" title="return size of enclosing grid">supersize</a>, fTupel h, fTupel r) 
<a name="l00604"></a>00604           : <a class="code" href="a00308.html">YGrid</a>&lt;d,ct&gt;::<a class="code" href="a00308.html">YGrid</a>(origin,size,h,r)
<a name="l00605"></a>00605         {
<a name="l00606"></a>00606           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i) 
<a name="l00607"></a>00607                 {
<a name="l00608"></a>00608                   _offset[i] = offset[i];
<a name="l00609"></a>00609                   _supersize[i] = supersize[i];
<a name="l00610"></a>00610                   <span class="keywordflow">if</span> (offset[i]&lt;0) 
<a name="l00611"></a>00611                         std::cout &lt;&lt; <span class="stringliteral">"warning: offset["</span>
<a name="l00612"></a>00612                                           &lt;&lt; i &lt;&lt;<span class="stringliteral">"] negative in SubYGrid"</span>
<a name="l00613"></a>00613                                           &lt;&lt; std::endl; 
<a name="l00614"></a>00614                   <span class="keywordflow">if</span> (-offset[i]+supersize[i]&lt;size[i]) 
<a name="l00615"></a>00615                         std::cout &lt;&lt; <span class="stringliteral">"warning: subgrid larger than enclosing grid in direction "</span>
<a name="l00616"></a>00616                                           &lt;&lt; i &lt;&lt;<span class="stringliteral">" in SubYGrid"</span>
<a name="l00617"></a>00617                                           &lt;&lt; std::endl; 
<a name="l00618"></a>00618                 }
<a name="l00619"></a>00619         }
<a name="l00620"></a>00620 
<a name="l00622"></a><a class="code" href="a00277.html#a399b44b75efafc93c31e9990055a630">00622</a>         <a class="code" href="a00277.html#d4514cb80ec110ea8495760171066b62" title="make uninitialized subgrid">SubYGrid</a> (<a class="code" href="a00308.html">YGrid&lt;d,ct&gt;</a> base) : <a class="code" href="a00308.html">YGrid</a>&lt;d,ct&gt;(base)
<a name="l00623"></a>00623         {
<a name="l00624"></a>00624           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i) 
<a name="l00625"></a>00625                 {
<a name="l00626"></a>00626                   _offset[i] = 0;
<a name="l00627"></a>00627                   _supersize[i] = this-&gt;<a class="code" href="a00308.html#7c257903c899929a0c86414d7e4e62b4" title="Return reference to size tupel.">size</a>(i);
<a name="l00628"></a>00628                 }
<a name="l00629"></a>00629         }
<a name="l00630"></a>00630  
<a name="l00632"></a><a class="code" href="a00277.html#de3ceaf5991c794f28b62c93005389bb">00632</a>         <span class="keywordtype">int</span> <a class="code" href="a00277.html#91f3eff13537b6cd6eae4461c38e5ee3" title="Return offset to origin of enclosing grid.">offset</a> (<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
<a name="l00633"></a>00633 <span class="keyword">        </span>{
<a name="l00634"></a>00634           <span class="keywordflow">return</span> _offset[i];
<a name="l00635"></a>00635         }
<a name="l00636"></a>00636 
<a name="l00638"></a><a class="code" href="a00277.html#91f3eff13537b6cd6eae4461c38e5ee3">00638</a>         <span class="keyword">const</span> <a class="code" href="a00277.html#69330d9ae40409c44f1b1c0df3b897a2" title="define types used for arguments">iTupel</a> &amp; <a class="code" href="a00277.html#91f3eff13537b6cd6eae4461c38e5ee3" title="Return offset to origin of enclosing grid.">offset</a> ()<span class="keyword"> const</span>
<a name="l00639"></a>00639 <span class="keyword">        </span>{
<a name="l00640"></a>00640           <span class="keywordflow">return</span> _offset;
<a name="l00641"></a>00641         }
<a name="l00642"></a>00642 
<a name="l00644"></a><a class="code" href="a00277.html#16416949f52bd21d0ec3c59c67562552">00644</a>         <span class="keywordtype">int</span> <a class="code" href="a00277.html#863ef41f499870fc20c63eee5e553fd4" title="return size of enclosing grid">supersize</a> (<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
<a name="l00645"></a>00645 <span class="keyword">        </span>{
<a name="l00646"></a>00646           <span class="keywordflow">return</span> _supersize[i];
<a name="l00647"></a>00647         }
<a name="l00648"></a>00648 
<a name="l00650"></a><a class="code" href="a00277.html#863ef41f499870fc20c63eee5e553fd4">00650</a>         <span class="keyword">const</span> <a class="code" href="a00277.html#69330d9ae40409c44f1b1c0df3b897a2" title="define types used for arguments">iTupel</a> &amp; <a class="code" href="a00277.html#863ef41f499870fc20c63eee5e553fd4" title="return size of enclosing grid">supersize</a> ()<span class="keyword"> const</span>
<a name="l00651"></a>00651 <span class="keyword">        </span>{
<a name="l00652"></a>00652           <span class="keywordflow">return</span> _supersize;
<a name="l00653"></a>00653         }
<a name="l00654"></a>00654 
<a name="l00656"></a><a class="code" href="a00277.html#26821e02db4813f3903aa0fcaf5714eb">00656</a>         <span class="keyword">virtual</span> <a class="code" href="a00277.html">SubYGrid&lt;d,ct&gt;</a> <a class="code" href="a00277.html#26821e02db4813f3903aa0fcaf5714eb" title="Return SubYGrid of supergrid of self which is the intersection of self and another...">intersection</a> (<span class="keyword">const</span> <a class="code" href="a00308.html">YGrid&lt;d,ct&gt;</a>&amp; r)<span class="keyword"> const</span>
<a name="l00657"></a>00657 <span class="keyword">        </span>{
<a name="l00658"></a>00658           <span class="comment">// check if the two grids can be intersected, must have same mesh size and shift</span>
<a name="l00659"></a>00659           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; i++)
<a name="l00660"></a>00660                 <span class="keywordflow">if</span> (fabs(this-&gt;<a class="code" href="a00308.html#7bed6643312a1e459af95cdcc69f8fbd" title="Return reference to mesh size tupel for read write access.">meshsize</a>(i)-r.<a class="code" href="a00308.html#7bed6643312a1e459af95cdcc69f8fbd" title="Return reference to mesh size tupel for read write access.">meshsize</a>(i))&gt;Ytolerance) <span class="keywordflow">return</span> <a class="code" href="a00277.html">SubYGrid&lt;d,ct&gt;</a>();
<a name="l00661"></a>00661           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; i++)
<a name="l00662"></a>00662                 <span class="keywordflow">if</span> (fabs(this-&gt;<a class="code" href="a00308.html#bc763dfd8b05a22a609bae31dfc64b94" title="Return shift tupel.">shift</a>(i)-r.<a class="code" href="a00308.html#bc763dfd8b05a22a609bae31dfc64b94" title="Return shift tupel.">shift</a>(i))&gt;Ytolerance) <span class="keywordflow">return</span> <a class="code" href="a00277.html">SubYGrid&lt;d,ct&gt;</a>();
<a name="l00663"></a>00663 
<a name="l00664"></a>00664           <a class="code" href="a00277.html#69330d9ae40409c44f1b1c0df3b897a2" title="define types used for arguments">iTupel</a> neworigin;
<a name="l00665"></a>00665           <a class="code" href="a00277.html#69330d9ae40409c44f1b1c0df3b897a2" title="define types used for arguments">iTupel</a> newsize;
<a name="l00666"></a>00666           <a class="code" href="a00277.html#69330d9ae40409c44f1b1c0df3b897a2" title="define types used for arguments">iTupel</a> <a class="code" href="a00277.html#91f3eff13537b6cd6eae4461c38e5ee3" title="Return offset to origin of enclosing grid.">offset</a>;
<a name="l00667"></a>00667 
<a name="l00668"></a>00668           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i)
<a name="l00669"></a>00669                 {
<a name="l00670"></a>00670                   <span class="comment">// intersect</span>
<a name="l00671"></a>00671                   neworigin[i] = std::max(this-&gt;<a class="code" href="a00308.html#31c32fddfc3c89fac70e1faf6f0d459a" title="Return minimum index in direction i.">min</a>(i),r.<a class="code" href="a00308.html#31c32fddfc3c89fac70e1faf6f0d459a" title="Return minimum index in direction i.">min</a>(i));
<a name="l00672"></a>00672                   newsize[i] = std::min(this-&gt;<a class="code" href="a00308.html#eb23a6893a81d54f72fe60e8acd75ad5" title="Return maximum index in direction i.">max</a>(i),r.<a class="code" href="a00308.html#eb23a6893a81d54f72fe60e8acd75ad5" title="Return maximum index in direction i.">max</a>(i))-neworigin[i]+1;
<a name="l00673"></a>00673                   <span class="keywordflow">if</span> (newsize[i]&lt;0) {
<a name="l00674"></a>00674                         newsize[i] = 0;
<a name="l00675"></a>00675                         neworigin[i] = this-&gt;<a class="code" href="a00308.html#31c32fddfc3c89fac70e1faf6f0d459a" title="Return minimum index in direction i.">min</a>(i);
<a name="l00676"></a>00676                   }
<a name="l00677"></a>00677 
<a name="l00678"></a>00678                   <span class="comment">// offset to my supergrid</span>
<a name="l00679"></a>00679                   offset[i] = _offset[i]+neworigin[i]-this-&gt;<a class="code" href="a00308.html#d56157b682bf637c2f286facef2ee6e9" title="return reference to origin">origin</a>(i);
<a name="l00680"></a>00680                 }       
<a name="l00681"></a>00681           <span class="keywordflow">return</span> <a class="code" href="a00277.html">SubYGrid&lt;d,ct&gt;</a>(neworigin,newsize,offset,_supersize,this-&gt;<a class="code" href="a00308.html#7bed6643312a1e459af95cdcc69f8fbd" title="Return reference to mesh size tupel for read write access.">meshsize</a>(),this-&gt;<a class="code" href="a00308.html#bc763dfd8b05a22a609bae31dfc64b94" title="Return shift tupel.">shift</a>());
<a name="l00682"></a>00682         }
<a name="l00683"></a>00683 
<a name="l00687"></a><a class="code" href="a00278.html">00687</a>         <span class="keyword">class </span><a class="code" href="a00278.html">SubIterator</a> : <span class="keyword">public</span> <a class="code" href="a00308.html">YGrid</a>&lt;d,ct&gt;::<a class="code" href="a00309.html">Iterator</a> {
<a name="l00688"></a>00688         <span class="keyword">public</span>:
<a name="l00690"></a><a class="code" href="a00278.html#b715644eb5226782fa5cab12f4918585">00690</a>           <a class="code" href="a00278.html#b715644eb5226782fa5cab12f4918585" title="Make iterator pointing to first cell in subgrid.">SubIterator</a> (<span class="keyword">const</span> <a class="code" href="a00277.html">SubYGrid&lt;d,ct&gt;</a>&amp; r) : <a class="code" href="a00308.html">YGrid</a>&lt;d,ct&gt;::<a class="code" href="a00309.html">Iterator</a>::<a class="code" href="a00309.html">Iterator</a> (r)
<a name="l00691"></a>00691           {
<a name="l00693"></a>00693                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i) <a class="code" href="a00278.html#352c9c2810e875f57a15064c97982dff" title="size of subgrid">_size</a>[i] = r.<a class="code" href="a00308.html#e672f5b5698739a0d552f28ca50266e5" title="Return size in direction i.">size</a>(i);
<a name="l00694"></a>00694 
<a name="l00695"></a>00695                 <span class="comment">// compute superincrements </span>
<a name="l00696"></a>00696                 <span class="keywordtype">int</span> inc = 1;
<a name="l00697"></a>00697                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i)
<a name="l00698"></a>00698                   {
<a name="l00699"></a>00699                         <a class="code" href="a00278.html#2b873645be4ee100bb65c105c8176b10" title="moves consecutive index by one in this direction in supergrid">_superincrement</a>[i] = inc;
<a name="l00700"></a>00700                         inc *= r.<a class="code" href="a00277.html#16416949f52bd21d0ec3c59c67562552" title="return size of enclosing grid">supersize</a>(i);
<a name="l00701"></a>00701                   }
<a name="l00702"></a>00702 
<a name="l00703"></a>00703                 <span class="comment">// move superindex to first cell in subgrid</span>
<a name="l00704"></a>00704                 <a class="code" href="a00278.html#d4c246a574feb07041d098d2905088e2" title="consecutive index in enclosing grid">_superindex</a> = 0;
<a name="l00705"></a>00705                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i)
<a name="l00706"></a>00706                   <a class="code" href="a00278.html#d4c246a574feb07041d098d2905088e2" title="consecutive index in enclosing grid">_superindex</a> += r.<a class="code" href="a00277.html#de3ceaf5991c794f28b62c93005389bb" title="Return offset to origin of enclosing grid.">offset</a>(i)*<a class="code" href="a00278.html#2b873645be4ee100bb65c105c8176b10" title="moves consecutive index by one in this direction in supergrid">_superincrement</a>[i];
<a name="l00707"></a>00707           }
<a name="l00708"></a>00708 
<a name="l00710"></a><a class="code" href="a00278.html#c67929962d54e7bbed941121065de2be">00710</a>           <a class="code" href="a00278.html#b715644eb5226782fa5cab12f4918585" title="Make iterator pointing to first cell in subgrid.">SubIterator</a> (<span class="keyword">const</span> <a class="code" href="a00277.html">SubYGrid&lt;d,ct&gt;</a>&amp; r, <span class="keyword">const</span> <a class="code" href="a00277.html#69330d9ae40409c44f1b1c0df3b897a2" title="define types used for arguments">iTupel</a>&amp; <a class="code" href="a00309.html#c38a790e7409c951cde186671cf7c99d" title="Return coordinate of the cell as reference (do not modify).">coord</a>) : <a class="code" href="a00308.html">YGrid</a>&lt;d,ct&gt;::<a class="code" href="a00309.html">Iterator</a>::<a class="code" href="a00309.html">Iterator</a> (r,coord)
<a name="l00711"></a>00711           {
<a name="l00713"></a>00713                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i) <a class="code" href="a00278.html#352c9c2810e875f57a15064c97982dff" title="size of subgrid">_size</a>[i] = r.<a class="code" href="a00308.html#e672f5b5698739a0d552f28ca50266e5" title="Return size in direction i.">size</a>(i);
<a name="l00714"></a>00714 
<a name="l00715"></a>00715                 <span class="comment">// compute superincrements </span>
<a name="l00716"></a>00716                 <span class="keywordtype">int</span> inc = 1;
<a name="l00717"></a>00717                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i)
<a name="l00718"></a>00718                   {
<a name="l00719"></a>00719                         <a class="code" href="a00278.html#2b873645be4ee100bb65c105c8176b10" title="moves consecutive index by one in this direction in supergrid">_superincrement</a>[i] = inc;
<a name="l00720"></a>00720                         inc *= r.<a class="code" href="a00277.html#16416949f52bd21d0ec3c59c67562552" title="return size of enclosing grid">supersize</a>(i);
<a name="l00721"></a>00721                   }
<a name="l00722"></a>00722 
<a name="l00723"></a>00723                 <span class="comment">// move superindex to first cell in subgrid</span>
<a name="l00724"></a>00724                 <a class="code" href="a00278.html#d4c246a574feb07041d098d2905088e2" title="consecutive index in enclosing grid">_superindex</a> = 0;
<a name="l00725"></a>00725                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i)
<a name="l00726"></a>00726                   <a class="code" href="a00278.html#d4c246a574feb07041d098d2905088e2" title="consecutive index in enclosing grid">_superindex</a> += (r.<a class="code" href="a00277.html#de3ceaf5991c794f28b62c93005389bb" title="Return offset to origin of enclosing grid.">offset</a>(i)+coord[i]-r.<a class="code" href="a00308.html#321e0bd5abb6d0471e368fbe131b87e5" title="Return origin in direction i.">origin</a>(i))*<a class="code" href="a00278.html#2b873645be4ee100bb65c105c8176b10" title="moves consecutive index by one in this direction in supergrid">_superincrement</a>[i];
<a name="l00727"></a>00727           }
<a name="l00728"></a>00728 
<a name="l00730"></a><a class="code" href="a00278.html#800d052e6f699f8998f13162ef45d43d">00730</a>           <a class="code" href="a00278.html#b715644eb5226782fa5cab12f4918585" title="Make iterator pointing to first cell in subgrid.">SubIterator</a> (<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="a00308.html">YGrid&lt;d,ct&gt;::Iterator</a>&amp; i) : <a class="code" href="a00308.html">YGrid</a>&lt;d,ct&gt;::<a class="code" href="a00309.html">Iterator</a>::<a class="code" href="a00309.html">Iterator</a>(i)
<a name="l00731"></a>00731         {}
<a name="l00732"></a>00732 
<a name="l00734"></a><a class="code" href="a00278.html#cc610e41e1b9ff2d183dc82c638a9d09">00734</a>           <span class="keywordtype">void</span> <a class="code" href="a00278.html#cc610e41e1b9ff2d183dc82c638a9d09" title="Make iterator pointing to given cell in subgrid.">reinit</a> (<span class="keyword">const</span> <a class="code" href="a00277.html">SubYGrid&lt;d,ct&gt;</a>&amp; r, <span class="keyword">const</span> <a class="code" href="a00277.html#69330d9ae40409c44f1b1c0df3b897a2" title="define types used for arguments">iTupel</a>&amp; <a class="code" href="a00309.html#c38a790e7409c951cde186671cf7c99d" title="Return coordinate of the cell as reference (do not modify).">coord</a>) 
<a name="l00735"></a>00735           {
<a name="l00736"></a>00736                 <a class="code" href="a00308.html">YGrid&lt;d,ct&gt;::Iterator::reinit</a>(r,coord);
<a name="l00737"></a>00737 
<a name="l00739"></a>00739                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i) <a class="code" href="a00278.html#352c9c2810e875f57a15064c97982dff" title="size of subgrid">_size</a>[i] = r.<a class="code" href="a00308.html#e672f5b5698739a0d552f28ca50266e5" title="Return size in direction i.">size</a>(i);
<a name="l00740"></a>00740 
<a name="l00741"></a>00741                 <span class="comment">// compute superincrements </span>
<a name="l00742"></a>00742                 <span class="keywordtype">int</span> inc = 1;
<a name="l00743"></a>00743                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i)
<a name="l00744"></a>00744                   {
<a name="l00745"></a>00745                         <a class="code" href="a00278.html#2b873645be4ee100bb65c105c8176b10" title="moves consecutive index by one in this direction in supergrid">_superincrement</a>[i] = inc;
<a name="l00746"></a>00746                         inc *= r.<a class="code" href="a00277.html#16416949f52bd21d0ec3c59c67562552" title="return size of enclosing grid">supersize</a>(i);
<a name="l00747"></a>00747                   }
<a name="l00748"></a>00748 
<a name="l00749"></a>00749                 <span class="comment">// move superindex to first cell in subgrid</span>
<a name="l00750"></a>00750                 <a class="code" href="a00278.html#d4c246a574feb07041d098d2905088e2" title="consecutive index in enclosing grid">_superindex</a> = 0;
<a name="l00751"></a>00751                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i)
<a name="l00752"></a>00752                   <a class="code" href="a00278.html#d4c246a574feb07041d098d2905088e2" title="consecutive index in enclosing grid">_superindex</a> += (r.<a class="code" href="a00277.html#de3ceaf5991c794f28b62c93005389bb" title="Return offset to origin of enclosing grid.">offset</a>(i)+coord[i]-r.<a class="code" href="a00308.html#321e0bd5abb6d0471e368fbe131b87e5" title="Return origin in direction i.">origin</a>(i))*<a class="code" href="a00278.html#2b873645be4ee100bb65c105c8176b10" title="moves consecutive index by one in this direction in supergrid">_superincrement</a>[i];
<a name="l00753"></a>00753           }
<a name="l00754"></a>00754 
<a name="l00756"></a><a class="code" href="a00278.html#288a44402a256aa3c5be551577110965">00756</a>           <span class="keywordtype">int</span> <a class="code" href="a00278.html#288a44402a256aa3c5be551577110965" title="Return consecutive index in enclosing grid.">superindex</a> ()<span class="keyword"> const</span>
<a name="l00757"></a>00757 <span class="keyword">          </span>{
<a name="l00758"></a>00758                 <span class="keywordflow">return</span> <a class="code" href="a00278.html#d4c246a574feb07041d098d2905088e2" title="consecutive index in enclosing grid">_superindex</a>;
<a name="l00759"></a>00759           }
<a name="l00760"></a>00760 
<a name="l00762"></a><a class="code" href="a00278.html#cd56363778e8c9a2b4b02930aff41543">00762</a>           <span class="keywordtype">int</span> <a class="code" href="a00278.html#cd56363778e8c9a2b4b02930aff41543" title="Get index of cell which is dist cells away in direction i in enclosing grid.">superneighbor</a> (<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> dist)<span class="keyword"> const</span>
<a name="l00763"></a>00763 <span class="keyword">          </span>{
<a name="l00764"></a>00764                 <span class="keywordflow">return</span> <a class="code" href="a00278.html#d4c246a574feb07041d098d2905088e2" title="consecutive index in enclosing grid">_superindex</a>+dist*<a class="code" href="a00278.html#2b873645be4ee100bb65c105c8176b10" title="moves consecutive index by one in this direction in supergrid">_superincrement</a>[i];
<a name="l00765"></a>00765           }
<a name="l00766"></a>00766 
<a name="l00768"></a><a class="code" href="a00278.html#2d528e548bb48fc0d5edb18cd855ee32">00768</a>           <span class="keywordtype">int</span> <a class="code" href="a00278.html#2d528e548bb48fc0d5edb18cd855ee32" title="Get index of neighboring cell which is -1 away in direction i in enclosing grid.">superdown</a> (<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
<a name="l00769"></a>00769 <span class="keyword">          </span>{
<a name="l00770"></a>00770                 <span class="keywordflow">return</span> <a class="code" href="a00278.html#d4c246a574feb07041d098d2905088e2" title="consecutive index in enclosing grid">_superindex</a>-<a class="code" href="a00278.html#2b873645be4ee100bb65c105c8176b10" title="moves consecutive index by one in this direction in supergrid">_superincrement</a>[i];
<a name="l00771"></a>00771           }
<a name="l00772"></a>00772 
<a name="l00774"></a><a class="code" href="a00278.html#53223c30dba438bd7581c35067261555">00774</a>           <span class="keywordtype">int</span> <a class="code" href="a00278.html#53223c30dba438bd7581c35067261555" title="Get index of neighboring cell which is +1 away in direction i in enclosing grid.">superup</a> (<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
<a name="l00775"></a>00775 <span class="keyword">          </span>{
<a name="l00776"></a>00776                 <span class="keywordflow">return</span> <a class="code" href="a00278.html#d4c246a574feb07041d098d2905088e2" title="consecutive index in enclosing grid">_superindex</a>+<a class="code" href="a00278.html#2b873645be4ee100bb65c105c8176b10" title="moves consecutive index by one in this direction in supergrid">_superincrement</a>[i];
<a name="l00777"></a>00777           }
<a name="l00778"></a>00778 
<a name="l00780"></a><a class="code" href="a00278.html#50d2a40014ef06319534ab798171c3f8">00780</a>           <span class="keywordtype">void</span> <a class="code" href="a00278.html#50d2a40014ef06319534ab798171c3f8" title="move this iterator dist cells in direction i">move</a> (<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> dist)
<a name="l00781"></a>00781           {
<a name="l00782"></a>00782                 <a class="code" href="a00308.html">YGrid&lt;d,ct&gt;::Iterator::move</a>(i,dist);    <span class="comment">// move base iterator</span>
<a name="l00783"></a>00783                 <a class="code" href="a00278.html#d4c246a574feb07041d098d2905088e2" title="consecutive index in enclosing grid">_superindex</a> += dist*<a class="code" href="a00278.html#2b873645be4ee100bb65c105c8176b10" title="moves consecutive index by one in this direction in supergrid">_superincrement</a>[i]; <span class="comment">// move superindex</span>
<a name="l00784"></a>00784           }
<a name="l00785"></a>00785 
<a name="l00787"></a><a class="code" href="a00278.html#a89c466c50a8536fd610093acbc63923">00787</a>           <a class="code" href="a00278.html">SubIterator</a>&amp; <a class="code" href="a00278.html#a89c466c50a8536fd610093acbc63923" title="Increment iterator to next cell in subgrid.">operator++ </a>()
<a name="l00788"></a>00788           {
<a name="l00789"></a>00789                 ++(this-&gt;_index);               <span class="comment">// update consecutive index in grid</span>
<a name="l00790"></a>00790                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; i++)         <span class="comment">// check for wrap around</span>
<a name="l00791"></a>00791                   {
<a name="l00792"></a>00792                         <a class="code" href="a00278.html#d4c246a574feb07041d098d2905088e2" title="consecutive index in enclosing grid">_superindex</a> += <a class="code" href="a00278.html#2b873645be4ee100bb65c105c8176b10" title="moves consecutive index by one in this direction in supergrid">_superincrement</a>[i]; <span class="comment">// move on cell in direction i</span>
<a name="l00793"></a>00793                         <span class="keywordflow">if</span> (++(this-&gt;_coord[i])&lt;=this-&gt;_end[i])
<a name="l00794"></a>00794                           <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00795"></a>00795                         <span class="keywordflow">else</span> 
<a name="l00796"></a>00796                           { 
<a name="l00797"></a>00797                                 this-&gt;_coord[i]=this-&gt;_origin[i];     <span class="comment">// move back to origin in direction i</span>
<a name="l00798"></a>00798                                 <a class="code" href="a00278.html#d4c246a574feb07041d098d2905088e2" title="consecutive index in enclosing grid">_superindex</a> -= <a class="code" href="a00278.html#352c9c2810e875f57a15064c97982dff" title="size of subgrid">_size</a>[i]*<a class="code" href="a00278.html#2b873645be4ee100bb65c105c8176b10" title="moves consecutive index by one in this direction in supergrid">_superincrement</a>[i]; 
<a name="l00799"></a>00799                           }
<a name="l00800"></a>00800                   }
<a name="l00801"></a>00801                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00802"></a>00802           }
<a name="l00803"></a>00803           
<a name="l00805"></a><a class="code" href="a00278.html#b8ae0ca1ddc4b7eac8349883e72fb40e">00805</a>           <span class="keywordtype">void</span> <a class="code" href="a00278.html#b8ae0ca1ddc4b7eac8349883e72fb40e" title="Print position of iterator.">print</a> (std::ostream&amp; s)<span class="keyword"> const</span>
<a name="l00806"></a>00806 <span class="keyword">          </span>{
<a name="l00807"></a>00807                 <a class="code" href="a00308.html">YGrid&lt;d,ct&gt;::Iterator::print</a>(s);
<a name="l00808"></a>00808                 s &lt;&lt; <span class="stringliteral">" super="</span> &lt;&lt; <a class="code" href="a00278.html#288a44402a256aa3c5be551577110965" title="Return consecutive index in enclosing grid.">superindex</a>();
<a name="l00809"></a>00809           }
<a name="l00810"></a>00810 
<a name="l00811"></a>00811         <span class="keyword">protected</span>:
<a name="l00812"></a><a class="code" href="a00278.html#d4c246a574feb07041d098d2905088e2">00812</a>           <span class="keywordtype">int</span> <a class="code" href="a00278.html#d4c246a574feb07041d098d2905088e2" title="consecutive index in enclosing grid">_superindex</a>;        
<a name="l00813"></a><a class="code" href="a00278.html#2b873645be4ee100bb65c105c8176b10">00813</a>           <a class="code" href="a00277.html#69330d9ae40409c44f1b1c0df3b897a2" title="define types used for arguments">iTupel</a> <a class="code" href="a00278.html#2b873645be4ee100bb65c105c8176b10" title="moves consecutive index by one in this direction in supergrid">_superincrement</a>; 
<a name="l00814"></a><a class="code" href="a00278.html#352c9c2810e875f57a15064c97982dff">00814</a>           <a class="code" href="a00277.html#69330d9ae40409c44f1b1c0df3b897a2" title="define types used for arguments">iTupel</a> <a class="code" href="a00278.html#352c9c2810e875f57a15064c97982dff" title="size of subgrid">_size</a>;           
<a name="l00815"></a>00815         };
<a name="l00816"></a>00816 
<a name="l00818"></a><a class="code" href="a00277.html#e355deb6e60425862121709a49be585c">00818</a>         SubIterator <a class="code" href="a00277.html#e355deb6e60425862121709a49be585c" title="return subiterator to first element of index set">subbegin</a> ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> SubIterator(*<span class="keyword">this</span>); }
<a name="l00819"></a>00819         
<a name="l00821"></a><a class="code" href="a00277.html#e3aa134c3cfe8af5c07cbe033330ac33">00821</a>         SubIterator <a class="code" href="a00277.html#e3aa134c3cfe8af5c07cbe033330ac33" title="return subiterator to last element of index set">subend</a> ()<span class="keyword"> const</span>
<a name="l00822"></a>00822 <span class="keyword">        </span>{
<a name="l00823"></a>00823           <a class="code" href="a00277.html#69330d9ae40409c44f1b1c0df3b897a2" title="define types used for arguments">iTupel</a> last;
<a name="l00824"></a>00824           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; i++) last[i] = this-&gt;<a class="code" href="a00308.html#eb23a6893a81d54f72fe60e8acd75ad5" title="Return maximum index in direction i.">max</a>(i);
<a name="l00825"></a>00825           last[0] += 1;
<a name="l00826"></a>00826           <span class="keywordflow">return</span> SubIterator(*<span class="keyword">this</span>,last);
<a name="l00827"></a>00827         }
<a name="l00828"></a>00828 
<a name="l00833"></a><a class="code" href="a00279.html">00833</a>         <span class="keyword">class </span><a class="code" href="a00279.html">TransformingSubIterator</a> : <span class="keyword">public</span> <a class="code" href="a00278.html">SubIterator</a> {
<a name="l00834"></a>00834         <span class="keyword">public</span>:
<a name="l00836"></a><a class="code" href="a00279.html#7c5f60e39e14cc87bd73c77a2903dd4e">00836</a>           <a class="code" href="a00279.html#7c5f60e39e14cc87bd73c77a2903dd4e" title="Make iterator pointing to first cell in a grid.">TransformingSubIterator</a> (<span class="keyword">const</span> <a class="code" href="a00277.html">SubYGrid&lt;d,ct&gt;</a>&amp; r) : <a class="code" href="a00278.html">SubIterator</a>(r)
<a name="l00837"></a>00837           {
<a name="l00838"></a>00838                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i) _h[i] = r.<a class="code" href="a00308.html#7bed6643312a1e459af95cdcc69f8fbd" title="Return reference to mesh size tupel for read write access.">meshsize</a>(i);
<a name="l00839"></a>00839                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i) _begin[i] = r.<a class="code" href="a00308.html#321e0bd5abb6d0471e368fbe131b87e5" title="Return origin in direction i.">origin</a>(i)*r.<a class="code" href="a00308.html#7bed6643312a1e459af95cdcc69f8fbd" title="Return reference to mesh size tupel for read write access.">meshsize</a>(i)+r.<a class="code" href="a00308.html#bc763dfd8b05a22a609bae31dfc64b94" title="Return shift tupel.">shift</a>(i);
<a name="l00840"></a>00840                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i) _position[i] = _begin[i];
<a name="l00841"></a>00841           }
<a name="l00842"></a>00842 
<a name="l00844"></a><a class="code" href="a00279.html#edbc0d82d2e742676150d983e2d56b9b">00844</a>           <a class="code" href="a00279.html#7c5f60e39e14cc87bd73c77a2903dd4e" title="Make iterator pointing to first cell in a grid.">TransformingSubIterator</a> (<span class="keyword">const</span> <a class="code" href="a00277.html">SubYGrid&lt;d,ct&gt;</a>&amp; r, <span class="keyword">const</span> <a class="code" href="a00277.html#69330d9ae40409c44f1b1c0df3b897a2" title="define types used for arguments">iTupel</a>&amp; <a class="code" href="a00309.html#c38a790e7409c951cde186671cf7c99d" title="Return coordinate of the cell as reference (do not modify).">coord</a>) : <a class="code" href="a00278.html">SubIterator</a>(r,coord)
<a name="l00845"></a>00845           {
<a name="l00846"></a>00846                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i) _h[i] = r.<a class="code" href="a00308.html#7bed6643312a1e459af95cdcc69f8fbd" title="Return reference to mesh size tupel for read write access.">meshsize</a>(i);
<a name="l00847"></a>00847                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i) _begin[i] = r.<a class="code" href="a00308.html#321e0bd5abb6d0471e368fbe131b87e5" title="Return origin in direction i.">origin</a>(i)*r.<a class="code" href="a00308.html#7bed6643312a1e459af95cdcc69f8fbd" title="Return reference to mesh size tupel for read write access.">meshsize</a>(i)+r.<a class="code" href="a00308.html#bc763dfd8b05a22a609bae31dfc64b94" title="Return shift tupel.">shift</a>(i);
<a name="l00848"></a>00848                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i) _position[i] = coord[i]*r.<a class="code" href="a00308.html#7bed6643312a1e459af95cdcc69f8fbd" title="Return reference to mesh size tupel for read write access.">meshsize</a>(i)+r.<a class="code" href="a00308.html#bc763dfd8b05a22a609bae31dfc64b94" title="Return shift tupel.">shift</a>(i);
<a name="l00849"></a>00849           }
<a name="l00850"></a>00850 
<a name="l00852"></a><a class="code" href="a00279.html#6acf1a33605e57c9b3e1ad0291274683">00852</a>       <a class="code" href="a00279.html#7c5f60e39e14cc87bd73c77a2903dd4e" title="Make iterator pointing to first cell in a grid.">TransformingSubIterator</a> (<span class="keyword">const</span> <a class="code" href="a00278.html">SubIterator</a>&amp; i) :
<a name="l00853"></a>00853         <a class="code" href="a00278.html">SubIterator</a>(i)
<a name="l00854"></a>00854         {}
<a name="l00855"></a>00855 
<a name="l00856"></a>00856       <a class="code" href="a00279.html#7c5f60e39e14cc87bd73c77a2903dd4e" title="Make iterator pointing to first cell in a grid.">TransformingSubIterator</a> (<span class="keyword">const</span> <a class="code" href="a00279.html">TransformingSubIterator</a> &amp; t) :
<a name="l00857"></a>00857         <a class="code" href="a00278.html">SubIterator</a>(t), _h(t._h), _begin(t._begin), _position(t._position)
<a name="l00858"></a>00858         {}
<a name="l00859"></a>00859 
<a name="l00861"></a><a class="code" href="a00279.html#c0ff73fa4b1d6ca51abc3c275aeb1f30">00861</a>           <span class="keywordtype">void</span> <a class="code" href="a00279.html#c0ff73fa4b1d6ca51abc3c275aeb1f30" title="Make iterator pointing to given cell in a grid.">reinit</a> (<span class="keyword">const</span> <a class="code" href="a00277.html">SubYGrid&lt;d,ct&gt;</a>&amp; r, <span class="keyword">const</span> <a class="code" href="a00277.html#69330d9ae40409c44f1b1c0df3b897a2" title="define types used for arguments">iTupel</a>&amp; <a class="code" href="a00309.html#c38a790e7409c951cde186671cf7c99d" title="Return coordinate of the cell as reference (do not modify).">coord</a>) 
<a name="l00862"></a>00862           {
<a name="l00863"></a>00863                 <a class="code" href="a00278.html#cc610e41e1b9ff2d183dc82c638a9d09" title="Make iterator pointing to given cell in subgrid.">SubIterator::reinit</a>(r,coord);
<a name="l00864"></a>00864                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i) _h[i] = r.<a class="code" href="a00308.html#7bed6643312a1e459af95cdcc69f8fbd" title="Return reference to mesh size tupel for read write access.">meshsize</a>(i);
<a name="l00865"></a>00865                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i) _begin[i] = r.<a class="code" href="a00308.html#321e0bd5abb6d0471e368fbe131b87e5" title="Return origin in direction i.">origin</a>(i)*r.<a class="code" href="a00308.html#7bed6643312a1e459af95cdcc69f8fbd" title="Return reference to mesh size tupel for read write access.">meshsize</a>(i)+r.<a class="code" href="a00308.html#bc763dfd8b05a22a609bae31dfc64b94" title="Return shift tupel.">shift</a>(i);
<a name="l00866"></a>00866                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i) _position[i] = coord[i]*r.<a class="code" href="a00308.html#7bed6643312a1e459af95cdcc69f8fbd" title="Return reference to mesh size tupel for read write access.">meshsize</a>(i)+r.<a class="code" href="a00308.html#bc763dfd8b05a22a609bae31dfc64b94" title="Return shift tupel.">shift</a>(i);
<a name="l00867"></a>00867           }
<a name="l00868"></a>00868 
<a name="l00870"></a><a class="code" href="a00279.html#537d91f61ced3953d8b34aaf2838f5f7">00870</a>           <a class="code" href="a00279.html">TransformingSubIterator</a>&amp; <a class="code" href="a00279.html#537d91f61ced3953d8b34aaf2838f5f7" title="Increment iterator to next cell with position.">operator++ </a>()
<a name="l00871"></a>00871           {
<a name="l00872"></a>00872                 ++(this-&gt;_index);                       <span class="comment">// update consecutive index in subgrid</span>
<a name="l00873"></a>00873                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; i++)         <span class="comment">// check for wrap around</span>
<a name="l00874"></a>00874                   {
<a name="l00875"></a>00875                         this-&gt;<a class="code" href="a00278.html#d4c246a574feb07041d098d2905088e2" title="consecutive index in enclosing grid">_superindex</a> += this-&gt;<a class="code" href="a00278.html#2b873645be4ee100bb65c105c8176b10" title="moves consecutive index by one in this direction in supergrid">_superincrement</a>[i]; <span class="comment">// move on cell in direction i</span>
<a name="l00876"></a>00876                         <span class="keywordflow">if</span> (++(this-&gt;_coord[i])&lt;=this-&gt;_end[i])
<a name="l00877"></a>00877                           {
<a name="l00878"></a>00878                                 _position[i] += _h[i];
<a name="l00879"></a>00879                                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00880"></a>00880                           }
<a name="l00881"></a>00881                         <span class="keywordflow">else</span> 
<a name="l00882"></a>00882                           { 
<a name="l00883"></a>00883                                 this-&gt;_coord[i]=this-&gt;_origin[i];     <span class="comment">// move back to origin in direction i</span>
<a name="l00884"></a>00884                                 this-&gt;<a class="code" href="a00278.html#d4c246a574feb07041d098d2905088e2" title="consecutive index in enclosing grid">_superindex</a> -= this-&gt;<a class="code" href="a00278.html#352c9c2810e875f57a15064c97982dff" title="size of subgrid">_size</a>[i]*this-&gt;<a class="code" href="a00278.html#2b873645be4ee100bb65c105c8176b10" title="moves consecutive index by one in this direction in supergrid">_superincrement</a>[i]; 
<a name="l00885"></a>00885                                 _position[i] = _begin[i];
<a name="l00886"></a>00886                           }
<a name="l00887"></a>00887                   }
<a name="l00888"></a>00888                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00889"></a>00889           }
<a name="l00890"></a>00890 
<a name="l00892"></a><a class="code" href="a00279.html#89dcd5a21f879a80441cf8ed180c871e">00892</a>           ct <a class="code" href="a00279.html#72f4eca58ad9ab89640194ed12d897ad" title="Return position of current cell as reference.">position</a> (<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
<a name="l00893"></a>00893 <span class="keyword">          </span>{
<a name="l00894"></a>00894                 <span class="keywordflow">return</span> _position[i];
<a name="l00895"></a>00895           }
<a name="l00896"></a>00896 
<a name="l00898"></a><a class="code" href="a00279.html#72f4eca58ad9ab89640194ed12d897ad">00898</a>           <span class="keyword">const</span> fTupel&amp; <a class="code" href="a00279.html#72f4eca58ad9ab89640194ed12d897ad" title="Return position of current cell as reference.">position</a> ()<span class="keyword"> const</span>
<a name="l00899"></a>00899 <span class="keyword">          </span>{
<a name="l00900"></a>00900                 <span class="keywordflow">return</span> _position;
<a name="l00901"></a>00901           }
<a name="l00902"></a>00902 
<a name="l00904"></a><a class="code" href="a00279.html#909f63dd690601d7096e44eeb47981ce">00904</a>           ct <a class="code" href="a00279.html#0e246118591781ef314bd00a97c8264f" title="Return meshsize of current cell as reference.">meshsize</a> (<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
<a name="l00905"></a>00905 <span class="keyword">          </span>{
<a name="l00906"></a>00906                 <span class="keywordflow">return</span> _h[i];
<a name="l00907"></a>00907           }
<a name="l00908"></a>00908 
<a name="l00910"></a><a class="code" href="a00279.html#0e246118591781ef314bd00a97c8264f">00910</a>           <span class="keyword">const</span> fTupel&amp; <a class="code" href="a00279.html#0e246118591781ef314bd00a97c8264f" title="Return meshsize of current cell as reference.">meshsize</a> ()<span class="keyword"> const</span>
<a name="l00911"></a>00911 <span class="keyword">          </span>{
<a name="l00912"></a>00912                 <span class="keywordflow">return</span> _h;
<a name="l00913"></a>00913           }
<a name="l00914"></a>00914 
<a name="l00916"></a><a class="code" href="a00279.html#ea0e590bec08b6eb595fd35799cd284a">00916</a>           <span class="keywordtype">void</span> <a class="code" href="a00279.html#ea0e590bec08b6eb595fd35799cd284a" title="Move cell position by dist cells in direction i.">move</a> (<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> dist)
<a name="l00917"></a>00917           {
<a name="l00918"></a>00918                 <a class="code" href="a00278.html#50d2a40014ef06319534ab798171c3f8" title="move this iterator dist cells in direction i">SubIterator::move</a>(i,dist);
<a name="l00919"></a>00919                 _position[i] += dist*_h[i];
<a name="l00920"></a>00920           }
<a name="l00921"></a>00921 
<a name="l00923"></a><a class="code" href="a00279.html#c09c200227cbe076a6a19f2879422a52">00923</a>           <span class="keywordtype">void</span> <a class="code" href="a00279.html#c09c200227cbe076a6a19f2879422a52" title="Print contents of iterator.">print</a> (std::ostream&amp; s)<span class="keyword"> const</span>
<a name="l00924"></a>00924 <span class="keyword">          </span>{
<a name="l00925"></a>00925                 <a class="code" href="a00278.html#b8ae0ca1ddc4b7eac8349883e72fb40e" title="Print position of iterator.">SubIterator::print</a>(s);
<a name="l00926"></a>00926                 s &lt;&lt; <span class="stringliteral">" ["</span>;
<a name="l00927"></a>00927                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d-1; i++) s &lt;&lt; <a class="code" href="a00279.html#72f4eca58ad9ab89640194ed12d897ad" title="Return position of current cell as reference.">position</a>(i) &lt;&lt; <span class="stringliteral">","</span>;
<a name="l00928"></a>00928                 s &lt;&lt; <a class="code" href="a00279.html#72f4eca58ad9ab89640194ed12d897ad" title="Return position of current cell as reference.">position</a>(d-1) &lt;&lt; <span class="stringliteral">"]"</span>;
<a name="l00929"></a>00929           }
<a name="l00930"></a>00930 
<a name="l00931"></a>00931         <span class="keyword">private</span>:
<a name="l00932"></a>00932           fTupel _h;        
<a name="l00933"></a>00933           fTupel _begin;    
<a name="l00934"></a>00934           fTupel _position; 
<a name="l00935"></a>00935         };
<a name="l00936"></a>00936 
<a name="l00938"></a><a class="code" href="a00277.html#4e4eddd4d22e3545c4e5e5a3161bb16f">00938</a>         TransformingSubIterator <a class="code" href="a00277.html#4e4eddd4d22e3545c4e5e5a3161bb16f" title="return iterator to first element of index set">tsubbegin</a> ()<span class="keyword"> const</span>
<a name="l00939"></a>00939 <span class="keyword">        </span>{
<a name="l00940"></a>00940           <span class="keywordflow">return</span> TransformingSubIterator(*<span class="keyword">this</span>);
<a name="l00941"></a>00941         }
<a name="l00942"></a>00942         
<a name="l00944"></a><a class="code" href="a00277.html#911cf8fd9d218be954d3fb268a8f935c">00944</a>         TransformingSubIterator <a class="code" href="a00277.html#4e4eddd4d22e3545c4e5e5a3161bb16f" title="return iterator to first element of index set">tsubbegin</a> (<a class="code" href="a00277.html#69330d9ae40409c44f1b1c0df3b897a2" title="define types used for arguments">iTupel</a>&amp; co)<span class="keyword"> const</span>
<a name="l00945"></a>00945 <span class="keyword">        </span>{
<a name="l00946"></a>00946           <span class="keywordflow">return</span> TransformingSubIterator(*<span class="keyword">this</span>,co);
<a name="l00947"></a>00947         }
<a name="l00948"></a>00948         
<a name="l00950"></a><a class="code" href="a00277.html#9833935f062e13a686d5b67acd647052">00950</a>         TransformingSubIterator <a class="code" href="a00277.html#9833935f062e13a686d5b67acd647052" title="return subiterator to last element of index set">tsubend</a> ()<span class="keyword"> const</span>
<a name="l00951"></a>00951 <span class="keyword">        </span>{
<a name="l00952"></a>00952           SubIterator endit = <a class="code" href="a00277.html#e3aa134c3cfe8af5c07cbe033330ac33" title="return subiterator to last element of index set">subend</a>();
<a name="l00953"></a>00953           <span class="keywordflow">return</span> TransformingSubIterator(endit);
<a name="l00954"></a>00954         }
<a name="l00955"></a>00955         
<a name="l00956"></a>00956   <span class="keyword">private</span>:
<a name="l00957"></a>00957         <a class="code" href="a00277.html#69330d9ae40409c44f1b1c0df3b897a2" title="define types used for arguments">iTupel</a> _offset;    
<a name="l00958"></a>00958         <a class="code" href="a00277.html#69330d9ae40409c44f1b1c0df3b897a2" title="define types used for arguments">iTupel</a> _supersize; 
<a name="l00959"></a>00959   };
<a name="l00960"></a>00960 
<a name="l00961"></a>00961 
<a name="l00963"></a>00963   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> d, <span class="keyword">typename</span> ct&gt;
<a name="l00964"></a><a class="code" href="a00441.html#817ffe0aeb2d5dffc56c7142967f4ead">00964</a>   <span class="keyword">inline</span> std::ostream&amp; operator&lt;&lt; (std::ostream&amp; s, SubYGrid&lt;d,ct&gt; e)
<a name="l00965"></a>00965   {
<a name="l00966"></a>00966         <a class="code" href="a00308.html">YGrid&lt;d,ct&gt;</a> x = e;
<a name="l00967"></a>00967         s &lt;&lt; x &lt;&lt; <span class="stringliteral">" ofs="</span> &lt;&lt; e.offset() &lt;&lt; <span class="stringliteral">" ss="</span> &lt;&lt; e.supersize();
<a name="l00968"></a>00968         <span class="keywordflow">return</span> s;
<a name="l00969"></a>00969   }
<a name="l00970"></a>00970 
<a name="l00972"></a>00972   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> d, <span class="keyword">typename</span> ct&gt;
<a name="l00973"></a><a class="code" href="a00441.html#0c1ecc11cba07b527df174ef18530aaa">00973</a>   <span class="keyword">inline</span> std::ostream&amp; operator&lt;&lt; (std::ostream&amp; s, typename SubYGrid&lt;d,ct&gt;::TransformingSubIterator&amp; e)
<a name="l00974"></a>00974   {
<a name="l00975"></a>00975         e.print(s);
<a name="l00976"></a>00976         <span class="keywordflow">return</span> s;
<a name="l00977"></a>00977   }
<a name="l00978"></a>00978 
<a name="l00979"></a>00979 
<a name="l00993"></a>00993   <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> d&gt;
<a name="l00994"></a><a class="code" href="a00280.html">00994</a>   <span class="keyword">class </span><a class="code" href="a00280.html">Torus</a> {
<a name="l00995"></a>00995   <span class="keyword">public</span>:
<a name="l00997"></a><a class="code" href="a00280.html#4adc59dea7328099f636e7d978b877cb">00997</a>         <span class="keyword">typedef</span> FieldVector&lt;int, d&gt; <a class="code" href="a00280.html#4adc59dea7328099f636e7d978b877cb" title="type used to pass tupels in and out">iTupel</a>;
<a name="l00998"></a>00998         <span class="keyword">typedef</span> FieldVector&lt;bool, d&gt; bTupel;
<a name="l00999"></a>00999 
<a name="l01000"></a>01000 
<a name="l01001"></a>01001   <span class="keyword">private</span>:
<a name="l01002"></a>01002         <span class="keyword">struct </span>CommPartner {
<a name="l01003"></a>01003           <span class="keywordtype">int</span> <a class="code" href="a00280.html#224f82289a447cbfecd50321ec3ba4aa" title="return own rank">rank</a>;
<a name="l01004"></a>01004           <a class="code" href="a00280.html#4adc59dea7328099f636e7d978b877cb" title="type used to pass tupels in and out">iTupel</a> delta;
<a name="l01005"></a>01005           <span class="keywordtype">int</span> index;
<a name="l01006"></a>01006         };
<a name="l01007"></a>01007 
<a name="l01008"></a>01008         <span class="keyword">struct </span>CommTask {
<a name="l01009"></a>01009           <span class="keywordtype">int</span> <a class="code" href="a00280.html#224f82289a447cbfecd50321ec3ba4aa" title="return own rank">rank</a>;      <span class="comment">// process to send to / receive from</span>
<a name="l01010"></a>01010           <span class="keywordtype">void</span> *buffer;  <span class="comment">// buffer to send / receive</span>
<a name="l01011"></a>01011           <span class="keywordtype">int</span> size;      <span class="comment">// size of buffer</span>
<a name="l01012"></a>01012 <span class="preprocessor">#if HAVE_MPI</span>
<a name="l01013"></a>01013 <span class="preprocessor"></span>          MPI_Request request; <span class="comment">// used by MPI to handle request</span>
<a name="l01014"></a>01014 <span class="preprocessor">#else</span>
<a name="l01015"></a>01015 <span class="preprocessor"></span>          <span class="keywordtype">int</span> request;
<a name="l01016"></a>01016 <span class="preprocessor">#endif</span>
<a name="l01017"></a>01017 <span class="preprocessor"></span>          <span class="keywordtype">int</span> flag;      <span class="comment">// used by MPI </span>
<a name="l01018"></a>01018         };
<a name="l01019"></a>01019 
<a name="l01020"></a>01020   <span class="keyword">public</span>:
<a name="l01022"></a><a class="code" href="a00280.html#99d118ae1f0dc133c974927bc2f04c1e">01022</a>         <a class="code" href="a00280.html#99d118ae1f0dc133c974927bc2f04c1e" title="constructor making uninitialized object">Torus</a> () 
<a name="l01023"></a>01023         {  }
<a name="l01024"></a>01024 
<a name="l01026"></a>01026 <span class="preprocessor">#if HAVE_MPI</span>
<a name="l01027"></a><a class="code" href="a00280.html#76ca3d1055ed2d86a900493d784c4d07">01027</a> <span class="preprocessor"></span>        <a class="code" href="a00280.html#99d118ae1f0dc133c974927bc2f04c1e" title="constructor making uninitialized object">Torus</a> (MPI_Comm <a class="code" href="a00280.html#e2900a1f366962caa110f00382ae2472" title="return MPI communicator">comm</a>, <span class="keywordtype">int</span> <a class="code" href="a00280.html#7162e481081e4ce538633c583e3aeb4f" title="return tag used by torus">tag</a>, <a class="code" href="a00280.html#4adc59dea7328099f636e7d978b877cb" title="type used to pass tupels in and out">iTupel</a> size)
<a name="l01028"></a>01028 <span class="preprocessor">#else</span>
<a name="l01029"></a>01029 <span class="preprocessor"></span>        <a class="code" href="a00280.html#99d118ae1f0dc133c974927bc2f04c1e" title="constructor making uninitialized object">Torus</a> (<span class="keywordtype">int</span> tag, <a class="code" href="a00280.html#4adc59dea7328099f636e7d978b877cb" title="type used to pass tupels in and out">iTupel</a> size)
<a name="l01030"></a>01030 <span class="preprocessor">#endif</span>
<a name="l01031"></a>01031 <span class="preprocessor"></span>        {
<a name="l01032"></a>01032           <span class="comment">// MPI stuff</span>
<a name="l01033"></a>01033 <span class="preprocessor">#if HAVE_MPI</span>
<a name="l01034"></a>01034 <span class="preprocessor"></span>          _comm = comm;
<a name="l01035"></a>01035           MPI_Comm_size(comm,&amp;_procs);
<a name="l01036"></a>01036           MPI_Comm_rank(comm,&amp;_rank);
<a name="l01037"></a>01037 <span class="preprocessor">#else</span>
<a name="l01038"></a>01038 <span class="preprocessor"></span>          _procs=1; _rank=0;
<a name="l01039"></a>01039 <span class="preprocessor">#endif</span>
<a name="l01040"></a>01040 <span class="preprocessor"></span>          _tag = tag;
<a name="l01041"></a>01041 
<a name="l01042"></a>01042           <span class="comment">// determine dimensions</span>
<a name="l01043"></a>01043           <a class="code" href="a00280.html#4adc59dea7328099f636e7d978b877cb" title="type used to pass tupels in and out">iTupel</a> <a class="code" href="a00280.html#d644437a102c8187b065d21f79f20628" title="return dimensions of torus">dims</a>;
<a name="l01044"></a>01044           <span class="keywordtype">double</span> opt=1E100;
<a name="l01045"></a>01045           optimize_dims(d-1,size,_procs,dims,opt);
<a name="l01046"></a>01046 <span class="comment">//        if (_rank==0) std::cout &lt;&lt; "Torus&lt;" &lt;&lt; d </span>
<a name="l01047"></a>01047 <span class="comment">//                                                        &lt;&lt; "&gt;: mapping " &lt;&lt; _procs &lt;&lt; " processes onto "</span>
<a name="l01048"></a>01048 <span class="comment">//                                                        &lt;&lt; _dims &lt;&lt; " torus." &lt;&lt; std::endl;</span>
<a name="l01049"></a>01049 
<a name="l01050"></a>01050           <span class="comment">// compute increments for lexicographic ordering</span>
<a name="l01051"></a>01051           <span class="keywordtype">int</span> inc = 1;
<a name="l01052"></a>01052           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; i++)
<a name="l01053"></a>01053                 {
<a name="l01054"></a>01054                   _increment[i] = inc;
<a name="l01055"></a>01055                   inc *= _dims[i];
<a name="l01056"></a>01056                 }
<a name="l01057"></a>01057 
<a name="l01058"></a>01058           <span class="comment">// make full schedule</span>
<a name="l01059"></a>01059           proclists();
<a name="l01060"></a>01060         }
<a name="l01061"></a>01061 
<a name="l01063"></a><a class="code" href="a00280.html#224f82289a447cbfecd50321ec3ba4aa">01063</a>         <span class="keywordtype">int</span> <a class="code" href="a00280.html#224f82289a447cbfecd50321ec3ba4aa" title="return own rank">rank</a> ()<span class="keyword"> const</span>
<a name="l01064"></a>01064 <span class="keyword">        </span>{
<a name="l01065"></a>01065           <span class="keywordflow">return</span> _rank;
<a name="l01066"></a>01066         }
<a name="l01067"></a>01067 
<a name="l01069"></a><a class="code" href="a00280.html#56bbc31a70b7b56e300ff1aaef61aef9">01069</a>         <a class="code" href="a00280.html#4adc59dea7328099f636e7d978b877cb" title="type used to pass tupels in and out">iTupel</a> <a class="code" href="a00280.html#56bbc31a70b7b56e300ff1aaef61aef9" title="return own coordinates">coord</a> ()<span class="keyword"> const</span>
<a name="l01070"></a>01070 <span class="keyword">        </span>{
<a name="l01071"></a>01071           <span class="keywordflow">return</span> <a class="code" href="a00280.html#cf0165d70e493bed9fdf958c7ccffe10" title="map rank to coordinate in torus using lexicographic ordering">rank_to_coord</a>(_rank);
<a name="l01072"></a>01072         }
<a name="l01073"></a>01073 
<a name="l01075"></a><a class="code" href="a00280.html#cc1be56fea6bb33bc2594c86e20f3624">01075</a>         <span class="keywordtype">int</span> <a class="code" href="a00280.html#cc1be56fea6bb33bc2594c86e20f3624" title="return number of processes">procs</a> ()<span class="keyword"> const</span>
<a name="l01076"></a>01076 <span class="keyword">        </span>{
<a name="l01077"></a>01077           <span class="keywordflow">return</span> _procs;
<a name="l01078"></a>01078         }
<a name="l01079"></a>01079 
<a name="l01081"></a><a class="code" href="a00280.html#d644437a102c8187b065d21f79f20628">01081</a>         <span class="keyword">const</span> <a class="code" href="a00280.html#4adc59dea7328099f636e7d978b877cb" title="type used to pass tupels in and out">iTupel</a> &amp; <a class="code" href="a00280.html#d644437a102c8187b065d21f79f20628" title="return dimensions of torus">dims</a> ()<span class="keyword"> const</span>
<a name="l01082"></a>01082 <span class="keyword">        </span>{
<a name="l01083"></a>01083           <span class="keywordflow">return</span> _dims;
<a name="l01084"></a>01084         }
<a name="l01085"></a>01085 
<a name="l01087"></a><a class="code" href="a00280.html#a97327c0cb14457cbdc391d156c70016">01087</a>         <span class="keywordtype">int</span> <a class="code" href="a00280.html#d644437a102c8187b065d21f79f20628" title="return dimensions of torus">dims</a> (<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
<a name="l01088"></a>01088 <span class="keyword">        </span>{
<a name="l01089"></a>01089           <span class="keywordflow">return</span> _dims[i];
<a name="l01090"></a>01090         }
<a name="l01091"></a>01091 
<a name="l01093"></a>01093 <span class="preprocessor">#if HAVE_MPI</span>
<a name="l01094"></a><a class="code" href="a00280.html#e2900a1f366962caa110f00382ae2472">01094</a> <span class="preprocessor"></span>        MPI_Comm <a class="code" href="a00280.html#e2900a1f366962caa110f00382ae2472" title="return MPI communicator">comm</a> ()<span class="keyword"> const</span>
<a name="l01095"></a>01095 <span class="keyword">        </span>{
<a name="l01096"></a>01096           <span class="keywordflow">return</span> _comm;
<a name="l01097"></a>01097         }
<a name="l01098"></a>01098 <span class="preprocessor">#endif</span>
<a name="l01099"></a>01099 <span class="preprocessor"></span>
<a name="l01101"></a><a class="code" href="a00280.html#7162e481081e4ce538633c583e3aeb4f">01101</a>         <span class="keywordtype">int</span> <a class="code" href="a00280.html#7162e481081e4ce538633c583e3aeb4f" title="return tag used by torus">tag</a> ()<span class="keyword"> const</span>
<a name="l01102"></a>01102 <span class="keyword">        </span>{
<a name="l01103"></a>01103           <span class="keywordflow">return</span> _tag;
<a name="l01104"></a>01104         }
<a name="l01105"></a>01105 
<a name="l01107"></a><a class="code" href="a00280.html#6e63df7cb83e6c0f13f8c6290f79c51c">01107</a>         <span class="keywordtype">bool</span> <a class="code" href="a00280.html#6e63df7cb83e6c0f13f8c6290f79c51c" title="return true if coordinate is inside torus">inside</a> (<a class="code" href="a00280.html#4adc59dea7328099f636e7d978b877cb" title="type used to pass tupels in and out">iTupel</a> c)<span class="keyword"> const</span>
<a name="l01108"></a>01108 <span class="keyword">        </span>{
<a name="l01109"></a>01109           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=d-1; i&gt;=0; i--)
<a name="l01110"></a>01110                 <span class="keywordflow">if</span> (c[i]&lt;0 || c[i]&gt;=_dims[i]) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01111"></a>01111           <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01112"></a>01112         }
<a name="l01113"></a>01113 
<a name="l01115"></a><a class="code" href="a00280.html#cf0165d70e493bed9fdf958c7ccffe10">01115</a>         <a class="code" href="a00280.html#4adc59dea7328099f636e7d978b877cb" title="type used to pass tupels in and out">iTupel</a> <a class="code" href="a00280.html#cf0165d70e493bed9fdf958c7ccffe10" title="map rank to coordinate in torus using lexicographic ordering">rank_to_coord</a> (<span class="keywordtype">int</span> <a class="code" href="a00280.html#224f82289a447cbfecd50321ec3ba4aa" title="return own rank">rank</a>)<span class="keyword"> const</span>
<a name="l01116"></a>01116 <span class="keyword">        </span>{
<a name="l01117"></a>01117           <a class="code" href="a00280.html#4adc59dea7328099f636e7d978b877cb" title="type used to pass tupels in and out">iTupel</a> <a class="code" href="a00280.html#56bbc31a70b7b56e300ff1aaef61aef9" title="return own coordinates">coord</a>;
<a name="l01118"></a>01118           rank = rank%_procs;
<a name="l01119"></a>01119           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=d-1; i&gt;=0; i--)
<a name="l01120"></a>01120                 {
<a name="l01121"></a>01121                   coord[i] = rank/_increment[i];
<a name="l01122"></a>01122                   rank = rank%_increment[i];
<a name="l01123"></a>01123                 }
<a name="l01124"></a>01124           <span class="keywordflow">return</span> coord;
<a name="l01125"></a>01125         }
<a name="l01126"></a>01126 
<a name="l01128"></a><a class="code" href="a00280.html#c8a9ec295ad2e936e231b8dcec7485d7">01128</a>         <span class="keywordtype">int</span> <a class="code" href="a00280.html#c8a9ec295ad2e936e231b8dcec7485d7" title="map coordinate in torus to rank using lexicographic ordering">coord_to_rank</a> (<a class="code" href="a00280.html#4adc59dea7328099f636e7d978b877cb" title="type used to pass tupels in and out">iTupel</a> <a class="code" href="a00280.html#56bbc31a70b7b56e300ff1aaef61aef9" title="return own coordinates">coord</a>)<span class="keyword"> const</span>
<a name="l01129"></a>01129 <span class="keyword">        </span>{
<a name="l01130"></a>01130           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; i++) coord[i] = coord[i]%_dims[i];
<a name="l01131"></a>01131           <span class="keywordtype">int</span> <a class="code" href="a00280.html#224f82289a447cbfecd50321ec3ba4aa" title="return own rank">rank</a> = 0;
<a name="l01132"></a>01132           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; i++) rank += coord[i]*_increment[i];
<a name="l01133"></a>01133           <span class="keywordflow">return</span> rank;
<a name="l01134"></a>01134         }
<a name="l01135"></a>01135 
<a name="l01137"></a><a class="code" href="a00280.html#a3be7ce850eeaf2ce7d0b72a2af15634">01137</a>         <span class="keywordtype">int</span> <a class="code" href="a00280.html#a3be7ce850eeaf2ce7d0b72a2af15634" title="return rank of process where its coordinate in direction dir has offset cnt (handles...">rank_relative</a> (<span class="keywordtype">int</span> <a class="code" href="a00280.html#224f82289a447cbfecd50321ec3ba4aa" title="return own rank">rank</a>, <span class="keywordtype">int</span> dir, <span class="keywordtype">int</span> cnt)<span class="keyword"> const</span>
<a name="l01138"></a>01138 <span class="keyword">        </span>{
<a name="l01139"></a>01139           <a class="code" href="a00280.html#4adc59dea7328099f636e7d978b877cb" title="type used to pass tupels in and out">iTupel</a> <a class="code" href="a00280.html#56bbc31a70b7b56e300ff1aaef61aef9" title="return own coordinates">coord</a> = <a class="code" href="a00280.html#cf0165d70e493bed9fdf958c7ccffe10" title="map rank to coordinate in torus using lexicographic ordering">rank_to_coord</a>(rank);
<a name="l01140"></a>01140           coord[dir] = (coord[dir]+<a class="code" href="a00280.html#d644437a102c8187b065d21f79f20628" title="return dimensions of torus">dims</a>[dir]+cnt)%<a class="code" href="a00280.html#d644437a102c8187b065d21f79f20628" title="return dimensions of torus">dims</a>[dir];
<a name="l01141"></a>01141           <span class="keywordflow">return</span> <a class="code" href="a00280.html#c8a9ec295ad2e936e231b8dcec7485d7" title="map coordinate in torus to rank using lexicographic ordering">coord_to_rank</a>(coord);
<a name="l01142"></a>01142         }
<a name="l01143"></a>01143 
<a name="l01145"></a><a class="code" href="a00280.html#6cd4fd1543e11fd2c2a74f73655ca9c5">01145</a>         <span class="keywordtype">int</span> <a class="code" href="a00280.html#6cd4fd1543e11fd2c2a74f73655ca9c5" title="assign color to given coordinate">color</a> (<span class="keyword">const</span> <a class="code" href="a00280.html#4adc59dea7328099f636e7d978b877cb" title="type used to pass tupels in and out">iTupel</a> &amp; <a class="code" href="a00280.html#56bbc31a70b7b56e300ff1aaef61aef9" title="return own coordinates">coord</a>)<span class="keyword"> const</span>
<a name="l01146"></a>01146 <span class="keyword">        </span>{
<a name="l01147"></a>01147           <span class="keywordtype">int</span> c = 0;
<a name="l01148"></a>01148           <span class="keywordtype">int</span> power = 1;
<a name="l01149"></a>01149 
<a name="l01150"></a>01150           <span class="comment">// interior coloring</span>
<a name="l01151"></a>01151           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; i++)
<a name="l01152"></a>01152                 {
<a name="l01153"></a>01153                   <span class="keywordflow">if</span> (coord[i]%2==1) c += power;
<a name="l01154"></a>01154                   power *= 2;
<a name="l01155"></a>01155                 }
<a name="l01156"></a>01156 
<a name="l01157"></a>01157           <span class="comment">// extra colors for boundary processes</span>
<a name="l01158"></a>01158           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; i++)
<a name="l01159"></a>01159                 {
<a name="l01160"></a>01160                   <span class="keywordflow">if</span> (_dims[i]&gt;1 &amp;&amp; coord[i]==_dims[i]-1) c += power;
<a name="l01161"></a>01161                   power *= 2;
<a name="l01162"></a>01162                 }
<a name="l01163"></a>01163 
<a name="l01164"></a>01164           <span class="keywordflow">return</span> c;
<a name="l01165"></a>01165         }
<a name="l01166"></a>01166 
<a name="l01168"></a><a class="code" href="a00280.html#d85137f16639795f749712e2f06d5ce6">01168</a>         <span class="keywordtype">int</span> <a class="code" href="a00280.html#6cd4fd1543e11fd2c2a74f73655ca9c5" title="assign color to given coordinate">color</a> (<span class="keywordtype">int</span> <a class="code" href="a00280.html#224f82289a447cbfecd50321ec3ba4aa" title="return own rank">rank</a>)<span class="keyword"> const</span>
<a name="l01169"></a>01169 <span class="keyword">        </span>{
<a name="l01170"></a>01170           <span class="keywordflow">return</span> <a class="code" href="a00280.html#6cd4fd1543e11fd2c2a74f73655ca9c5" title="assign color to given coordinate">color</a>(<a class="code" href="a00280.html#cf0165d70e493bed9fdf958c7ccffe10" title="map rank to coordinate in torus using lexicographic ordering">rank_to_coord</a>(rank));
<a name="l01171"></a>01171         }
<a name="l01172"></a>01172 
<a name="l01174"></a><a class="code" href="a00280.html#0399cffe0a9566d1bb1f5107298fe5d3">01174</a>         <span class="keywordtype">int</span> <a class="code" href="a00280.html#0399cffe0a9566d1bb1f5107298fe5d3" title="return the number of neighbors, which is ">neighbors</a> ()<span class="keyword"> const</span>
<a name="l01175"></a>01175 <span class="keyword">        </span>{
<a name="l01176"></a>01176           <span class="keywordtype">int</span> n=1;
<a name="l01177"></a>01177           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i)
<a name="l01178"></a>01178                 n *= 3;
<a name="l01179"></a>01179           <span class="keywordflow">return</span> n-1;
<a name="l01180"></a>01180         }
<a name="l01181"></a>01181 
<a name="l01183"></a><a class="code" href="a00280.html#cb07dd5722671d93001a085c1baf5616">01183</a>         <span class="keywordtype">bool</span> <a class="code" href="a00280.html#cb07dd5722671d93001a085c1baf5616" title="return true if neighbor with given delta is a neighbor under the given periodicity...">is_neighbor</a> (<a class="code" href="a00280.html#4adc59dea7328099f636e7d978b877cb" title="type used to pass tupels in and out">iTupel</a> delta, bTupel periodic)<span class="keyword"> const</span>
<a name="l01184"></a>01184 <span class="keyword">        </span>{
<a name="l01185"></a>01185           <a class="code" href="a00280.html#4adc59dea7328099f636e7d978b877cb" title="type used to pass tupels in and out">iTupel</a> <a class="code" href="a00280.html#56bbc31a70b7b56e300ff1aaef61aef9" title="return own coordinates">coord</a> = <a class="code" href="a00280.html#cf0165d70e493bed9fdf958c7ccffe10" title="map rank to coordinate in torus using lexicographic ordering">rank_to_coord</a>(_rank); <span class="comment">// my own coordinate with 0 &lt;= c_i &lt; dims_i</span>
<a name="l01186"></a>01186 
<a name="l01187"></a>01187 
<a name="l01188"></a>01188           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; i++)
<a name="l01189"></a>01189                 {
<a name="l01190"></a>01190                   <span class="keywordflow">if</span> (delta[i]&lt;0)
<a name="l01191"></a>01191                         {
<a name="l01192"></a>01192                           <span class="comment">// if I am on the boundary and domain is not periodic =&gt; no neighbor</span>
<a name="l01193"></a>01193                           <span class="keywordflow">if</span> (coord[i]==0 &amp;&amp; periodic[i]==<span class="keyword">false</span>) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01194"></a>01194                         }
<a name="l01195"></a>01195                   <span class="keywordflow">if</span> (delta[i]&gt;0)
<a name="l01196"></a>01196                         {
<a name="l01197"></a>01197                           <span class="comment">// if I am on the boundary and domain is not periodic =&gt; no neighbor</span>
<a name="l01198"></a>01198                           <span class="keywordflow">if</span> (coord[i]==_dims[i]-1 &amp;&amp; periodic[i]==<span class="keyword">false</span>) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01199"></a>01199                         }
<a name="l01200"></a>01200                 }
<a name="l01201"></a>01201           <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01202"></a>01202         }
<a name="l01203"></a>01203 
<a name="l01205"></a><a class="code" href="a00280.html#2e5c7d96b422b75621651355b1dc4d5e">01205</a>         <span class="keywordtype">double</span> <a class="code" href="a00280.html#2e5c7d96b422b75621651355b1dc4d5e" title="partition the given grid onto the torus and return the piece of the process with...">partition</a> (<span class="keywordtype">int</span> <a class="code" href="a00280.html#224f82289a447cbfecd50321ec3ba4aa" title="return own rank">rank</a>, <a class="code" href="a00280.html#4adc59dea7328099f636e7d978b877cb" title="type used to pass tupels in and out">iTupel</a> origin_in, <a class="code" href="a00280.html#4adc59dea7328099f636e7d978b877cb" title="type used to pass tupels in and out">iTupel</a> size_in, <a class="code" href="a00280.html#4adc59dea7328099f636e7d978b877cb" title="type used to pass tupels in and out">iTupel</a>&amp; origin_out, <a class="code" href="a00280.html#4adc59dea7328099f636e7d978b877cb" title="type used to pass tupels in and out">iTupel</a>&amp; size_out)<span class="keyword"> const</span>
<a name="l01206"></a>01206 <span class="keyword">        </span>{
<a name="l01207"></a>01207           <a class="code" href="a00280.html#4adc59dea7328099f636e7d978b877cb" title="type used to pass tupels in and out">iTupel</a> <a class="code" href="a00280.html#56bbc31a70b7b56e300ff1aaef61aef9" title="return own coordinates">coord</a> = <a class="code" href="a00280.html#cf0165d70e493bed9fdf958c7ccffe10" title="map rank to coordinate in torus using lexicographic ordering">rank_to_coord</a>(rank);
<a name="l01208"></a>01208           <span class="keywordtype">double</span> maxsize = 1;
<a name="l01209"></a>01209           <span class="keywordtype">double</span> sz = 1;
<a name="l01210"></a>01210 
<a name="l01211"></a>01211           <span class="comment">// make a tensor product partition</span>
<a name="l01212"></a>01212           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; i++)
<a name="l01213"></a>01213                 {
<a name="l01214"></a>01214                   <span class="comment">// determine </span>
<a name="l01215"></a>01215                   <span class="keywordtype">int</span> m = size_in[i]/_dims[i];
<a name="l01216"></a>01216                   <span class="keywordtype">int</span> r = size_in[i]%_dims[i];
<a name="l01217"></a>01217 
<a name="l01218"></a>01218                   sz *= size_in[i];
<a name="l01219"></a>01219 
<a name="l01220"></a>01220                   <span class="keywordflow">if</span> (coord[i]&lt;_dims[i]-r)
<a name="l01221"></a>01221                         {
<a name="l01222"></a>01222                           origin_out[i] = origin_in[i] + coord[i]*m;
<a name="l01223"></a>01223                           size_out[i] = m;
<a name="l01224"></a>01224                           maxsize *= m;
<a name="l01225"></a>01225                         }
<a name="l01226"></a>01226                   <span class="keywordflow">else</span>
<a name="l01227"></a>01227                         {
<a name="l01228"></a>01228                           origin_out[i] = origin_in[i] + (_dims[i]-r)*m + (coord[i]-(_dims[i]-r))*(m+1);
<a name="l01229"></a>01229                           size_out[i] = m+1;
<a name="l01230"></a>01230                           maxsize *= m+1;
<a name="l01231"></a>01231                         }
<a name="l01232"></a>01232                 }
<a name="l01233"></a>01233           <span class="keywordflow">return</span> maxsize/(sz/_procs);
<a name="l01234"></a>01234         }
<a name="l01235"></a>01235 
<a name="l01242"></a><a class="code" href="a00281.html">01242</a>         <span class="keyword">class </span><a class="code" href="a00281.html">ProcListIterator</a> {
<a name="l01243"></a>01243         <span class="keyword">public</span>:
<a name="l01245"></a><a class="code" href="a00281.html#24da52dce556ee83772a3c0cf8c218c2">01245</a>           <a class="code" href="a00281.html#24da52dce556ee83772a3c0cf8c218c2" title="make an iterator">ProcListIterator</a> (<span class="keyword">typename</span> std::deque&lt;CommPartner&gt;::const_iterator iter)
<a name="l01246"></a>01246           {
<a name="l01247"></a>01247                 i = iter;
<a name="l01248"></a>01248           }
<a name="l01249"></a>01249 
<a name="l01251"></a><a class="code" href="a00281.html#4fc774ae99e5742198a4990ee4fee846">01251</a>           <span class="keywordtype">int</span> <a class="code" href="a00281.html#4fc774ae99e5742198a4990ee4fee846" title="return rank of neighboring process">rank</a> ()<span class="keyword"> const</span>
<a name="l01252"></a>01252 <span class="keyword">          </span>{
<a name="l01253"></a>01253                 <span class="keywordflow">return</span> i-&gt;rank;
<a name="l01254"></a>01254           }
<a name="l01255"></a>01255 
<a name="l01257"></a><a class="code" href="a00281.html#8ae6cfef7479c381d37ebce3accf3583">01257</a>           <a class="code" href="a00280.html#4adc59dea7328099f636e7d978b877cb" title="type used to pass tupels in and out">iTupel</a> <a class="code" href="a00281.html#8ae6cfef7479c381d37ebce3accf3583" title="return distance vector">delta</a> ()<span class="keyword"> const</span>
<a name="l01258"></a>01258 <span class="keyword">          </span>{
<a name="l01259"></a>01259                 <span class="keywordflow">return</span> i-&gt;delta;
<a name="l01260"></a>01260           }
<a name="l01261"></a>01261 
<a name="l01263"></a><a class="code" href="a00281.html#9dffad05f7e940b84a0f5cdc2895fe06">01263</a>           <span class="keywordtype">int</span> <a class="code" href="a00281.html#9dffad05f7e940b84a0f5cdc2895fe06" title="return index in proclist">index</a> ()<span class="keyword"> const</span>
<a name="l01264"></a>01264 <span class="keyword">          </span>{
<a name="l01265"></a>01265                 <span class="keywordflow">return</span> i-&gt;index;
<a name="l01266"></a>01266           }
<a name="l01267"></a>01267 
<a name="l01269"></a><a class="code" href="a00281.html#722696ba0588b5228410ccc23ead5e03">01269</a>           <span class="keywordtype">int</span> <a class="code" href="a00281.html#722696ba0588b5228410ccc23ead5e03" title="return 1-norm of distance vector">distance</a> ()<span class="keyword"> const</span>
<a name="l01270"></a>01270 <span class="keyword">          </span>{
<a name="l01271"></a>01271                 <span class="keywordtype">int</span> dist = 0;
<a name="l01272"></a>01272                 <a class="code" href="a00280.html#4adc59dea7328099f636e7d978b877cb" title="type used to pass tupels in and out">iTupel</a> <a class="code" href="a00281.html#8ae6cfef7479c381d37ebce3accf3583" title="return distance vector">delta</a>=i-&gt;delta;
<a name="l01273"></a>01273                 <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; ++i)
<a name="l01274"></a>01274                   dist += std::abs(delta[i]);
<a name="l01275"></a>01275                 <span class="keywordflow">return</span> dist;
<a name="l01276"></a>01276           }
<a name="l01277"></a>01277 
<a name="l01279"></a><a class="code" href="a00281.html#397e582b702714aed0a1eddc39347f5e">01279</a>           <span class="keywordtype">bool</span> <a class="code" href="a00281.html#397e582b702714aed0a1eddc39347f5e" title="Return true when two iterators point to same member.">operator== </a>(<span class="keyword">const</span> <a class="code" href="a00281.html">ProcListIterator</a>&amp; iter)
<a name="l01280"></a>01280           {
<a name="l01281"></a>01281                 <span class="keywordflow">return</span> i == iter.<a class="code" href="a00281.html#f138fb84a75b326d3531b2e2b5688333">i</a>;
<a name="l01282"></a>01282           }
<a name="l01283"></a>01283 
<a name="l01284"></a>01284 
<a name="l01286"></a><a class="code" href="a00281.html#997cfb0de76c83ac979b0e77d9e77540">01286</a>           <span class="keywordtype">bool</span> <a class="code" href="a00281.html#997cfb0de76c83ac979b0e77d9e77540" title="Return true when two iterators do not point to same member.">operator!= </a>(<span class="keyword">const</span> <a class="code" href="a00281.html">ProcListIterator</a>&amp; iter)
<a name="l01287"></a>01287           {
<a name="l01288"></a>01288                 <span class="keywordflow">return</span> i != iter.<a class="code" href="a00281.html#f138fb84a75b326d3531b2e2b5688333">i</a>;
<a name="l01289"></a>01289           }
<a name="l01290"></a>01290         
<a name="l01292"></a><a class="code" href="a00281.html#916d5a4024b3dc0d0f34ac70c0b25109">01292</a>           <a class="code" href="a00281.html">ProcListIterator</a>&amp; <a class="code" href="a00281.html#916d5a4024b3dc0d0f34ac70c0b25109" title="Increment iterator to next cell.">operator++ </a>()
<a name="l01293"></a>01293           {
<a name="l01294"></a>01294                 ++i;
<a name="l01295"></a>01295                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01296"></a>01296           }
<a name="l01297"></a>01297           
<a name="l01298"></a>01298         <span class="keyword">private</span>:
<a name="l01299"></a>01299           <span class="keyword">typename</span> std::deque&lt;CommPartner&gt;::const_iterator i;
<a name="l01300"></a>01300         };
<a name="l01301"></a>01301 
<a name="l01303"></a><a class="code" href="a00280.html#7d404bca911fe0c9ba1fc560629bef15">01303</a>         <a class="code" href="a00281.html">ProcListIterator</a> <a class="code" href="a00280.html#7d404bca911fe0c9ba1fc560629bef15" title="first process in send list">sendbegin</a> ()<span class="keyword"> const</span>
<a name="l01304"></a>01304 <span class="keyword">        </span>{
<a name="l01305"></a>01305           <span class="keywordflow">return</span> <a class="code" href="a00281.html">ProcListIterator</a>(_sendlist.begin());
<a name="l01306"></a>01306         }
<a name="l01307"></a>01307 
<a name="l01309"></a><a class="code" href="a00280.html#ec79ec4ff8519317e7118214c4422c9a">01309</a>         <a class="code" href="a00281.html">ProcListIterator</a> <a class="code" href="a00280.html#ec79ec4ff8519317e7118214c4422c9a" title="end of send list">sendend</a> ()<span class="keyword"> const</span>
<a name="l01310"></a>01310 <span class="keyword">        </span>{
<a name="l01311"></a>01311           <span class="keywordflow">return</span> <a class="code" href="a00281.html">ProcListIterator</a>(_sendlist.end());
<a name="l01312"></a>01312         }
<a name="l01313"></a>01313 
<a name="l01315"></a><a class="code" href="a00280.html#6385f2e5a12b55ddfa8dee6a44c0c82e">01315</a>         <a class="code" href="a00281.html">ProcListIterator</a> <a class="code" href="a00280.html#6385f2e5a12b55ddfa8dee6a44c0c82e" title="first process in receive list">recvbegin</a> ()<span class="keyword"> const</span>
<a name="l01316"></a>01316 <span class="keyword">        </span>{
<a name="l01317"></a>01317           <span class="keywordflow">return</span> <a class="code" href="a00281.html">ProcListIterator</a>(_recvlist.begin());
<a name="l01318"></a>01318         }
<a name="l01319"></a>01319 
<a name="l01321"></a><a class="code" href="a00280.html#3b2a93bef9ff4966d04347481254f953">01321</a>         <a class="code" href="a00281.html">ProcListIterator</a> <a class="code" href="a00280.html#3b2a93bef9ff4966d04347481254f953" title="last process in receive list">recvend</a> ()<span class="keyword"> const</span>
<a name="l01322"></a>01322 <span class="keyword">        </span>{
<a name="l01323"></a>01323           <span class="keywordflow">return</span> <a class="code" href="a00281.html">ProcListIterator</a>(_recvlist.end());
<a name="l01324"></a>01324         }
<a name="l01325"></a>01325 
<a name="l01327"></a><a class="code" href="a00280.html#db682dc170bda4114f3c8fe38b5a3916">01327</a>         <span class="keywordtype">void</span> <a class="code" href="a00280.html#db682dc170bda4114f3c8fe38b5a3916" title="store a send request; buffers are sent in order; handles also local requests with...">send</a> (<span class="keywordtype">int</span> <a class="code" href="a00280.html#224f82289a447cbfecd50321ec3ba4aa" title="return own rank">rank</a>, <span class="keywordtype">void</span>* buffer, <span class="keywordtype">int</span> size)<span class="keyword"> const</span>
<a name="l01328"></a>01328 <span class="keyword">        </span>{
<a name="l01329"></a>01329           CommTask task;
<a name="l01330"></a>01330           task.rank = rank;
<a name="l01331"></a>01331           task.buffer = buffer;
<a name="l01332"></a>01332           task.size = size;
<a name="l01333"></a>01333           <span class="keywordflow">if</span> (rank!=_rank)
<a name="l01334"></a>01334                 _sendrequests.push_back(task);
<a name="l01335"></a>01335           <span class="keywordflow">else</span>
<a name="l01336"></a>01336                 _localsendrequests.push_back(task);
<a name="l01337"></a>01337         }
<a name="l01338"></a>01338  
<a name="l01340"></a><a class="code" href="a00280.html#e38ba363998da139f724251a42a9ca27">01340</a>         <span class="keywordtype">void</span> <a class="code" href="a00280.html#e38ba363998da139f724251a42a9ca27" title="store a receive request; buffers are received in order; handles also local requests...">recv</a> (<span class="keywordtype">int</span> <a class="code" href="a00280.html#224f82289a447cbfecd50321ec3ba4aa" title="return own rank">rank</a>, <span class="keywordtype">void</span>* buffer, <span class="keywordtype">int</span> size)<span class="keyword"> const</span>
<a name="l01341"></a>01341 <span class="keyword">        </span>{
<a name="l01342"></a>01342           CommTask task;
<a name="l01343"></a>01343           task.rank = rank;
<a name="l01344"></a>01344           task.buffer = buffer;
<a name="l01345"></a>01345           task.size = size;
<a name="l01346"></a>01346           <span class="keywordflow">if</span> (rank!=_rank)
<a name="l01347"></a>01347                 _recvrequests.push_back(task);
<a name="l01348"></a>01348           <span class="keywordflow">else</span>
<a name="l01349"></a>01349                 _localrecvrequests.push_back(task);
<a name="l01350"></a>01350         }
<a name="l01351"></a>01351  
<a name="l01353"></a><a class="code" href="a00280.html#2eef6969946021638682c48aea181c75">01353</a>         <span class="keywordtype">void</span> <a class="code" href="a00280.html#2eef6969946021638682c48aea181c75" title="exchange messages stored in request buffers; clear request buffers afterwards">exchange</a> ()<span class="keyword"> const</span>
<a name="l01354"></a>01354 <span class="keyword">        </span>{
<a name="l01355"></a>01355           <span class="comment">// handle local requests first</span>
<a name="l01356"></a>01356           <span class="keywordflow">if</span> (_localsendrequests.size()!=_localrecvrequests.size())
<a name="l01357"></a>01357                 {
<a name="l01358"></a>01358                   std::cout &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; <a class="code" href="a00280.html#224f82289a447cbfecd50321ec3ba4aa" title="return own rank">rank</a>() &lt;&lt; <span class="stringliteral">"]: ERROR: local sends/receives do not match in exchange!"</span> &lt;&lt; std::endl;
<a name="l01359"></a>01359                   <span class="keywordflow">return</span>;
<a name="l01360"></a>01360                 }
<a name="l01361"></a>01361           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;_localsendrequests.size(); i++)
<a name="l01362"></a>01362                 {
<a name="l01363"></a>01363                   <span class="keywordflow">if</span> (_localsendrequests[i].size!=_localrecvrequests[i].size)
<a name="l01364"></a>01364                         {
<a name="l01365"></a>01365                           std::cout &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; <a class="code" href="a00280.html#224f82289a447cbfecd50321ec3ba4aa" title="return own rank">rank</a>() &lt;&lt; <span class="stringliteral">"]: ERROR: size in local sends/receive does not match in exchange!"</span> &lt;&lt; std::endl;
<a name="l01366"></a>01366                           <span class="keywordflow">return</span>;
<a name="l01367"></a>01367                         }
<a name="l01368"></a>01368                   memcpy(_localrecvrequests[i].buffer,_localsendrequests[i].buffer,_localsendrequests[i].size);
<a name="l01369"></a>01369                 }
<a name="l01370"></a>01370           _localsendrequests.clear();
<a name="l01371"></a>01371           _localrecvrequests.clear();
<a name="l01372"></a>01372 
<a name="l01373"></a>01373 <span class="preprocessor">#if HAVE_MPI</span>
<a name="l01374"></a>01374 <span class="preprocessor"></span>          <span class="comment">// handle foreign requests</span>
<a name="l01375"></a>01375           <span class="keywordtype">int</span> sends=0;
<a name="l01376"></a>01376           <span class="keywordtype">int</span> recvs=0;
<a name="l01377"></a>01377 
<a name="l01378"></a>01378           <span class="comment">// issue sends to foreign processes</span>
<a name="l01379"></a>01379           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;_sendrequests.size(); i++)
<a name="l01380"></a>01380                 <span class="keywordflow">if</span> (_sendrequests[i].<a class="code" href="a00280.html#224f82289a447cbfecd50321ec3ba4aa" title="return own rank">rank</a>!=<a class="code" href="a00280.html#224f82289a447cbfecd50321ec3ba4aa" title="return own rank">rank</a>())
<a name="l01381"></a>01381                   {
<a name="l01382"></a>01382 <span class="comment">//                      std::cout &lt;&lt; "[" &lt;&lt; rank() &lt;&lt; "]" &lt;&lt; " send " &lt;&lt; _sendrequests[i].size &lt;&lt; " bytes " </span>
<a name="l01383"></a>01383 <span class="comment">//                                        &lt;&lt; "to " &lt;&lt; _sendrequests[i].rank &lt;&lt; " p=" &lt;&lt; _sendrequests[i].buffer &lt;&lt; std::endl;</span>
<a name="l01384"></a>01384                         MPI_Isend(_sendrequests[i].buffer, _sendrequests[i].size, MPI_BYTE, 
<a name="l01385"></a>01385                                           _sendrequests[i].<a class="code" href="a00280.html#224f82289a447cbfecd50321ec3ba4aa" title="return own rank">rank</a>, _tag, _comm, &amp;(_sendrequests[i].request));
<a name="l01386"></a>01386                         _sendrequests[i].flag = <span class="keyword">false</span>;
<a name="l01387"></a>01387                         sends++;
<a name="l01388"></a>01388                   }
<a name="l01389"></a>01389 
<a name="l01390"></a>01390           <span class="comment">// issue receives from foreign processes</span>
<a name="l01391"></a>01391           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;_recvrequests.size(); i++)
<a name="l01392"></a>01392                 <span class="keywordflow">if</span> (_recvrequests[i].<a class="code" href="a00280.html#224f82289a447cbfecd50321ec3ba4aa" title="return own rank">rank</a>!=<a class="code" href="a00280.html#224f82289a447cbfecd50321ec3ba4aa" title="return own rank">rank</a>())
<a name="l01393"></a>01393                   {
<a name="l01394"></a>01394 <span class="comment">//                      std::cout &lt;&lt; "[" &lt;&lt; rank() &lt;&lt; "]"  &lt;&lt; " recv " &lt;&lt; _recvrequests[i].size &lt;&lt; " bytes " </span>
<a name="l01395"></a>01395 <span class="comment">//                                        &lt;&lt; "fm " &lt;&lt; _recvrequests[i].rank &lt;&lt; " p=" &lt;&lt; _recvrequests[i].buffer &lt;&lt; std::endl;</span>
<a name="l01396"></a>01396                         MPI_Irecv(_recvrequests[i].buffer, _recvrequests[i].size, MPI_BYTE, 
<a name="l01397"></a>01397                                           _recvrequests[i].<a class="code" href="a00280.html#224f82289a447cbfecd50321ec3ba4aa" title="return own rank">rank</a>, _tag, _comm, &amp;(_recvrequests[i].request));
<a name="l01398"></a>01398                         _recvrequests[i].flag = <span class="keyword">false</span>;
<a name="l01399"></a>01399                         recvs++;
<a name="l01400"></a>01400                   }
<a name="l01401"></a>01401 
<a name="l01402"></a>01402           <span class="comment">// poll sends</span>
<a name="l01403"></a>01403           <span class="keywordflow">while</span> (sends&gt;0)
<a name="l01404"></a>01404                 {
<a name="l01405"></a>01405                   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;_sendrequests.size(); i++)
<a name="l01406"></a>01406                         <span class="keywordflow">if</span> (!_sendrequests[i].flag)
<a name="l01407"></a>01407                           {
<a name="l01408"></a>01408                                 MPI_Status status;
<a name="l01409"></a>01409                                 MPI_Test( &amp;(_sendrequests[i].request), &amp;(_sendrequests[i].flag), &amp;status);
<a name="l01410"></a>01410                                 <span class="keywordflow">if</span> (_sendrequests[i].flag)
<a name="l01411"></a>01411                                   {
<a name="l01412"></a>01412                                         sends--;
<a name="l01413"></a>01413 <span class="comment">//                                      std::cout &lt;&lt; "[" &lt;&lt; rank() &lt;&lt; "]"  &lt;&lt; " send to " &lt;&lt; _sendrequests[i].rank &lt;&lt; " OK" &lt;&lt; std::endl;</span>
<a name="l01414"></a>01414                                   }
<a name="l01415"></a>01415                           }
<a name="l01416"></a>01416                 }
<a name="l01417"></a>01417 
<a name="l01418"></a>01418           <span class="comment">// poll receives</span>
<a name="l01419"></a>01419           <span class="keywordflow">while</span> (recvs&gt;0)
<a name="l01420"></a>01420                 {
<a name="l01421"></a>01421                   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;_recvrequests.size(); i++)
<a name="l01422"></a>01422                         <span class="keywordflow">if</span> (!_recvrequests[i].flag)
<a name="l01423"></a>01423                           {
<a name="l01424"></a>01424                                 MPI_Status status;
<a name="l01425"></a>01425                                 MPI_Test( &amp;(_recvrequests[i].request), &amp;(_recvrequests[i].flag), &amp;status);
<a name="l01426"></a>01426                                 <span class="keywordflow">if</span> (_recvrequests[i].flag)
<a name="l01427"></a>01427                                   {
<a name="l01428"></a>01428                                         recvs--;
<a name="l01429"></a>01429 <span class="comment">//                                      std::cout &lt;&lt; "[" &lt;&lt; rank() &lt;&lt; "]"  &lt;&lt; " recv fm " &lt;&lt; _recvrequests[i].rank &lt;&lt; " OK" &lt;&lt; std::endl;</span>
<a name="l01430"></a>01430                                   }
<a name="l01431"></a>01431 
<a name="l01432"></a>01432                           }
<a name="l01433"></a>01433                 }
<a name="l01434"></a>01434 
<a name="l01435"></a>01435           <span class="comment">// clear request buffers</span>
<a name="l01436"></a>01436           _sendrequests.clear();
<a name="l01437"></a>01437           _recvrequests.clear();
<a name="l01438"></a>01438 <span class="preprocessor">#endif</span>
<a name="l01439"></a>01439 <span class="preprocessor"></span>        }
<a name="l01440"></a>01440 
<a name="l01442"></a><a class="code" href="a00280.html#03cdbfe218a4af238b0725df2377f436">01442</a>         <span class="keywordtype">double</span> <a class="code" href="a00280.html#03cdbfe218a4af238b0725df2377f436" title="global sum">global_sum</a> (<span class="keywordtype">double</span> x)<span class="keyword"> const</span>
<a name="l01443"></a>01443 <span class="keyword">        </span>{
<a name="l01444"></a>01444           <span class="keywordtype">double</span> res;
<a name="l01445"></a>01445         
<a name="l01446"></a>01446           <span class="keywordflow">if</span> (_procs==1) <span class="keywordflow">return</span> x;
<a name="l01447"></a>01447 <span class="preprocessor">#if HAVE_MPI</span>
<a name="l01448"></a>01448 <span class="preprocessor"></span>          MPI_Allreduce(&amp;x,&amp;res,1,MPI_DOUBLE,MPI_SUM,_comm);
<a name="l01449"></a>01449           <span class="keywordflow">return</span> res;
<a name="l01450"></a>01450 <span class="preprocessor">#endif</span>
<a name="l01451"></a>01451 <span class="preprocessor"></span>        }
<a name="l01452"></a>01452 
<a name="l01454"></a><a class="code" href="a00280.html#3ee731083ecb93b5cae74b51e7147d43">01454</a>         <span class="keywordtype">double</span> <a class="code" href="a00280.html#3ee731083ecb93b5cae74b51e7147d43" title="global max">global_max</a> (<span class="keywordtype">double</span> x)<span class="keyword"> const</span>
<a name="l01455"></a>01455 <span class="keyword">        </span>{
<a name="l01456"></a>01456           <span class="keywordtype">double</span> res;
<a name="l01457"></a>01457         
<a name="l01458"></a>01458           <span class="keywordflow">if</span> (_procs==1) <span class="keywordflow">return</span> x;
<a name="l01459"></a>01459 <span class="preprocessor">#if HAVE_MPI</span>
<a name="l01460"></a>01460 <span class="preprocessor"></span>          MPI_Allreduce(&amp;x,&amp;res,1,MPI_DOUBLE,MPI_MAX,_comm);
<a name="l01461"></a>01461           <span class="keywordflow">return</span> res;
<a name="l01462"></a>01462 <span class="preprocessor">#endif</span>
<a name="l01463"></a>01463 <span class="preprocessor"></span>        }
<a name="l01464"></a>01464 
<a name="l01466"></a><a class="code" href="a00280.html#eb2eb1da805711556ccf775d7428b63c">01466</a>         <span class="keywordtype">double</span> <a class="code" href="a00280.html#eb2eb1da805711556ccf775d7428b63c" title="global min">global_min</a> (<span class="keywordtype">double</span> x)<span class="keyword"> const</span>
<a name="l01467"></a>01467 <span class="keyword">        </span>{
<a name="l01468"></a>01468           <span class="keywordtype">double</span> res;
<a name="l01469"></a>01469         
<a name="l01470"></a>01470           <span class="keywordflow">if</span> (_procs==1) <span class="keywordflow">return</span> x;
<a name="l01471"></a>01471 <span class="preprocessor">#if HAVE_MPI</span>
<a name="l01472"></a>01472 <span class="preprocessor"></span>          MPI_Allreduce(&amp;x,&amp;res,1,MPI_DOUBLE,MPI_MIN,_comm);
<a name="l01473"></a>01473           <span class="keywordflow">return</span> res;
<a name="l01474"></a>01474 <span class="preprocessor">#endif</span>
<a name="l01475"></a>01475 <span class="preprocessor"></span>        }
<a name="l01476"></a>01476 
<a name="l01477"></a>01477  
<a name="l01479"></a><a class="code" href="a00280.html#e7e3838eb93140ceeeeb568473adc907">01479</a>         <span class="keywordtype">void</span> <a class="code" href="a00280.html#e7e3838eb93140ceeeeb568473adc907" title="print contents of torus object">print</a> (std::ostream&amp; s)<span class="keyword"> const</span>
<a name="l01480"></a>01480 <span class="keyword">        </span>{
<a name="l01481"></a>01481           s &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; <a class="code" href="a00280.html#224f82289a447cbfecd50321ec3ba4aa" title="return own rank">rank</a>() &lt;&lt;  <span class="stringliteral">"]: Torus "</span> &lt;&lt; <a class="code" href="a00280.html#cc1be56fea6bb33bc2594c86e20f3624" title="return number of processes">procs</a>() &lt;&lt; <span class="stringliteral">" processor(s) arranged as "</span> &lt;&lt; <a class="code" href="a00280.html#d644437a102c8187b065d21f79f20628" title="return dimensions of torus">dims</a>() &lt;&lt; std::endl;
<a name="l01482"></a>01482           <span class="keywordflow">for</span> (<a class="code" href="a00281.html">ProcListIterator</a> i=<a class="code" href="a00280.html#7d404bca911fe0c9ba1fc560629bef15" title="first process in send list">sendbegin</a>(); i!=<a class="code" href="a00280.html#ec79ec4ff8519317e7118214c4422c9a" title="end of send list">sendend</a>(); ++i)
<a name="l01483"></a>01483                 {
<a name="l01484"></a>01484                   s &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; <a class="code" href="a00280.html#224f82289a447cbfecd50321ec3ba4aa" title="return own rank">rank</a>() &lt;&lt;  <span class="stringliteral">"]: send to   "</span> 
<a name="l01485"></a>01485                         &lt;&lt; <span class="stringliteral">"rank="</span> &lt;&lt; i.rank() 
<a name="l01486"></a>01486                         &lt;&lt; <span class="stringliteral">" index="</span> &lt;&lt; i.index() 
<a name="l01487"></a>01487                         &lt;&lt; <span class="stringliteral">" delta="</span> &lt;&lt; i.delta() &lt;&lt; <span class="stringliteral">" dist="</span> &lt;&lt; i.distance() &lt;&lt; std::endl;
<a name="l01488"></a>01488                 }
<a name="l01489"></a>01489           <span class="keywordflow">for</span> (<a class="code" href="a00281.html">ProcListIterator</a> i=<a class="code" href="a00280.html#6385f2e5a12b55ddfa8dee6a44c0c82e" title="first process in receive list">recvbegin</a>(); i!=<a class="code" href="a00280.html#3b2a93bef9ff4966d04347481254f953" title="last process in receive list">recvend</a>(); ++i)
<a name="l01490"></a>01490                 {
<a name="l01491"></a>01491                   s &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; <a class="code" href="a00280.html#224f82289a447cbfecd50321ec3ba4aa" title="return own rank">rank</a>() &lt;&lt;  <span class="stringliteral">"]: recv from "</span> 
<a name="l01492"></a>01492                         &lt;&lt; <span class="stringliteral">"rank="</span> &lt;&lt; i.rank() 
<a name="l01493"></a>01493                         &lt;&lt; <span class="stringliteral">" index="</span> &lt;&lt; i.index() 
<a name="l01494"></a>01494                         &lt;&lt; <span class="stringliteral">" delta="</span> &lt;&lt; i.delta() &lt;&lt; <span class="stringliteral">" dist="</span> &lt;&lt; i.distance() &lt;&lt; std::endl;
<a name="l01495"></a>01495                 }
<a name="l01496"></a>01496         }
<a name="l01497"></a>01497 
<a name="l01498"></a>01498   <span class="keyword">private</span>:
<a name="l01499"></a>01499 
<a name="l01500"></a>01500         <span class="keywordtype">void</span> optimize_dims (<span class="keywordtype">int</span> i, <a class="code" href="a00280.html#4adc59dea7328099f636e7d978b877cb" title="type used to pass tupels in and out">iTupel</a>&amp; size, <span class="keywordtype">int</span> P, <a class="code" href="a00280.html#4adc59dea7328099f636e7d978b877cb" title="type used to pass tupels in and out">iTupel</a>&amp; <a class="code" href="a00280.html#d644437a102c8187b065d21f79f20628" title="return dimensions of torus">dims</a>, <span class="keywordtype">double</span> &amp;opt )
<a name="l01501"></a>01501         {
<a name="l01502"></a>01502           <span class="keywordflow">if</span> (i&gt;0) <span class="comment">// test all subdivisions recursively</span>
<a name="l01503"></a>01503                 {
<a name="l01504"></a>01504                   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=1; k&lt;=P; k++)
<a name="l01505"></a>01505                         <span class="keywordflow">if</span> (P%k==0)
<a name="l01506"></a>01506                           {
<a name="l01507"></a>01507                                 <span class="comment">// P divisible by k</span>
<a name="l01508"></a>01508                                 dims[i] = k;
<a name="l01509"></a>01509                                 optimize_dims(i-1,size,P/k,dims,opt);
<a name="l01510"></a>01510                           }
<a name="l01511"></a>01511                 }
<a name="l01512"></a>01512           <span class="keywordflow">else</span>
<a name="l01513"></a>01513                 {
<a name="l01514"></a>01514                   <span class="comment">// found a possible combination</span>
<a name="l01515"></a>01515                   dims[0] = P;
<a name="l01516"></a>01516                   
<a name="l01517"></a>01517                   <span class="comment">// check for optimality</span>
<a name="l01518"></a>01518                   <span class="keywordtype">double</span> m = -1.0;
<a name="l01519"></a>01519 
<a name="l01520"></a>01520                   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;d; k++)
<a name="l01521"></a>01521                         {
<a name="l01522"></a>01522                       <span class="keywordtype">double</span> mm=((double)size[k])/((double)dims[k]);
<a name="l01523"></a>01523                       <span class="keywordflow">if</span> (fmod((<span class="keywordtype">double</span>)size[k],(double)dims[k])&gt;0.0001) mm*=3;
<a name="l01524"></a>01524                       <span class="keywordflow">if</span> ( mm &gt; m ) m = mm;
<a name="l01525"></a>01525                         }
<a name="l01526"></a>01526                   <span class="comment">//              if (_rank==0) std::cout &lt;&lt; "optimize_dims: " &lt;&lt; size &lt;&lt; " | " &lt;&lt; dims &lt;&lt; " norm=" &lt;&lt; m &lt;&lt; std::endl;  </span>
<a name="l01527"></a>01527                   <span class="keywordflow">if</span> (m&lt;opt) 
<a name="l01528"></a>01528                         {
<a name="l01529"></a>01529                           opt = m;
<a name="l01530"></a>01530                           _dims = dims;
<a name="l01531"></a>01531                         }
<a name="l01532"></a>01532                 }
<a name="l01533"></a>01533         }
<a name="l01534"></a>01534 
<a name="l01535"></a>01535         <span class="keywordtype">void</span> proclists ()
<a name="l01536"></a>01536         {
<a name="l01537"></a>01537           <span class="comment">// compile the full neighbor list</span>
<a name="l01538"></a>01538           CommPartner cp;
<a name="l01539"></a>01539           <a class="code" href="a00280.html#4adc59dea7328099f636e7d978b877cb" title="type used to pass tupels in and out">iTupel</a> delta;
<a name="l01540"></a>01540 
<a name="l01541"></a>01541           delta = -1;
<a name="l01542"></a>01542           <span class="keywordtype">bool</span> ready = <span class="keyword">false</span>;
<a name="l01543"></a>01543           <a class="code" href="a00280.html#4adc59dea7328099f636e7d978b877cb" title="type used to pass tupels in and out">iTupel</a> me, nb;
<a name="l01544"></a>01544           me = <a class="code" href="a00280.html#cf0165d70e493bed9fdf958c7ccffe10" title="map rank to coordinate in torus using lexicographic ordering">rank_to_coord</a>(_rank);
<a name="l01545"></a>01545           <span class="keywordtype">int</span> index = 0;
<a name="l01546"></a>01546           <span class="keywordtype">int</span> last = <a class="code" href="a00280.html#0399cffe0a9566d1bb1f5107298fe5d3" title="return the number of neighbors, which is ">neighbors</a>()-1;
<a name="l01547"></a>01547           <span class="keywordflow">while</span> (!ready)
<a name="l01548"></a>01548                 {
<a name="l01549"></a>01549                   <span class="comment">// find neighbors coordinates</span>
<a name="l01550"></a>01550                   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; i++)
<a name="l01551"></a>01551                         nb[i] = ( me[i]+_dims[i]+delta[i] ) % _dims[i];
<a name="l01552"></a>01552 
<a name="l01553"></a>01553                   <span class="comment">// find neighbors rank</span>
<a name="l01554"></a>01554                   <span class="keywordtype">int</span> nbrank = <a class="code" href="a00280.html#c8a9ec295ad2e936e231b8dcec7485d7" title="map coordinate in torus to rank using lexicographic ordering">coord_to_rank</a>(nb);
<a name="l01555"></a>01555                   
<a name="l01556"></a>01556                   <span class="comment">// check if delta is not zero</span>
<a name="l01557"></a>01557                   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; i++)
<a name="l01558"></a>01558                         <span class="keywordflow">if</span> (delta[i]!=0) 
<a name="l01559"></a>01559                           {
<a name="l01560"></a>01560                                 cp.rank = nbrank;
<a name="l01561"></a>01561                                 cp.delta = delta;
<a name="l01562"></a>01562                                 cp.index = index;
<a name="l01563"></a>01563                                 _recvlist.push_back(cp);
<a name="l01564"></a>01564                                 cp.index = last-index;
<a name="l01565"></a>01565                                 _sendlist.push_front(cp);
<a name="l01566"></a>01566                                 index++;
<a name="l01567"></a>01567                                 <span class="keywordflow">break</span>;
<a name="l01568"></a>01568                           }
<a name="l01569"></a>01569 
<a name="l01570"></a>01570                   <span class="comment">// next neighbor</span>
<a name="l01571"></a>01571                   ready = <span class="keyword">true</span>;
<a name="l01572"></a>01572                   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; i++)
<a name="l01573"></a>01573                         <span class="keywordflow">if</span> (delta[i]&lt;1)
<a name="l01574"></a>01574                           {
<a name="l01575"></a>01575                                 (delta[i])++;
<a name="l01576"></a>01576                                 ready=<span class="keyword">false</span>;
<a name="l01577"></a>01577                                 <span class="keywordflow">break</span>;
<a name="l01578"></a>01578                           }
<a name="l01579"></a>01579                         <span class="keywordflow">else</span>
<a name="l01580"></a>01580                           {
<a name="l01581"></a>01581                                 delta[i] = -1;
<a name="l01582"></a>01582                           }
<a name="l01583"></a>01583                 }
<a name="l01584"></a>01584 
<a name="l01585"></a>01585         }
<a name="l01586"></a>01586 
<a name="l01587"></a>01587 <span class="preprocessor">#if HAVE_MPI</span>
<a name="l01588"></a>01588 <span class="preprocessor"></span>        MPI_Comm _comm;
<a name="l01589"></a>01589 <span class="preprocessor">#endif</span>
<a name="l01590"></a>01590 <span class="preprocessor"></span>        <span class="keywordtype">int</span> _rank;
<a name="l01591"></a>01591         <span class="keywordtype">int</span> _procs;
<a name="l01592"></a>01592         <a class="code" href="a00280.html#4adc59dea7328099f636e7d978b877cb" title="type used to pass tupels in and out">iTupel</a> _dims;
<a name="l01593"></a>01593         <a class="code" href="a00280.html#4adc59dea7328099f636e7d978b877cb" title="type used to pass tupels in and out">iTupel</a> _increment;
<a name="l01594"></a>01594         <span class="keywordtype">int</span> _tag;
<a name="l01595"></a>01595         std::deque&lt;CommPartner&gt; _sendlist;
<a name="l01596"></a>01596         std::deque&lt;CommPartner&gt; _recvlist;
<a name="l01597"></a>01597  
<a name="l01598"></a>01598         <span class="keyword">mutable</span> std::vector&lt;CommTask&gt; _sendrequests;
<a name="l01599"></a>01599         <span class="keyword">mutable</span> std::vector&lt;CommTask&gt; _recvrequests;
<a name="l01600"></a>01600         <span class="keyword">mutable</span> std::vector&lt;CommTask&gt; _localsendrequests;
<a name="l01601"></a>01601         <span class="keyword">mutable</span> std::vector&lt;CommTask&gt; _localrecvrequests;
<a name="l01602"></a>01602   };
<a name="l01603"></a>01603 
<a name="l01605"></a>01605   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> d&gt;
<a name="l01606"></a><a class="code" href="a00441.html#a780c9d679729ac736ec2151398ddda0">01606</a>   <span class="keyword">inline</span> std::ostream&amp; operator&lt;&lt; (std::ostream&amp; s, const Torus&lt;d&gt; &amp; t)
<a name="l01607"></a>01607   {
<a name="l01608"></a>01608         t.print(s);
<a name="l01609"></a>01609         <span class="keywordflow">return</span> s;
<a name="l01610"></a>01610   }
<a name="l01611"></a>01611 
<a name="l01612"></a>01612 
<a name="l01615"></a>01615   <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> d, <span class="keyword">typename</span> ct&gt;
<a name="l01616"></a><a class="code" href="a00219.html">01616</a>   <span class="keyword">class </span><a class="code" href="a00219.html">MultiYGrid</a> {
<a name="l01617"></a>01617   <span class="keyword">public</span>:
<a name="l01618"></a>01618         <span class="comment">// some data types</span>
<a name="l01619"></a>01619         <span class="keyword">struct </span>Intersection {
<a name="l01620"></a>01620           <a class="code" href="a00277.html">SubYGrid&lt;d,ct&gt;</a> grid; <span class="comment">// the intersection as a subgrid of local grid</span>
<a name="l01621"></a>01621           <span class="keywordtype">int</span> rank;            <span class="comment">// rank of process where other grid is stored</span>
<a name="l01622"></a>01622           <span class="keywordtype">int</span> distance;        <span class="comment">// manhattan distance to other grid</span>
<a name="l01623"></a>01623         };
<a name="l01624"></a>01624         
<a name="l01625"></a>01625         <span class="keyword">struct </span>YGridLevel {        <span class="comment">// This stores all the information on one grid level </span>
<a name="l01626"></a>01626           <span class="comment">// cell (codim 0) data</span>
<a name="l01627"></a>01627           <a class="code" href="a00308.html">YGrid&lt;d,ct&gt;</a> cell_global;         <span class="comment">// the whole cell grid on that level</span>
<a name="l01628"></a>01628           <a class="code" href="a00277.html">SubYGrid&lt;d,ct&gt;</a> cell_overlap;     <span class="comment">// we have no ghost cells, so our part is overlap completely</span>
<a name="l01629"></a>01629           <a class="code" href="a00277.html">SubYGrid&lt;d,ct&gt;</a> cell_interior;    <span class="comment">// interior cells are a subgrid of all cells</span>
<a name="l01630"></a>01630           
<a name="l01631"></a>01631           std::deque&lt;Intersection&gt; send_cell_overlap_overlap;  <span class="comment">// each intersection is a subgrid of overlap</span>
<a name="l01632"></a>01632           std::deque&lt;Intersection&gt; recv_cell_overlap_overlap;  <span class="comment">// each intersection is a subgrid of overlap</span>
<a name="l01633"></a>01633           
<a name="l01634"></a>01634       std::deque&lt;Intersection&gt; send_cell_interior_overlap; <span class="comment">// each intersection is a subgrid of overlap</span>
<a name="l01635"></a>01635       std::deque&lt;Intersection&gt; recv_cell_overlap_interior; <span class="comment">// each intersection is a subgrid of overlap</span>
<a name="l01636"></a>01636           
<a name="l01637"></a>01637           <span class="comment">// vertex (codim dim) data</span>
<a name="l01638"></a>01638       <a class="code" href="a00308.html">YGrid&lt;d,ct&gt;</a> vertex_global;           <span class="comment">// the whole vertex grid on that level</span>
<a name="l01639"></a>01639       <a class="code" href="a00277.html">SubYGrid&lt;d,ct&gt;</a> vertex_overlapfront;  <span class="comment">// all our vertices are overlap and front</span>
<a name="l01640"></a>01640       <a class="code" href="a00277.html">SubYGrid&lt;d,ct&gt;</a> vertex_overlap;       <span class="comment">// subgrid containing only overlap</span>
<a name="l01641"></a>01641       <a class="code" href="a00277.html">SubYGrid&lt;d,ct&gt;</a> vertex_interiorborder;<span class="comment">// subgrid containing only interior and border</span>
<a name="l01642"></a>01642       <a class="code" href="a00277.html">SubYGrid&lt;d,ct&gt;</a> vertex_interior;      <span class="comment">// subgrid containing only interior</span>
<a name="l01643"></a>01643 
<a name="l01644"></a>01644       std::deque&lt;Intersection&gt; send_vertex_overlapfront_overlapfront; <span class="comment">// each intersection is a subgrid of overlapfront</span>
<a name="l01645"></a>01645       std::deque&lt;Intersection&gt; recv_vertex_overlapfront_overlapfront; <span class="comment">// each intersection is a subgrid of overlapfront</span>
<a name="l01646"></a>01646 
<a name="l01647"></a>01647       std::deque&lt;Intersection&gt; send_vertex_overlap_overlapfront; <span class="comment">// each intersection is a subgrid of overlapfront</span>
<a name="l01648"></a>01648       std::deque&lt;Intersection&gt; recv_vertex_overlapfront_overlap; <span class="comment">// each intersection is a subgrid of overlapfront</span>
<a name="l01649"></a>01649 
<a name="l01650"></a>01650           std::deque&lt;Intersection&gt; send_vertex_interiorborder_interiorborder; <span class="comment">// each intersection is a subgrid of overlapfront</span>
<a name="l01651"></a>01651           std::deque&lt;Intersection&gt; recv_vertex_interiorborder_interiorborder; <span class="comment">// each intersection is a subgrid of overlapfront</span>
<a name="l01652"></a>01652         
<a name="l01653"></a>01653           std::deque&lt;Intersection&gt; send_vertex_interiorborder_overlapfront; <span class="comment">// each intersection is a subgrid of overlapfront</span>
<a name="l01654"></a>01654           std::deque&lt;Intersection&gt; recv_vertex_overlapfront_interiorborder; <span class="comment">// each intersection is a subgrid of overlapfront</span>
<a name="l01655"></a>01655         
<a name="l01656"></a>01656           <span class="comment">// general</span>
<a name="l01657"></a>01657       <a class="code" href="a00219.html">MultiYGrid&lt;d,ct&gt;</a>* mg;  <span class="comment">// each grid level knows its multigrid</span>
<a name="l01658"></a>01658       <span class="keywordtype">int</span> overlap;           <span class="comment">// in mesh cells on this level</span>
<a name="l01659"></a>01659     };
<a name="l01660"></a>01660 
<a name="l01662"></a><a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39">01662</a>         <span class="keyword">typedef</span> FieldVector&lt;int, d&gt; <a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a>;
<a name="l01663"></a>01663         <span class="keyword">typedef</span> FieldVector&lt;ct, d&gt; fTupel;
<a name="l01664"></a>01664         <span class="keyword">typedef</span> FieldVector&lt;bool, d&gt; bTupel;
<a name="l01665"></a>01665 
<a name="l01666"></a>01666         <span class="comment">// communication tag used by multigrid</span>
<a name="l01667"></a>01667         <span class="keyword">enum</span> { tag = 17 };
<a name="l01668"></a>01668 
<a name="l01670"></a>01670 <span class="preprocessor">#if HAVE_MPI</span>
<a name="l01671"></a><a class="code" href="a00219.html#6e21049eb39a51592d791dd9493187fc">01671</a> <span class="preprocessor"></span>        <a class="code" href="a00219.html#6e21049eb39a51592d791dd9493187fc" title="constructor making a grid">MultiYGrid</a> (MPI_Comm comm, fTupel L, <a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a> s, bTupel <a class="code" href="a00219.html#f4711def27d3e2c69a9b2dee4d664d85" title="return true if grid is periodic in given direction">periodic</a>, <span class="keywordtype">int</span> overlap) 
<a name="l01672"></a>01672           : _torus(comm,tag,s) <span class="comment">// torus gets s to compute procs/direction</span>
<a name="l01673"></a>01673         {
<a name="l01674"></a>01674           <span class="comment">// store parameters</span>
<a name="l01675"></a>01675           _LL = L;
<a name="l01676"></a>01676           _s = s;
<a name="l01677"></a>01677           _periodic = periodic;
<a name="l01678"></a>01678           _overlap = overlap;
<a name="l01679"></a>01679 
<a name="l01680"></a>01680           <span class="comment">// coarse cell interior  grid obtained through partitioning of global grid</span>
<a name="l01681"></a>01681           <a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a> o_interior;
<a name="l01682"></a>01682           <a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a> s_interior;
<a name="l01683"></a>01683           <a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a> o = <a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a>(0);
<a name="l01684"></a>01684           <span class="keywordtype">double</span> imbal = _torus.partition(_torus.rank(),o,s,o_interior,s_interior);
<a name="l01685"></a>01685           imbal = _torus.global_max(imbal);
<a name="l01686"></a>01686 
<a name="l01687"></a>01687           <span class="comment">// add level</span>
<a name="l01688"></a>01688           _maxlevel = 0;
<a name="l01689"></a>01689           _levels[_maxlevel] = makelevel(L,s,periodic,o_interior,s_interior,overlap);
<a name="l01690"></a>01690 
<a name="l01691"></a>01691           <span class="comment">// output</span>
<a name="l01692"></a>01692 <span class="comment">//        if (_torus.rank()==0) std::cout &lt;&lt; "MultiYGrid&lt;" &lt;&lt; d // changed dinfo to cout</span>
<a name="l01693"></a>01693 <span class="comment">//                                                                        &lt;&lt; "&gt;: coarse grid with size " &lt;&lt; s </span>
<a name="l01694"></a>01694 <span class="comment">//                                                                        &lt;&lt; " imbalance=" &lt;&lt; (imbal-1)*100 &lt;&lt; "%" &lt;&lt; std::endl;</span>
<a name="l01695"></a>01695           <span class="comment">//      print(std::cout);</span>
<a name="l01696"></a>01696         }
<a name="l01697"></a>01697 <span class="preprocessor">#else</span>
<a name="l01698"></a>01698 <span class="preprocessor"></span>        <a class="code" href="a00219.html#6e21049eb39a51592d791dd9493187fc" title="constructor making a grid">MultiYGrid</a> (fTupel L, <a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a> s, bTupel <a class="code" href="a00219.html#f4711def27d3e2c69a9b2dee4d664d85" title="return true if grid is periodic in given direction">periodic</a>, <span class="keywordtype">int</span> overlap) 
<a name="l01699"></a>01699           : _torus(tag,s) <span class="comment">// torus gets s to compute procs/direction</span>
<a name="l01700"></a>01700         {
<a name="l01701"></a>01701           <span class="comment">// store parameters</span>
<a name="l01702"></a>01702           _LL = L;
<a name="l01703"></a>01703           _s = s;
<a name="l01704"></a>01704           _periodic = periodic;
<a name="l01705"></a>01705           _overlap = overlap;
<a name="l01706"></a>01706 
<a name="l01707"></a>01707           <span class="comment">// coarse cell interior  grid obtained through partitioning of global grid</span>
<a name="l01708"></a>01708           <a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a> o = <a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a>(0);
<a name="l01709"></a>01709           <a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a> o_interior(o);
<a name="l01710"></a>01710           <a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a> s_interior(s);
<a name="l01711"></a>01711 
<a name="l01712"></a>01712           <span class="comment">// add level</span>
<a name="l01713"></a>01713           _maxlevel = 0;
<a name="l01714"></a>01714           _levels[_maxlevel] = makelevel(L,s,periodic,o_interior,s_interior,overlap);
<a name="l01715"></a>01715           <span class="comment">// output</span>
<a name="l01716"></a>01716 <span class="comment">//        if (_torus.rank()==0) std::cout &lt;&lt; "MultiYGrid&lt;" &lt;&lt; d // changed dinfo to cout</span>
<a name="l01717"></a>01717 <span class="comment">//                                                                        &lt;&lt; "&gt;: coarse grid with size " &lt;&lt; s </span>
<a name="l01718"></a>01718 <span class="comment">//                                                                        &lt;&lt; " imbalance=" &lt;&lt; (imbal-1)*100 &lt;&lt; "%" &lt;&lt; std::endl;</span>
<a name="l01719"></a>01719           <span class="comment">//      print(std::cout);</span>
<a name="l01720"></a>01720         }
<a name="l01721"></a>01721 <span class="preprocessor">#endif</span>
<a name="l01722"></a>01722 <span class="preprocessor"></span>
<a name="l01724"></a><a class="code" href="a00219.html#8f667eb419774e1631a69a9dcea3fd09">01724</a>         <span class="keywordtype">void</span> <a class="code" href="a00219.html#8f667eb419774e1631a69a9dcea3fd09" title="do a global mesh refinement; true: keep overlap in absolute size; false: keep overlap...">refine</a> (<span class="keywordtype">bool</span> keep_overlap)
<a name="l01725"></a>01725         {
<a name="l01726"></a>01726           <span class="comment">// access to coarser grid level</span>
<a name="l01727"></a>01727           YGridLevel&amp; cg = _levels[<a class="code" href="a00219.html#4e9ad37b1c10491f083c9a5599dc31ce" title="return the maximum level index (number of levels is maxlevel()+1)">maxlevel</a>()];
<a name="l01728"></a>01728 
<a name="l01729"></a>01729           <span class="comment">// compute size of new global grid</span>
<a name="l01730"></a>01730           <a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a> s;
<a name="l01731"></a>01731           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; i++) s[i] = 2*cg.cell_global.size(i);
<a name="l01732"></a>01732 
<a name="l01733"></a>01733           <span class="comment">// compute overlap</span>
<a name="l01734"></a>01734           <span class="keywordtype">int</span> overlap;
<a name="l01735"></a>01735           <span class="keywordflow">if</span> (keep_overlap) overlap = 2*cg.overlap; <span class="keywordflow">else</span> overlap = cg.overlap;
<a name="l01736"></a>01736 
<a name="l01737"></a>01737           <span class="comment">// output</span>
<a name="l01738"></a>01738 <span class="comment">//        if (_torus.rank()==0) std::cout &lt;&lt; "MultiYGrid&lt;" // changed dinfo to cout</span>
<a name="l01739"></a>01739 <span class="comment">//                                                                        &lt;&lt; d &lt;&lt; "&gt;: refined to size " </span>
<a name="l01740"></a>01740 <span class="comment">//                                                                        &lt;&lt; s &lt;&lt; std::endl;</span>
<a name="l01741"></a>01741 
<a name="l01742"></a>01742           <span class="comment">// the cell interior grid obtained from coarse cell interior grid</span>
<a name="l01743"></a>01743           <a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a> o_interior;
<a name="l01744"></a>01744           <a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a> s_interior;
<a name="l01745"></a>01745           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; i++) o_interior[i] = 2*cg.cell_interior.origin(i);
<a name="l01746"></a>01746           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; i++) s_interior[i] = 2*cg.cell_interior.size(i);
<a name="l01747"></a>01747           
<a name="l01748"></a>01748           <span class="comment">// add level</span>
<a name="l01749"></a>01749           _maxlevel++;
<a name="l01750"></a>01750           _levels[_maxlevel] = makelevel(_LL,s,_periodic,o_interior,s_interior,overlap);
<a name="l01751"></a>01751         }
<a name="l01752"></a>01752 
<a name="l01754"></a><a class="code" href="a00219.html#ad7c5a6d48492dc7390618a442fd420d">01754</a>         <span class="keyword">const</span> <a class="code" href="a00280.html">Torus&lt;d&gt;</a>&amp; <a class="code" href="a00219.html#ad7c5a6d48492dc7390618a442fd420d" title="return reference to torus">torus</a> ()<span class="keyword"> const</span>
<a name="l01755"></a>01755 <span class="keyword">        </span>{
<a name="l01756"></a>01756           <span class="keywordflow">return</span> _torus;
<a name="l01757"></a>01757         }
<a name="l01758"></a>01758 
<a name="l01760"></a><a class="code" href="a00219.html#4e9ad37b1c10491f083c9a5599dc31ce">01760</a>         <span class="keywordtype">int</span> <a class="code" href="a00219.html#4e9ad37b1c10491f083c9a5599dc31ce" title="return the maximum level index (number of levels is maxlevel()+1)">maxlevel</a> ()<span class="keyword"> const</span>
<a name="l01761"></a>01761 <span class="keyword">        </span>{
<a name="l01762"></a>01762           <span class="keywordflow">return</span> _maxlevel;
<a name="l01763"></a>01763         }
<a name="l01764"></a>01764 
<a name="l01766"></a><a class="code" href="a00219.html#f4711def27d3e2c69a9b2dee4d664d85">01766</a>         <span class="keywordtype">bool</span> <a class="code" href="a00219.html#f4711def27d3e2c69a9b2dee4d664d85" title="return true if grid is periodic in given direction">periodic</a> (<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
<a name="l01767"></a>01767 <span class="keyword">        </span>{
<a name="l01768"></a>01768           <span class="keywordflow">return</span> _periodic[i];
<a name="l01769"></a>01769         }
<a name="l01770"></a>01770 
<a name="l01772"></a><a class="code" href="a00220.html">01772</a>         <span class="keyword">class </span><a class="code" href="a00220.html" title="provides access to a given grid level">YGridLevelIterator</a> {
<a name="l01773"></a>01773         <span class="keyword">private</span>:
<a name="l01774"></a>01774           <span class="keywordtype">int</span> l;
<a name="l01775"></a>01775           <span class="keyword">const</span> YGridLevel* i;
<a name="l01776"></a>01776         <span class="keyword">public</span>:
<a name="l01778"></a><a class="code" href="a00220.html#528dc9aefe4d4c865968ba70bb6e79ac">01778</a>           <a class="code" href="a00220.html#528dc9aefe4d4c865968ba70bb6e79ac" title="empty constructor, use with care">YGridLevelIterator</a> ()
<a name="l01779"></a>01779           {
<a name="l01780"></a>01780           }
<a name="l01781"></a>01781 
<a name="l01783"></a><a class="code" href="a00220.html#35e9d9efc7bac83ad94572c5ef35ea07">01783</a>           <a class="code" href="a00220.html#528dc9aefe4d4c865968ba70bb6e79ac" title="empty constructor, use with care">YGridLevelIterator</a> (<span class="keyword">const</span> YGridLevel* start, <span class="keywordtype">int</span> <a class="code" href="a00220.html#e1657dd8cfc2112a092b0a7e37c8f01e" title="return number of this grid level">level</a>)
<a name="l01784"></a>01784           {
<a name="l01785"></a>01785                 i=start; l=level;
<a name="l01786"></a>01786           }
<a name="l01787"></a>01787 
<a name="l01789"></a><a class="code" href="a00220.html#8522e213f10b23e6a84df7d029cab763">01789</a>           <a class="code" href="a00220.html#528dc9aefe4d4c865968ba70bb6e79ac" title="empty constructor, use with care">YGridLevelIterator</a> (<span class="keyword">const</span> <a class="code" href="a00220.html" title="provides access to a given grid level">YGridLevelIterator</a> &amp; it)
<a name="l01790"></a>01790         : l(it.l), i(it.i)
<a name="l01791"></a>01791       {}
<a name="l01792"></a>01792 
<a name="l01794"></a><a class="code" href="a00220.html#e1657dd8cfc2112a092b0a7e37c8f01e">01794</a>           <span class="keywordtype">int</span> <a class="code" href="a00220.html#e1657dd8cfc2112a092b0a7e37c8f01e" title="return number of this grid level">level</a> ()<span class="keyword"> const</span>
<a name="l01795"></a>01795 <span class="keyword">          </span>{
<a name="l01796"></a>01796                 <span class="keywordflow">return</span> l;
<a name="l01797"></a>01797           }
<a name="l01798"></a>01798 
<a name="l01800"></a><a class="code" href="a00220.html#27255841e7cd5e4b3b276aed9ee15c16">01800</a>           <span class="keywordtype">int</span> <a class="code" href="a00220.html#27255841e7cd5e4b3b276aed9ee15c16" title="return size of overlap on this level">overlap</a> ()<span class="keyword"> const</span>
<a name="l01801"></a>01801 <span class="keyword">          </span>{
<a name="l01802"></a>01802                 <span class="keywordflow">return</span> i-&gt;overlap;
<a name="l01803"></a>01803           }
<a name="l01804"></a>01804 
<a name="l01806"></a><a class="code" href="a00220.html#b055551fffd078cbfb99e5c30a55ed72">01806</a>           <span class="keyword">const</span> <a class="code" href="a00219.html">MultiYGrid&lt;d,ct&gt;</a>* <a class="code" href="a00220.html#b055551fffd078cbfb99e5c30a55ed72" title="return pointer to multigrid object that contains this level">mg</a> ()<span class="keyword"> const</span>
<a name="l01807"></a>01807 <span class="keyword">          </span>{
<a name="l01808"></a>01808                 <span class="keywordflow">return</span> i-&gt;mg;
<a name="l01809"></a>01809           }
<a name="l01810"></a>01810 
<a name="l01812"></a><a class="code" href="a00220.html#68e50be62841d0b203197ccf87d89b95">01812</a>           <span class="keywordtype">bool</span> <a class="code" href="a00220.html#68e50be62841d0b203197ccf87d89b95" title="Return true when two iterators point to same member.">operator== </a>(<span class="keyword">const</span> <a class="code" href="a00220.html" title="provides access to a given grid level">YGridLevelIterator</a>&amp; iter)<span class="keyword"> const</span>
<a name="l01813"></a>01813 <span class="keyword">          </span>{
<a name="l01814"></a>01814                 <span class="keywordflow">return</span> i == iter.<a class="code" href="a00220.html#8ad362b6d7a66c75744dff00e05c5fba">i</a>;
<a name="l01815"></a>01815           }
<a name="l01816"></a>01816 
<a name="l01818"></a><a class="code" href="a00220.html#09fb4e7c527fca74eac568fd34734130">01818</a>           <span class="keywordtype">bool</span> <a class="code" href="a00220.html#09fb4e7c527fca74eac568fd34734130" title="Return true when two iterators do not point to same member.">operator!= </a>(<span class="keyword">const</span> <a class="code" href="a00220.html" title="provides access to a given grid level">YGridLevelIterator</a>&amp; iter)<span class="keyword"> const</span>
<a name="l01819"></a>01819 <span class="keyword">          </span>{
<a name="l01820"></a>01820                 <span class="keywordflow">return</span> i != iter.<a class="code" href="a00220.html#8ad362b6d7a66c75744dff00e05c5fba">i</a>;
<a name="l01821"></a>01821           }
<a name="l01822"></a>01822         
<a name="l01824"></a><a class="code" href="a00220.html#32e1c70d98f3c1ca2f7c6d41f4523427">01824</a>           <a class="code" href="a00220.html" title="provides access to a given grid level">YGridLevelIterator</a>&amp; <a class="code" href="a00220.html#32e1c70d98f3c1ca2f7c6d41f4523427" title="Increment iterator to next finer grid level.">operator++ </a>()
<a name="l01825"></a>01825           {
<a name="l01826"></a>01826                 ++i; <span class="comment">// assumes built-in array</span>
<a name="l01827"></a>01827                 ++l;
<a name="l01828"></a>01828                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01829"></a>01829           }
<a name="l01830"></a>01830 
<a name="l01832"></a><a class="code" href="a00220.html#4827c7ef3f43defb9e1078c69be99888">01832</a>           <a class="code" href="a00220.html" title="provides access to a given grid level">YGridLevelIterator</a>&amp; <a class="code" href="a00220.html#4827c7ef3f43defb9e1078c69be99888" title="Increment iterator to coarser grid level.">operator-- </a>()
<a name="l01833"></a>01833           {
<a name="l01834"></a>01834                 --i;
<a name="l01835"></a>01835                 --l;
<a name="l01836"></a>01836                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01837"></a>01837           }
<a name="l01838"></a>01838 
<a name="l01840"></a><a class="code" href="a00220.html#9e391c0a82ad79c8a9f73b8ce4fe2ad8">01840</a>           <a class="code" href="a00220.html" title="provides access to a given grid level">YGridLevelIterator</a> <a class="code" href="a00220.html#9e391c0a82ad79c8a9f73b8ce4fe2ad8" title="get iterator to next finer grid level">finer</a> ()<span class="keyword"> const</span>
<a name="l01841"></a>01841 <span class="keyword">          </span>{
<a name="l01842"></a>01842                 <span class="keywordflow">return</span> <a class="code" href="a00220.html#528dc9aefe4d4c865968ba70bb6e79ac" title="empty constructor, use with care">YGridLevelIterator</a>(i+1,l+1);
<a name="l01843"></a>01843           }
<a name="l01844"></a>01844 
<a name="l01846"></a><a class="code" href="a00220.html#68509db30fc4ffb532f2d87bad84d131">01846</a>           <a class="code" href="a00220.html" title="provides access to a given grid level">YGridLevelIterator</a> <a class="code" href="a00220.html#68509db30fc4ffb532f2d87bad84d131" title="get iterator to next coarser grid level">coarser</a> ()<span class="keyword"> const</span>
<a name="l01847"></a>01847 <span class="keyword">          </span>{
<a name="l01848"></a>01848                 <span class="keywordflow">return</span> <a class="code" href="a00220.html#528dc9aefe4d4c865968ba70bb6e79ac" title="empty constructor, use with care">YGridLevelIterator</a>(i-1,l-1);
<a name="l01849"></a>01849           }
<a name="l01850"></a>01850 
<a name="l01852"></a><a class="code" href="a00220.html#b8d0e3920ecbbbf94c469d27f2c5040b">01852</a>           <span class="keyword">const</span> <a class="code" href="a00308.html">YGrid&lt;d,ct&gt;</a>&amp; <a class="code" href="a00220.html#b8d0e3920ecbbbf94c469d27f2c5040b" title="reference to global cell grid">cell_global</a> ()<span class="keyword"> const</span>
<a name="l01853"></a>01853 <span class="keyword">          </span>{
<a name="l01854"></a>01854                 <span class="keywordflow">return</span> i-&gt;cell_global;
<a name="l01855"></a>01855           }
<a name="l01856"></a>01856 
<a name="l01858"></a><a class="code" href="a00220.html#2eafac9a05e522e7e9ec679b4d10ca90">01858</a>           <span class="keyword">const</span> <a class="code" href="a00277.html">SubYGrid&lt;d,ct&gt;</a>&amp; <a class="code" href="a00220.html#2eafac9a05e522e7e9ec679b4d10ca90" title="reference to local cell grid which is a subgrid of the global cell grid">cell_overlap</a> ()<span class="keyword"> const</span>
<a name="l01859"></a>01859 <span class="keyword">          </span>{
<a name="l01860"></a>01860                 <span class="keywordflow">return</span> i-&gt;cell_overlap;
<a name="l01861"></a>01861           }
<a name="l01862"></a>01862 
<a name="l01864"></a><a class="code" href="a00220.html#5e7da20d0bd84c94c62abc11831f1c4f">01864</a>           <span class="keyword">const</span> <a class="code" href="a00277.html">SubYGrid&lt;d,ct&gt;</a>&amp; <a class="code" href="a00220.html#5e7da20d0bd84c94c62abc11831f1c4f" title="reference to cell master grid which is a subgrid of the local cell grid">cell_interior</a> ()<span class="keyword"> const</span>
<a name="l01865"></a>01865 <span class="keyword">          </span>{
<a name="l01866"></a>01866                 <span class="keywordflow">return</span> i-&gt;cell_interior;
<a name="l01867"></a>01867           }
<a name="l01868"></a>01868 
<a name="l01869"></a>01869 
<a name="l01871"></a><a class="code" href="a00220.html#b96b9a742c0c7d47f1d61563488b90e5">01871</a>           <span class="keyword">const</span> std::deque&lt;Intersection&gt;&amp; <a class="code" href="a00220.html#b96b9a742c0c7d47f1d61563488b90e5" title="access to intersection lists">send_cell_overlap_overlap</a> ()<span class="keyword"> const</span>
<a name="l01872"></a>01872 <span class="keyword">          </span>{
<a name="l01873"></a>01873                 <span class="keywordflow">return</span> i-&gt;send_cell_overlap_overlap;
<a name="l01874"></a>01874           }
<a name="l01875"></a>01875           <span class="keyword">const</span> std::deque&lt;Intersection&gt;&amp; recv_cell_overlap_overlap ()<span class="keyword"> const</span>
<a name="l01876"></a>01876 <span class="keyword">          </span>{
<a name="l01877"></a>01877                 <span class="keywordflow">return</span> i-&gt;recv_cell_overlap_overlap;
<a name="l01878"></a>01878           }
<a name="l01879"></a>01879           <span class="keyword">const</span> std::deque&lt;Intersection&gt;&amp; send_cell_interior_overlap ()<span class="keyword"> const</span>
<a name="l01880"></a>01880 <span class="keyword">          </span>{
<a name="l01881"></a>01881                 <span class="keywordflow">return</span> i-&gt;send_cell_interior_overlap;
<a name="l01882"></a>01882           }
<a name="l01883"></a>01883           <span class="keyword">const</span> std::deque&lt;Intersection&gt;&amp; recv_cell_overlap_interior ()<span class="keyword"> const </span>
<a name="l01884"></a>01884 <span class="keyword">          </span>{
<a name="l01885"></a>01885                 <span class="keywordflow">return</span> i-&gt;recv_cell_overlap_interior;
<a name="l01886"></a>01886           }
<a name="l01887"></a>01887 
<a name="l01888"></a>01888 
<a name="l01890"></a><a class="code" href="a00220.html#32cccfa2994e4fd8679763bbbd9b54e2">01890</a>           <span class="keyword">const</span> <a class="code" href="a00308.html">YGrid&lt;d,ct&gt;</a>&amp; <a class="code" href="a00220.html#32cccfa2994e4fd8679763bbbd9b54e2" title="reference to global vertex grid">vertex_global</a> ()<span class="keyword"> const</span>
<a name="l01891"></a>01891 <span class="keyword">          </span>{
<a name="l01892"></a>01892                 <span class="keywordflow">return</span> i-&gt;vertex_global;
<a name="l01893"></a>01893           }
<a name="l01895"></a><a class="code" href="a00220.html#f30d648fb0650bef1fb627786b9f50a5">01895</a>           <span class="keyword">const</span> <a class="code" href="a00277.html">SubYGrid&lt;d,ct&gt;</a>&amp; <a class="code" href="a00220.html#f30d648fb0650bef1fb627786b9f50a5" title="reference to vertex grid, up to front; there are no ghosts in this implementation...">vertex_overlapfront</a> ()<span class="keyword"> const</span>
<a name="l01896"></a>01896 <span class="keyword">          </span>{
<a name="l01897"></a>01897                 <span class="keywordflow">return</span> i-&gt;vertex_overlapfront;
<a name="l01898"></a>01898           }
<a name="l01900"></a><a class="code" href="a00220.html#283e7a3430804935bdf53f83917c9e04">01900</a>           <span class="keyword">const</span> <a class="code" href="a00277.html">SubYGrid&lt;d,ct&gt;</a>&amp; <a class="code" href="a00220.html#283e7a3430804935bdf53f83917c9e04" title="reference to overlap vertex grid; is subgrid of overlapfront vertex grid">vertex_overlap</a> ()<span class="keyword"> const</span>
<a name="l01901"></a>01901 <span class="keyword">          </span>{
<a name="l01902"></a>01902                 <span class="keywordflow">return</span> i-&gt;vertex_overlap;
<a name="l01903"></a>01903           }
<a name="l01905"></a><a class="code" href="a00220.html#ca887f602e565027e2f814e6cf22d0da">01905</a>           <span class="keyword">const</span> <a class="code" href="a00277.html">SubYGrid&lt;d,ct&gt;</a>&amp; <a class="code" href="a00220.html#ca887f602e565027e2f814e6cf22d0da" title="reference to interiorborder vertex grid; is subgrid of overlapfront vertex grid">vertex_interiorborder</a> ()<span class="keyword"> const</span>
<a name="l01906"></a>01906 <span class="keyword">          </span>{
<a name="l01907"></a>01907                 <span class="keywordflow">return</span> i-&gt;vertex_interiorborder;
<a name="l01908"></a>01908           }
<a name="l01910"></a><a class="code" href="a00220.html#1b9bc876d7c14e338b1975a21c5904ae">01910</a>           <span class="keyword">const</span> <a class="code" href="a00277.html">SubYGrid&lt;d,ct&gt;</a>&amp; <a class="code" href="a00220.html#1b9bc876d7c14e338b1975a21c5904ae" title="reference to interior vertex grid; is subgrid of overlapfront vertex grid">vertex_interior</a> ()<span class="keyword"> const</span>
<a name="l01911"></a>01911 <span class="keyword">          </span>{
<a name="l01912"></a>01912                 <span class="keywordflow">return</span> i-&gt;vertex_interior;
<a name="l01913"></a>01913           }
<a name="l01914"></a>01914 
<a name="l01916"></a><a class="code" href="a00220.html#352caaae1d42e23de335cbcc9c545edd">01916</a>           <span class="keyword">const</span> std::deque&lt;Intersection&gt;&amp; <a class="code" href="a00220.html#352caaae1d42e23de335cbcc9c545edd" title="access to intersection lists">send_vertex_overlapfront_overlapfront</a> ()<span class="keyword"> const</span>
<a name="l01917"></a>01917 <span class="keyword">          </span>{
<a name="l01918"></a>01918                 <span class="keywordflow">return</span> i-&gt;send_vertex_overlapfront_overlapfront;
<a name="l01919"></a>01919           }
<a name="l01920"></a>01920           <span class="keyword">const</span> std::deque&lt;Intersection&gt;&amp; recv_vertex_overlapfront_overlapfront ()<span class="keyword"> const</span>
<a name="l01921"></a>01921 <span class="keyword">          </span>{
<a name="l01922"></a>01922                 <span class="keywordflow">return</span> i-&gt;recv_vertex_overlapfront_overlapfront;
<a name="l01923"></a>01923           }
<a name="l01924"></a>01924           <span class="keyword">const</span> std::deque&lt;Intersection&gt;&amp; send_vertex_overlap_overlapfront ()<span class="keyword"> const</span>
<a name="l01925"></a>01925 <span class="keyword">          </span>{
<a name="l01926"></a>01926                 <span class="keywordflow">return</span> i-&gt;send_vertex_overlap_overlapfront;
<a name="l01927"></a>01927           }
<a name="l01928"></a>01928           <span class="keyword">const</span> std::deque&lt;Intersection&gt;&amp; recv_vertex_overlapfront_overlap ()<span class="keyword"> const</span>
<a name="l01929"></a>01929 <span class="keyword">          </span>{
<a name="l01930"></a>01930                 <span class="keywordflow">return</span> i-&gt;recv_vertex_overlapfront_overlap;
<a name="l01931"></a>01931           }
<a name="l01932"></a>01932           <span class="keyword">const</span> std::deque&lt;Intersection&gt;&amp; send_vertex_interiorborder_interiorborder ()<span class="keyword"> const</span>
<a name="l01933"></a>01933 <span class="keyword">          </span>{
<a name="l01934"></a>01934                 <span class="keywordflow">return</span> i-&gt;send_vertex_interiorborder_interiorborder;
<a name="l01935"></a>01935           }
<a name="l01936"></a>01936           <span class="keyword">const</span> std::deque&lt;Intersection&gt;&amp; recv_vertex_interiorborder_interiorborder ()<span class="keyword"> const</span>
<a name="l01937"></a>01937 <span class="keyword">          </span>{
<a name="l01938"></a>01938                 <span class="keywordflow">return</span> i-&gt;recv_vertex_interiorborder_interiorborder;
<a name="l01939"></a>01939           }
<a name="l01940"></a>01940           <span class="keyword">const</span> std::deque&lt;Intersection&gt;&amp; send_vertex_interiorborder_overlapfront ()<span class="keyword"> const</span>
<a name="l01941"></a>01941 <span class="keyword">          </span>{
<a name="l01942"></a>01942                 <span class="keywordflow">return</span> i-&gt;send_vertex_interiorborder_overlapfront;
<a name="l01943"></a>01943           }
<a name="l01944"></a>01944           <span class="keyword">const</span> std::deque&lt;Intersection&gt;&amp; recv_vertex_overlapfront_interiorborder ()<span class="keyword"> const</span>
<a name="l01945"></a>01945 <span class="keyword">          </span>{
<a name="l01946"></a>01946                 <span class="keywordflow">return</span> i-&gt;recv_vertex_overlapfront_interiorborder;
<a name="l01947"></a>01947           }
<a name="l01948"></a>01948         };
<a name="l01949"></a>01949 
<a name="l01951"></a><a class="code" href="a00219.html#6d778775dd1a73e626a09da915e7321b">01951</a>         YGridLevelIterator <a class="code" href="a00219.html#6d778775dd1a73e626a09da915e7321b" title="return iterator pointing to coarsest level">begin</a> ()<span class="keyword"> const</span>
<a name="l01952"></a>01952 <span class="keyword">        </span>{
<a name="l01953"></a>01953           <span class="keywordflow">return</span> YGridLevelIterator(_levels,0);
<a name="l01954"></a>01954         }
<a name="l01955"></a>01955 
<a name="l01957"></a><a class="code" href="a00219.html#742f61f541aba6b9122ed93d4dca3f87">01957</a>         YGridLevelIterator <a class="code" href="a00219.html#6d778775dd1a73e626a09da915e7321b" title="return iterator pointing to coarsest level">begin</a> (<span class="keywordtype">int</span> i)<span class="keyword"> const</span>
<a name="l01958"></a>01958 <span class="keyword">        </span>{
<a name="l01959"></a>01959           <span class="keywordflow">if</span> (i&lt;0 || i&gt;<a class="code" href="a00219.html#4e9ad37b1c10491f083c9a5599dc31ce" title="return the maximum level index (number of levels is maxlevel()+1)">maxlevel</a>())
<a name="l01960"></a>01960                 DUNE_THROW(<a class="code" href="a00105.html" title="Base class for exceptions in Dune grid modules.">GridError</a>, <span class="stringliteral">"level not existing"</span>);
<a name="l01961"></a>01961           <span class="keywordflow">return</span> YGridLevelIterator(_levels+i,i);
<a name="l01962"></a>01962         }
<a name="l01963"></a>01963 
<a name="l01965"></a><a class="code" href="a00219.html#c04b4813d0ce720e56be6769188beb15">01965</a>         YGridLevelIterator <a class="code" href="a00219.html#c04b4813d0ce720e56be6769188beb15" title="return iterator pointing to one past the finest level">end</a> ()<span class="keyword"> const</span>
<a name="l01966"></a>01966 <span class="keyword">        </span>{
<a name="l01967"></a>01967           <span class="keywordflow">return</span> YGridLevelIterator(_levels+(_maxlevel+1),_maxlevel+1);
<a name="l01968"></a>01968         }
<a name="l01969"></a>01969 
<a name="l01971"></a><a class="code" href="a00219.html#8cd32dfe328032992357c121fb4049a3">01971</a>         YGridLevelIterator <a class="code" href="a00219.html#8cd32dfe328032992357c121fb4049a3" title="return iterator pointing to the finest level">rbegin</a> ()<span class="keyword"> const</span>
<a name="l01972"></a>01972 <span class="keyword">        </span>{
<a name="l01973"></a>01973           <span class="keywordflow">return</span> YGridLevelIterator(_levels+_maxlevel,_maxlevel);
<a name="l01974"></a>01974         }
<a name="l01975"></a>01975 
<a name="l01977"></a><a class="code" href="a00219.html#c8a560baef7d21ecb6d7cf12c328c721">01977</a>         YGridLevelIterator <a class="code" href="a00219.html#c8a560baef7d21ecb6d7cf12c328c721" title="return iterator pointing to one before the coarsest level">rend</a> ()<span class="keyword"> const</span>
<a name="l01978"></a>01978 <span class="keyword">        </span>{
<a name="l01979"></a>01979           <span class="keywordflow">return</span> YGridLevelIterator(_levels-1,-1);
<a name="l01980"></a>01980         }
<a name="l01981"></a>01981 
<a name="l01983"></a><a class="code" href="a00219.html#0e9fb43dd21015e030e5dd85437282f2">01983</a>         <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="a00219.html#0e9fb43dd21015e030e5dd85437282f2" title="print function for multigrids">print</a> (std::ostream&amp; s)<span class="keyword"> const</span>
<a name="l01984"></a>01984 <span class="keyword">        </span>{
<a name="l01985"></a>01985           <span class="keywordtype">int</span> rank = <a class="code" href="a00219.html#ad7c5a6d48492dc7390618a442fd420d" title="return reference to torus">torus</a>().rank();
<a name="l01986"></a>01986 
<a name="l01987"></a>01987           s &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; rank &lt;&lt; <span class="stringliteral">"]:"</span> &lt;&lt; <span class="stringliteral">" MultiYGrid maxlevel="</span> &lt;&lt; <a class="code" href="a00219.html#4e9ad37b1c10491f083c9a5599dc31ce" title="return the maximum level index (number of levels is maxlevel()+1)">maxlevel</a>() &lt;&lt; std::endl;
<a name="l01988"></a>01988 
<a name="l01989"></a>01989           <span class="keywordflow">for</span> (YGridLevelIterator g=<a class="code" href="a00219.html#6d778775dd1a73e626a09da915e7321b" title="return iterator pointing to coarsest level">begin</a>(); g!=<a class="code" href="a00219.html#c04b4813d0ce720e56be6769188beb15" title="return iterator pointing to one past the finest level">end</a>(); ++g)
<a name="l01990"></a>01990                 {
<a name="l01991"></a>01991                   s &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; rank &lt;&lt; <span class="stringliteral">"]:   "</span> &lt;&lt; std::endl;
<a name="l01992"></a>01992                   s &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; rank &lt;&lt; <span class="stringliteral">"]:   "</span> &lt;&lt; <span class="stringliteral">"=========================================="</span> &lt;&lt; std::endl;
<a name="l01993"></a>01993                   s &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; rank &lt;&lt; <span class="stringliteral">"]:   "</span> &lt;&lt; <span class="stringliteral">"level="</span> &lt;&lt; g.level() &lt;&lt; std::endl;
<a name="l01994"></a>01994                   s &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; rank &lt;&lt; <span class="stringliteral">"]:   "</span> &lt;&lt; <span class="stringliteral">"cell_global="</span> &lt;&lt; g.cell_global() &lt;&lt; std::endl;
<a name="l01995"></a>01995                   s &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; rank &lt;&lt; <span class="stringliteral">"]:   "</span> &lt;&lt; <span class="stringliteral">"cell_overlap="</span> &lt;&lt; g.cell_overlap() &lt;&lt; std::endl;
<a name="l01996"></a>01996                   s &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; rank &lt;&lt; <span class="stringliteral">"]:   "</span> &lt;&lt; <span class="stringliteral">"cell_interior="</span> &lt;&lt; g.cell_interior() &lt;&lt; std::endl;          
<a name="l01997"></a>01997                   <span class="keywordflow">for</span> (<span class="keyword">typename</span> std::deque&lt;Intersection&gt;::const_iterator i=g.send_cell_overlap_overlap().begin();
<a name="l01998"></a>01998                            i!=g.send_cell_overlap_overlap().end(); ++i)
<a name="l01999"></a>01999                         {
<a name="l02000"></a>02000                           s &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; rank &lt;&lt; <span class="stringliteral">"]:    "</span> &lt;&lt; <span class="stringliteral">" s_c_o_o "</span>
<a name="l02001"></a>02001                                 &lt;&lt; i-&gt;rank &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; i-&gt;grid &lt;&lt; std::endl;
<a name="l02002"></a>02002                         }
<a name="l02003"></a>02003                   <span class="keywordflow">for</span> (<span class="keyword">typename</span> std::deque&lt;Intersection&gt;::const_iterator i=g.recv_cell_overlap_overlap().begin();
<a name="l02004"></a>02004                            i!=g.recv_cell_overlap_overlap().end(); ++i)
<a name="l02005"></a>02005                         {
<a name="l02006"></a>02006                           s &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; rank &lt;&lt; <span class="stringliteral">"]:    "</span> &lt;&lt; <span class="stringliteral">" r_c_o_o "</span>
<a name="l02007"></a>02007                                 &lt;&lt; i-&gt;rank &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; i-&gt;grid &lt;&lt; std::endl;
<a name="l02008"></a>02008                         }
<a name="l02009"></a>02009                   <span class="keywordflow">for</span> (<span class="keyword">typename</span> std::deque&lt;Intersection&gt;::const_iterator i=g.send_cell_interior_overlap().begin();
<a name="l02010"></a>02010                            i!=g.send_cell_interior_overlap().end(); ++i)
<a name="l02011"></a>02011                         {
<a name="l02012"></a>02012                           s &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; rank &lt;&lt; <span class="stringliteral">"]:    "</span> &lt;&lt; <span class="stringliteral">" s_c_i_o "</span>
<a name="l02013"></a>02013                                 &lt;&lt; i-&gt;rank &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; i-&gt;grid &lt;&lt; std::endl;
<a name="l02014"></a>02014                         }
<a name="l02015"></a>02015                   <span class="keywordflow">for</span> (<span class="keyword">typename</span> std::deque&lt;Intersection&gt;::const_iterator i=g.recv_cell_overlap_interior().begin();
<a name="l02016"></a>02016                            i!=g.recv_cell_overlap_interior().end(); ++i)
<a name="l02017"></a>02017                         {
<a name="l02018"></a>02018                           s &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; rank &lt;&lt; <span class="stringliteral">"]:    "</span> &lt;&lt; <span class="stringliteral">" r_c_o_i "</span>
<a name="l02019"></a>02019                                 &lt;&lt; i-&gt;rank &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; i-&gt;grid &lt;&lt; std::endl;
<a name="l02020"></a>02020                         }
<a name="l02021"></a>02021 
<a name="l02022"></a>02022                   s &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; rank &lt;&lt; <span class="stringliteral">"]:   "</span> &lt;&lt; <span class="stringliteral">"-----------------------------------------------"</span>  &lt;&lt; std::endl;
<a name="l02023"></a>02023                   s &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; rank &lt;&lt; <span class="stringliteral">"]:   "</span> &lt;&lt; <span class="stringliteral">"vertex_global="</span>         &lt;&lt; g.vertex_global() &lt;&lt; std::endl;
<a name="l02024"></a>02024                   s &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; rank &lt;&lt; <span class="stringliteral">"]:   "</span> &lt;&lt; <span class="stringliteral">"vertex_overlapfront="</span>   &lt;&lt; g.vertex_overlapfront() &lt;&lt; std::endl;
<a name="l02025"></a>02025                   s &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; rank &lt;&lt; <span class="stringliteral">"]:   "</span> &lt;&lt; <span class="stringliteral">"vertex_overlap="</span>        &lt;&lt; g.vertex_overlap() &lt;&lt; std::endl;
<a name="l02026"></a>02026                   s &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; rank &lt;&lt; <span class="stringliteral">"]:   "</span> &lt;&lt; <span class="stringliteral">"vertex_interiorborder="</span> &lt;&lt; g.vertex_interiorborder() &lt;&lt; std::endl;
<a name="l02027"></a>02027                   s &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; rank &lt;&lt; <span class="stringliteral">"]:   "</span> &lt;&lt; <span class="stringliteral">"vertex_interior="</span>       &lt;&lt; g.vertex_interior() &lt;&lt; std::endl;
<a name="l02028"></a>02028                   <span class="keywordflow">for</span> (<span class="keyword">typename</span> std::deque&lt;Intersection&gt;::const_iterator i=g.send_vertex_overlapfront_overlapfront().begin();
<a name="l02029"></a>02029                            i!=g.send_vertex_overlapfront_overlapfront().end(); ++i)
<a name="l02030"></a>02030                         {
<a name="l02031"></a>02031                           s &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; rank &lt;&lt; <span class="stringliteral">"]:    "</span> &lt;&lt; <span class="stringliteral">" s_v_of_of "</span>
<a name="l02032"></a>02032                                 &lt;&lt; i-&gt;rank &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; i-&gt;grid &lt;&lt; std::endl;
<a name="l02033"></a>02033                         }
<a name="l02034"></a>02034                   <span class="keywordflow">for</span> (<span class="keyword">typename</span> std::deque&lt;Intersection&gt;::const_iterator i=g.recv_vertex_overlapfront_overlapfront().begin();
<a name="l02035"></a>02035                            i!=g.recv_vertex_overlapfront_overlapfront().end(); ++i)
<a name="l02036"></a>02036                         {
<a name="l02037"></a>02037                           s &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; rank &lt;&lt; <span class="stringliteral">"]:    "</span> &lt;&lt; <span class="stringliteral">" r_v_of_of "</span>
<a name="l02038"></a>02038                                 &lt;&lt; i-&gt;rank &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; i-&gt;grid &lt;&lt; std::endl;
<a name="l02039"></a>02039                         }
<a name="l02040"></a>02040                   <span class="keywordflow">for</span> (<span class="keyword">typename</span> std::deque&lt;Intersection&gt;::const_iterator i=g.send_vertex_overlap_overlapfront().begin();
<a name="l02041"></a>02041                            i!=g.send_vertex_overlap_overlapfront().end(); ++i)
<a name="l02042"></a>02042                         {
<a name="l02043"></a>02043                           s &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; rank &lt;&lt; <span class="stringliteral">"]:    "</span> &lt;&lt; <span class="stringliteral">" s_v_o_of "</span>
<a name="l02044"></a>02044                                 &lt;&lt; i-&gt;rank &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; i-&gt;grid &lt;&lt; std::endl;
<a name="l02045"></a>02045                         }
<a name="l02046"></a>02046                   <span class="keywordflow">for</span> (<span class="keyword">typename</span> std::deque&lt;Intersection&gt;::const_iterator i=g.recv_vertex_overlapfront_overlap().begin();
<a name="l02047"></a>02047                            i!=g.recv_vertex_overlapfront_overlap().end(); ++i)
<a name="l02048"></a>02048                         {
<a name="l02049"></a>02049                           s &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; rank &lt;&lt; <span class="stringliteral">"]:    "</span> &lt;&lt; <span class="stringliteral">" r_v_of_o "</span>
<a name="l02050"></a>02050                                 &lt;&lt; i-&gt;rank &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; i-&gt;grid &lt;&lt; std::endl;
<a name="l02051"></a>02051                         }
<a name="l02052"></a>02052                   <span class="keywordflow">for</span> (<span class="keyword">typename</span> std::deque&lt;Intersection&gt;::const_iterator i=g.send_vertex_interiorborder_interiorborder().begin();
<a name="l02053"></a>02053                            i!=g.send_vertex_interiorborder_interiorborder().end(); ++i)
<a name="l02054"></a>02054                         {
<a name="l02055"></a>02055                           s &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; rank &lt;&lt; <span class="stringliteral">"]:    "</span> &lt;&lt; <span class="stringliteral">" s_v_ib_ib "</span>
<a name="l02056"></a>02056                                 &lt;&lt; i-&gt;rank &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; i-&gt;grid &lt;&lt; std::endl;
<a name="l02057"></a>02057                         }
<a name="l02058"></a>02058                   <span class="keywordflow">for</span> (<span class="keyword">typename</span> std::deque&lt;Intersection&gt;::const_iterator i=g.recv_vertex_interiorborder_interiorborder().begin();
<a name="l02059"></a>02059                            i!=g.recv_vertex_interiorborder_interiorborder().end(); ++i)
<a name="l02060"></a>02060                         {
<a name="l02061"></a>02061                           s &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; rank &lt;&lt; <span class="stringliteral">"]:    "</span> &lt;&lt; <span class="stringliteral">" r_v_ib_ib "</span>
<a name="l02062"></a>02062                                 &lt;&lt; i-&gt;rank &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; i-&gt;grid &lt;&lt; std::endl;
<a name="l02063"></a>02063                         }
<a name="l02064"></a>02064                   <span class="keywordflow">for</span> (<span class="keyword">typename</span> std::deque&lt;Intersection&gt;::const_iterator i=g.send_vertex_interiorborder_overlapfront().begin();
<a name="l02065"></a>02065                            i!=g.send_vertex_interiorborder_overlapfront().end(); ++i)
<a name="l02066"></a>02066                         {
<a name="l02067"></a>02067                           s &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; rank &lt;&lt; <span class="stringliteral">"]:    "</span> &lt;&lt; <span class="stringliteral">" s_v_ib_of "</span>
<a name="l02068"></a>02068                                 &lt;&lt; i-&gt;rank &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; i-&gt;grid &lt;&lt; std::endl;
<a name="l02069"></a>02069                         }
<a name="l02070"></a>02070                   <span class="keywordflow">for</span> (<span class="keyword">typename</span> std::deque&lt;Intersection&gt;::const_iterator i=g.recv_vertex_overlapfront_interiorborder().begin();
<a name="l02071"></a>02071                            i!=g.recv_vertex_overlapfront_interiorborder().end(); ++i)
<a name="l02072"></a>02072                         {
<a name="l02073"></a>02073                           s &lt;&lt; <span class="stringliteral">"["</span> &lt;&lt; rank &lt;&lt; <span class="stringliteral">"]:    "</span> &lt;&lt; <span class="stringliteral">" s_v_of_ib "</span>
<a name="l02074"></a>02074                                 &lt;&lt; i-&gt;rank &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; i-&gt;grid &lt;&lt; std::endl;
<a name="l02075"></a>02075                         }
<a name="l02076"></a>02076                 }
<a name="l02077"></a>02077 
<a name="l02078"></a>02078           s &lt;&lt; std::endl;
<a name="l02079"></a>02079         }
<a name="l02080"></a>02080 
<a name="l02081"></a>02081   <span class="keyword">private</span>:
<a name="l02082"></a>02082     <span class="comment">// make a new YGridLevel structure. For that we need</span>
<a name="l02083"></a>02083     <span class="comment">// L           size of the whole domain in each direction</span>
<a name="l02084"></a>02084     <span class="comment">// s           number of cells in each direction</span>
<a name="l02085"></a>02085     <span class="comment">// periodic    boolean indication periodicity in each direction</span>
<a name="l02086"></a>02086     <span class="comment">// o_interior  origin of interior (non-overlapping) cell decomposition</span>
<a name="l02087"></a>02087     <span class="comment">// s_interior  size of interior cell decomposition</span>
<a name="l02088"></a>02088     <span class="comment">// overlap     to be used on this grid level</span>
<a name="l02089"></a>02089         YGridLevel makelevel (fTupel L, <a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a> s, bTupel <a class="code" href="a00219.html#f4711def27d3e2c69a9b2dee4d664d85" title="return true if grid is periodic in given direction">periodic</a>, <a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a> o_interior, <a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a> s_interior, <span class="keywordtype">int</span> overlap)
<a name="l02090"></a>02090     {
<a name="l02091"></a>02091           <span class="comment">// first, lets allocate a new structure</span>
<a name="l02092"></a>02092           YGridLevel g;
<a name="l02093"></a>02093           g.overlap = overlap;
<a name="l02094"></a>02094           g.mg = <span class="keyword">this</span>;
<a name="l02095"></a>02095 
<a name="l02096"></a>02096           <span class="comment">// the global cell grid</span>
<a name="l02097"></a>02097           <a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a> o = <a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a>(0); <span class="comment">// logical origin is always 0, that is not a restriction</span>
<a name="l02098"></a>02098           fTupel h;
<a name="l02099"></a>02099           fTupel r;
<a name="l02100"></a>02100           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; i++) h[i] = L[i]/s[i]; <span class="comment">// the mesh size in each direction</span>
<a name="l02101"></a>02101           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; i++) r[i] = 0.5*h[i];  <span class="comment">// the shift for cell centers</span>
<a name="l02102"></a>02102           g.cell_global = <a class="code" href="a00308.html">YGrid&lt;d,ct&gt;</a>(o,s,h,r);     <span class="comment">// this is the global cell grid</span>
<a name="l02103"></a>02103 
<a name="l02104"></a>02104           <span class="comment">// extend the cell interior grid by overlap considering periodicity</span>
<a name="l02105"></a>02105           <a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a> o_overlap;
<a name="l02106"></a>02106           <a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a> s_overlap;
<a name="l02107"></a>02107           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; i++)
<a name="l02108"></a>02108                 {
<a name="l02109"></a>02109                   <span class="keywordflow">if</span> (periodic[i])
<a name="l02110"></a>02110                         {
<a name="l02111"></a>02111                           <span class="comment">// easy case, extend by 2 overlaps in total</span>
<a name="l02112"></a>02112                           o_overlap[i] = o_interior[i]-overlap;  <span class="comment">// Note: origin might be negative now </span>
<a name="l02113"></a>02113                           s_overlap[i] = s_interior[i]+2*overlap;<span class="comment">// Note: might be larger than global size</span>
<a name="l02114"></a>02114                         }
<a name="l02115"></a>02115                   <span class="keywordflow">else</span>
<a name="l02116"></a>02116                         {
<a name="l02117"></a>02117                           <span class="comment">// nonperiodic case, intersect with global size</span>
<a name="l02118"></a>02118                           <span class="keywordtype">int</span> min = std::max(0,o_interior[i]-overlap);
<a name="l02119"></a>02119                           <span class="keywordtype">int</span> max = std::min(s[i]-1,o_interior[i]+s_interior[i]-1+overlap);
<a name="l02120"></a>02120                           o_overlap[i] = min;
<a name="l02121"></a>02121                           s_overlap[i] = max-min+1;
<a name="l02122"></a>02122                         }
<a name="l02123"></a>02123                 }
<a name="l02124"></a>02124           g.cell_overlap = SubYGrid&lt;d,ct&gt;(YGrid&lt;d,ct&gt;(o_overlap,s_overlap,h,r));
<a name="l02125"></a>02125 
<a name="l02126"></a>02126           <span class="comment">// now make the interior grid a subgrid of the overlapping grid</span>
<a name="l02127"></a>02127           <a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a> offset;
<a name="l02128"></a>02128           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; i++) offset[i] = o_interior[i]-o_overlap[i];
<a name="l02129"></a>02129           g.cell_interior = SubYGrid&lt;d,ct&gt;(o_interior,s_interior,offset,s_overlap,h,r);
<a name="l02130"></a>02130 
<a name="l02131"></a>02131           <span class="comment">// compute cell intersections </span>
<a name="l02132"></a>02132           intersections(g.cell_overlap,g.cell_overlap,g.cell_global.size(),g.send_cell_overlap_overlap,g.recv_cell_overlap_overlap);
<a name="l02133"></a>02133           intersections(g.cell_interior,g.cell_overlap,g.cell_global.size(),g.send_cell_interior_overlap,g.recv_cell_overlap_interior);
<a name="l02134"></a>02134 
<a name="l02135"></a>02135           <span class="comment">// now we can do the vertex grids. They are derived completely from the cell grids</span>
<a name="l02136"></a>02136           <a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a> o_vertex_global, s_vertex_global;
<a name="l02137"></a>02137           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; i++) r[i] = 0.0;  <span class="comment">// the shift for vertices is zero, and the mesh size is same as for cells</span>
<a name="l02138"></a>02138 
<a name="l02139"></a>02139           <span class="comment">// first let's make the global grid</span>
<a name="l02140"></a>02140           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; i++) o_vertex_global[i] = g.cell_global.origin(i);
<a name="l02141"></a>02141           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; i++) s_vertex_global[i] = g.cell_global.size(i)+1; <span class="comment">// one more vertices than cells ...</span>
<a name="l02142"></a>02142           g.vertex_global = YGrid&lt;d,ct&gt;(o_vertex_global,s_vertex_global,h,r);
<a name="l02143"></a>02143 
<a name="l02144"></a>02144           <span class="comment">// now the local grid stored in this processor. All other grids are subgrids of this</span>
<a name="l02145"></a>02145           <a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a> o_vertex_overlapfront;
<a name="l02146"></a>02146           <a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a> s_vertex_overlapfront;
<a name="l02147"></a>02147           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; i++) o_vertex_overlapfront[i] = g.cell_overlap.origin(i);
<a name="l02148"></a>02148           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; i++) s_vertex_overlapfront[i] = g.cell_overlap.size(i)+1; <span class="comment">// one more vertices than cells ...</span>
<a name="l02149"></a>02149           g.vertex_overlapfront = SubYGrid&lt;d,ct&gt;(YGrid&lt;d,ct&gt;(o_vertex_overlapfront,s_vertex_overlapfront,h,r));
<a name="l02150"></a>02150 
<a name="l02151"></a>02151           <span class="comment">// now overlap only (i.e. without front), is subgrid of overlapfront</span>
<a name="l02152"></a>02152           <a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a> o_vertex_overlap;
<a name="l02153"></a>02153           <a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a> s_vertex_overlap;
<a name="l02154"></a>02154           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; i++) 
<a name="l02155"></a>02155                 {
<a name="l02156"></a>02156                   o_vertex_overlap[i] = g.cell_overlap.origin(i);
<a name="l02157"></a>02157                   s_vertex_overlap[i] = g.cell_overlap.size(i)+1;
<a name="l02158"></a>02158 
<a name="l02159"></a>02159                   <span class="keywordflow">if</span> (!periodic[i] &amp;&amp; g.cell_overlap.origin(i)&gt;g.cell_global.origin(i))
<a name="l02160"></a>02160                   {
<a name="l02161"></a>02161                         <span class="comment">// not at the lower boundary</span>
<a name="l02162"></a>02162                         o_vertex_overlap[i] += 1;
<a name="l02163"></a>02163                         s_vertex_overlap[i] -= 1;
<a name="l02164"></a>02164                   }
<a name="l02165"></a>02165 
<a name="l02166"></a>02166                   <span class="keywordflow">if</span> (!periodic[i] &amp;&amp; g.cell_overlap.origin(i)+g.cell_overlap.size(i)&lt;g.cell_global.origin(i)+g.cell_global.size(i))
<a name="l02167"></a>02167                   {
<a name="l02168"></a>02168                         <span class="comment">// not at the upper boundary</span>
<a name="l02169"></a>02169                         s_vertex_overlap[i] -= 1;
<a name="l02170"></a>02170                   }
<a name="l02171"></a>02171 
<a name="l02172"></a>02172 
<a name="l02173"></a>02173                   offset[i] = o_vertex_overlap[i]-o_vertex_overlapfront[i];
<a name="l02174"></a>02174                 }
<a name="l02175"></a>02175           g.vertex_overlap = SubYGrid&lt;d,ct&gt;(o_vertex_overlap,s_vertex_overlap,offset,s_vertex_overlapfront,h,r);
<a name="l02176"></a>02176 
<a name="l02177"></a>02177           <span class="comment">// now interior with border</span>
<a name="l02178"></a>02178           <a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a> o_vertex_interiorborder;
<a name="l02179"></a>02179           <a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a> s_vertex_interiorborder;
<a name="l02180"></a>02180           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; i++) o_vertex_interiorborder[i] = g.cell_interior.origin(i);
<a name="l02181"></a>02181           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; i++) s_vertex_interiorborder[i] = g.cell_interior.size(i)+1;
<a name="l02182"></a>02182           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; i++) offset[i] = o_vertex_interiorborder[i]-o_vertex_overlapfront[i];
<a name="l02183"></a>02183           g.vertex_interiorborder = SubYGrid&lt;d,ct&gt;(o_vertex_interiorborder,s_vertex_interiorborder,offset,s_vertex_overlapfront,h,r);
<a name="l02184"></a>02184 
<a name="l02185"></a>02185           <span class="comment">// now only interior</span>
<a name="l02186"></a>02186           <a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a> o_vertex_interior;
<a name="l02187"></a>02187           <a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a> s_vertex_interior;
<a name="l02188"></a>02188           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;d; i++) 
<a name="l02189"></a>02189                 {
<a name="l02190"></a>02190                   o_vertex_interior[i] = g.cell_interior.origin(i);
<a name="l02191"></a>02191                   s_vertex_interior[i] = g.cell_interior.size(i)+1;
<a name="l02192"></a>02192 
<a name="l02193"></a>02193                   <span class="keywordflow">if</span> (!periodic[i] &amp;&amp; g.cell_interior.origin(i)&gt;g.cell_global.origin(i))
<a name="l02194"></a>02194                   {
<a name="l02195"></a>02195                         <span class="comment">// not at the lower boundary</span>
<a name="l02196"></a>02196                         o_vertex_interior[i] += 1;
<a name="l02197"></a>02197                         s_vertex_interior[i] -= 1;
<a name="l02198"></a>02198                   }
<a name="l02199"></a>02199 
<a name="l02200"></a>02200                   <span class="keywordflow">if</span> (!periodic[i] &amp;&amp; g.cell_interior.origin(i)+g.cell_interior.size(i)&lt;g.cell_global.origin(i)+g.cell_global.size(i))
<a name="l02201"></a>02201                   {
<a name="l02202"></a>02202                         <span class="comment">// not at the upper boundary</span>
<a name="l02203"></a>02203                         s_vertex_interior[i] -= 1;
<a name="l02204"></a>02204                   }
<a name="l02205"></a>02205 
<a name="l02206"></a>02206                   offset[i] = o_vertex_interior[i]-o_vertex_overlapfront[i];
<a name="l02207"></a>02207                 }
<a name="l02208"></a>02208           g.vertex_interior = SubYGrid&lt;d,ct&gt;(o_vertex_interior,s_vertex_interior,offset,s_vertex_overlapfront,h,r);
<a name="l02209"></a>02209 
<a name="l02210"></a>02210           <span class="comment">// compute vertex intersections</span>
<a name="l02211"></a>02211           intersections(g.vertex_overlapfront,g.vertex_overlapfront,g.cell_global.size(),
<a name="l02212"></a>02212                                         g.send_vertex_overlapfront_overlapfront,g.recv_vertex_overlapfront_overlapfront);
<a name="l02213"></a>02213           intersections(g.vertex_overlap,g.vertex_overlapfront,g.cell_global.size(),
<a name="l02214"></a>02214                                         g.send_vertex_overlap_overlapfront,g.recv_vertex_overlapfront_overlap);
<a name="l02215"></a>02215           intersections(g.vertex_interiorborder,g.vertex_interiorborder,g.cell_global.size(),
<a name="l02216"></a>02216                                         g.send_vertex_interiorborder_interiorborder,g.recv_vertex_interiorborder_interiorborder);
<a name="l02217"></a>02217           intersections(g.vertex_interiorborder,g.vertex_overlapfront,g.cell_global.size(),
<a name="l02218"></a>02218                                         g.send_vertex_interiorborder_overlapfront,g.recv_vertex_overlapfront_interiorborder);
<a name="l02219"></a>02219 
<a name="l02220"></a>02220           <span class="comment">// return the whole thing</span>
<a name="l02221"></a>02221           <span class="keywordflow">return</span> g;
<a name="l02222"></a>02222         }
<a name="l02223"></a>02223 
<a name="l02224"></a>02224 
<a name="l02225"></a>02225         <span class="comment">// construct list of intersections with neighboring processors:</span>
<a name="l02226"></a>02226     <span class="comment">//   recvgrid: the grid stored in this processor</span>
<a name="l02227"></a>02227     <span class="comment">//   sendgrid:  the subgrid to be sent to neighboring processors</span>
<a name="l02228"></a>02228     <span class="comment">//   size: needed to shift local grid in periodic case</span>
<a name="l02229"></a>02229     <span class="comment">//   returns two lists: Intersections to be sent and Intersections to be received</span>
<a name="l02230"></a>02230         <span class="comment">// Note: sendgrid/recvgrid may be SubYGrids. Since intersection method is virtual it should work properly</span>
<a name="l02231"></a>02231         <span class="keywordtype">void</span> intersections (<span class="keyword">const</span> SubYGrid&lt;d,ct&gt;&amp; sendgrid, <span class="keyword">const</span> SubYGrid&lt;d,ct&gt;&amp; recvgrid, <span class="keyword">const</span> <a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a>&amp; size, 
<a name="l02232"></a>02232                                                 std::deque&lt;Intersection&gt;&amp; sendlist, std::deque&lt;Intersection&gt;&amp; recvlist)
<a name="l02233"></a>02233         {
<a name="l02234"></a>02234           <span class="comment">// the exchange buffers</span>
<a name="l02235"></a>02235           std::vector&lt;YGrid&lt;d,ct&gt; &gt; send_recvgrid(_torus.neighbors()); 
<a name="l02236"></a>02236           std::vector&lt;YGrid&lt;d,ct&gt; &gt; recv_recvgrid(_torus.neighbors());
<a name="l02237"></a>02237           std::vector&lt;YGrid&lt;d,ct&gt; &gt; send_sendgrid(_torus.neighbors()); 
<a name="l02238"></a>02238           std::vector&lt;YGrid&lt;d,ct&gt; &gt; recv_sendgrid(_torus.neighbors());
<a name="l02239"></a>02239 
<a name="l02240"></a>02240           <span class="comment">// fill send buffers; iterate over all neighboring processes</span>
<a name="l02241"></a>02241           <span class="comment">// non-periodic case is handled automatically because intersection will be zero</span>
<a name="l02242"></a>02242           <span class="keywordflow">for</span> (<span class="keyword">typename</span> Torus&lt;d&gt;::ProcListIterator i=_torus.sendbegin(); i!=_torus.sendend(); ++i)
<a name="l02243"></a>02243                 {
<a name="l02244"></a>02244                   <span class="comment">// determine if we communicate with this neighbor (and what)</span>
<a name="l02245"></a>02245                   <span class="keywordtype">bool</span> skip = <span class="keyword">false</span>;
<a name="l02246"></a>02246                   <a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a> coord = _torus.coord(); <span class="comment">// my coordinates</span>
<a name="l02247"></a>02247                   <a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a> delta = i.delta();      <span class="comment">// delta to neighbor</span>
<a name="l02248"></a>02248                   <a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a> nb = coord;             <span class="comment">// the neighbor</span>
<a name="l02249"></a>02249                   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;d; k++) nb[k] += delta[k];
<a name="l02250"></a>02250                   <a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a> v = <a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a>(0);                  <span class="comment">// grid movement</span>
<a name="l02251"></a>02251 
<a name="l02252"></a>02252                   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k&lt;d; k++)
<a name="l02253"></a>02253                         {
<a name="l02254"></a>02254                           <span class="keywordflow">if</span> (nb[k]&lt;0) 
<a name="l02255"></a>02255                                 {
<a name="l02256"></a>02256                                   <span class="keywordflow">if</span> (_periodic[k])
<a name="l02257"></a>02257                                         v[k] += size[k];
<a name="l02258"></a>02258                                   <span class="keywordflow">else</span>
<a name="l02259"></a>02259                                         skip = <span class="keyword">true</span>;
<a name="l02260"></a>02260                                 }
<a name="l02261"></a>02261                           <span class="keywordflow">if</span> (nb[k]&gt;=_torus.dims(k))
<a name="l02262"></a>02262                                 {
<a name="l02263"></a>02263                                   <span class="keywordflow">if</span> (_periodic[k])
<a name="l02264"></a>02264                                         v[k] -= size[k];
<a name="l02265"></a>02265                                   <span class="keywordflow">else</span>
<a name="l02266"></a>02266                                         skip = <span class="keyword">true</span>;
<a name="l02267"></a>02267                                 }
<a name="l02268"></a>02268                           <span class="comment">// neither might be true, then v=0</span>
<a name="l02269"></a>02269                         }
<a name="l02270"></a>02270 
<a name="l02271"></a>02271                   <span class="comment">// store moved grids in send buffers</span>
<a name="l02272"></a>02272                   <span class="keywordflow">if</span> (!skip)
<a name="l02273"></a>02273                         {
<a name="l02274"></a>02274                           send_sendgrid[i.index()] = sendgrid.move(v);
<a name="l02275"></a>02275                           send_recvgrid[i.index()] = recvgrid.move(v);
<a name="l02276"></a>02276                         }
<a name="l02277"></a>02277                   <span class="keywordflow">else</span>
<a name="l02278"></a>02278                         {
<a name="l02279"></a>02279                           send_sendgrid[i.index()] = YGrid&lt;d,ct&gt;(<a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a>(0),<a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a>(0),fTupel(0.0),fTupel(0.0));
<a name="l02280"></a>02280                           send_recvgrid[i.index()] = YGrid&lt;d,ct&gt;(<a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a>(0),<a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a>(0),fTupel(0.0),fTupel(0.0));
<a name="l02281"></a>02281                         }
<a name="l02282"></a>02282                 }
<a name="l02283"></a>02283 
<a name="l02284"></a>02284           <span class="comment">// issue send requests for sendgrid being sent to all neighbors</span>
<a name="l02285"></a>02285           <span class="keywordflow">for</span> (<span class="keyword">typename</span> Torus&lt;d&gt;::ProcListIterator i=_torus.sendbegin(); i!=_torus.sendend(); ++i)
<a name="l02286"></a>02286                 _torus.send(i.rank(), &amp;send_sendgrid[i.index()], <span class="keyword">sizeof</span>(YGrid&lt;d,ct&gt;));
<a name="l02287"></a>02287 
<a name="l02288"></a>02288           <span class="comment">// issue recv requests for sendgrids of neighbors</span>
<a name="l02289"></a>02289           <span class="keywordflow">for</span> (<span class="keyword">typename</span> Torus&lt;d&gt;::ProcListIterator i=_torus.recvbegin(); i!=_torus.recvend(); ++i)
<a name="l02290"></a>02290                 _torus.recv(i.rank(), &amp;recv_sendgrid[i.index()], <span class="keyword">sizeof</span>(YGrid&lt;d,ct&gt;));
<a name="l02291"></a>02291           
<a name="l02292"></a>02292           <span class="comment">// exchange the sendgrids</span>
<a name="l02293"></a>02293           _torus.exchange();
<a name="l02294"></a>02294 
<a name="l02295"></a>02295           <span class="comment">// issue send requests for recvgrid being sent to all neighbors</span>
<a name="l02296"></a>02296           <span class="keywordflow">for</span> (<span class="keyword">typename</span> Torus&lt;d&gt;::ProcListIterator i=_torus.sendbegin(); i!=_torus.sendend(); ++i)
<a name="l02297"></a>02297                 _torus.send(i.rank(), &amp;send_recvgrid[i.index()], <span class="keyword">sizeof</span>(YGrid&lt;d,ct&gt;));
<a name="l02298"></a>02298 
<a name="l02299"></a>02299           <span class="comment">// issue recv requests for recvgrid of neighbors</span>
<a name="l02300"></a>02300           <span class="keywordflow">for</span> (<span class="keyword">typename</span> Torus&lt;d&gt;::ProcListIterator i=_torus.recvbegin(); i!=_torus.recvend(); ++i)
<a name="l02301"></a>02301                 _torus.recv(i.rank(), &amp;recv_recvgrid[i.index()], <span class="keyword">sizeof</span>(YGrid&lt;d,ct&gt;));
<a name="l02302"></a>02302           
<a name="l02303"></a>02303           <span class="comment">// exchange the recvgrid</span>
<a name="l02304"></a>02304           _torus.exchange();
<a name="l02305"></a>02305 
<a name="l02306"></a>02306           <span class="comment">// process receive buffers and compute intersections</span>
<a name="l02307"></a>02307           <span class="keywordflow">for</span> (<span class="keyword">typename</span> Torus&lt;d&gt;::ProcListIterator i=_torus.recvbegin(); i!=_torus.recvend(); ++i)
<a name="l02308"></a>02308                 {
<a name="l02309"></a>02309                   <span class="comment">// what must be sent to this neighbor</span>
<a name="l02310"></a>02310                   Intersection send_intersection;
<a name="l02311"></a>02311                   send_intersection.grid = sendgrid.intersection(recv_recvgrid[i.index()]);
<a name="l02312"></a>02312 <span class="comment">//                std::cout &lt;&lt; "[" &lt;&lt; _torus.rank() &lt;&lt; "]:   " &lt;&lt; "sendgrid=" &lt;&lt; sendgrid &lt;&lt; std::endl;</span>
<a name="l02313"></a>02313 <span class="comment">//                std::cout &lt;&lt; "[" &lt;&lt; _torus.rank() &lt;&lt; "]:   " &lt;&lt; "recved recvgrid=" &lt;&lt; recv_recvgrid[i.index()] &lt;&lt; std::endl;</span>
<a name="l02314"></a>02314 <span class="comment">//                std::cout &lt;&lt; "[" &lt;&lt; _torus.rank() &lt;&lt; "]:   " &lt;&lt; "intersection=" &lt;&lt; send_intersection.grid &lt;&lt; std::endl;</span>
<a name="l02315"></a>02315                   send_intersection.rank = i.rank();
<a name="l02316"></a>02316                   send_intersection.distance = i.distance();
<a name="l02317"></a>02317                   <span class="keywordflow">if</span> (!send_intersection.grid.empty()) sendlist.push_front(send_intersection);
<a name="l02318"></a>02318 
<a name="l02319"></a>02319                   Intersection recv_intersection;
<a name="l02320"></a>02320                   recv_intersection.grid = recvgrid.intersection(recv_sendgrid[i.index()]);
<a name="l02321"></a>02321 <span class="comment">//                std::cout &lt;&lt; "[" &lt;&lt; _torus.rank() &lt;&lt; "]:   " &lt;&lt; "recvgrid=" &lt;&lt; recvgrid &lt;&lt; std::endl;</span>
<a name="l02322"></a>02322 <span class="comment">//                std::cout &lt;&lt; "[" &lt;&lt; _torus.rank() &lt;&lt; "]:   " &lt;&lt; "recved sendgrid=" &lt;&lt; recv_sendgrid[i.index()] &lt;&lt; std::endl;</span>
<a name="l02323"></a>02323 <span class="comment">//                std::cout &lt;&lt; "[" &lt;&lt; _torus.rank() &lt;&lt; "]:   " &lt;&lt; "intersection=" &lt;&lt; recv_intersection.grid &lt;&lt; std::endl;</span>
<a name="l02324"></a>02324                   recv_intersection.rank = i.rank();
<a name="l02325"></a>02325                   recv_intersection.distance = i.distance();
<a name="l02326"></a>02326                   <span class="keywordflow">if</span>(!recv_intersection.grid.empty()) recvlist.push_back(recv_intersection);
<a name="l02327"></a>02327                 }
<a name="l02328"></a>02328         }
<a name="l02329"></a>02329 
<a name="l02330"></a>02330         <span class="comment">// private data of multigrid</span>
<a name="l02331"></a>02331         fTupel _LL;
<a name="l02332"></a>02332         <a class="code" href="a00219.html#4c670115b7f9193be23094be737a3c39" title="define types used for arguments">iTupel</a> _s;
<a name="l02333"></a>02333         bTupel _periodic;
<a name="l02334"></a>02334         <span class="keywordtype">int</span> _maxlevel;
<a name="l02335"></a>02335         YGridLevel _levels[32];
<a name="l02336"></a>02336         <span class="keywordtype">int</span> _overlap;
<a name="l02337"></a>02337         Torus&lt;d&gt; _torus;
<a name="l02338"></a>02338   };
<a name="l02339"></a>02339 
<a name="l02341"></a>02341   <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> d, <span class="keyword">class</span> ct&gt;
<a name="l02342"></a><a class="code" href="a00441.html#7d611caf63221ff20b78384857a4c893">02342</a>   <span class="keyword">inline</span> std::ostream&amp; operator&lt;&lt; (std::ostream&amp; s, MultiYGrid&lt;d,ct&gt;&amp; mg)
<a name="l02343"></a>02343   {
<a name="l02344"></a>02344         mg.print(s);
<a name="l02345"></a>02345         s &lt;&lt; std::endl;
<a name="l02346"></a>02346         <span class="keywordflow">return</span> s;
<a name="l02347"></a>02347   }
<a name="l02348"></a>02348 
<a name="l02349"></a>02349 } <span class="comment">// namespace Dune</span>
<a name="l02350"></a>02350 
<a name="l02351"></a>02351 <span class="preprocessor">#endif</span>
</pre></div></div>
</div> <!-- end doxygen -->
</div> <!-- end main -->
<div class="foot">

<p class="foot">
  Generated on 6 Nov 2008 with <a
  href="http://www.doxygen.org/">Doxygen</a> (ver 1.5.6)  
  [<a href="doxygen.log">logfile</a>].
</p>

</div>

</body>
</html>
