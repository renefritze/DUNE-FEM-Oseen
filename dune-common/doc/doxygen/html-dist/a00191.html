<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN""http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>dune-common: Common (dune-common )</title>
  <link rel="stylesheet" type="text/css" href="./dune-doxy.css">
  <link rel="stylesheet" type="text/css" href="./tabs.css">
</head>
<div class="main">
<div class="doxygen">
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Common</h1>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html">alignment.hh</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This file implements a template class to determine alignment requirements at compile time. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00147.html">dlist.hh</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html">gcd.hh</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00162.html">lcm.hh</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html">sllist.hh</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This file implements a single linked list together with the necessary iterators. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00176.html">stack.hh</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00180.html">timer.hh</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A simple timing class. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00181.html">tuples.hh</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Contains classes that implement tuples. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Modules</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00192.html">GeometryType</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00193.html">Parallel Communication</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00194.html">Debug output</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html">Exception handling</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00196.html">Dense Matrix and Vector Template Library</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00198.html">Iterator facades</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterator facades for writing stl conformant iterators. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html">Dune::AlignmentStruct&lt; T &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00001.html">Dune::AlignmentHelper&lt; T, N &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html">Dune::AlignmentOf&lt; T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates the alignment properties of a type.  <a href="a00002.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html">Dune::Array&lt; T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A simple dynamic <a class="el" href="a00004.html" title="Simple fixed size array class.">array</a> class.  <a href="a00005.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00007.html">Dune::ArrayList&lt; T, N, A &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A dynamically growing random access list.  <a href="a00007.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00008.html">Dune::ArrayListIterator&lt; T, N, A &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A random access iterator for the <a class="el" href="a00007.html" title="A dynamically growing random access list.">Dune::ArrayList</a> class.  <a href="a00008.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html">Dune::ConstArrayListIterator&lt; T, N, A &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A constant random access iterator for the <a class="el" href="a00007.html" title="A dynamically growing random access list.">Dune::ArrayList</a> class.  <a href="a00026.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html">Dune::bigunsignedint&lt; k &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Portable very large unsigned integers.  <a href="a00013.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html">Dune::BitField</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A dynamic <a class="el" href="a00004.html" title="Simple fixed size array class.">array</a> of booleans<p>
This class is basically std::vector&lt;bool&gt;, but with a few added methods.  <a href="a00014.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00024.html">Dune::ConfigParser</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parser for hierarchical configuration files<p>
This class parses config files into a hierarchical structure. Config files should look like this.  <a href="a00024.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html">Dune::DoubleLinkedListError</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">exception thrown on illegal element access  <a href="a00035.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00033.html">Dune::DoubleLinkedList&lt; T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">(DEPRECATED) A doubly-linked list  <a href="a00033.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00034.html">Dune::DoubleLinkedList&lt; T &gt;::Iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="a00034.html" title="Iterator class for the doubly-linked list.">Iterator</a> class for the doubly-linked list.  <a href="a00034.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00039.html">Dune::EmptySet&lt; TA &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An empty set.  <a href="a00039.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00042.html">Dune::EnumItem&lt; TA, item &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A set consisting only of one item.  <a href="a00042.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00043.html">Dune::EnumRange&lt; T, from, end &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A set representing a range including the borders.  <a href="a00043.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html">Dune::NegateSet&lt; S &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The negation of a set. An item is contained in the set if and only if it is not contained in the negated set.  <a href="a00090.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00021.html">Dune::Combine&lt; TI1, TI2, TA &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A set combining two other sets.  <a href="a00021.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html">Dune::array&lt; T, N &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple fixed size <a class="el" href="a00004.html" title="Simple fixed size array class.">array</a> class.  <a href="a00004.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00054.html">Dune::FixedArray&lt; T, N &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Simple fixed size <a class="el" href="a00004.html" title="Simple fixed size array class.">array</a> class.  <a href="a00054.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00064.html">Dune::GcdHelper&lt; a, b, bo &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper for calculating the gcd.  <a href="a00064.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html">Dune::Gcd&lt; a, b &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculator of the greatest common divisor.  <a href="a00063.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00085.html">Dune::Lcm&lt; m, n &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the least common multiple of two numbers.  <a href="a00085.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html">Dune::Power_m_p&lt; m, p &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates m^p at compile time.  <a href="a00102.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html">Dune::Power_m_p&lt; m, 0 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">end of recursion via specialization  <a href="a00103.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html">Dune::Factorial&lt; m &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates the factorial of m at compile time.  <a href="a00045.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00046.html">Dune::Factorial&lt; 0 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">end of recursion of factorial via specialization  <a href="a00046.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00099.html">Dune::Pool&lt; T, s &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A memory pool of objects.  <a href="a00099.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00100.html">Dune::PoolAllocator&lt; T, s &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An allocator managing a pool of objects for reuse.  <a href="a00100.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00116.html">Dune::SLList&lt; T, A &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A single linked list.  <a href="a00116.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00118.html">Dune::SLListIterator&lt; T, A &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A mutable iterator for the <a class="el" href="a00116.html" title="A single linked list.">SLList</a>.  <a href="a00118.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html">Dune::SLListConstIterator&lt; T, A &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A constant iterator for the <a class="el" href="a00116.html" title="A single linked list.">SLList</a>.  <a href="a00117.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html">Dune::SLListModifyIterator&lt; T, A &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A mutable iterator for the <a class="el" href="a00116.html" title="A single linked list.">SLList</a>.  <a href="a00119.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html">Dune::SmartPointer&lt; T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A reference counting smart pointer.  <a href="a00120.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00122.html">Dune::StackException</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="a00044.html" title="Base class for Dune-Exceptions.">Exception</a> thrown by the stack.  <a href="a00122.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00121.html">Dune::Stack&lt; T &gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html">Dune::FiniteStack&lt; T, n &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A stack with static memory allocation.  <a href="a00053.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00125.html">Dune::TimerError</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Exception thrown by the <a class="el" href="a00124.html" title="A simple stop watch.">Timer</a> class  <a href="a00125.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00124.html">Dune::Timer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A simple stop watch.  <a href="a00124.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00091.html">Dune::Nil</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An empty class.  <a href="a00091.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html">Dune::Pair&lt; T1, TT &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a> consisting of two objects.  <a href="a00096.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00097.html">Dune::Pair&lt; T1, Nil &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a> consisting of one object. Specialization of <a class="el" href="a00096.html" title="A tuple consisting of two objects.">Pair</a> that really is a single value.  <a href="a00097.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00130.html">Dune::TupleToPairs&lt; T1, T2, T3, T4, T5, T6, T7, T8, T9 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts the Tuple to a list of pairs.  <a href="a00130.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00131.html">Dune::TupleToPairs&lt; T1, Nil, Nil, Nil, Nil, Nil, Nil, Nil, Nil &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Specialization for a <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a> consisting only of one type.  <a href="a00131.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00126.html">Dune::tuple&lt; T1, T2, T3, T4, T5, T6, T7, T8, T9 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A Tuple of objects.  <a href="a00126.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00127.html">Dune::tuple_element&lt; N, Tuple &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the type of the N-th element of the <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a>.  <a href="a00127.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html">Dune::tuple_element&lt; 0, Pair&lt; T1, T2 &gt; &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the type of the first element of the <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a>.  <a href="a00128.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html">Dune::Element&lt; N &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the N-th element of a <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a>.  <a href="a00036.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html">Dune::Element&lt; 0 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the first element of a <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a>.  <a href="a00037.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html">Dune::tuple_size&lt; T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Template meta_programm to query the size of a <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a>.  <a href="a00129.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00038.html">Dune::Empty</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Just an empty class.  <a href="a00038.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00132.html">Dune::TypeTraits&lt; T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">General type traits class to check whether type is reference or pointer type.  <a href="a00132.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00025.html">Dune::ConstantVolatileTraits&lt; T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines wether a type is const or volatile and provides the unqualified types.  <a href="a00025.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00082.html">Dune::IsVolatile&lt; T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tests wether a type is volatile.  <a href="a00082.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00078.html">Dune::IsConst&lt; T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tests wether a type is constant.  <a href="a00078.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html">Dune::remove_const&lt; T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes a const qualifier while preserving others.  <a href="a00109.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html">Dune::RemoveConst&lt; T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes a const qualifier while preserving others.  <a href="a00110.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00028.html">Dune::Conversion&lt; From, To &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks wether a type is derived from another.  <a href="a00028.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html">Dune::IsInteroperable&lt; T1, T2 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks wether two types are interoperable.  <a href="a00080.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00040.html">Dune::EnableIf&lt; b, T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable typedef if condition is met.  <a href="a00040.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00041.html">Dune::EnableIfInterOperable&lt; T1, T2, Type &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable typedef if two types are interoperable.  <a href="a00041.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00077.html">Dune::is_same&lt; T1, T2 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compile time test for testing whether two types are the same.  <a href="a00077.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00111.html">Dune::SameType&lt; T1, T2 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compile time test for testing whether two types are the same.  <a href="a00111.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html">Dune::SameType&lt; T, T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compile time test for testing whether two types are the same.  <a href="a00112.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00113.html">Dune::SelectType&lt; first, T1, T2 &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Select a type based on a condition.  <a href="a00113.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gdefacd67926b31f38dcc996d275ff1e7"></a><!-- doxytag: member="Common::size_type" ref="gdefacd67926b31f38dcc996d275ff1e7" args="" -->
typedef A::size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gdefacd67926b31f38dcc996d275ff1e7">Dune::SLList::size_type</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The size type. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g9548258d3f4de56a110c6f549780ec2a"></a><!-- doxytag: member="Common::MemberType" ref="g9548258d3f4de56a110c6f549780ec2a" args="" -->
typedef T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g9548258d3f4de56a110c6f549780ec2a">Dune::SLList::MemberType</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type we store. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g532745b2d9cf125023ffed1acd31d75c"></a><!-- doxytag: member="Common::Allocator" ref="g532745b2d9cf125023ffed1acd31d75c" args="" -->
typedef A::template rebind<br>
&lt; Element &gt;::other&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g532745b2d9cf125023ffed1acd31d75c">Dune::SLList::Allocator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The allocator to use. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g543a8c5a50d30cd488550f5e99161754"></a><!-- doxytag: member="Common::iterator" ref="g543a8c5a50d30cd488550f5e99161754" args="" -->
typedef SLListIterator&lt; T, A &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g543a8c5a50d30cd488550f5e99161754">Dune::SLList::iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The mutable iterator of the list. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga026efcc562ed6ef620e4a96f26a393e"></a><!-- doxytag: member="Common::const_iterator" ref="ga026efcc562ed6ef620e4a96f26a393e" args="" -->
typedef SLListConstIterator&lt; T, A &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#ga026efcc562ed6ef620e4a96f26a393e">Dune::SLList::const_iterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The mutable iterator of the list. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gac398614c243228cc0f7678b6c70007b"></a><!-- doxytag: member="Common::ModifyIterator" ref="gac398614c243228cc0f7678b6c70007b" args="" -->
typedef SLListModifyIterator<br>
&lt; T, A &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gac398614c243228cc0f7678b6c70007b">Dune::SLList::ModifyIterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the iterator capable of deletion and insertion. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga3b5f6009f07a9094f9dcfd6b247530c"></a><!-- doxytag: member="Common::Type2" ref="ga3b5f6009f07a9094f9dcfd6b247530c" args="" -->
typedef TT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#ga3b5f6009f07a9094f9dcfd6b247530c">Dune::Pair::Type2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the second field. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g414b8bfade23db170fe3d6972a2f86fb"></a><!-- doxytag: member="Common::Type2" ref="g414b8bfade23db170fe3d6972a2f86fb" args="" -->
typedef Nil&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g414b8bfade23db170fe3d6972a2f86fb">Dune::Pair&lt; T1, Nil &gt;::Type2</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The type of the (non-existent) second field is <a class="el" href="a00091.html" title="An empty class.">Nil</a>. This typedef is useful in template metaprogramming, since it allows you to specialise for <a class="el" href="a00091.html" title="An empty class.">Nil</a> instead of Pair&lt;T, Nil&gt;. <br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g367c716781c800a0335a4cb60cb97ef9"></a><!-- doxytag: member="Common::Iterator" ref="g367c716781c800a0335a4cb60cb97ef9" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g367c716781c800a0335a4cb60cb97ef9">Dune::DoubleLinkedList::Iterator::Iterator</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">constructor <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gb72bc346b5e1ea4741140b8630996421"></a><!-- doxytag: member="Common::operator!=" ref="gb72bc346b5e1ea4741140b8630996421" args="(Iterator x) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gb72bc346b5e1ea4741140b8630996421">Dune::DoubleLinkedList::Iterator::operator!=</a> (Iterator x) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">comparison <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gb324a5a994d8b13a3a9f30b79c09d2b7"></a><!-- doxytag: member="Common::operator==" ref="gb324a5a994d8b13a3a9f30b79c09d2b7" args="(Iterator x) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gb324a5a994d8b13a3a9f30b79c09d2b7">Dune::DoubleLinkedList::Iterator::operator==</a> (Iterator x) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">comparison <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g5772235401f39b35073325c6e158adcc"></a><!-- doxytag: member="Common::operator++" ref="g5772235401f39b35073325c6e158adcc" args="()" -->
Iterator &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g5772235401f39b35073325c6e158adcc">Dune::DoubleLinkedList::Iterator::operator++</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prefix increment. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g515506f269377dc113837a789a42c68c"></a><!-- doxytag: member="Common::operator++" ref="g515506f269377dc113837a789a42c68c" args="(int)" -->
Iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g515506f269377dc113837a789a42c68c">Dune::DoubleLinkedList::Iterator::operator++</a> (int)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Postfix increment. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gea426d5f8f52284073283f3905ddf072"></a><!-- doxytag: member="Common::operator--" ref="gea426d5f8f52284073283f3905ddf072" args="()" -->
Iterator &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gea426d5f8f52284073283f3905ddf072">Dune::DoubleLinkedList::Iterator::operator--</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prefix decrement. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gc15c74c47e9fd2c1ff53148cbaf0a906"></a><!-- doxytag: member="Common::operator--" ref="gc15c74c47e9fd2c1ff53148cbaf0a906" args="(int)" -->
Iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gc15c74c47e9fd2c1ff53148cbaf0a906">Dune::DoubleLinkedList::Iterator::operator--</a> (int)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Postfix decrement. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g86581c9afeeed0800d909b0363962352"></a><!-- doxytag: member="Common::operator*" ref="g86581c9afeeed0800d909b0363962352" args="() const " -->
T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g86581c9afeeed0800d909b0363962352">Dune::DoubleLinkedList::Iterator::operator*</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">dereferenciation <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga6a7ea5c78ffa26ca301c7cdd1a6b009"></a><!-- doxytag: member="Common::operator-&gt;" ref="ga6a7ea5c78ffa26ca301c7cdd1a6b009" args="() const " -->
T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#ga6a7ea5c78ffa26ca301c7cdd1a6b009">Dune::DoubleLinkedList::Iterator::operator-&gt;</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">dereferenciation (Stroustrup p. 289) <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g5232db15328f8b619f1b2c9fbe32b904"></a><!-- doxytag: member="Common::begin" ref="g5232db15328f8b619f1b2c9fbe32b904" args="() const " -->
Iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g5232db15328f8b619f1b2c9fbe32b904">Dune::DoubleLinkedList::begin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">iterator at the lists start <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g626117ab80aca67d0eb4e8aa4b8bf778"></a><!-- doxytag: member="Common::end" ref="g626117ab80aca67d0eb4e8aa4b8bf778" args="() const " -->
Iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g626117ab80aca67d0eb4e8aa4b8bf778">Dune::DoubleLinkedList::end</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">iterator behind last element <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gfdee29afadbf340e33e0141a18b06212"></a><!-- doxytag: member="Common::rbegin" ref="gfdee29afadbf340e33e0141a18b06212" args="() const " -->
Iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gfdee29afadbf340e33e0141a18b06212">Dune::DoubleLinkedList::rbegin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">iterator at the lists end <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g63e754e12dcbe6a1f27a1e5d29878ea6"></a><!-- doxytag: member="Common::rend" ref="g63e754e12dcbe6a1f27a1e5d29878ea6" args="() const " -->
Iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g63e754e12dcbe6a1f27a1e5d29878ea6">Dune::DoubleLinkedList::rend</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">iterator before the lists start <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gbb1dd499be1f8b49945a07a9a971f620"></a><!-- doxytag: member="Common::DoubleLinkedList" ref="gbb1dd499be1f8b49945a07a9a971f620" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gbb1dd499be1f8b49945a07a9a971f620">Dune::DoubleLinkedList::DoubleLinkedList</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">empty constructor <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g0ffa85a17e362a133bfc56c3e6ba3f84"></a><!-- doxytag: member="Common::DoubleLinkedList" ref="g0ffa85a17e362a133bfc56c3e6ba3f84" args="(const DoubleLinkedList&lt; T &gt; &amp;)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g0ffa85a17e362a133bfc56c3e6ba3f84">Dune::DoubleLinkedList::DoubleLinkedList</a> (const DoubleLinkedList&lt; T &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">copy constructor <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ge64545fbec39f4c61bb6e241863939c3"></a><!-- doxytag: member="Common::~DoubleLinkedList" ref="ge64545fbec39f4c61bb6e241863939c3" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#ge64545fbec39f4c61bb6e241863939c3">Dune::DoubleLinkedList::~DoubleLinkedList</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">destructor <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g663f2935736736d48b59e2a629011689"></a><!-- doxytag: member="Common::operator=" ref="g663f2935736736d48b59e2a629011689" args="(const DoubleLinkedList&lt; T &gt; &amp;)" -->
DoubleLinkedList&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g663f2935736736d48b59e2a629011689">Dune::DoubleLinkedList::operator=</a> (const DoubleLinkedList&lt; T &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deep copy operator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g75ce2593a9788c449289be5186cfd0bb"></a><!-- doxytag: member="Common::size" ref="g75ce2593a9788c449289be5186cfd0bb" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g75ce2593a9788c449289be5186cfd0bb">Dune::DoubleLinkedList::size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">current list size <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gbfbcf518444b122ccb4d99633503af1f">Dune::DoubleLinkedList::insert_after</a> (Iterator i, T &amp;t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">insert after an iterators position  <a href="#gbfbcf518444b122ccb4d99633503af1f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gec092c60a4aa05df72763263cbfa82e7">Dune::DoubleLinkedList::insert_before</a> (Iterator i, T &amp;t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">insert before an iterators position  <a href="#gec092c60a4aa05df72763263cbfa82e7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g55ffaaa44cadeb4c2e619c2ca1b25266"></a><!-- doxytag: member="Common::erase" ref="g55ffaaa44cadeb4c2e619c2ca1b25266" args="(Iterator i)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g55ffaaa44cadeb4c2e619c2ca1b25266">Dune::DoubleLinkedList::erase</a> (Iterator i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">remove selected element <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gd6896f6b80873c335514bc4385e652e7"></a><!-- doxytag: member="Common::operator&lt;&lt;" ref="gd6896f6b80873c335514bc4385e652e7" args="(std::ostream &amp;s, array&lt; T, N &gt; e)" -->
template&lt;class T, int N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00191.html#gd6896f6b80873c335514bc4385e652e7">Dune::operator&lt;&lt;</a> (std::ostream &amp;s, array&lt; T, N &gt; e)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output operator for <a class="el" href="a00004.html" title="Simple fixed size array class.">array</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gdc92e178fa360c5a520ad3eb8dd8a5cd"></a><!-- doxytag: member="Common::operator&lt;&lt;" ref="gdc92e178fa360c5a520ad3eb8dd8a5cd" args="(std::ostream &amp;s, FixedArray&lt; T, N &gt; e)" -->
template&lt;class T, int N&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00191.html#gdc92e178fa360c5a520ad3eb8dd8a5cd">Dune::operator&lt;&lt;</a> (std::ostream &amp;s, FixedArray&lt; T, N &gt; e)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Output operator for <a class="el" href="a00054.html" title="Simple fixed size array class.">FixedArray</a>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g6ce9aae11b9cc4fe70872e544cd161d5"></a><!-- doxytag: member="Common::sign" ref="g6ce9aae11b9cc4fe70872e544cd161d5" args="(const T &amp;val)" -->
template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00191.html#g6ce9aae11b9cc4fe70872e544cd161d5">Dune::sign</a> (const T &amp;val)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the sign of the value. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ge1652549f4e44e2b24ea58ded031c22a"></a><!-- doxytag: member="Common::SQR" ref="ge1652549f4e44e2b24ea58ded031c22a" args="(T t)" -->
template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00191.html#ge1652549f4e44e2b24ea58ded031c22a">Dune::SQR</a> (T t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the square of T. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ge8918274799a3243e56948734fe80cef"></a><!-- doxytag: member="Common::genFilename" ref="ge8918274799a3243e56948734fe80cef" args="(const std::string &amp;path, const std::string &amp;fn, int ntime, int precision=6)" -->
std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#ge8918274799a3243e56948734fe80cef">Dune::genFilename</a> (const std::string &amp;path, const std::string &amp;fn, int ntime, int precision=6)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate filenames with timestep number in it. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gb097c05f186dacbbdd11361de5b2500f"></a><!-- doxytag: member="Common::SLList" ref="gb097c05f186dacbbdd11361de5b2500f" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gb097c05f186dacbbdd11361de5b2500f">Dune::SLList::SLList</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="gc2a83336a9806fc2689189580d64f328"></a><!-- doxytag: member="Common::SLList" ref="gc2a83336a9806fc2689189580d64f328" args="(const SLList&lt; T1, A1 &gt; &amp;other)" -->
template&lt;typename T1, typename A1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00191.html#gc2a83336a9806fc2689189580d64f328">Dune::SLList::SLList</a> (const SLList&lt; T1, A1 &gt; &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor with type conversion. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g72a901265ef5d3658dceb0f7bd6a0782"></a><!-- doxytag: member="Common::SLList" ref="g72a901265ef5d3658dceb0f7bd6a0782" args="(const SLList&lt; T, A &gt; &amp;other)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g72a901265ef5d3658dceb0f7bd6a0782">Dune::SLList::SLList</a> (const SLList&lt; T, A &gt; &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gfa3231a07e56ae81cc6334e19d603a23">Dune::SLList::~SLList</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#gfa3231a07e56ae81cc6334e19d603a23"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g9f0eb5f84602ae9120178e2e9659bc41"></a><!-- doxytag: member="Common::operator=" ref="g9f0eb5f84602ae9120178e2e9659bc41" args="(const SLList&lt; T, A &gt; &amp;other)" -->
SLList&lt; T, A &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g9f0eb5f84602ae9120178e2e9659bc41">Dune::SLList::operator=</a> (const SLList&lt; T, A &gt; &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g0a71f761f2ee2a6d5c72c5b8b6b60f0e">Dune::SLList::push_back</a> (const MemberType &amp;item)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new entry to the end of the list.  <a href="#g0a71f761f2ee2a6d5c72c5b8b6b60f0e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g07373aa465c1db378233026b89420275">Dune::SLList::push_front</a> (const MemberType &amp;item)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a new entry to the beginning of the list.  <a href="#g07373aa465c1db378233026b89420275"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gc40778d9f4576908734ed49890c26a93"></a><!-- doxytag: member="Common::pop_front" ref="gc40778d9f4576908734ed49890c26a93" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gc40778d9f4576908734ed49890c26a93">Dune::SLList::pop_front</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the first item in the list. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g91a8c67d17ae6595ee2f5eca3a2df144"></a><!-- doxytag: member="Common::clear" ref="g91a8c67d17ae6595ee2f5eca3a2df144" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g91a8c67d17ae6595ee2f5eca3a2df144">Dune::SLList::clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove all elements from the list. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gff151c44f4a1e43ab0b2f0cf55bab6f8">Dune::SLList::begin</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator pointing to the first element in the list.  <a href="#gff151c44f4a1e43ab0b2f0cf55bab6f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g302758547958e3d1159058578037fdbf">Dune::SLList::begin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator pointing to the first element in the list.  <a href="#g302758547958e3d1159058578037fdbf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ModifyIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g9f0cfc5d3be7b2719e938face53b832f">Dune::SLList::beginModify</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator capable of deleting and inserting elements.  <a href="#g9f0cfc5d3be7b2719e938face53b832f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">ModifyIterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g1859abb70b39f6cd675d5d1f6c23a5e0">Dune::SLList::endModify</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator capable of deleting and inserting elements.  <a href="#g1859abb70b39f6cd675d5d1f6c23a5e0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g8eee1922ee4cf09e85c03af4ceef39ed">Dune::SLList::end</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator pointing to the end of the list.  <a href="#g8eee1922ee4cf09e85c03af4ceef39ed"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g79b03872a4227720653e9c6e13916f63">Dune::SLList::end</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator pointing to the end of the list.  <a href="#g79b03872a4227720653e9c6e13916f63"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gc74361d124cf27c5e7384a66b9bcda02">Dune::SLList::empty</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check whether the list is empty.  <a href="#gc74361d124cf27c5e7384a66b9bcda02"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g7793abbcf5b154130d6d824c93be9c5d"></a><!-- doxytag: member="Common::size" ref="g7793abbcf5b154130d6d824c93be9c5d" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g7793abbcf5b154130d6d824c93be9c5d">Dune::SLList::size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of elements the list contains. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gc2d3d84935e5b39ca1bd6d6c8391f0f6">Dune::SLListIterator::dereference</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dereferencing function for the iterator facade.  <a href="#gc2d3d84935e5b39ca1bd6d6c8391f0f6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gf63a1bd5ca049d868a51d8b1980626ed">Dune::SLListIterator::equals</a> (const SLListConstIterator&lt; T, A &gt; &amp;other) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Equality test for the iterator facade.  <a href="#gf63a1bd5ca049d868a51d8b1980626ed"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g505c5ed0d921eb390a6878002db2d86a">Dune::SLListIterator::equals</a> (const SLListIterator&lt; T, A &gt; &amp;other) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Equality test for the iterator facade.  <a href="#g505c5ed0d921eb390a6878002db2d86a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g9644fc7ba7f428fffe069a2b64bb063d">Dune::SLListIterator::equals</a> (const SLListModifyIterator&lt; T, A &gt; &amp;other) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Equality test for the iterator facade.  <a href="#g9644fc7ba7f428fffe069a2b64bb063d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gc484c101bf8dac91cf42c87ab4095c1b"></a><!-- doxytag: member="Common::increment" ref="gc484c101bf8dac91cf42c87ab4095c1b" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gc484c101bf8dac91cf42c87ab4095c1b">Dune::SLListIterator::increment</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increment function for the iterator facade. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g95dbf81fd02659c2c72c2f3e08c14148">Dune::SLListIterator::insertAfter</a> (const T &amp;v) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert an element in the underlying list after the current position.  <a href="#g95dbf81fd02659c2c72c2f3e08c14148"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g3bcdf1643346941a6ee1da08ad58906b">Dune::SLListIterator::deleteNext</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete the entry after the current position.  <a href="#g3bcdf1643346941a6ee1da08ad58906b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g783fbeb76a0111524727d09e15a40a48">Dune::SLListConstIterator::dereference</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dereferencing function for the facade.  <a href="#g783fbeb76a0111524727d09e15a40a48"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g90d32112d46785cf69962f5913eed2d4">Dune::SLListConstIterator::equals</a> (const SLListConstIterator&lt; T, A &gt; &amp;other) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Equality test for the iterator facade.  <a href="#g90d32112d46785cf69962f5913eed2d4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gf7b6b1990f6bf2abeadd60f3ae813bd8"></a><!-- doxytag: member="Common::increment" ref="gf7b6b1990f6bf2abeadd60f3ae813bd8" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gf7b6b1990f6bf2abeadd60f3ae813bd8">Dune::SLListConstIterator::increment</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increment function for the iterator facade. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#ga8802093ad519c06d8341fa704cdb1cb">Dune::SLListModifyIterator::dereference</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dereferencing function for the iterator facade.  <a href="#ga8802093ad519c06d8341fa704cdb1cb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g9805d4f139dbfc5012ed7cc2529e4d04">Dune::SLListModifyIterator::equals</a> (const SLListConstIterator&lt; T, A &gt; &amp;other) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test whether another iterator is equal.  <a href="#g9805d4f139dbfc5012ed7cc2529e4d04"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#ga10e4670355e1294786f738733e944cc">Dune::SLListModifyIterator::equals</a> (const SLListIterator&lt; T, A &gt; &amp;other) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test whether another iterator is equal.  <a href="#ga10e4670355e1294786f738733e944cc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g8ac0a9ab1ee0a848b0b22c43b1bd36a5">Dune::SLListModifyIterator::equals</a> (const SLListModifyIterator&lt; T, A &gt; &amp;other) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test whether another iterator is equal.  <a href="#g8ac0a9ab1ee0a848b0b22c43b1bd36a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gf185b8fbd19f5e6aa881f94781f97ea0"></a><!-- doxytag: member="Common::increment" ref="gf185b8fbd19f5e6aa881f94781f97ea0" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gf185b8fbd19f5e6aa881f94781f97ea0">Dune::SLListModifyIterator::increment</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increment function for the iterator facade. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gb584227c678fe14379ab64bf38e90fc3">Dune::SLListModifyIterator::insert</a> (const T &amp;v)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert an element at the current position.  <a href="#gb584227c678fe14379ab64bf38e90fc3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#ge1aa043816f91daf4d1cc0d680b6cec0">Dune::SLListModifyIterator::remove</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete the entry at the current position.  <a href="#ge1aa043816f91daf4d1cc0d680b6cec0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g815d1f5734f751d3a9746f3048158145"></a><!-- doxytag: member="Common::full" ref="g815d1f5734f751d3a9746f3048158145" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g815d1f5734f751d3a9746f3048158145">Dune::Stack::full</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Always returns false because the stack is never full. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g54cde592fba7dee7e361e76d58f3b6cb"></a><!-- doxytag: member="Common::push" ref="g54cde592fba7dee7e361e76d58f3b6cb" args="(T &amp;t)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g54cde592fba7dee7e361e76d58f3b6cb">Dune::Stack::push</a> (T &amp;t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Put a new object onto the stack. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g3c38e6b3fffdd7c57ee22fcf5654d4ad"></a><!-- doxytag: member="Common::pop" ref="g3c38e6b3fffdd7c57ee22fcf5654d4ad" args="()" -->
T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g3c38e6b3fffdd7c57ee22fcf5654d4ad">Dune::Stack::pop</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes and returns the uppermost object from the stack. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g0f4d497f7a7757611f917c17f2be98f9"></a><!-- doxytag: member="Common::top" ref="g0f4d497f7a7757611f917c17f2be98f9" args="() const " -->
T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g0f4d497f7a7757611f917c17f2be98f9">Dune::Stack::top</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the uppermost object from the stack. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gf153d38e4e856d78cead720ce6739714"></a><!-- doxytag: member="Common::size" ref="gf153d38e4e856d78cead720ce6739714" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gf153d38e4e856d78cead720ce6739714">Dune::Stack::size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of elements on the stack. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gc9c044d3d38f48621ba904f62168478a"></a><!-- doxytag: member="Common::full" ref="gc9c044d3d38f48621ba904f62168478a" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gc9c044d3d38f48621ba904f62168478a">Dune::FiniteStack::full</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the stack is full. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g66d7a817640b3781f6b22c77351d1a42"></a><!-- doxytag: member="Common::push" ref="g66d7a817640b3781f6b22c77351d1a42" args="(const T &amp;t)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g66d7a817640b3781f6b22c77351d1a42">Dune::FiniteStack::push</a> (const T &amp;t)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Puts a new object onto the stack. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g2be3f2742211133fcdabed835302bc77"></a><!-- doxytag: member="Common::pop" ref="g2be3f2742211133fcdabed835302bc77" args="()" -->
T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g2be3f2742211133fcdabed835302bc77">Dune::FiniteStack::pop</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes and returns the uppermost object from the stack. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g436549636fbe1766dcf63ee6eb5da187"></a><!-- doxytag: member="Common::top" ref="g436549636fbe1766dcf63ee6eb5da187" args="() const " -->
T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g436549636fbe1766dcf63ee6eb5da187">Dune::FiniteStack::top</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the uppermost object on the stack. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g65547a6b86f7d20fb71aa24b4ecaeac0"></a><!-- doxytag: member="Common::size" ref="g65547a6b86f7d20fb71aa24b4ecaeac0" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g65547a6b86f7d20fb71aa24b4ecaeac0">Dune::FiniteStack::size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dynamic stacksize. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga60b6a07f442dfd7aef80ab7af1927e8"></a><!-- doxytag: member="Common::FiniteStack" ref="ga60b6a07f442dfd7aef80ab7af1927e8" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#ga60b6a07f442dfd7aef80ab7af1927e8">Dune::FiniteStack::FiniteStack</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes empty stack. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00191.html#gb1d5499b4b8f3d3d2c71fbefdc2c8200">Dune::Pair::Pair</a> (typename TupleAccessTraits&lt; T1 &gt;::ParameterType t1, T2 &amp;t2, T3 &amp;t3, T4 &amp;t4, T5 &amp;t5, T6 &amp;t6, T7 &amp;t7, T8 &amp;t8, T9 &amp;t9)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of values we hold.  <a href="#gb1d5499b4b8f3d3d2c71fbefdc2c8200"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g9fbcf451ebc1a0bc143e8d32c681d107">Dune::Pair::Pair</a> (typename TupleAccessTraits&lt; Type1 &gt;::ParameterType t1, TT &amp;t2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#g9fbcf451ebc1a0bc143e8d32c681d107"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename U1, typename U2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00191.html#g08933df7ca2fa89f08035246e3ac9210">Dune::Pair::Pair</a> (const Pair&lt; U1, U2 &gt; &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy Constructor for implicit type conversion.  <a href="#g08933df7ca2fa89f08035246e3ac9210"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename U1, typename U2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Pair &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00191.html#gb74608fd7b95e4af09e8006222e21d7f">Dune::Pair::operator=</a> (const Pair&lt; U1, U2 &gt; &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator for implicit type conversion.  <a href="#gb74608fd7b95e4af09e8006222e21d7f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TupleAccessTraits&lt; Type1 &gt;<br>
::NonConstType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gbe61b0c28b4d21174ececf45db15a478">Dune::Pair::first</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the first value.  <a href="#gbe61b0c28b4d21174ececf45db15a478"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TupleAccessTraits&lt; Type1 &gt;<br>
::ConstType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gfc42133f1c2e07ef6ffda6b0809ec9ef">Dune::Pair::first</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the first value.  <a href="#gfc42133f1c2e07ef6ffda6b0809ec9ef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TupleAccessTraits&lt; Type2 &gt;<br>
::NonConstType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g3f6e5cfc1cb0f7618c4c4cfa294a4e0c">Dune::Pair::second</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the second value.  <a href="#g3f6e5cfc1cb0f7618c4c4cfa294a4e0c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TupleAccessTraits&lt; Type2 &gt;<br>
::ConstType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g613519eab98df27973d23ea8de72533b">Dune::Pair::second</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the second value.  <a href="#g613519eab98df27973d23ea8de72533b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g927d4b64b27030ba8d6452571185fe5b">Dune::Pair&lt; T1, Nil &gt;::Pair</a> (typename TupleAccessTraits&lt; T1 &gt;::ParameterType first, const Nil &amp;, const Nil &amp;, const Nil &amp;, const Nil &amp;, const Nil &amp;, const Nil &amp;, const Nil &amp;, const Nil &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#g927d4b64b27030ba8d6452571185fe5b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g4b70002789d7c8c5fd8a259b0019adf1">Dune::Pair&lt; T1, Nil &gt;::Pair</a> (typename TupleAccessTraits&lt; T1 &gt;::ParameterType first, const Nil &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#g4b70002789d7c8c5fd8a259b0019adf1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g520937ee6d06469a0612d44850937626"></a><!-- doxytag: member="Common::Pair" ref="g520937ee6d06469a0612d44850937626" args="(const Pair&lt; T2, Nil &gt; &amp;other)" -->
template&lt;typename T2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00191.html#g520937ee6d06469a0612d44850937626">Dune::Pair&lt; T1, Nil &gt;::Pair</a> (const Pair&lt; T2, Nil &gt; &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor for type conversion. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="g1aec74db2d69a0b5bb6ef2dd67aa6b93"></a><!-- doxytag: member="Common::operator=" ref="g1aec74db2d69a0b5bb6ef2dd67aa6b93" args="(const Pair&lt; T2, Nil &gt; &amp;other)" -->
template&lt;typename T2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Pair &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00191.html#g1aec74db2d69a0b5bb6ef2dd67aa6b93">Dune::Pair&lt; T1, Nil &gt;::operator=</a> (const Pair&lt; T2, Nil &gt; &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator for type conversion. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga3fb0e053e2073b355c7f6d71810303f"></a><!-- doxytag: member="Common::operator=" ref="ga3fb0e053e2073b355c7f6d71810303f" args="(const Pair &amp;other)" -->
Pair &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#ga3fb0e053e2073b355c7f6d71810303f">Dune::Pair&lt; T1, Nil &gt;::operator=</a> (const Pair &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TupleAccessTraits&lt; Type1 &gt;<br>
::NonConstType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gd99aea5c67f5164e03a0a5fa4c826837">Dune::Pair&lt; T1, Nil &gt;::first</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the first value.  <a href="#gd99aea5c67f5164e03a0a5fa4c826837"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TupleAccessTraits&lt; Type1 &gt;<br>
::ConstType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g3e86cfcccb48459b5f439ecadb0828d8">Dune::Pair&lt; T1, Nil &gt;::first</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the first value.  <a href="#g3e86cfcccb48459b5f439ecadb0828d8"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class U1, class U2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">tuple &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00191.html#gae2b51ada5007b7dc1a7f52b0ece8518">Dune::tuple::operator=</a> (const Pair&lt; U1, U2 &gt; &amp;other)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator for implicit type conversion.  <a href="#gae2b51ada5007b7dc1a7f52b0ece8518"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename T2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static TupleAccessTraits<br>
&lt; typename tuple_element&lt; N, <br>
Pair&lt; T1, T2 &gt; &gt;::type &gt;<br>
::ConstType&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00191.html#gc3074e13e06b0a9e35e226b92ec4c690">Dune::Element::get</a> (const Pair&lt; T1, T2 &gt; &amp;tuple)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the N-th element of the <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a>.  <a href="#gc3074e13e06b0a9e35e226b92ec4c690"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename T2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">static TupleAccessTraits&lt; T1 &gt;<br>
::ConstType&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00191.html#g673fe14ed265913fddf933326ae5f88f">Dune::Element&lt; 0 &gt;::get</a> (const Pair&lt; T1, T2 &gt; &amp;tuple)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the first element of the <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a>.  <a href="#g673fe14ed265913fddf933326ae5f88f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename T2, typename U1, typename U2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00191.html#gfc4454ea9411ef5cdfdbbf751bdf0801">Dune::operator==</a> (const Pair&lt; T1, T2 &gt; &amp;tuple1, const Pair&lt; U1, U2 &gt; &amp;tuple2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Equality comparison operator for tuples.  <a href="#gfc4454ea9411ef5cdfdbbf751bdf0801"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename T2, typename U1, typename U2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00191.html#g4d2687d1ad1eca4e78fac5e5df8e2583">Dune::operator!=</a> (const Pair&lt; T1, T2 &gt; &amp;tuple1, const Pair&lt; U1, U2 &gt; &amp;tuple2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inequality comparison operator for tuples.  <a href="#g4d2687d1ad1eca4e78fac5e5df8e2583"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename T2, typename U1, typename U2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00191.html#g55bc73cb2500088ef3cfa9bdbd679be9">Dune::operator&lt;</a> (const Pair&lt; T1, T2 &gt; &amp;tuple1, const Pair&lt; U1, U2 &gt; &amp;tuple2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Less operator for tuples.  <a href="#g55bc73cb2500088ef3cfa9bdbd679be9"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename U1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00191.html#gc16eda811e356babe5b8a1736c7f5694">Dune::operator==</a> (const Pair&lt; T1, Nil &gt; &amp;tuple1, const Pair&lt; U1, Nil &gt; &amp;tuple2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Equality comparison operator for tuples.  <a href="#gc16eda811e356babe5b8a1736c7f5694"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename U1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00191.html#g88b81aaa691d955587a4ba6d34ab5be5">Dune::operator!=</a> (const Pair&lt; T1, Nil &gt; &amp;tuple1, const Pair&lt; U1, Nil &gt; &amp;tuple2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inequality comparison operator for tuples.  <a href="#g88b81aaa691d955587a4ba6d34ab5be5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename U1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00191.html#g0d66fe6bdca738355692d6912413a3bc">Dune::operator&lt;</a> (const Pair&lt; T1, Nil &gt; &amp;tuple1, const Pair&lt; U1, Nil &gt; &amp;tuple2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Less operator for tuples.  <a href="#g0d66fe6bdca738355692d6912413a3bc"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename U1, typename U2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00191.html#g3d2ad94764611e5356694e02a323a072">Dune::operator==</a> (const Pair&lt; T1, Nil &gt; &amp;tuple1, const Pair&lt; U1, U2 &gt; &amp;tuple2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Equality comparison operator for tuples.  <a href="#g3d2ad94764611e5356694e02a323a072"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename U1, typename U2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00191.html#g78746f0e4f7028746c95daf40d799008">Dune::operator!=</a> (const Pair&lt; T1, Nil &gt; &amp;tuple1, const Pair&lt; U1, U2 &gt; &amp;tuple2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inequality comparison operator for tuples.  <a href="#g78746f0e4f7028746c95daf40d799008"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename T2, typename U1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00191.html#g57bf4ce9229d1105a6fee2c58bd2ef3c">Dune::operator==</a> (const Pair&lt; T1, T2 &gt; &amp;tuple1, const Pair&lt; U1, Nil &gt; &amp;tuple2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Equality comparison operator for tuples.  <a href="#g57bf4ce9229d1105a6fee2c58bd2ef3c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename T2, typename U1&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00191.html#g67f33244a7dcb098c9c924301ac70833">Dune::operator!=</a> (const Pair&lt; T1, T2 &gt; &amp;tuple1, const Pair&lt; U1, Nil &gt; &amp;tuple2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inequality comparison operator for tuples.  <a href="#g67f33244a7dcb098c9c924301ac70833"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T1, typename T2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">Pair&lt; T1, T2 &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00191.html#g8bb8b6b5a1db70f6f1e8c193cc37312b">Dune::makePair</a> (const T1 &amp;first, const T2 &amp;second)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a> and initialize it.  <a href="#g8bb8b6b5a1db70f6f1e8c193cc37312b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="ged1acc4ebd06c1d9d16ef2ef6f63588e"></a><!-- doxytag: member="Common::operator&lt;&lt;" ref="ged1acc4ebd06c1d9d16ef2ef6f63588e" args="(std::ostream &amp;os, const Pair&lt; T1, T2 &gt; &amp;pair)" -->
template&lt;typename T1, typename T2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">std::ostream &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00191.html#ged1acc4ebd06c1d9d16ef2ef6f63588e">Dune::operator&lt;&lt;</a> (std::ostream &amp;os, const Pair&lt; T1, T2 &gt; &amp;pair)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print aa pair or <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g04bfc0dc215764f4d0f0544c9aeb1ebb">Dune::Array::begin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return iterator refering to first element in <a class="el" href="a00004.html" title="Simple fixed size array class.">array</a>.  <a href="#g04bfc0dc215764f4d0f0544c9aeb1ebb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gad3fcc3d6ac7c80b6b30bf33648abfc0">Dune::Array::end</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return iterator refering to one past the last element of the <a class="el" href="a00004.html" title="Simple fixed size array class.">array</a>.  <a href="#gad3fcc3d6ac7c80b6b30bf33648abfc0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g225f341e109cd3a122ab84584e3ee36c">Dune::Array::~Array</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">destructor  <a href="#g225f341e109cd3a122ab84584e3ee36c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g4aacc3a111a4ff2353ea2ff93a410a1a">Dune::Array::Array</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">make empty <a class="el" href="a00004.html" title="Simple fixed size array class.">array</a>  <a href="#g4aacc3a111a4ff2353ea2ff93a410a1a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g442a5e5236bb859fb24bcb5765f02618">Dune::Array::Array</a> (int m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">make <a class="el" href="a00004.html" title="Simple fixed size array class.">array</a> with m components  <a href="#g442a5e5236bb859fb24bcb5765f02618"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gdeb2730e24ef28a1562b3c0a8fe2ada5">Dune::Array::resize</a> (int m)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">reallocate <a class="el" href="a00004.html" title="Simple fixed size array class.">array</a> with size m  <a href="#gdeb2730e24ef28a1562b3c0a8fe2ada5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g7255bd0cd112e1e6d1f2f026866eb066"></a><!-- doxytag: member="Common::Array" ref="g7255bd0cd112e1e6d1f2f026866eb066" args="(const Array&lt; T &gt; &amp;)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g7255bd0cd112e1e6d1f2f026866eb066">Dune::Array::Array</a> (const Array&lt; T &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">copy constructor making shallow copy <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gde6b7dfc79f0021c4a314a03f8d913f7"></a><!-- doxytag: member="Common::operator=" ref="gde6b7dfc79f0021c4a314a03f8d913f7" args="(const Array&lt; T &gt; &amp;)" -->
Array&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gde6b7dfc79f0021c4a314a03f8d913f7">Dune::Array::operator=</a> (const Array&lt; T &gt; &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">assignment of two arrays <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g501fe29f9f7704991292b959b77696d7"></a><!-- doxytag: member="Common::operator=" ref="g501fe29f9f7704991292b959b77696d7" args="(const T &amp;a)" -->
Array&lt; T &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g501fe29f9f7704991292b959b77696d7">Dune::Array::operator=</a> (const T &amp;a)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">assign value to all components <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gb57eddb704a44ef55dd3473dda605997"></a><!-- doxytag: member="Common::operator[]" ref="gb57eddb704a44ef55dd3473dda605997" args="(int i)" -->
T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gb57eddb704a44ef55dd3473dda605997">Dune::Array::operator[]</a> (int i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">random access operator <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g9529780ac424202d2389ac7cbcd3f47d"></a><!-- doxytag: member="Common::operator[]" ref="g9529780ac424202d2389ac7cbcd3f47d" args="(int i) const " -->
const T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g9529780ac424202d2389ac7cbcd3f47d">Dune::Array::operator[]</a> (int i) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Const random access operator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g543bcf839c951ed82c9b3351299c06dc"></a><!-- doxytag: member="Common::size" ref="g543bcf839c951ed82c9b3351299c06dc" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g543bcf839c951ed82c9b3351299c06dc">Dune::Array::size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">return number of components in <a class="el" href="a00004.html" title="Simple fixed size array class.">array</a> <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g80b54a62210bef1e5eae3eb45bbdbf52">Dune::Array::Iterator::Iterator</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor.  <a href="#g80b54a62210bef1e5eae3eb45bbdbf52"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g0b6e99caa52b02a9727ff48a4be0c74a">Dune::Array::Iterator::operator++</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prefix increment.  <a href="#g0b6e99caa52b02a9727ff48a4be0c74a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">Iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gfc20cae176d4dac1082dfc59caa8a82b">Dune::Array::Iterator::operator++</a> (int)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Postfix increment.  <a href="#gfc20cae176d4dac1082dfc59caa8a82b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g6dd5a6c4784ab021ae67be0135e3d165"></a><!-- doxytag: member="Common::operator*" ref="g6dd5a6c4784ab021ae67be0135e3d165" args="() const " -->
const T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g6dd5a6c4784ab021ae67be0135e3d165">Dune::Array::Iterator::operator*</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dereferencing. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g30279b6b38b8d3cab6163f1bee283c5e">Dune::Array::Iterator::operator-&gt;</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">selector  <a href="#g30279b6b38b8d3cab6163f1bee283c5e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g5f26956b01c6a3d9db4c9da3ecd8b7f4"></a><!-- doxytag: member="Common::ArrayList" ref="g5f26956b01c6a3d9db4c9da3ecd8b7f4" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g5f26956b01c6a3d9db4c9da3ecd8b7f4">Dune::ArrayList::ArrayList</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs an <a class="el" href="a00005.html" title="A simple dynamic array class.">Array</a> list with one chunk. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gb837ba808b8bfeeb6dac65a00b2e9c31"></a><!-- doxytag: member="Common::clear" ref="gb837ba808b8bfeeb6dac65a00b2e9c31" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gb837ba808b8bfeeb6dac65a00b2e9c31">Dune::ArrayList::clear</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete all entries from the list. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gc813ed76944fdbae6e71d8792e4af432">Dune::ArrayList::size</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of elements in the list.  <a href="#gc813ed76944fdbae6e71d8792e4af432"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gb7751eecb5b784102990419cd999e465">Dune::ArrayList::capacity</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current capacity of the list.  <a href="#gb7751eecb5b784102990419cd999e465"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#ge5d0068f5773845dd133cb2cc6c2ab9c">Dune::ArrayList::push_back</a> (const_reference entry)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append an entry to the list.  <a href="#ge5d0068f5773845dd133cb2cc6c2ab9c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g00fb2e9b1c7ed63dc48185d9fece84b3">Dune::ArrayList::operator[]</a> (size_type i)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the element at specific position.  <a href="#g00fb2e9b1c7ed63dc48185d9fece84b3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gf4f9d40ec569ddcda1f5869b776cee8d">Dune::ArrayList::operator[]</a> (size_type i) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the element at specific position.  <a href="#gf4f9d40ec569ddcda1f5869b776cee8d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g0453c1e8cf90d912f11c521784c917c9">Dune::ArrayList::begin</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an iterator that is positioned at the first element.  <a href="#g0453c1e8cf90d912f11c521784c917c9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#ge289cc77d4332c113e0bb7bcf3cdc4a7">Dune::ArrayList::begin</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a random access iterator that is positioned at the first element.  <a href="#ge289cc77d4332c113e0bb7bcf3cdc4a7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g84de6115438d8d36040af42a92777f66"></a><!-- doxytag: member="Common::end" ref="g84de6115438d8d36040af42a92777f66" args="()" -->
iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g84de6115438d8d36040af42a92777f66">Dune::ArrayList::end</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a random access iterator positioned after the last element. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g1cc02fa3b238944d8fab8ad3e180ae80"></a><!-- doxytag: member="Common::end" ref="g1cc02fa3b238944d8fab8ad3e180ae80" args="() const " -->
const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g1cc02fa3b238944d8fab8ad3e180ae80">Dune::ArrayList::end</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a random access iterator positioned after the last element. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g2b627c8796d6946f57458f9e90980397">Dune::ArrayList::purge</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Purge the list.  <a href="#g2b627c8796d6946f57458f9e90980397"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gdcaa9ef9cac9effc73f797c9ec914d43">Dune::ArrayListIterator::advance</a> (difference_type n)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#ga8f468008db350985416802e19284c70">Dune::ConstArrayListIterator::advance</a> (difference_type n)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g2d2c288766bed54d81aef9ece437c925">Dune::ArrayListIterator::equals</a> (const ArrayListIterator&lt; MemberType, N, A &gt; &amp;other) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comares two iterators.  <a href="#g2d2c288766bed54d81aef9ece437c925"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g20fc3b0f08378ff91a81bc537a9220f0">Dune::ArrayListIterator::equals</a> (const ConstArrayListIterator&lt; MemberType, N, A &gt; &amp;other) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comares two iterators.  <a href="#g20fc3b0f08378ff91a81bc537a9220f0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g22acf5061c608c5967871bb6cb6ae729">Dune::ConstArrayListIterator::equals</a> (const ConstArrayListIterator&lt; MemberType, N, A &gt; &amp;other) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comares to iterators.  <a href="#g22acf5061c608c5967871bb6cb6ae729"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g1a141c2254e8326f22057e8e33086412"></a><!-- doxytag: member="Common::increment" ref="g1a141c2254e8326f22057e8e33086412" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g1a141c2254e8326f22057e8e33086412">Dune::ArrayListIterator::increment</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increment the iterator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g76de40b277f94ee868d428d228e653db"></a><!-- doxytag: member="Common::increment" ref="g76de40b277f94ee868d428d228e653db" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g76de40b277f94ee868d428d228e653db">Dune::ConstArrayListIterator::increment</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increment the iterator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g4456b3d5cbaa8d387a79412a97749ada"></a><!-- doxytag: member="Common::decrement" ref="g4456b3d5cbaa8d387a79412a97749ada" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g4456b3d5cbaa8d387a79412a97749ada">Dune::ArrayListIterator::decrement</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">decrement the iterator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g9c8c49a4c9e7f9ec05f13ef08838125c"></a><!-- doxytag: member="Common::decrement" ref="g9c8c49a4c9e7f9ec05f13ef08838125c" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g9c8c49a4c9e7f9ec05f13ef08838125c">Dune::ConstArrayListIterator::decrement</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">decrement the iterator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MemberType &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gb265dca18afec7e88c4e6572b2ad87f6">Dune::ArrayListIterator::elementAt</a> (size_type i) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the value of the list at an arbitrary position.  <a href="#gb265dca18afec7e88c4e6572b2ad87f6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const MemberType &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g89b34c1581a5b69593cc2b38041ca3e2">Dune::ConstArrayListIterator::elementAt</a> (size_type i) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the value of the list at an arbitrary position.  <a href="#g89b34c1581a5b69593cc2b38041ca3e2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">MemberType &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g02716cace31198859205be004052cc26">Dune::ArrayListIterator::dereference</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the element at the current position.  <a href="#g02716cace31198859205be004052cc26"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const MemberType &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gbcbfe90d7975d08dcfb2c7d92630efb7">Dune::ConstArrayListIterator::dereference</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Access the element at the current position.  <a href="#gbcbfe90d7975d08dcfb2c7d92630efb7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">difference_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g77a7f3b330f2f1642c6a4e174813714a">Dune::ArrayListIterator::distanceTo</a> (const ArrayListIterator&lt; T, N, A &gt; &amp;other) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">difference_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gd6de3c44f3331ccb2f66d508528af8ae">Dune::ConstArrayListIterator::distanceTo</a> (const ConstArrayListIterator&lt; T, N, A &gt; &amp;other) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">ArrayListIterator&lt; T, N, A &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#ge0d198bd472c7e6e5358fd51dd27f9d1">Dune::ArrayListIterator::operator=</a> (const ArrayListIterator&lt; T, N, A &gt; &amp;other)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g492de54ad819c0b784b7981d68228e4d">Dune::ArrayListIterator::eraseToHere</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erase all entries before the current position and the one at the current position.  <a href="#g492de54ad819c0b784b7981d68228e4d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g7276ad3ad9f0130df9307acf08c0dd8f"></a><!-- doxytag: member="Common::bigunsignedint" ref="g7276ad3ad9f0130df9307acf08c0dd8f" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g7276ad3ad9f0130df9307acf08c0dd8f">Dune::bigunsignedint::bigunsignedint</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct uninitialized. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gbdeb148aef826a1670ad6f9ca9042c97"></a><!-- doxytag: member="Common::bigunsignedint" ref="gbdeb148aef826a1670ad6f9ca9042c97" args="(int x)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gbdeb148aef826a1670ad6f9ca9042c97">Dune::bigunsignedint::bigunsignedint</a> (int x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct from signed int. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g6dc3e9812a724a9eb0d5a4a253313a70"></a><!-- doxytag: member="Common::bigunsignedint" ref="g6dc3e9812a724a9eb0d5a4a253313a70" args="(unsigned int x)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g6dc3e9812a724a9eb0d5a4a253313a70">Dune::bigunsignedint::bigunsignedint</a> (unsigned int x)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct from unsigned int. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gbb85398aa6fe52b3e5adb72808fd4a5d"></a><!-- doxytag: member="Common::touint" ref="gbb85398aa6fe52b3e5adb72808fd4a5d" args="() const " -->
unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gbb85398aa6fe52b3e5adb72808fd4a5d">Dune::bigunsignedint::touint</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">export to other types <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g3a92f35f46c77869ab1122a308d6f267"></a><!-- doxytag: member="Common::print" ref="g3a92f35f46c77869ab1122a308d6f267" args="(std::ostream &amp;s) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g3a92f35f46c77869ab1122a308d6f267">Dune::bigunsignedint::print</a> (std::ostream &amp;s) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print number in hex notation. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g71db4fa0d867b58257214c29de697dd7"></a><!-- doxytag: member="Common::operator+" ref="g71db4fa0d867b58257214c29de697dd7" args="(const bigunsignedint&lt; k &gt; &amp;x) const " -->
bigunsignedint&lt; k &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g71db4fa0d867b58257214c29de697dd7">Dune::bigunsignedint::operator+</a> (const bigunsignedint&lt; k &gt; &amp;x) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">add <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g3a5b8789fad6daaa00e4313aeab55135"></a><!-- doxytag: member="Common::operator-" ref="g3a5b8789fad6daaa00e4313aeab55135" args="(const bigunsignedint&lt; k &gt; &amp;x) const " -->
bigunsignedint&lt; k &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g3a5b8789fad6daaa00e4313aeab55135">Dune::bigunsignedint::operator-</a> (const bigunsignedint&lt; k &gt; &amp;x) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">subtract <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g910dec75aca102d572cae19a910ed3df"></a><!-- doxytag: member="Common::operator*" ref="g910dec75aca102d572cae19a910ed3df" args="(const bigunsignedint&lt; k &gt; &amp;x) const " -->
bigunsignedint&lt; k &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g910dec75aca102d572cae19a910ed3df">Dune::bigunsignedint::operator*</a> (const bigunsignedint&lt; k &gt; &amp;x) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">multiply <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gbca7e8dbfe73be43c64c517621f5177e"></a><!-- doxytag: member="Common::operator++" ref="gbca7e8dbfe73be43c64c517621f5177e" args="()" -->
bigunsignedint&lt; k &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gbca7e8dbfe73be43c64c517621f5177e">Dune::bigunsignedint::operator++</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">prefix increment <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g8e42a9e160854a910a1f744af260cdfc"></a><!-- doxytag: member="Common::operator/" ref="g8e42a9e160854a910a1f744af260cdfc" args="(const bigunsignedint&lt; k &gt; &amp;x) const " -->
bigunsignedint&lt; k &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g8e42a9e160854a910a1f744af260cdfc">Dune::bigunsignedint::operator/</a> (const bigunsignedint&lt; k &gt; &amp;x) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">divide <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g5fa0981a31cc794c2a9fe6f050f43815"></a><!-- doxytag: member="Common::operator%" ref="g5fa0981a31cc794c2a9fe6f050f43815" args="(const bigunsignedint&lt; k &gt; &amp;x) const " -->
bigunsignedint&lt; k &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g5fa0981a31cc794c2a9fe6f050f43815">Dune::bigunsignedint::operator%</a> (const bigunsignedint&lt; k &gt; &amp;x) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">modulo <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gd6fc10948de2245d83f0ddfea2519ba7"></a><!-- doxytag: member="Common::operator &amp;" ref="gd6fc10948de2245d83f0ddfea2519ba7" args="(const bigunsignedint&lt; k &gt; &amp;x) const " -->
bigunsignedint&lt; k &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gd6fc10948de2245d83f0ddfea2519ba7">Dune::bigunsignedint::operator &amp;</a> (const bigunsignedint&lt; k &gt; &amp;x) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">bitwise and <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gcf5cad5a2402a12f6691dc7cad5577ef"></a><!-- doxytag: member="Common::operator^" ref="gcf5cad5a2402a12f6691dc7cad5577ef" args="(const bigunsignedint&lt; k &gt; &amp;x) const " -->
bigunsignedint&lt; k &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gcf5cad5a2402a12f6691dc7cad5577ef">Dune::bigunsignedint::operator^</a> (const bigunsignedint&lt; k &gt; &amp;x) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">bitwise exor <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gf75429fd71c4a40fc5c48b9c52f56022"></a><!-- doxytag: member="Common::operator|" ref="gf75429fd71c4a40fc5c48b9c52f56022" args="(const bigunsignedint&lt; k &gt; &amp;x) const " -->
bigunsignedint&lt; k &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gf75429fd71c4a40fc5c48b9c52f56022">Dune::bigunsignedint::operator|</a> (const bigunsignedint&lt; k &gt; &amp;x) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">bitwise or <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gcba9f09a54efac06870bfee8044d220f"></a><!-- doxytag: member="Common::operator~" ref="gcba9f09a54efac06870bfee8044d220f" args="() const " -->
bigunsignedint&lt; k &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gcba9f09a54efac06870bfee8044d220f">Dune::bigunsignedint::operator~</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">bitwise komplement <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g3f1960630bedc00d21f1d86592fa49dc"></a><!-- doxytag: member="Common::operator&lt;&lt;" ref="g3f1960630bedc00d21f1d86592fa49dc" args="(int i) const " -->
bigunsignedint&lt; k &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g3f1960630bedc00d21f1d86592fa49dc">Dune::bigunsignedint::operator&lt;&lt;</a> (int i) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">left shift1/ <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gc31da4080d643d3e3e8c5d35a4b902eb"></a><!-- doxytag: member="Common::operator&gt;&gt;" ref="gc31da4080d643d3e3e8c5d35a4b902eb" args="(int i) const " -->
bigunsignedint&lt; k &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gc31da4080d643d3e3e8c5d35a4b902eb">Dune::bigunsignedint::operator&gt;&gt;</a> (int i) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">right shift <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gd8b3994615fe0c66e47947b2e8bfbf1f"></a><!-- doxytag: member="Common::operator!=" ref="gd8b3994615fe0c66e47947b2e8bfbf1f" args="(const bigunsignedint&lt; k &gt; &amp;x) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gd8b3994615fe0c66e47947b2e8bfbf1f">Dune::bigunsignedint::operator!=</a> (const bigunsignedint&lt; k &gt; &amp;x) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">not equal <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g09629b1a4669f8165f2ccdde061c607e"></a><!-- doxytag: member="Common::operator==" ref="g09629b1a4669f8165f2ccdde061c607e" args="(const bigunsignedint&lt; k &gt; &amp;x) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g09629b1a4669f8165f2ccdde061c607e">Dune::bigunsignedint::operator==</a> (const bigunsignedint&lt; k &gt; &amp;x) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">equal <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga06fd9a7758e68c35c31324adcbbd317"></a><!-- doxytag: member="Common::operator&lt;" ref="ga06fd9a7758e68c35c31324adcbbd317" args="(const bigunsignedint&lt; k &gt; &amp;x) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#ga06fd9a7758e68c35c31324adcbbd317">Dune::bigunsignedint::operator&lt;</a> (const bigunsignedint&lt; k &gt; &amp;x) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">less than <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g0d141cf1482b330528c219cbbb9ef600"></a><!-- doxytag: member="Common::operator&lt;=" ref="g0d141cf1482b330528c219cbbb9ef600" args="(const bigunsignedint&lt; k &gt; &amp;x) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g0d141cf1482b330528c219cbbb9ef600">Dune::bigunsignedint::operator&lt;=</a> (const bigunsignedint&lt; k &gt; &amp;x) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">less than or equal <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g476baca3277413dc2477aaaf40620e34"></a><!-- doxytag: member="Common::operator&gt;" ref="g476baca3277413dc2477aaaf40620e34" args="(const bigunsignedint&lt; k &gt; &amp;x) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g476baca3277413dc2477aaaf40620e34">Dune::bigunsignedint::operator&gt;</a> (const bigunsignedint&lt; k &gt; &amp;x) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">greater than <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gff4f131c99cdd31fa0c24763691d4574"></a><!-- doxytag: member="Common::operator&gt;=" ref="gff4f131c99cdd31fa0c24763691d4574" args="(const bigunsignedint&lt; k &gt; &amp;x) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gff4f131c99cdd31fa0c24763691d4574">Dune::bigunsignedint::operator&gt;=</a> (const bigunsignedint&lt; k &gt; &amp;x) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">greater or equalt <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gbe9c296a2213a977a8579d2b1972bbd3"></a><!-- doxytag: member="Common::contains" ref="gbe9c296a2213a977a8579d2b1972bbd3" args="(const Type &amp;attribute)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gbe9c296a2213a977a8579d2b1972bbd3">Dune::EmptySet::contains</a> (const Type &amp;attribute)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Always returns false. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gdd4bd8a68ff82f7bd648a651990ae8e5">Dune::EnumItem::contains</a> (const Type &amp;attribute)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tests whether an item is in the set.  <a href="#gdd4bd8a68ff82f7bd648a651990ae8e5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gd22b5366230a0a19803668fb20fbd059"></a><!-- doxytag: member="Common::Pool" ref="gd22b5366230a0a19803668fb20fbd059" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gd22b5366230a0a19803668fb20fbd059">Dune::Pool::Pool</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g4e532951b380f21051712b6e458389e5"></a><!-- doxytag: member="Common::~Pool" ref="g4e532951b380f21051712b6e458389e5" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g4e532951b380f21051712b6e458389e5">Dune::Pool::~Pool</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g7b0a19e8009fb6e5b43ebf5a27c38ce5"></a><!-- doxytag: member="Common::print" ref="g7b0a19e8009fb6e5b43ebf5a27c38ce5" args="(std::ostream &amp;os)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g7b0a19e8009fb6e5b43ebf5a27c38ce5">Dune::Pool::print</a> (std::ostream &amp;os)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print elements in pool for debugging. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g47e9484d263bece81e75897dd885f5c0">Dune::Pool::free</a> (void *o)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free an object.  <a href="#g47e9484d263bece81e75897dd885f5c0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#ge8caf5d70df23af5fee312696c635080">Dune::Pool::allocate</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a new or recycled object.  <a href="#ge8caf5d70df23af5fee312696c635080"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gfe8c4a7219fd9e0a6ccddb9f8195891c"></a><!-- doxytag: member="Common::PoolAllocator" ref="gfe8c4a7219fd9e0a6ccddb9f8195891c" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gfe8c4a7219fd9e0a6ccddb9f8195891c">Dune::PoolAllocator::PoolAllocator</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#ge2fe41e945dc1313868890aa28d75e7f">Dune::PoolAllocator::deallocate</a> (pointer p, std::size_t n)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free objects.  <a href="#ge2fe41e945dc1313868890aa28d75e7f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g2c654f3d338d310b294d105d28d78758">Dune::PoolAllocator::construct</a> (pointer p, const_reference value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct an object.  <a href="#g2c654f3d338d310b294d105d28d78758"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#geb9692354592eaceb050be5299c344af">Dune::PoolAllocator::destroy</a> (pointer p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy an object without freeing memory.  <a href="#geb9692354592eaceb050be5299c344af"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g2dda21b5596205389b1a0d4f19f522c5"></a><!-- doxytag: member="Common::SmartPointer" ref="g2dda21b5596205389b1a0d4f19f522c5" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g2dda21b5596205389b1a0d4f19f522c5">Dune::SmartPointer::SmartPointer</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs a new smart pointer and allocates the referenced Object. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#ge35bbe2177c815c5fd307be741e98bda">Dune::SmartPointer::SmartPointer</a> (const SmartPointer&lt; T &gt; &amp;pointer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor.  <a href="#ge35bbe2177c815c5fd307be741e98bda"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g72757c9d0b09515fc013afe10258d4db"></a><!-- doxytag: member="Common::operator=" ref="g72757c9d0b09515fc013afe10258d4db" args="(const SmartPointer&lt; T &gt; &amp;pointer)" -->
SmartPointer &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g72757c9d0b09515fc013afe10258d4db">Dune::SmartPointer::operator=</a> (const SmartPointer&lt; T &gt; &amp;pointer)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g5e56f153138668a42ab1a888bfff59db"></a><!-- doxytag: member="Common::~SmartPointer" ref="g5e56f153138668a42ab1a888bfff59db" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g5e56f153138668a42ab1a888bfff59db">Dune::SmartPointer::~SmartPointer</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gdbc2ded94b12b8aa58d2d4a158a45576"></a><!-- doxytag: member="Common::operator*" ref="gdbc2ded94b12b8aa58d2d4a158a45576" args="()" -->
MemberType &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gdbc2ded94b12b8aa58d2d4a158a45576">Dune::SmartPointer::operator*</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dereference as object. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gf7c6b44d906668e4fbad43d155b9bb14"></a><!-- doxytag: member="Common::operator-&gt;" ref="gf7c6b44d906668e4fbad43d155b9bb14" args="()" -->
MemberType *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gf7c6b44d906668e4fbad43d155b9bb14">Dune::SmartPointer::operator-&gt;</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dereference as pointer. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g468dde866d9e98c4adb6f0f2f3ee6c5b"></a><!-- doxytag: member="Common::operator*" ref="g468dde866d9e98c4adb6f0f2f3ee6c5b" args="() const " -->
const MemberType &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g468dde866d9e98c4adb6f0f2f3ee6c5b">Dune::SmartPointer::operator*</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dereference as const object. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g9a065b15c05c4098a609d2d5c82d1c42"></a><!-- doxytag: member="Common::operator-&gt;" ref="g9a065b15c05c4098a609d2d5c82d1c42" args="() const " -->
const MemberType *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g9a065b15c05c4098a609d2d5c82d1c42">Dune::SmartPointer::operator-&gt;</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Dereference as const pointer. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gb9df0d7cab1c3b198ab2a6d75821f446"></a><!-- doxytag: member="Common::deallocate" ref="gb9df0d7cab1c3b198ab2a6d75821f446" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gb9df0d7cab1c3b198ab2a6d75821f446">Dune::SmartPointer::deallocate</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deallocates the references object if no other pointers reference it. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gfde4245b921340adcd12eb4bf4ac2501"></a><!-- doxytag: member="Common::empty" ref="gfde4245b921340adcd12eb4bf4ac2501" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gfde4245b921340adcd12eb4bf4ac2501">Dune::Stack::empty</a> () const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the stack is emptry. <br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class <a class="el" href="a00033.html">Dune::DoubleLinkedList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g4a76589a319b7f5011856d565443e9e5">Dune::DUNE_DEPRECATED</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">(DEPRECATED) A doubly-linked list  <a href="#g4a76589a319b7f5011856d565443e9e5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gb1133a960f22504951497778c1266624"></a><!-- doxytag: member="Common::value" ref="gb1133a960f22504951497778c1266624" args="" -->
static const long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gb1133a960f22504951497778c1266624">Dune::Lcm::value</a> = (m/Gcd&lt;m,n&gt;::value)*n</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The least common multiple of the template parameters m and n. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g2ab7716a755ae785552cd61f167dad34"></a><!-- doxytag: member="Common::item_" ref="g2ab7716a755ae785552cd61f167dad34" args="" -->
MemberType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g2ab7716a755ae785552cd61f167dad34">Dune::SLList::Element::item_</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The element we hold. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g461898aa7abba650caaf46f04f019d51"></a><!-- doxytag: member="Common::first_" ref="g461898aa7abba650caaf46f04f019d51" args="" -->
Type1&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g461898aa7abba650caaf46f04f019d51">Dune::Pair::first_</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The value of the first field. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g4942cc140939562aa4ed9dd9330910ce"></a><!-- doxytag: member="Common::second_" ref="g4942cc140939562aa4ed9dd9330910ce" args="" -->
Type2&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#g4942cc140939562aa4ed9dd9330910ce">Dune::Pair::second_</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The value of the second field. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gce232fd8062f8d6eaf05e7c555b1fc7c"></a><!-- doxytag: member="Common::first_" ref="gce232fd8062f8d6eaf05e7c555b1fc7c" args="" -->
Type1&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html#gce232fd8062f8d6eaf05e7c555b1fc7c">Dune::Pair&lt; T1, Nil &gt;::first_</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The value of the first field. <br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga8f468008db350985416802e19284c70"></a><!-- doxytag: member="Dune::ConstArrayListIterator::advance" ref="ga8f468008db350985416802e19284c70" args="(difference_type n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00026.html">Dune::ConstArrayListIterator</a>&lt; T, N, A &gt;::advance           </td>
          <td>(</td>
          <td class="paramtype">difference_type&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>Please doc me! </dd></dl>

</div>
</div><p>
<a class="anchor" name="gdcaa9ef9cac9effc73f797c9ec914d43"></a><!-- doxytag: member="Dune::ArrayListIterator::advance" ref="gdcaa9ef9cac9effc73f797c9ec914d43" args="(difference_type n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00008.html">Dune::ArrayListIterator</a>&lt; T, N, A &gt;::advance           </td>
          <td>(</td>
          <td class="paramtype">difference_type&nbsp;</td>
          <td class="paramname"> <em>n</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>Please doc me! </dd></dl>

</div>
</div><p>
<a class="anchor" name="ge8caf5d70df23af5fee312696c635080"></a><!-- doxytag: member="Dune::Pool::allocate" ref="ge8caf5d70df23af5fee312696c635080" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t S&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T * <a class="el" href="a00099.html">Dune::Pool</a>&lt; T, S &gt;::allocate           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a new or recycled object. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the object memory. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g442a5e5236bb859fb24bcb5765f02618"></a><!-- doxytag: member="Dune::Array::Array" ref="g442a5e5236bb859fb24bcb5765f02618" args="(int m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00005.html">Dune::Array</a>&lt; T &gt;::Array           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>m</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
make <a class="el" href="a00004.html" title="Simple fixed size array class.">array</a> with m components 
<p>
Constructor with size indicator Creates an empty <a class="el" href="a00004.html" title="Simple fixed size array class.">array</a> of size m. 
<p>References <a class="el" href="a00216.html#l00131">DUNE_THROW</a>.</p>

</div>
</div><p>
<a class="anchor" name="g4aacc3a111a4ff2353ea2ff93a410a1a"></a><!-- doxytag: member="Dune::Array::Array" ref="g4aacc3a111a4ff2353ea2ff93a410a1a" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00005.html">Dune::Array</a>&lt; T &gt;::Array           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
make empty <a class="el" href="a00004.html" title="Simple fixed size array class.">array</a> 
<p>
Default constructor Creates an <a class="el" href="a00004.html" title="Simple fixed size array class.">array</a> of size 0. 
</div>
</div><p>
<a class="anchor" name="ge289cc77d4332c113e0bb7bcf3cdc4a7"></a><!-- doxytag: member="Dune::ArrayList::begin" ref="ge289cc77d4332c113e0bb7bcf3cdc4a7" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ConstArrayListIterator&lt; T, N, A &gt; <a class="el" href="a00007.html">Dune::ArrayList</a>&lt; T, N, A &gt;::begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get a random access iterator that is positioned at the first element. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The iterator. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g0453c1e8cf90d912f11c521784c917c9"></a><!-- doxytag: member="Dune::ArrayList::begin" ref="g0453c1e8cf90d912f11c521784c917c9" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ArrayListIterator&lt; T, N, A &gt; <a class="el" href="a00007.html">Dune::ArrayList</a>&lt; T, N, A &gt;::begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator that is positioned at the first element. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The iterator. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g04bfc0dc215764f4d0f0544c9aeb1ebb"></a><!-- doxytag: member="Dune::Array::begin" ref="g04bfc0dc215764f4d0f0544c9aeb1ebb" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Array&lt; T &gt;::Iterator <a class="el" href="a00005.html">Dune::Array</a>&lt; T &gt;::begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return iterator refering to first element in <a class="el" href="a00004.html" title="Simple fixed size array class.">array</a>. 
<p>
<a class="el" href="a00006.html" title="An iterator to access all components of array.">Iterator</a> interface. 
<p>References <a class="el" href="a00202.html#l00035">Dune::Array&lt; T &gt;::Iterator::p</a>.</p>

</div>
</div><p>
<a class="anchor" name="g302758547958e3d1159058578037fdbf"></a><!-- doxytag: member="Dune::SLList::begin" ref="g302758547958e3d1159058578037fdbf" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SLListConstIterator&lt; T, A &gt; <a class="el" href="a00116.html">Dune::SLList</a>&lt; T, A &gt;::begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator pointing to the first element in the list. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An iterator pointing to the first element or the end if the list is empty. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gff151c44f4a1e43ab0b2f0cf55bab6f8"></a><!-- doxytag: member="Dune::SLList::begin" ref="gff151c44f4a1e43ab0b2f0cf55bab6f8" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SLListIterator&lt; T, A &gt; <a class="el" href="a00116.html">Dune::SLList</a>&lt; T, A &gt;::begin           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator pointing to the first element in the list. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An iterator pointing to the first element or the end if the list is empty. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g9f0cfc5d3be7b2719e938face53b832f"></a><!-- doxytag: member="Dune::SLList::beginModify" ref="g9f0cfc5d3be7b2719e938face53b832f" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SLListModifyIterator&lt; T, A &gt; <a class="el" href="a00116.html">Dune::SLList</a>&lt; T, A &gt;::beginModify           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator capable of deleting and inserting elements. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Modifying iterator positioned at the beginning of the list. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb7751eecb5b784102990419cd999e465"></a><!-- doxytag: member="Dune::ArrayList::capacity" ref="gb7751eecb5b784102990419cd999e465" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="a00007.html">Dune::ArrayList</a>&lt; T, N, A &gt;::capacity           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the current capacity of the list. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The capacity. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g2c654f3d338d310b294d105d28d78758"></a><!-- doxytag: member="Dune::PoolAllocator::construct" ref="g2c654f3d338d310b294d105d28d78758" args="(pointer p, const_reference value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t s&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00100.html">Dune::PoolAllocator</a>&lt; T, s &gt;::construct           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00100.html#bd4eae3a95c4e8d4d34ef208c2c07c18">pointer</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00100.html#207175c65f7a437325bd52e89a947eb2">const_reference</a>&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct an object. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>Pointer to the object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value to initialize it to. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gdd4bd8a68ff82f7bd648a651990ae8e5"></a><!-- doxytag: member="Dune::EnumItem::contains" ref="gdd4bd8a68ff82f7bd648a651990ae8e5" args="(const Type &amp;attribute)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TA, int i&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00042.html">Dune::EnumItem</a>&lt; TA, i &gt;::contains           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00042.html#38b6b18d6a44b18e42f42be188baa255">Type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>attribute</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tests whether an item is in the set. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if item==Type. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ge2fe41e945dc1313868890aa28d75e7f"></a><!-- doxytag: member="Dune::PoolAllocator::deallocate" ref="ge2fe41e945dc1313868890aa28d75e7f" args="(pointer p, std::size_t n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t s&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00100.html">Dune::PoolAllocator</a>&lt; T, s &gt;::deallocate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00100.html#bd4eae3a95c4e8d4d34ef208c2c07c18">pointer</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free objects. 
<p>
Does not call the contructor! <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>The number of object to free. Has to be one! </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>Pointer to the first object. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g3bcdf1643346941a6ee1da08ad58906b"></a><!-- doxytag: member="Dune::SLListIterator::deleteNext" ref="g3bcdf1643346941a6ee1da08ad58906b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00118.html">Dune::SLListIterator</a>&lt; T, A &gt;::deleteNext           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete the entry after the current position. 
<p>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>This will invalidate all iterators positioned at the delete position! Use with care! </dd></dl>

</div>
</div><p>
<a class="anchor" name="gbcbfe90d7975d08dcfb2c7d92630efb7"></a><!-- doxytag: member="Dune::ConstArrayListIterator::dereference" ref="gbcbfe90d7975d08dcfb2c7d92630efb7" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const ConstArrayListIterator&lt; T, N, A &gt;::MemberType &amp; <a class="el" href="a00026.html">Dune::ConstArrayListIterator</a>&lt; T, N, A &gt;::dereference           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Access the element at the current position. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The element at the current position. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g02716cace31198859205be004052cc26"></a><!-- doxytag: member="Dune::ArrayListIterator::dereference" ref="g02716cace31198859205be004052cc26" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ArrayListIterator&lt; T, N, A &gt;::MemberType &amp; <a class="el" href="a00008.html">Dune::ArrayListIterator</a>&lt; T, N, A &gt;::dereference           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Access the element at the current position. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The element at the current position. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ga8802093ad519c06d8341fa704cdb1cb"></a><!-- doxytag: member="Dune::SLListModifyIterator::dereference" ref="ga8802093ad519c06d8341fa704cdb1cb" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="a00119.html">Dune::SLListModifyIterator</a>&lt; T, A &gt;::dereference           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Dereferencing function for the iterator facade. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A reference to the element at the current position. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g783fbeb76a0111524727d09e15a40a48"></a><!-- doxytag: member="Dune::SLListConstIterator::dereference" ref="g783fbeb76a0111524727d09e15a40a48" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="a00117.html">Dune::SLListConstIterator</a>&lt; T, A &gt;::dereference           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Dereferencing function for the facade. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A reference to the element at the current position. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gc2d3d84935e5b39ca1bd6d6c8391f0f6"></a><!-- doxytag: member="Dune::SLListIterator::dereference" ref="gc2d3d84935e5b39ca1bd6d6c8391f0f6" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="a00118.html">Dune::SLListIterator</a>&lt; T, A &gt;::dereference           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Dereferencing function for the iterator facade. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A reference to the element at the current position. </dd></dl>

</div>
</div><p>
<a class="anchor" name="geb9692354592eaceb050be5299c344af"></a><!-- doxytag: member="Dune::PoolAllocator::destroy" ref="geb9692354592eaceb050be5299c344af" args="(pointer p)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t s&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00100.html">Dune::PoolAllocator</a>&lt; T, s &gt;::destroy           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00100.html#bd4eae3a95c4e8d4d34ef208c2c07c18">pointer</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destroy an object without freeing memory. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>Pointer to the object. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gd6de3c44f3331ccb2f66d508528af8ae"></a><!-- doxytag: member="Dune::ConstArrayListIterator::distanceTo" ref="gd6de3c44f3331ccb2f66d508528af8ae" args="(const ConstArrayListIterator&lt; T, N, A &gt; &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ConstArrayListIterator&lt; T, N, A &gt;::difference_type <a class="el" href="a00026.html">Dune::ConstArrayListIterator</a>&lt; T, N, A &gt;::distanceTo           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00026.html">ConstArrayListIterator</a>&lt; T, N, A &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000010">Todo:</a></b></dt><dd>Please doc me! </dd></dl>

<p>References <a class="el" href="a00203.html#l00437">Dune::ConstArrayListIterator&lt; T, N, A &gt;::list_</a>, and <a class="el" href="a00203.html#l00433">Dune::ConstArrayListIterator&lt; T, N, A &gt;::position_</a>.</p>

</div>
</div><p>
<a class="anchor" name="g77a7f3b330f2f1642c6a4e174813714a"></a><!-- doxytag: member="Dune::ArrayListIterator::distanceTo" ref="g77a7f3b330f2f1642c6a4e174813714a" args="(const ArrayListIterator&lt; T, N, A &gt; &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ArrayListIterator&lt; T, N, A &gt;::difference_type <a class="el" href="a00008.html">Dune::ArrayListIterator</a>&lt; T, N, A &gt;::distanceTo           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00008.html">ArrayListIterator</a>&lt; T, N, A &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>Please doc me! </dd></dl>

<p>References <a class="el" href="a00203.html#l00342">Dune::ArrayListIterator&lt; T, N, A &gt;::list_</a>, and <a class="el" href="a00203.html#l00338">Dune::ArrayListIterator&lt; T, N, A &gt;::position_</a>.</p>

</div>
</div><p>
<a class="anchor" name="g89b34c1581a5b69593cc2b38041ca3e2"></a><!-- doxytag: member="Dune::ConstArrayListIterator::elementAt" ref="g89b34c1581a5b69593cc2b38041ca3e2" args="(size_type i) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const ConstArrayListIterator&lt; T, N, A &gt;::MemberType &amp; <a class="el" href="a00026.html">Dune::ConstArrayListIterator</a>&lt; T, N, A &gt;::elementAt           </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>i</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the value of the list at an arbitrary position. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value at that postion. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb265dca18afec7e88c4e6572b2ad87f6"></a><!-- doxytag: member="Dune::ArrayListIterator::elementAt" ref="gb265dca18afec7e88c4e6572b2ad87f6" args="(size_type i) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ArrayListIterator&lt; T, N, A &gt;::MemberType &amp; <a class="el" href="a00008.html">Dune::ArrayListIterator</a>&lt; T, N, A &gt;::elementAt           </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>i</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the value of the list at an arbitrary position. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value at that postion. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gc74361d124cf27c5e7384a66b9bcda02"></a><!-- doxytag: member="Dune::SLList::empty" ref="gc74361d124cf27c5e7384a66b9bcda02" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00116.html">Dune::SLList</a>&lt; T, A &gt;::empty           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check whether the list is empty. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if the list is empty; </dd></dl>

</div>
</div><p>
<a class="anchor" name="gad3fcc3d6ac7c80b6b30bf33648abfc0"></a><!-- doxytag: member="Dune::Array::end" ref="gad3fcc3d6ac7c80b6b30bf33648abfc0" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Array&lt; T &gt;::Iterator <a class="el" href="a00005.html">Dune::Array</a>&lt; T &gt;::end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return iterator refering to one past the last element of the <a class="el" href="a00004.html" title="Simple fixed size array class.">array</a>. 
<p>
<a class="el" href="a00006.html" title="An iterator to access all components of array.">Iterator</a> interface. 
<p>References <a class="el" href="a00202.html#l00035">Dune::Array&lt; T &gt;::Iterator::p</a>.</p>

</div>
</div><p>
<a class="anchor" name="g79b03872a4227720653e9c6e13916f63"></a><!-- doxytag: member="Dune::SLList::end" ref="g79b03872a4227720653e9c6e13916f63" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SLListConstIterator&lt; T, A &gt; <a class="el" href="a00116.html">Dune::SLList</a>&lt; T, A &gt;::end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator pointing to the end of the list. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An iterator pointing to the end. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g8eee1922ee4cf09e85c03af4ceef39ed"></a><!-- doxytag: member="Dune::SLList::end" ref="g8eee1922ee4cf09e85c03af4ceef39ed" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SLListIterator&lt; T, A &gt; <a class="el" href="a00116.html">Dune::SLList</a>&lt; T, A &gt;::end           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator pointing to the end of the list. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An iterator pointing to the end. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g1859abb70b39f6cd675d5d1f6c23a5e0"></a><!-- doxytag: member="Dune::SLList::endModify" ref="g1859abb70b39f6cd675d5d1f6c23a5e0" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">SLListModifyIterator&lt; T, A &gt; <a class="el" href="a00116.html">Dune::SLList</a>&lt; T, A &gt;::endModify           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get an iterator capable of deleting and inserting elements. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Modifying iterator positioned after the end of the list. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g22acf5061c608c5967871bb6cb6ae729"></a><!-- doxytag: member="Dune::ConstArrayListIterator::equals" ref="g22acf5061c608c5967871bb6cb6ae729" args="(const ConstArrayListIterator&lt; MemberType, N, A &gt; &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00026.html">Dune::ConstArrayListIterator</a>&lt; T, N, A &gt;::equals           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00026.html">ConstArrayListIterator</a>&lt; <a class="el" href="a00026.html#17f853264e435614b1b7be688122b686">MemberType</a>, N, A &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Comares to iterators. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the iterators are for the same list and at the position. </dd></dl>

<p>References <a class="el" href="a00203.html#l00437">Dune::ConstArrayListIterator&lt; T, N, A &gt;::list_</a>, and <a class="el" href="a00203.html#l00433">Dune::ConstArrayListIterator&lt; T, N, A &gt;::position_</a>.</p>

</div>
</div><p>
<a class="anchor" name="g20fc3b0f08378ff91a81bc537a9220f0"></a><!-- doxytag: member="Dune::ArrayListIterator::equals" ref="g20fc3b0f08378ff91a81bc537a9220f0" args="(const ConstArrayListIterator&lt; MemberType, N, A &gt; &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00008.html">Dune::ArrayListIterator</a>&lt; T, N, A &gt;::equals           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00026.html">ConstArrayListIterator</a>&lt; <a class="el" href="a00008.html#44d8c9d4aa483f2caaf01337649a12d8">MemberType</a>, N, A &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Comares two iterators. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if the iterators are for the same list and at the position. </dd></dl>

<p>References <a class="el" href="a00203.html#l00437">Dune::ConstArrayListIterator&lt; T, N, A &gt;::list_</a>, and <a class="el" href="a00203.html#l00433">Dune::ConstArrayListIterator&lt; T, N, A &gt;::position_</a>.</p>

</div>
</div><p>
<a class="anchor" name="g2d2c288766bed54d81aef9ece437c925"></a><!-- doxytag: member="Dune::ArrayListIterator::equals" ref="g2d2c288766bed54d81aef9ece437c925" args="(const ArrayListIterator&lt; MemberType, N, A &gt; &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00008.html">Dune::ArrayListIterator</a>&lt; T, N, A &gt;::equals           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00008.html">ArrayListIterator</a>&lt; <a class="el" href="a00008.html#44d8c9d4aa483f2caaf01337649a12d8">MemberType</a>, N, A &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Comares two iterators. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if the iterators are for the same list and at the position. </dd></dl>

<p>References <a class="el" href="a00203.html#l00342">Dune::ArrayListIterator&lt; T, N, A &gt;::list_</a>, and <a class="el" href="a00203.html#l00338">Dune::ArrayListIterator&lt; T, N, A &gt;::position_</a>.</p>

</div>
</div><p>
<a class="anchor" name="g8ac0a9ab1ee0a848b0b22c43b1bd36a5"></a><!-- doxytag: member="Dune::SLListModifyIterator::equals" ref="g8ac0a9ab1ee0a848b0b22c43b1bd36a5" args="(const SLListModifyIterator&lt; T, A &gt; &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00119.html">Dune::SLListModifyIterator</a>&lt; T, A &gt;::equals           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00119.html">SLListModifyIterator</a>&lt; T, A &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Test whether another iterator is equal. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the other iterator is at the same position as this one. </dd></dl>

<p>References <a class="el" href="a00241.html#l00527">Dune::SLListModifyIterator&lt; T, A &gt;::iterator_</a>.</p>

</div>
</div><p>
<a class="anchor" name="ga10e4670355e1294786f738733e944cc"></a><!-- doxytag: member="Dune::SLListModifyIterator::equals" ref="ga10e4670355e1294786f738733e944cc" args="(const SLListIterator&lt; T, A &gt; &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00119.html">Dune::SLListModifyIterator</a>&lt; T, A &gt;::equals           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00118.html">SLListIterator</a>&lt; T, A &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Test whether another iterator is equal. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the other iterator is at the same position as this one. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g9805d4f139dbfc5012ed7cc2529e4d04"></a><!-- doxytag: member="Dune::SLListModifyIterator::equals" ref="g9805d4f139dbfc5012ed7cc2529e4d04" args="(const SLListConstIterator&lt; T, A &gt; &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00119.html">Dune::SLListModifyIterator</a>&lt; T, A &gt;::equals           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00117.html">SLListConstIterator</a>&lt; T, A &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Test whether another iterator is equal. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the other iterator is at the same position as this one. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g90d32112d46785cf69962f5913eed2d4"></a><!-- doxytag: member="Dune::SLListConstIterator::equals" ref="g90d32112d46785cf69962f5913eed2d4" args="(const SLListConstIterator&lt; T, A &gt; &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00117.html">Dune::SLListConstIterator</a>&lt; T, A &gt;::equals           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00117.html">SLListConstIterator</a>&lt; T, A &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equality test for the iterator facade. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>The other iterator to check. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true If the other iterator is at the same position. </dd></dl>

<p>References <a class="el" href="a00241.html#l00416">Dune::SLListConstIterator&lt; T, A &gt;::current_</a>.</p>

</div>
</div><p>
<a class="anchor" name="g9644fc7ba7f428fffe069a2b64bb063d"></a><!-- doxytag: member="Dune::SLListIterator::equals" ref="g9644fc7ba7f428fffe069a2b64bb063d" args="(const SLListModifyIterator&lt; T, A &gt; &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00118.html">Dune::SLListIterator</a>&lt; T, A &gt;::equals           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00119.html">SLListModifyIterator</a>&lt; T, A &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equality test for the iterator facade. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>The other iterator to check. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true If the other iterator is at the same position. </dd></dl>

<p>References <a class="el" href="a00241.html#l00527">Dune::SLListModifyIterator&lt; T, A &gt;::iterator_</a>.</p>

</div>
</div><p>
<a class="anchor" name="g505c5ed0d921eb390a6878002db2d86a"></a><!-- doxytag: member="Dune::SLListIterator::equals" ref="g505c5ed0d921eb390a6878002db2d86a" args="(const SLListIterator&lt; T, A &gt; &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00118.html">Dune::SLListIterator</a>&lt; T, A &gt;::equals           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00118.html">SLListIterator</a>&lt; T, A &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equality test for the iterator facade. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>The other iterator to check. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true If the other iterator is at the same position. </dd></dl>

<p>References <a class="el" href="a00241.html#l00352">Dune::SLListIterator&lt; T, A &gt;::current_</a>.</p>

</div>
</div><p>
<a class="anchor" name="gf63a1bd5ca049d868a51d8b1980626ed"></a><!-- doxytag: member="Dune::SLListIterator::equals" ref="gf63a1bd5ca049d868a51d8b1980626ed" args="(const SLListConstIterator&lt; T, A &gt; &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00118.html">Dune::SLListIterator</a>&lt; T, A &gt;::equals           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00117.html">SLListConstIterator</a>&lt; T, A &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equality test for the iterator facade. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>The other iterator to check. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true If the other iterator is at the same position. </dd></dl>

<p>References <a class="el" href="a00241.html#l00416">Dune::SLListConstIterator&lt; T, A &gt;::current_</a>.</p>

</div>
</div><p>
<a class="anchor" name="g492de54ad819c0b784b7981d68228e4d"></a><!-- doxytag: member="Dune::ArrayListIterator::eraseToHere" ref="g492de54ad819c0b784b7981d68228e4d" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00008.html">Dune::ArrayListIterator</a>&lt; T, N, A &gt;::eraseToHere           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Erase all entries before the current position and the one at the current position. 
<p>
Afterwards the iterator will be positioned at the next unerased entry or the end if the list is empty. This does not invalidate any iterators positioned after the current position but those positioned at previous ones. <dl class="return" compact><dt><b>Returns:</b></dt><dd>An iterator to the first position after the deleted ones or to the end if the list is empty. </dd></dl>

<p>References <a class="el" href="a00203.html#l00258">Dune::ArrayListIterator&lt; T, N, A &gt;::chunkSize_</a>.</p>

</div>
</div><p>
<a class="anchor" name="g3e86cfcccb48459b5f439ecadb0828d8"></a><!-- doxytag: member="Dune::Pair&lt; T1, Nil &gt;::first" ref="g3e86cfcccb48459b5f439ecadb0828d8" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TupleAccessTraits&lt; T1 &gt;::ConstType <a class="el" href="a00096.html">Dune::Pair</a>&lt; T1, Nil &gt;::first           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the first value. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The first value </dd></dl>

<p>References <a class="el" href="a00248.html#l00167">Dune::Pair&lt; T1, TT &gt;::first_</a>.</p>

</div>
</div><p>
<a class="anchor" name="gd99aea5c67f5164e03a0a5fa4c826837"></a><!-- doxytag: member="Dune::Pair&lt; T1, Nil &gt;::first" ref="gd99aea5c67f5164e03a0a5fa4c826837" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TupleAccessTraits&lt; T1 &gt;::NonConstType <a class="el" href="a00096.html">Dune::Pair</a>&lt; T1, Nil &gt;::first           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the first value. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The first value </dd></dl>

<p>References <a class="el" href="a00248.html#l00167">Dune::Pair&lt; T1, TT &gt;::first_</a>.</p>

</div>
</div><p>
<a class="anchor" name="gfc42133f1c2e07ef6ffda6b0809ec9ef"></a><!-- doxytag: member="Dune::Pair::first" ref="gfc42133f1c2e07ef6ffda6b0809ec9ef" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TupleAccessTraits&lt; T1 &gt;::ConstType <a class="el" href="a00096.html">Dune::Pair</a>&lt; T1, T2 &gt;::first           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the first value. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The first value </dd></dl>

<p>References <a class="el" href="a00248.html#l00167">Dune::Pair&lt; T1, TT &gt;::first_</a>.</p>

</div>
</div><p>
<a class="anchor" name="gbe61b0c28b4d21174ececf45db15a478"></a><!-- doxytag: member="Dune::Pair::first" ref="gbe61b0c28b4d21174ececf45db15a478" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TupleAccessTraits&lt; T1 &gt;::NonConstType <a class="el" href="a00096.html">Dune::Pair</a>&lt; T1, T2 &gt;::first           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the first value. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The first value </dd></dl>

<p>References <a class="el" href="a00248.html#l00167">Dune::Pair&lt; T1, TT &gt;::first_</a>.</p>

<p>Referenced by <a class="el" href="a00248.html#l00715">Dune::operator!=()</a>, and <a class="el" href="a00248.html#l00704">Dune::operator==()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g47e9484d263bece81e75897dd885f5c0"></a><!-- doxytag: member="Dune::Pool::free" ref="g47e9484d263bece81e75897dd885f5c0" args="(void *o)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, std::size_t S&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00099.html">Dune::Pool</a>&lt; T, S &gt;::free           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>o</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Free an object. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>o</em>&nbsp;</td><td>The pointer to memory block of the object. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g673fe14ed265913fddf933326ae5f88f"></a><!-- doxytag: member="Dune::Element&lt; 0 &gt;::get" ref="g673fe14ed265913fddf933326ae5f88f" args="(const Pair&lt; T1, T2 &gt; &amp;tuple)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static TupleAccessTraits&lt;T1&gt;::ConstType <a class="el" href="a00036.html">Dune::Element</a>&lt; 0 &gt;::get           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00096.html">Pair</a>&lt; T1, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>tuple</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the first element of the <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a></em>&nbsp;</td><td>The <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a> whose first element we want. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The first element of the <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gc3074e13e06b0a9e35e226b92ec4c690"></a><!-- doxytag: member="Dune::Element::get" ref="gc3074e13e06b0a9e35e226b92ec4c690" args="(const Pair&lt; T1, T2 &gt; &amp;tuple)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static TupleAccessTraits&lt; typename tuple_element&lt;N,Pair&lt;T1,T2&gt; &gt;::type &gt;::ConstType <a class="el" href="a00036.html">Dune::Element</a>&lt; N &gt;::get           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00096.html">Pair</a>&lt; T1, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>tuple</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the N-th element of the <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a></em>&nbsp;</td><td>The <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a> whose N-th element we want. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The N-th element of the <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gb584227c678fe14379ab64bf38e90fc3"></a><!-- doxytag: member="Dune::SLListModifyIterator::insert" ref="gb584227c678fe14379ab64bf38e90fc3" args="(const T &amp;v)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00119.html">Dune::SLListModifyIterator</a>&lt; T, A &gt;::insert           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert an element at the current position. 
<p>
Starting from the element at the current position all elements will be shifted by one position to the back. The iterator will point to the same element as before after the insertion, i.e the number of increments to reach the same position from a begin iterator increases by one. This means the inserted element is the one before the one the iterator points to. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>The value to insert. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gbfbcf518444b122ccb4d99633503af1f"></a><!-- doxytag: member="Dune::DoubleLinkedList::insert_after" ref="gbfbcf518444b122ccb4d99633503af1f" args="(Iterator i, T &amp;t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DoubleLinkedList&lt; T &gt;::Iterator <a class="el" href="a00033.html">Dune::DoubleLinkedList</a>&lt; T &gt;::insert_after           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00034.html">Iterator</a>&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
insert after an iterators position 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="a00034.html" title="Iterator class for the doubly-linked list.">Iterator</a> pointing to new element </dd></dl>

<p>References <a class="el" href="a00216.html#l00131">DUNE_THROW</a>, and <a class="el" href="a00214.html#l00035">Dune::DoubleLinkedList&lt; T &gt;::Iterator::p</a>.</p>

<p>Referenced by <a class="el" href="a00213.html#l00044">Dune::DoubleLinkedList&lt; T &gt;::DoubleLinkedList()</a>, <a class="el" href="a00213.html#l00054">Dune::DoubleLinkedList&lt; T &gt;::operator=()</a>, and <a class="el" href="a00243.html#l00073">Dune::Stack&lt; T &gt;::push()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gec092c60a4aa05df72763263cbfa82e7"></a><!-- doxytag: member="Dune::DoubleLinkedList::insert_before" ref="gec092c60a4aa05df72763263cbfa82e7" args="(Iterator i, T &amp;t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DoubleLinkedList&lt; T &gt;::Iterator <a class="el" href="a00033.html">Dune::DoubleLinkedList</a>&lt; T &gt;::insert_before           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00034.html">Iterator</a>&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
insert before an iterators position 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd><a class="el" href="a00034.html" title="Iterator class for the doubly-linked list.">Iterator</a> pointing to new element </dd></dl>

<p>References <a class="el" href="a00216.html#l00131">DUNE_THROW</a>, and <a class="el" href="a00214.html#l00035">Dune::DoubleLinkedList&lt; T &gt;::Iterator::p</a>.</p>

</div>
</div><p>
<a class="anchor" name="g95dbf81fd02659c2c72c2f3e08c14148"></a><!-- doxytag: member="Dune::SLListIterator::insertAfter" ref="g95dbf81fd02659c2c72c2f3e08c14148" args="(const T &amp;v) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00118.html">Dune::SLListIterator</a>&lt; T, A &gt;::insertAfter           </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Insert an element in the underlying list after the current position. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>The value to insert. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g80b54a62210bef1e5eae3eb45bbdbf52"></a><!-- doxytag: member="Dune::Array::Iterator::Iterator" ref="g80b54a62210bef1e5eae3eb45bbdbf52" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00005.html">Dune::Array</a>&lt; T &gt;::Iterator::Iterator           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default constructor. 
<p>
Constructor. 
</div>
</div><p>
<a class="anchor" name="g8bb8b6b5a1db70f6f1e8c193cc37312b"></a><!-- doxytag: member="Dune::makePair" ref="g8bb8b6b5a1db70f6f1e8c193cc37312b" args="(const T1 &amp;first, const T2 &amp;second)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Pair&lt;T1,T2&gt; Dune::makePair           </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&nbsp;</td>
          <td class="paramname"> <em>second</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a> and initialize it. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>The value of the first field. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>second</em>&nbsp;</td><td>The value of the second field. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g67f33244a7dcb098c9c924301ac70833"></a><!-- doxytag: member="Dune::operator!=" ref="g67f33244a7dcb098c9c924301ac70833" args="(const Pair&lt; T1, T2 &gt; &amp;tuple1, const Pair&lt; U1, Nil &gt; &amp;tuple2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2, typename U1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Dune::operator!=           </td>
          <td>(</td>
          <td class="paramtype">const Pair&lt; T1, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>tuple1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Pair&lt; U1, Nil &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>tuple2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inequality comparison operator for tuples. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tuple1</em>&nbsp;</td><td>The first <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tuple2</em>&nbsp;</td><td>The second <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True as the type of the compared objects are different. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g78746f0e4f7028746c95daf40d799008"></a><!-- doxytag: member="Dune::operator!=" ref="g78746f0e4f7028746c95daf40d799008" args="(const Pair&lt; T1, Nil &gt; &amp;tuple1, const Pair&lt; U1, U2 &gt; &amp;tuple2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename U1, typename U2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Dune::operator!=           </td>
          <td>(</td>
          <td class="paramtype">const Pair&lt; T1, Nil &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>tuple1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Pair&lt; U1, U2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>tuple2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inequality comparison operator for tuples. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tuple1</em>&nbsp;</td><td>The first <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tuple2</em>&nbsp;</td><td>The second <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True as the type of the compared objects are different. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g88b81aaa691d955587a4ba6d34ab5be5"></a><!-- doxytag: member="Dune::operator!=" ref="g88b81aaa691d955587a4ba6d34ab5be5" args="(const Pair&lt; T1, Nil &gt; &amp;tuple1, const Pair&lt; U1, Nil &gt; &amp;tuple2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename U1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Dune::operator!=           </td>
          <td>(</td>
          <td class="paramtype">const Pair&lt; T1, Nil &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>tuple1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Pair&lt; U1, Nil &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>tuple2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inequality comparison operator for tuples. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tuple1</em>&nbsp;</td><td>The first <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tuple2</em>&nbsp;</td><td>The second <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a>, </td></tr>
  </table>
</dl>

<p>References <a class="el" href="a00248.html#l01000">Dune::Pair&lt; T1, TT &gt;::first()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g4d2687d1ad1eca4e78fac5e5df8e2583"></a><!-- doxytag: member="Dune::operator!=" ref="g4d2687d1ad1eca4e78fac5e5df8e2583" args="(const Pair&lt; T1, T2 &gt; &amp;tuple1, const Pair&lt; U1, U2 &gt; &amp;tuple2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2, typename U1, typename U2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Dune::operator!=           </td>
          <td>(</td>
          <td class="paramtype">const Pair&lt; T1, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>tuple1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Pair&lt; U1, U2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>tuple2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inequality comparison operator for tuples. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tuple1</em>&nbsp;</td><td>The first <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tuple2</em>&nbsp;</td><td>The second <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a>, </td></tr>
  </table>
</dl>

<p>References <a class="el" href="a00248.html#l01000">Dune::Pair&lt; T1, TT &gt;::first()</a>, and <a class="el" href="a00248.html#l01015">Dune::Pair&lt; T1, TT &gt;::second()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gfc20cae176d4dac1082dfc59caa8a82b"></a><!-- doxytag: member="Dune::Array::Iterator::operator++" ref="gfc20cae176d4dac1082dfc59caa8a82b" args="(int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Array&lt; T &gt;::Iterator <a class="el" href="a00005.html">Dune::Array</a>&lt; T &gt;::Iterator::operator++           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Postfix increment. 
<p>
Postfix-increment operator. 
</div>
</div><p>
<a class="anchor" name="g0b6e99caa52b02a9727ff48a4be0c74a"></a><!-- doxytag: member="Dune::Array::Iterator::operator++" ref="g0b6e99caa52b02a9727ff48a4be0c74a" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Array&lt; T &gt;::Iterator <a class="el" href="a00005.html">Dune::Array</a>&lt; T &gt;::Iterator::operator++           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prefix increment. 
<p>
Prefix-increment operator. 
</div>
</div><p>
<a class="anchor" name="g30279b6b38b8d3cab6163f1bee283c5e"></a><!-- doxytag: member="Dune::Array::Iterator::operator-&gt;" ref="g30279b6b38b8d3cab6163f1bee283c5e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T * <a class="el" href="a00005.html">Dune::Array</a>&lt; T &gt;::Iterator::operator-&gt;           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
selector 
<p>
Dereferencing. 
</div>
</div><p>
<a class="anchor" name="g0d66fe6bdca738355692d6912413a3bc"></a><!-- doxytag: member="Dune::operator&lt;" ref="g0d66fe6bdca738355692d6912413a3bc" args="(const Pair&lt; T1, Nil &gt; &amp;tuple1, const Pair&lt; U1, Nil &gt; &amp;tuple2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename U1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Dune::operator&lt;           </td>
          <td>(</td>
          <td class="paramtype">const Pair&lt; T1, Nil &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>tuple1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Pair&lt; U1, Nil &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>tuple2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Less operator for tuples. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tuple1</em>&nbsp;</td><td>The first <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tuple2</em>&nbsp;</td><td>The second <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a>, </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g55bc73cb2500088ef3cfa9bdbd679be9"></a><!-- doxytag: member="Dune::operator&lt;" ref="g55bc73cb2500088ef3cfa9bdbd679be9" args="(const Pair&lt; T1, T2 &gt; &amp;tuple1, const Pair&lt; U1, U2 &gt; &amp;tuple2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2, typename U1, typename U2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Dune::operator&lt;           </td>
          <td>(</td>
          <td class="paramtype">const Pair&lt; T1, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>tuple1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Pair&lt; U1, U2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>tuple2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Less operator for tuples. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tuple1</em>&nbsp;</td><td>The first <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tuple2</em>&nbsp;</td><td>The second <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a>, </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ge0d198bd472c7e6e5358fd51dd27f9d1"></a><!-- doxytag: member="Dune::ArrayListIterator::operator=" ref="ge0d198bd472c7e6e5358fd51dd27f9d1" args="(const ArrayListIterator&lt; T, N, A &gt; &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ArrayListIterator&lt; T, N, A &gt; &amp; <a class="el" href="a00008.html">Dune::ArrayListIterator</a>&lt; T, N, A &gt;::operator=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00008.html">ArrayListIterator</a>&lt; T, N, A &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>Please doc me! </dd></dl>

<p>References <a class="el" href="a00203.html#l00342">Dune::ArrayListIterator&lt; T, N, A &gt;::list_</a>, and <a class="el" href="a00203.html#l00338">Dune::ArrayListIterator&lt; T, N, A &gt;::position_</a>.</p>

</div>
</div><p>
<a class="anchor" name="gae2b51ada5007b7dc1a7f52b0ece8518"></a><!-- doxytag: member="Dune::tuple::operator=" ref="gae2b51ada5007b7dc1a7f52b0ece8518" args="(const Pair&lt; U1, U2 &gt; &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2 = Nil, typename T3 = Nil, typename T4 = Nil, typename T5 = Nil, typename T6 = Nil, typename T7 = Nil, typename T8 = Nil, typename T9 = Nil&gt; </div>
<div class="memtemplate">
template&lt;class U1, class U2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tuple&amp; <a class="el" href="a00126.html">Dune::tuple</a>&lt; T1, T2, T3, T4, T5, T6, T7, T8, T9 &gt;::operator=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00096.html">Pair</a>&lt; U1, U2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assignment operator for implicit type conversion. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>The <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a> to assign. </td></tr>
  </table>
</dl>

<p>Reimplemented from <a class="el" href="a00191.html#gb74608fd7b95e4af09e8006222e21d7f">Dune::Pair&lt; T1, TT &gt;</a>.</p>

<p>References <a class="el" href="a00248.html#l00983">Dune::Pair&lt; T1, TT &gt;::operator=()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gb74608fd7b95e4af09e8006222e21d7f"></a><!-- doxytag: member="Dune::Pair::operator=" ref="gb74608fd7b95e4af09e8006222e21d7f" args="(const Pair&lt; U1, U2 &gt; &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
<div class="memtemplate">
template&lt;typename U1, typename U2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Pair&lt; T1, T2 &gt; &amp; <a class="el" href="a00096.html">Dune::Pair</a>&lt; T1, T2 &gt;::operator=           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00096.html">Pair</a>&lt; U1, U2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assignment operator for implicit type conversion. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>The <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a> to assign. </td></tr>
  </table>
</dl>

<p>Reimplemented in <a class="el" href="a00191.html#gae2b51ada5007b7dc1a7f52b0ece8518">Dune::tuple&lt; T1, T2, T3, T4, T5, T6, T7, T8, T9 &gt;</a>.</p>

<p>References <a class="el" href="a00248.html#l00167">Dune::Pair&lt; T1, TT &gt;::first_</a>, and <a class="el" href="a00248.html#l00169">Dune::Pair&lt; T1, TT &gt;::second_</a>.</p>

<p>Referenced by <a class="el" href="a00248.html#l00383">Dune::tuple&lt; T1, T2, T3, T4, T5, T6, T7, T8, T9 &gt;::operator=()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g57bf4ce9229d1105a6fee2c58bd2ef3c"></a><!-- doxytag: member="Dune::operator==" ref="g57bf4ce9229d1105a6fee2c58bd2ef3c" args="(const Pair&lt; T1, T2 &gt; &amp;tuple1, const Pair&lt; U1, Nil &gt; &amp;tuple2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2, typename U1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Dune::operator==           </td>
          <td>(</td>
          <td class="paramtype">const Pair&lt; T1, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>tuple1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Pair&lt; U1, Nil &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>tuple2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equality comparison operator for tuples. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tuple1</em>&nbsp;</td><td>The first <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tuple2</em>&nbsp;</td><td>The second <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>False as the type of the compared objects are different. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g3d2ad94764611e5356694e02a323a072"></a><!-- doxytag: member="Dune::operator==" ref="g3d2ad94764611e5356694e02a323a072" args="(const Pair&lt; T1, Nil &gt; &amp;tuple1, const Pair&lt; U1, U2 &gt; &amp;tuple2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename U1, typename U2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Dune::operator==           </td>
          <td>(</td>
          <td class="paramtype">const Pair&lt; T1, Nil &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>tuple1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Pair&lt; U1, U2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>tuple2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equality comparison operator for tuples. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tuple1</em>&nbsp;</td><td>The first <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tuple2</em>&nbsp;</td><td>The second <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>False as the type of the compared objects are different. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gc16eda811e356babe5b8a1736c7f5694"></a><!-- doxytag: member="Dune::operator==" ref="gc16eda811e356babe5b8a1736c7f5694" args="(const Pair&lt; T1, Nil &gt; &amp;tuple1, const Pair&lt; U1, Nil &gt; &amp;tuple2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename U1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Dune::operator==           </td>
          <td>(</td>
          <td class="paramtype">const Pair&lt; T1, Nil &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>tuple1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Pair&lt; U1, Nil &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>tuple2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equality comparison operator for tuples. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tuple1</em>&nbsp;</td><td>The first <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tuple2</em>&nbsp;</td><td>The second <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a>, </td></tr>
  </table>
</dl>

<p>References <a class="el" href="a00248.html#l01000">Dune::Pair&lt; T1, TT &gt;::first()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gfc4454ea9411ef5cdfdbbf751bdf0801"></a><!-- doxytag: member="Dune::operator==" ref="gfc4454ea9411ef5cdfdbbf751bdf0801" args="(const Pair&lt; T1, T2 &gt; &amp;tuple1, const Pair&lt; U1, U2 &gt; &amp;tuple2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2, typename U1, typename U2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Dune::operator==           </td>
          <td>(</td>
          <td class="paramtype">const Pair&lt; T1, T2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>tuple1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Pair&lt; U1, U2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>tuple2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Equality comparison operator for tuples. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tuple1</em>&nbsp;</td><td>The first <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tuple2</em>&nbsp;</td><td>The second <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a>, </td></tr>
  </table>
</dl>

<p>References <a class="el" href="a00248.html#l01000">Dune::Pair&lt; T1, TT &gt;::first()</a>, and <a class="el" href="a00248.html#l01015">Dune::Pair&lt; T1, TT &gt;::second()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gf4f9d40ec569ddcda1f5869b776cee8d"></a><!-- doxytag: member="Dune::ArrayList::operator[]" ref="gf4f9d40ec569ddcda1f5869b776cee8d" args="(size_type i) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ArrayList&lt; T, N, A &gt;::const_reference <a class="el" href="a00007.html">Dune::ArrayList</a>&lt; T, N, A &gt;::operator[]           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00007.html#c7115acf8023bbe985125ca3a3b11d6f">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>i</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the element at specific position. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The index of the position. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The element at that position. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g00fb2e9b1c7ed63dc48185d9fece84b3"></a><!-- doxytag: member="Dune::ArrayList::operator[]" ref="g00fb2e9b1c7ed63dc48185d9fece84b3" args="(size_type i)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ArrayList&lt; T, N, A &gt;::reference <a class="el" href="a00007.html">Dune::ArrayList</a>&lt; T, N, A &gt;::operator[]           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00007.html#c7115acf8023bbe985125ca3a3b11d6f">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>i</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the element at specific position. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The index of the position. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The element at that position. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g4b70002789d7c8c5fd8a259b0019adf1"></a><!-- doxytag: member="Dune::Pair&lt; T1, Nil &gt;::Pair" ref="g4b70002789d7c8c5fd8a259b0019adf1" args="(typename TupleAccessTraits&lt; T1 &gt;::ParameterType first, const Nil &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00096.html">Dune::Pair</a>&lt; T1, Nil &gt;::Pair           </td>
          <td>(</td>
          <td class="paramtype">typename TupleAccessTraits&lt; T1 &gt;::ParameterType&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00091.html">Nil</a> &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t1</em>&nbsp;</td><td>The values for the first field. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t2</em>&nbsp;</td><td>The value for the second field. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g927d4b64b27030ba8d6452571185fe5b"></a><!-- doxytag: member="Dune::Pair&lt; T1, Nil &gt;::Pair" ref="g927d4b64b27030ba8d6452571185fe5b" args="(typename TupleAccessTraits&lt; T1 &gt;::ParameterType first, const Nil &amp;, const Nil &amp;, const Nil &amp;, const Nil &amp;, const Nil &amp;, const Nil &amp;, const Nil &amp;, const Nil &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00096.html">Dune::Pair</a>&lt; T1, Nil &gt;::Pair           </td>
          <td>(</td>
          <td class="paramtype">typename TupleAccessTraits&lt; T1 &gt;::ParameterType&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00091.html">Nil</a> &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00091.html">Nil</a> &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00091.html">Nil</a> &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00091.html">Nil</a> &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00091.html">Nil</a> &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00091.html">Nil</a> &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00091.html">Nil</a> &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00091.html">Nil</a> &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t1</em>&nbsp;</td><td>The values for the first field. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t2</em>&nbsp;</td><td>The value for the second field. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g08933df7ca2fa89f08035246e3ac9210"></a><!-- doxytag: member="Dune::Pair::Pair" ref="g08933df7ca2fa89f08035246e3ac9210" args="(const Pair&lt; U1, U2 &gt; &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
<div class="memtemplate">
template&lt;typename U1, typename U2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00096.html">Dune::Pair</a>&lt; T1, T2 &gt;::Pair           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00096.html">Pair</a>&lt; U1, U2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy Constructor for implicit type conversion. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>The <a class="el" href="a00126.html" title="A Tuple of objects.">tuple</a> to copy. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g9fbcf451ebc1a0bc143e8d32c681d107"></a><!-- doxytag: member="Dune::Pair::Pair" ref="g9fbcf451ebc1a0bc143e8d32c681d107" args="(typename TupleAccessTraits&lt; Type1 &gt;::ParameterType t1, TT &amp;t2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename TT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00096.html">Dune::Pair</a>&lt; T1, TT &gt;::Pair           </td>
          <td>(</td>
          <td class="paramtype">typename TupleAccessTraits&lt; <a class="el" href="a00096.html#9ee7524fd4ea7127402db2b952573608">Type1</a> &gt;::ParameterType&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TT &amp;&nbsp;</td>
          <td class="paramname"> <em>t2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t1</em>&nbsp;</td><td>The value of the first field. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t2</em>&nbsp;</td><td>The value of the second field. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gb1d5499b4b8f3d3d2c71fbefdc2c8200"></a><!-- doxytag: member="Dune::Pair::Pair" ref="gb1d5499b4b8f3d3d2c71fbefdc2c8200" args="(typename TupleAccessTraits&lt; T1 &gt;::ParameterType t1, T2 &amp;t2, T3 &amp;t3, T4 &amp;t4, T5 &amp;t5, T6 &amp;t6, T7 &amp;t7, T8 &amp;t8, T9 &amp;t9)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename TT&gt; </div>
<div class="memtemplate">
template&lt;typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00096.html">Dune::Pair</a>&lt; T1, TT &gt;::Pair           </td>
          <td>(</td>
          <td class="paramtype">typename TupleAccessTraits&lt; T1 &gt;::ParameterType&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&nbsp;</td>
          <td class="paramname"> <em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T3 &amp;&nbsp;</td>
          <td class="paramname"> <em>t3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T4 &amp;&nbsp;</td>
          <td class="paramname"> <em>t4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T5 &amp;&nbsp;</td>
          <td class="paramname"> <em>t5</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T6 &amp;&nbsp;</td>
          <td class="paramname"> <em>t6</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T7 &amp;&nbsp;</td>
          <td class="paramname"> <em>t7</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T8 &amp;&nbsp;</td>
          <td class="paramname"> <em>t8</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T9 &amp;&nbsp;</td>
          <td class="paramname"> <em>t9</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The number of values we hold. 
<p>
Constructor <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t1</em>&nbsp;</td><td>The value of the first field. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t2</em>&nbsp;</td><td>The value of the second field. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g2b627c8796d6946f57458f9e90980397"></a><!-- doxytag: member="Dune::ArrayList::purge" ref="g2b627c8796d6946f57458f9e90980397" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00007.html">Dune::ArrayList</a>&lt; T, N, A &gt;::purge           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Purge the list. 
<p>
If there are empty chunks at the front all nonempty chunks will be moved towards the front and the capacity increases. 
<p>References <a class="el" href="a00203.html#l00086">Dune::ArrayList&lt; T, N, A &gt;::chunkSize_</a>.</p>

</div>
</div><p>
<a class="anchor" name="ge5d0068f5773845dd133cb2cc6c2ab9c"></a><!-- doxytag: member="Dune::ArrayList::push_back" ref="ge5d0068f5773845dd133cb2cc6c2ab9c" args="(const_reference entry)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00007.html">Dune::ArrayList</a>&lt; T, N, A &gt;::push_back           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00007.html#9001bd10815a115576b70fc7c5eed675">const_reference</a>&nbsp;</td>
          <td class="paramname"> <em>entry</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Append an entry to the list. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>entry</em>&nbsp;</td><td>The new entry. </td></tr>
  </table>
</dl>

<p>References <a class="el" href="a00203.html#l00086">Dune::ArrayList&lt; T, N, A &gt;::chunkSize_</a>.</p>

</div>
</div><p>
<a class="anchor" name="g0a71f761f2ee2a6d5c72c5b8b6b60f0e"></a><!-- doxytag: member="Dune::SLList::push_back" ref="g0a71f761f2ee2a6d5c72c5b8b6b60f0e" args="(const MemberType &amp;item)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00116.html">Dune::SLList</a>&lt; T, A &gt;::push_back           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00191.html#g9548258d3f4de56a110c6f549780ec2a">MemberType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a new entry to the end of the list. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>item</em>&nbsp;</td><td>The item to add. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g07373aa465c1db378233026b89420275"></a><!-- doxytag: member="Dune::SLList::push_front" ref="g07373aa465c1db378233026b89420275" args="(const MemberType &amp;item)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00116.html">Dune::SLList</a>&lt; T, A &gt;::push_front           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00191.html#g9548258d3f4de56a110c6f549780ec2a">MemberType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>item</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Add a new entry to the beginning of the list. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>item</em>&nbsp;</td><td>The item to add. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ge1aa043816f91daf4d1cc0d680b6cec0"></a><!-- doxytag: member="Dune::SLListModifyIterator::remove" ref="ge1aa043816f91daf4d1cc0d680b6cec0" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00119.html">Dune::SLListModifyIterator</a>&lt; T, A &gt;::remove           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete the entry at the current position. 
<p>
The iterator will be positioned at the next postion after the deletion <dl class="warning" compact><dt><b>Warning:</b></dt><dd>This will invalidate all iterators positioned at the delete position! Use with care! </dd></dl>

</div>
</div><p>
<a class="anchor" name="gdeb2730e24ef28a1562b3c0a8fe2ada5"></a><!-- doxytag: member="Dune::Array::resize" ref="gdeb2730e24ef28a1562b3c0a8fe2ada5" args="(int m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00005.html">Dune::Array</a>&lt; T &gt;::resize           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>m</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
reallocate <a class="el" href="a00004.html" title="Simple fixed size array class.">array</a> with size m 
<p>
Resizing of an <a class="el" href="a00004.html" title="Simple fixed size array class.">array</a> Resizing causes the old <a class="el" href="a00004.html" title="Simple fixed size array class.">array</a> to be deleted. All data is lost! 
<p>References <a class="el" href="a00216.html#l00131">DUNE_THROW</a>.</p>

<p>Referenced by <a class="el" href="a00202.html#l00161">Dune::Array&lt; T &gt;::processXdr()</a>, and <a class="el" href="a00202.html#l00090">Dune::Array&lt; T &gt;::realloc()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g613519eab98df27973d23ea8de72533b"></a><!-- doxytag: member="Dune::Pair::second" ref="g613519eab98df27973d23ea8de72533b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TupleAccessTraits&lt; T2 &gt;::ConstType <a class="el" href="a00096.html">Dune::Pair</a>&lt; T1, T2 &gt;::second           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the second value. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The second value </dd></dl>

<p>References <a class="el" href="a00248.html#l00169">Dune::Pair&lt; T1, TT &gt;::second_</a>.</p>

</div>
</div><p>
<a class="anchor" name="g3f6e5cfc1cb0f7618c4c4cfa294a4e0c"></a><!-- doxytag: member="Dune::Pair::second" ref="g3f6e5cfc1cb0f7618c4c4cfa294a4e0c" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1, typename T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TupleAccessTraits&lt; T2 &gt;::NonConstType <a class="el" href="a00096.html">Dune::Pair</a>&lt; T1, T2 &gt;::second           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the second value. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The second value </dd></dl>

<p>References <a class="el" href="a00248.html#l00169">Dune::Pair&lt; T1, TT &gt;::second_</a>.</p>

<p>Referenced by <a class="el" href="a00248.html#l00715">Dune::operator!=()</a>, and <a class="el" href="a00248.html#l00704">Dune::operator==()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gc813ed76944fdbae6e71d8792e4af432"></a><!-- doxytag: member="Dune::ArrayList::size" ref="gc813ed76944fdbae6e71d8792e4af432" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, int N, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="a00007.html">Dune::ArrayList</a>&lt; T, N, A &gt;::size           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the number of elements in the list. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of elements. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ge35bbe2177c815c5fd307be741e98bda"></a><!-- doxytag: member="Dune::SmartPointer::SmartPointer" ref="ge35bbe2177c815c5fd307be741e98bda" args="(const SmartPointer&lt; T &gt; &amp;pointer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00120.html">Dune::SmartPointer</a>&lt; T &gt;::SmartPointer           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00120.html">SmartPointer</a>&lt; T &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>pointer</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Copy constructor. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pointer</em>&nbsp;</td><td>The object to copy. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g225f341e109cd3a122ab84584e3ee36c"></a><!-- doxytag: member="Dune::Array::~Array" ref="g225f341e109cd3a122ab84584e3ee36c" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00005.html">Dune::Array</a>&lt; T &gt;::~Array           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
destructor 
<p>
Destructor Deletes contents of <a class="el" href="a00004.html" title="Simple fixed size array class.">array</a>. 
</div>
</div><p>
<a class="anchor" name="gfa3231a07e56ae81cc6334e19d603a23"></a><!-- doxytag: member="Dune::SLList::~SLList" ref="gfa3231a07e56ae81cc6334e19d603a23" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00116.html">Dune::SLList</a>&lt; T, A &gt;::~SLList           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>
Deallocates all elements in the list. 
<p>References <a class="el" href="a00241.html#l00717">Dune::SLList&lt; T, A &gt;::clear()</a>.</p>

</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="g4a76589a319b7f5011856d565443e9e5"></a><!-- doxytag: member="Dune::DUNE_DEPRECATED" ref="g4a76589a319b7f5011856d565443e9e5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="a00111.html">Dune::SameType</a>&lt; T, T &gt; Dune::DUNE_DEPRECATED          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
(DEPRECATED) A doubly-linked list 
<p>
Compile time test for testing whether two types are the same.<p>
Removes a const qualifier while preserving others.<p>
Simple fixed size <a class="el" href="a00004.html" title="Simple fixed size array class.">array</a> class.<p>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Please use std::list </dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="a00004.html" title="Simple fixed size array class.">array</a> </dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated:</a></b></dt><dd>Use <a class="el" href="a00109.html" title="Removes a const qualifier while preserving others.">remove_const</a> instead! </dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated:</a></b></dt><dd>Use <a class="el" href="a00077.html" title="Compile time test for testing whether two types are the same.">is_same</a> instead! </dd></dl>
<dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000008">Deprecated:</a></b></dt><dd>Use <a class="el" href="a00077.html" title="Compile time test for testing whether two types are the same.">is_same</a> instead! </dd></dl>

</div>
</div><p>
</div>
</div> <!-- end doxygen -->
</div> <!-- end main -->
<div class="foot">

<p class="foot">
  Generated on 6 Nov 2008 with <a
  href="http://www.doxygen.org/">Doxygen</a> (ver 1.5.6)  
  [<a href="doxygen.log">logfile</a>].
</p>

</div>

</body>
</html>
