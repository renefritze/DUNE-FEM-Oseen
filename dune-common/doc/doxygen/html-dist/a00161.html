<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN""http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>dune-common: iteratorfacades.hh File Reference (dune-common )</title>
  <link rel="stylesheet" type="text/css" href="./dune-doxy.css">
  <link rel="stylesheet" type="text/css" href="./tabs.css">
</head>
<div class="main">
<div class="doxygen">
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_2ca904c6ce82cf2d3dcac8fdc6f434f6.html">common</a>
  </div>
</div>
<div class="contents">
<h1>iteratorfacades.hh File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
This file implements iterator facade classes for writing stl conformant iterators. 
<p>
With using these facades writing iterators for arbitrary containers becomes much less cumbersome as only few functions have to be implemented. All other functions needed by the stl are provided by the facades using the Barton-Nackman trick (also known as curiously recurring template pattern. 
<p>
<code>#include &lt;iterator&gt;</code><br>
<code>#include &quot;<a class="el" href="a00249.html">typetraits.hh</a>&quot;</code><br>

<p>
<a href="a00228.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><b>Dune</b></td></tr>

<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html">Dune::ForwardIteratorFacade&lt; T, V, R, D &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for stl conformant forward iterators.  <a href="a00061.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html">Dune::BidirectionalIteratorFacade&lt; T, V, R, D &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Facade class for stl conformant bidirectional iterators.  <a href="a00012.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00105.html">Dune::RandomAccessIteratorFacade&lt; T, V, R, D &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for stl conformant forward iterators.  <a href="a00105.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T1, class V1, class R1, class D, class T2, class V2, class R2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">EnableIfInterOperable&lt; T1, T2, <br>
bool &gt;::Type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00198.html#g08dcc3a032ab4adc1f2639f319019053">Dune::operator==</a> (const ForwardIteratorFacade&lt; T1, V1, R1, D &gt; &amp;lhs, const ForwardIteratorFacade&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for equality.  <a href="a00198.html#g08dcc3a032ab4adc1f2639f319019053"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T1, class V1, class R1, class D, class T2, class V2, class R2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">EnableIfInterOperable&lt; T1, T2, <br>
bool &gt;::Type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00198.html#g5453af083101aa4ecf51ca7662e67188">Dune::operator!=</a> (const ForwardIteratorFacade&lt; T1, V1, R1, D &gt; &amp;lhs, const ForwardIteratorFacade&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for inequality.  <a href="a00198.html#g5453af083101aa4ecf51ca7662e67188"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T1, class V1, class R1, class D, class T2, class V2, class R2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">EnableIfInterOperable&lt; T1, T2, <br>
bool &gt;::Type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00198.html#gdce22b78ea7f319666399f373b4dbd1c">Dune::operator==</a> (const BidirectionalIteratorFacade&lt; T1, V1, R1, D &gt; &amp;lhs, const BidirectionalIteratorFacade&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for equality.  <a href="a00198.html#gdce22b78ea7f319666399f373b4dbd1c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T1, class V1, class R1, class D, class T2, class V2, class R2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">EnableIfInterOperable&lt; T1, T2, <br>
bool &gt;::Type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00198.html#ga66c921d994583f94286a4392ac6524d">Dune::operator!=</a> (const BidirectionalIteratorFacade&lt; T1, V1, R1, D &gt; &amp;lhs, const BidirectionalIteratorFacade&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for inequality.  <a href="a00198.html#ga66c921d994583f94286a4392ac6524d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T1, class V1, class R1, class D, class T2, class V2, class R2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">EnableIfInterOperable&lt; T1, T2, <br>
bool &gt;::Type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00198.html#g27f37ec045571a0aba6fb30272d743eb">Dune::operator==</a> (const RandomAccessIteratorFacade&lt; T1, V1, R1, D &gt; &amp;lhs, const RandomAccessIteratorFacade&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for equality.  <a href="a00198.html#g27f37ec045571a0aba6fb30272d743eb"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T1, class V1, class R1, class D, class T2, class V2, class R2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">EnableIfInterOperable&lt; T1, T2, <br>
bool &gt;::Type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00198.html#gf0050caf9677b317bde008a062dcdf4e">Dune::operator!=</a> (const RandomAccessIteratorFacade&lt; T1, V1, R1, D &gt; &amp;lhs, const RandomAccessIteratorFacade&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for inequality.  <a href="a00198.html#gf0050caf9677b317bde008a062dcdf4e"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T1, class V1, class R1, class D, class T2, class V2, class R2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">EnableIfInterOperable&lt; T1, T2, <br>
bool &gt;::Type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00198.html#g28ed08f4239b654384959affc7f9cde5">Dune::operator&lt;</a> (const RandomAccessIteratorFacade&lt; T1, V1, R1, D &gt; &amp;lhs, const RandomAccessIteratorFacade&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comparison operator.  <a href="a00198.html#g28ed08f4239b654384959affc7f9cde5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T1, class V1, class R1, class D, class T2, class V2, class R2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">EnableIfInterOperable&lt; T1, T2, <br>
bool &gt;::Type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00198.html#g2692db21be773e6af851126973758198">Dune::operator&lt;=</a> (const RandomAccessIteratorFacade&lt; T1, V1, R1, D &gt; &amp;lhs, const RandomAccessIteratorFacade&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comparison operator.  <a href="a00198.html#g2692db21be773e6af851126973758198"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T1, class V1, class R1, class D, class T2, class V2, class R2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">EnableIfInterOperable&lt; T1, T2, <br>
bool &gt;::Type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00198.html#g4cbf39bc45b01c73292aa19a19e96a56">Dune::operator&gt;</a> (const RandomAccessIteratorFacade&lt; T1, V1, R1, D &gt; &amp;lhs, const RandomAccessIteratorFacade&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comparison operator.  <a href="a00198.html#g4cbf39bc45b01c73292aa19a19e96a56"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T1, class V1, class R1, class D, class T2, class V2, class R2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">EnableIfInterOperable&lt; T1, T2, <br>
bool &gt;::Type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00198.html#geb9de751f8083dadd06a4ed5a7b8be12">Dune::operator&gt;=</a> (const RandomAccessIteratorFacade&lt; T1, V1, R1, D &gt; &amp;lhs, const RandomAccessIteratorFacade&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comparison operator.  <a href="a00198.html#geb9de751f8083dadd06a4ed5a7b8be12"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T1, class V1, class R1, class D, class T2, class V2, class R2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">EnableIfInterOperable&lt; T1, T2, <br>
D &gt;::Type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00198.html#g3f9af23d01448f19280b87dab8bca5ca">Dune::operator-</a> (const RandomAccessIteratorFacade&lt; T1, V1, R1, D &gt; &amp;lhs, const RandomAccessIteratorFacade&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates the difference between two pointers.  <a href="a00198.html#g3f9af23d01448f19280b87dab8bca5ca"></a><br></td></tr>
</table>
</div>
</div> <!-- end doxygen -->
</div> <!-- end main -->
<div class="foot">

<p class="foot">
  Generated on 6 Nov 2008 with <a
  href="http://www.doxygen.org/">Doxygen</a> (ver 1.5.6)  
  [<a href="doxygen.log">logfile</a>].
</p>

</div>

</body>
</html>
