<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN""http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>dune-common: iteratorfacades.hh Source File (dune-common )</title>
  <link rel="stylesheet" type="text/css" href="./dune-doxy.css">
  <link rel="stylesheet" type="text/css" href="./tabs.css">
</head>
<div class="main">
<div class="doxygen">
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_2ca904c6ce82cf2d3dcac8fdc6f434f6.html">common</a>
  </div>
</div>
<div class="contents">
<h1>iteratorfacades.hh</h1><a href="a00161.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// $Id: iteratorfacades.hh 4931 2007-05-01 10:49:22Z mblatt $</span>
<a name="l00002"></a>00002 <span class="preprocessor">#ifndef DUNE_ITERATORFACADES_HH</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span><span class="preprocessor">#define DUNE_ITERATORFACADES_HH</span>
<a name="l00004"></a>00004 <span class="preprocessor"></span><span class="preprocessor">#include&lt;iterator&gt;</span>
<a name="l00005"></a>00005 <span class="preprocessor">#include"<a class="code" href="a00182.html" title="Traits for type conversions and type information.">typetraits.hh</a>"</span>
<a name="l00006"></a>00006 
<a name="l00007"></a>00007 <span class="keyword">namespace </span>Dune
<a name="l00008"></a>00008 {
<a name="l00129"></a>00129   <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> V, <span class="keyword">class</span> R = V&amp;, <span class="keyword">class</span> D = std::ptrdiff_t&gt;
<a name="l00130"></a><a class="code" href="a00061.html">00130</a>   <span class="keyword">class </span><a class="code" href="a00061.html" title="Base class for stl conformant forward iterators.">ForwardIteratorFacade</a> :
<a name="l00131"></a>00131     <span class="keyword">public</span> std::iterator&lt; std::forward_iterator_tag, 
<a name="l00132"></a>00132                           typename remove_const&lt;V&gt;::type, <span class="comment">// std::iterator needs mutable value type </span>
<a name="l00133"></a>00133                           D,
<a name="l00134"></a>00134                           V*,
<a name="l00135"></a>00135                           R&gt;
<a name="l00136"></a>00136   {
<a name="l00137"></a>00137 
<a name="l00138"></a>00138   <span class="keyword">public</span>:
<a name="l00160"></a><a class="code" href="a00061.html#9192927ea5d6bde865f36619380692ca">00160</a>     <span class="keyword">typedef</span> T <a class="code" href="a00118.html" title="A mutable iterator for the SLList.">DerivedType</a>;
<a name="l00161"></a>00161 
<a name="l00165"></a><a class="code" href="a00061.html#91b8956e40e1fa5395f9bc095bc69557">00165</a>     <span class="keyword">typedef</span> V <a class="code" href="a00061.html#91b8956e40e1fa5395f9bc095bc69557" title="The type of value accessed through the iterator.">Value</a>;
<a name="l00166"></a>00166 
<a name="l00170"></a><a class="code" href="a00061.html#bf8e952829c2c7c3a7635939b40c630b">00170</a>     <span class="keyword">typedef</span> V* <a class="code" href="a00061.html#bf8e952829c2c7c3a7635939b40c630b" title="The pointer to the Value.">Pointer</a>;
<a name="l00171"></a>00171 
<a name="l00175"></a><a class="code" href="a00061.html#4b5e403398426bad661a47efd77f3329">00175</a>     <span class="keyword">typedef</span> D <a class="code" href="a00061.html#4b5e403398426bad661a47efd77f3329" title="The type of the difference between two positions.">DifferenceType</a>;
<a name="l00176"></a>00176     
<a name="l00180"></a><a class="code" href="a00061.html#5086d138aa712956ab7334e3677e5f65">00180</a>     <span class="keyword">typedef</span> R <a class="code" href="a00061.html#5086d138aa712956ab7334e3677e5f65" title="The type of the reference to the values accessed.">Reference</a>;
<a name="l00181"></a>00181     
<a name="l00183"></a><a class="code" href="a00061.html#84149e5d8b7e312553c66da6161bcc5d">00183</a>     <a class="code" href="a00061.html#5086d138aa712956ab7334e3677e5f65" title="The type of the reference to the values accessed.">Reference</a> <a class="code" href="a00061.html#84149e5d8b7e312553c66da6161bcc5d" title="Dereferencing operator.">operator*</a>()<span class="keyword"> const</span>
<a name="l00184"></a>00184 <span class="keyword">    </span>{
<a name="l00185"></a>00185       <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><a class="code" href="a00118.html" title="A mutable iterator for the SLList.">DerivedType</a> const*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;dereference();
<a name="l00186"></a>00186     }
<a name="l00187"></a>00187 
<a name="l00188"></a>00188     <a class="code" href="a00061.html#bf8e952829c2c7c3a7635939b40c630b" title="The pointer to the Value.">Pointer</a> operator-&gt;()<span class="keyword"> const</span>
<a name="l00189"></a>00189 <span class="keyword">    </span>{
<a name="l00190"></a>00190       <span class="keywordflow">return</span> &amp;(<span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="a00061.html#9192927ea5d6bde865f36619380692ca" title="The type of derived iterator.">DerivedType</a> *<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;dereference());
<a name="l00191"></a>00191     }
<a name="l00192"></a>00192 
<a name="l00194"></a><a class="code" href="a00061.html#b644e9f915098aefc8a090004a8f6b2a">00194</a>     <a class="code" href="a00118.html" title="A mutable iterator for the SLList.">DerivedType</a>&amp; <a class="code" href="a00061.html#b644e9f915098aefc8a090004a8f6b2a" title="Preincrement operator.">operator++</a>()
<a name="l00195"></a>00195     {
<a name="l00196"></a>00196       <span class="keyword">static_cast&lt;</span><a class="code" href="a00118.html" title="A mutable iterator for the SLList.">DerivedType</a> *<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;increment();
<a name="l00197"></a>00197       <span class="keywordflow">return</span> *<span class="keyword">static_cast&lt;</span><a class="code" href="a00118.html" title="A mutable iterator for the SLList.">DerivedType</a> *<span class="keyword">&gt;</span>(<span class="keyword">this</span>);
<a name="l00198"></a>00198     }
<a name="l00199"></a>00199 
<a name="l00201"></a><a class="code" href="a00061.html#beab195ddd461db8d2d9e6f560ddee6d">00201</a>     <a class="code" href="a00118.html" title="A mutable iterator for the SLList.">DerivedType</a> <a class="code" href="a00061.html#b644e9f915098aefc8a090004a8f6b2a" title="Preincrement operator.">operator++</a>(<span class="keywordtype">int</span>)
<a name="l00202"></a>00202     {
<a name="l00203"></a>00203       <a class="code" href="a00118.html" title="A mutable iterator for the SLList.">DerivedType</a> tmp(static_cast&lt;DerivedType const&amp;&gt;(*<span class="keyword">this</span>));
<a name="l00204"></a>00204       this-&gt;<a class="code" href="a00061.html#b644e9f915098aefc8a090004a8f6b2a" title="Preincrement operator.">operator++</a>();
<a name="l00205"></a>00205       <span class="keywordflow">return</span> tmp;
<a name="l00206"></a>00206     }
<a name="l00207"></a>00207   };
<a name="l00208"></a>00208 
<a name="l00219"></a>00219   <span class="keyword">template</span>&lt;<span class="keyword">class </span>T1, <span class="keyword">class </span>V1, <span class="keyword">class </span>R1, <span class="keyword">class </span>D,
<a name="l00220"></a>00220            <span class="keyword">class </span>T2, <span class="keyword">class </span>V2, <span class="keyword">class </span>R2&gt;
<a name="l00221"></a>00221   <span class="keyword">inline</span> <span class="keyword">typename</span> EnableIfInterOperable&lt;T1,T2,bool&gt;::Type
<a name="l00222"></a><a class="code" href="a00198.html#g08dcc3a032ab4adc1f2639f319019053">00222</a>   <a class="code" href="a00191.html#g57bf4ce9229d1105a6fee2c58bd2ef3c" title="Equality comparison operator for tuples.">operator==</a>(<span class="keyword">const</span> <a class="code" href="a00061.html" title="Base class for stl conformant forward iterators.">ForwardIteratorFacade&lt;T1,V1,R1,D&gt;</a>&amp; lhs,
<a name="l00223"></a>00223              <span class="keyword">const</span> <a class="code" href="a00061.html" title="Base class for stl conformant forward iterators.">ForwardIteratorFacade&lt;T2,V2,R2,D&gt;</a>&amp; rhs)
<a name="l00224"></a>00224   {
<a name="l00225"></a>00225     <span class="keywordflow">if</span>(<a class="code" href="a00028.html" title="Checks wether a type is derived from another.">Conversion&lt;T2,T1&gt;::exists</a>)
<a name="l00226"></a>00226       <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>T1&amp;<span class="keyword">&gt;</span>(lhs).equals(static_cast&lt;const T2&amp;&gt;(rhs));
<a name="l00227"></a>00227     <span class="keywordflow">else</span>
<a name="l00228"></a>00228       <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>T2&amp;<span class="keyword">&gt;</span>(rhs).equals(static_cast&lt;const T1&amp;&gt;(lhs));
<a name="l00229"></a>00229   }
<a name="l00230"></a>00230 
<a name="l00241"></a>00241   <span class="keyword">template</span>&lt;<span class="keyword">class </span>T1, <span class="keyword">class </span>V1, <span class="keyword">class </span>R1, <span class="keyword">class </span>D,
<a name="l00242"></a>00242            <span class="keyword">class </span>T2, <span class="keyword">class </span>V2, <span class="keyword">class </span>R2&gt;
<a name="l00243"></a>00243   <span class="keyword">inline</span> <span class="keyword">typename</span> EnableIfInterOperable&lt;T1,T2,bool&gt;::Type
<a name="l00244"></a><a class="code" href="a00198.html#g5453af083101aa4ecf51ca7662e67188">00244</a>   <a class="code" href="a00191.html#g67f33244a7dcb098c9c924301ac70833" title="Inequality comparison operator for tuples.">operator!=</a>(<span class="keyword">const</span> <a class="code" href="a00061.html" title="Base class for stl conformant forward iterators.">ForwardIteratorFacade&lt;T1,V1,R1,D&gt;</a>&amp; lhs,
<a name="l00245"></a>00245              <span class="keyword">const</span> <a class="code" href="a00061.html" title="Base class for stl conformant forward iterators.">ForwardIteratorFacade&lt;T2,V2,R2,D&gt;</a>&amp; rhs)
<a name="l00246"></a>00246   {
<a name="l00247"></a>00247     <span class="keywordflow">if</span>(<a class="code" href="a00028.html" title="Checks wether a type is derived from another.">Conversion&lt;T2,T1&gt;::exists</a>)
<a name="l00248"></a>00248       <span class="keywordflow">return</span> !<span class="keyword">static_cast&lt;</span><span class="keyword">const </span>T1&amp;<span class="keyword">&gt;</span>(lhs).equals(static_cast&lt;const T2&amp;&gt;(rhs));
<a name="l00249"></a>00249     <span class="keywordflow">else</span>
<a name="l00250"></a>00250       <span class="keywordflow">return</span> !<span class="keyword">static_cast&lt;</span><span class="keyword">const </span>T2&amp;<span class="keyword">&gt;</span>(rhs).equals(static_cast&lt;const T1&amp;&gt;(lhs));
<a name="l00251"></a>00251   }
<a name="l00252"></a>00252 
<a name="l00257"></a>00257   <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> V, <span class="keyword">class</span> R = V&amp;, <span class="keyword">class</span> D = std::ptrdiff_t&gt;
<a name="l00258"></a><a class="code" href="a00012.html">00258</a>   <span class="keyword">class </span><a class="code" href="a00012.html" title="Facade class for stl conformant bidirectional iterators.">BidirectionalIteratorFacade</a> :
<a name="l00259"></a>00259     <span class="keyword">public</span> std::iterator&lt; std::bidirectional_iterator_tag, 
<a name="l00260"></a>00260                           typename remove_const&lt;V&gt;::type, <span class="comment">// std::iterator needs mutable value type </span>
<a name="l00261"></a>00261                           D,
<a name="l00262"></a>00262                           V*,
<a name="l00263"></a>00263                           R&gt;
<a name="l00264"></a>00264   {
<a name="l00265"></a>00265 
<a name="l00266"></a>00266   <span class="keyword">public</span>:
<a name="l00292"></a><a class="code" href="a00012.html#38eca8a2f5f291eea2e671c779b4835c">00292</a>     <span class="keyword">typedef</span> T <a class="code" href="a00012.html#38eca8a2f5f291eea2e671c779b4835c" title="The type of derived iterator.">DerivedType</a>;
<a name="l00293"></a>00293 
<a name="l00297"></a><a class="code" href="a00012.html#fa784c7ae85e48ce1b92e2d4c5e4607b">00297</a>     <span class="keyword">typedef</span> V <a class="code" href="a00012.html#fa784c7ae85e48ce1b92e2d4c5e4607b" title="The type of value accessed through the iterator.">Value</a>;
<a name="l00298"></a>00298 
<a name="l00302"></a><a class="code" href="a00012.html#84852b8bb971d813fdea08505e8beb9d">00302</a>     <span class="keyword">typedef</span> V* <a class="code" href="a00012.html#84852b8bb971d813fdea08505e8beb9d" title="The pointer to the Value.">Pointer</a>;
<a name="l00303"></a>00303 
<a name="l00307"></a><a class="code" href="a00012.html#b46450f118d91d1ab6f369de739a317f">00307</a>     <span class="keyword">typedef</span> D <a class="code" href="a00012.html#b46450f118d91d1ab6f369de739a317f" title="The type of the difference between two positions.">DifferenceType</a>;
<a name="l00308"></a>00308     
<a name="l00312"></a><a class="code" href="a00012.html#87c3aa03eb2c5dd985c8d77ae852e87b">00312</a>     <span class="keyword">typedef</span> R <a class="code" href="a00012.html#87c3aa03eb2c5dd985c8d77ae852e87b" title="The type of the reference to the values accessed.">Reference</a>;
<a name="l00313"></a>00313     
<a name="l00315"></a><a class="code" href="a00012.html#47107ad21e3437e0594e1a02e6865d1e">00315</a>     <a class="code" href="a00012.html#87c3aa03eb2c5dd985c8d77ae852e87b" title="The type of the reference to the values accessed.">Reference</a> <a class="code" href="a00012.html#47107ad21e3437e0594e1a02e6865d1e" title="Dereferencing operator.">operator*</a>()<span class="keyword"> const</span>
<a name="l00316"></a>00316 <span class="keyword">    </span>{
<a name="l00317"></a>00317       <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><a class="code" href="a00012.html#38eca8a2f5f291eea2e671c779b4835c" title="The type of derived iterator.">DerivedType</a> const*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;dereference();
<a name="l00318"></a>00318     }
<a name="l00319"></a>00319 
<a name="l00320"></a>00320     <a class="code" href="a00012.html#84852b8bb971d813fdea08505e8beb9d" title="The pointer to the Value.">Pointer</a> operator-&gt;()<span class="keyword"> const</span>
<a name="l00321"></a>00321 <span class="keyword">    </span>{
<a name="l00322"></a>00322       <span class="keywordflow">return</span> &amp;(<span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="a00012.html#38eca8a2f5f291eea2e671c779b4835c" title="The type of derived iterator.">DerivedType</a> *<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;dereference());
<a name="l00323"></a>00323     }
<a name="l00324"></a>00324 
<a name="l00326"></a><a class="code" href="a00012.html#0457e2e3dabf7b32f4941817ca58d502">00326</a>     <a class="code" href="a00012.html#38eca8a2f5f291eea2e671c779b4835c" title="The type of derived iterator.">DerivedType</a>&amp; <a class="code" href="a00012.html#0457e2e3dabf7b32f4941817ca58d502" title="Preincrement operator.">operator++</a>()
<a name="l00327"></a>00327     {
<a name="l00328"></a>00328       <span class="keyword">static_cast&lt;</span><a class="code" href="a00012.html#38eca8a2f5f291eea2e671c779b4835c" title="The type of derived iterator.">DerivedType</a> *<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;increment();
<a name="l00329"></a>00329       <span class="keywordflow">return</span> *<span class="keyword">static_cast&lt;</span><a class="code" href="a00012.html#38eca8a2f5f291eea2e671c779b4835c" title="The type of derived iterator.">DerivedType</a> *<span class="keyword">&gt;</span>(<span class="keyword">this</span>);
<a name="l00330"></a>00330     }
<a name="l00331"></a>00331 
<a name="l00333"></a><a class="code" href="a00012.html#95b63baa3c45e25ef363fc0558943b2b">00333</a>     <a class="code" href="a00012.html#38eca8a2f5f291eea2e671c779b4835c" title="The type of derived iterator.">DerivedType</a> <a class="code" href="a00012.html#0457e2e3dabf7b32f4941817ca58d502" title="Preincrement operator.">operator++</a>(<span class="keywordtype">int</span>)
<a name="l00334"></a>00334     {
<a name="l00335"></a>00335       <a class="code" href="a00012.html#38eca8a2f5f291eea2e671c779b4835c" title="The type of derived iterator.">DerivedType</a> tmp(static_cast&lt;DerivedType const&amp;&gt;(*<span class="keyword">this</span>));
<a name="l00336"></a>00336       this-&gt;<a class="code" href="a00012.html#0457e2e3dabf7b32f4941817ca58d502" title="Preincrement operator.">operator++</a>();
<a name="l00337"></a>00337       <span class="keywordflow">return</span> tmp;
<a name="l00338"></a>00338     }
<a name="l00339"></a>00339 
<a name="l00340"></a>00340     
<a name="l00342"></a><a class="code" href="a00012.html#2cc0819c6d8a6170ecf692969c1a4057">00342</a>     <a class="code" href="a00012.html#38eca8a2f5f291eea2e671c779b4835c" title="The type of derived iterator.">DerivedType</a>&amp; <a class="code" href="a00012.html#2cc0819c6d8a6170ecf692969c1a4057" title="Preincrement operator.">operator--</a>()
<a name="l00343"></a>00343     {
<a name="l00344"></a>00344       <span class="keyword">static_cast&lt;</span><a class="code" href="a00012.html#38eca8a2f5f291eea2e671c779b4835c" title="The type of derived iterator.">DerivedType</a> *<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;decrement();
<a name="l00345"></a>00345       <span class="keywordflow">return</span> *<span class="keyword">static_cast&lt;</span><a class="code" href="a00012.html#38eca8a2f5f291eea2e671c779b4835c" title="The type of derived iterator.">DerivedType</a> *<span class="keyword">&gt;</span>(<span class="keyword">this</span>);
<a name="l00346"></a>00346     }
<a name="l00347"></a>00347 
<a name="l00349"></a><a class="code" href="a00012.html#bad46a4c4536249d4cf557f63506e23a">00349</a>     <a class="code" href="a00012.html#38eca8a2f5f291eea2e671c779b4835c" title="The type of derived iterator.">DerivedType</a> <a class="code" href="a00012.html#2cc0819c6d8a6170ecf692969c1a4057" title="Preincrement operator.">operator--</a>(<span class="keywordtype">int</span>)
<a name="l00350"></a>00350     {
<a name="l00351"></a>00351       <a class="code" href="a00012.html#38eca8a2f5f291eea2e671c779b4835c" title="The type of derived iterator.">DerivedType</a> tmp(static_cast&lt;DerivedType const&amp;&gt;(*<span class="keyword">this</span>));
<a name="l00352"></a>00352       this-&gt;<a class="code" href="a00012.html#2cc0819c6d8a6170ecf692969c1a4057" title="Preincrement operator.">operator--</a>();
<a name="l00353"></a>00353       <span class="keywordflow">return</span> tmp;
<a name="l00354"></a>00354     }
<a name="l00355"></a>00355   };
<a name="l00356"></a>00356 
<a name="l00367"></a>00367   <span class="keyword">template</span>&lt;<span class="keyword">class </span>T1, <span class="keyword">class </span>V1, <span class="keyword">class </span>R1, <span class="keyword">class </span>D,
<a name="l00368"></a>00368            <span class="keyword">class </span>T2, <span class="keyword">class </span>V2, <span class="keyword">class </span>R2&gt;
<a name="l00369"></a>00369   <span class="keyword">inline</span> <span class="keyword">typename</span> EnableIfInterOperable&lt;T1,T2,bool&gt;::Type
<a name="l00370"></a><a class="code" href="a00198.html#gdce22b78ea7f319666399f373b4dbd1c">00370</a>   <a class="code" href="a00191.html#g57bf4ce9229d1105a6fee2c58bd2ef3c" title="Equality comparison operator for tuples.">operator==</a>(<span class="keyword">const</span> <a class="code" href="a00012.html" title="Facade class for stl conformant bidirectional iterators.">BidirectionalIteratorFacade&lt;T1,V1,R1,D&gt;</a>&amp; lhs,
<a name="l00371"></a>00371              <span class="keyword">const</span> <a class="code" href="a00012.html" title="Facade class for stl conformant bidirectional iterators.">BidirectionalIteratorFacade&lt;T2,V2,R2,D&gt;</a>&amp; rhs)
<a name="l00372"></a>00372   {
<a name="l00373"></a>00373     <span class="keywordflow">if</span>(<a class="code" href="a00028.html" title="Checks wether a type is derived from another.">Conversion&lt;T2,T1&gt;::exists</a>)
<a name="l00374"></a>00374       <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>T1&amp;<span class="keyword">&gt;</span>(lhs).equals(static_cast&lt;const T2&amp;&gt;(rhs));
<a name="l00375"></a>00375     <span class="keywordflow">else</span>
<a name="l00376"></a>00376       <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>T2&amp;<span class="keyword">&gt;</span>(rhs).equals(static_cast&lt;const T1&amp;&gt;(lhs));
<a name="l00377"></a>00377   }
<a name="l00378"></a>00378 
<a name="l00389"></a>00389   <span class="keyword">template</span>&lt;<span class="keyword">class </span>T1, <span class="keyword">class </span>V1, <span class="keyword">class </span>R1, <span class="keyword">class </span>D,
<a name="l00390"></a>00390            <span class="keyword">class </span>T2, <span class="keyword">class </span>V2, <span class="keyword">class </span>R2&gt;
<a name="l00391"></a>00391   <span class="keyword">inline</span> <span class="keyword">typename</span> EnableIfInterOperable&lt;T1,T2,bool&gt;::Type
<a name="l00392"></a><a class="code" href="a00198.html#ga66c921d994583f94286a4392ac6524d">00392</a>   <a class="code" href="a00191.html#g67f33244a7dcb098c9c924301ac70833" title="Inequality comparison operator for tuples.">operator!=</a>(<span class="keyword">const</span> <a class="code" href="a00012.html" title="Facade class for stl conformant bidirectional iterators.">BidirectionalIteratorFacade&lt;T1,V1,R1,D&gt;</a>&amp; lhs,
<a name="l00393"></a>00393              <span class="keyword">const</span> <a class="code" href="a00012.html" title="Facade class for stl conformant bidirectional iterators.">BidirectionalIteratorFacade&lt;T2,V2,R2,D&gt;</a>&amp; rhs)
<a name="l00394"></a>00394   {
<a name="l00395"></a>00395     <span class="keywordflow">if</span>(<a class="code" href="a00028.html" title="Checks wether a type is derived from another.">Conversion&lt;T2,T1&gt;::exists</a>)
<a name="l00396"></a>00396       <span class="keywordflow">return</span> !<span class="keyword">static_cast&lt;</span><span class="keyword">const </span>T1&amp;<span class="keyword">&gt;</span>(lhs).equals(static_cast&lt;const T2&amp;&gt;(rhs));
<a name="l00397"></a>00397     <span class="keywordflow">else</span>
<a name="l00398"></a>00398       <span class="keywordflow">return</span> !<span class="keyword">static_cast&lt;</span><span class="keyword">const </span>T2&amp;<span class="keyword">&gt;</span>(rhs).equals(static_cast&lt;const T1&amp;&gt;(lhs));
<a name="l00399"></a>00399   }
<a name="l00400"></a>00400 
<a name="l00405"></a>00405   <span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> V, <span class="keyword">class</span> R = V&amp;, <span class="keyword">class</span> D = std::ptrdiff_t&gt;
<a name="l00406"></a><a class="code" href="a00105.html">00406</a>   <span class="keyword">class </span><a class="code" href="a00105.html" title="Base class for stl conformant forward iterators.">RandomAccessIteratorFacade</a> :
<a name="l00407"></a>00407     <span class="keyword">public</span> std::iterator&lt; std::random_access_iterator_tag, 
<a name="l00408"></a>00408                           typename remove_const&lt;V&gt;::type, <span class="comment">// std::iterator needs mutable value type </span>
<a name="l00409"></a>00409                           D,
<a name="l00410"></a>00410                           V*,
<a name="l00411"></a>00411                           R&gt;
<a name="l00412"></a>00412   {
<a name="l00413"></a>00413 
<a name="l00414"></a>00414   <span class="keyword">public</span>:
<a name="l00446"></a><a class="code" href="a00105.html#c79014d9986cecb8e8434889be331d3e">00446</a>     <span class="keyword">typedef</span> T <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">DerivedType</a>;
<a name="l00447"></a>00447 
<a name="l00451"></a><a class="code" href="a00105.html#e381544d0a7ecdccb8b950e5e3603239">00451</a>     <span class="keyword">typedef</span> V <a class="code" href="a00105.html#e381544d0a7ecdccb8b950e5e3603239" title="The type of value accessed through the iterator.">Value</a>;
<a name="l00452"></a>00452 
<a name="l00456"></a><a class="code" href="a00105.html#ce674ab45e91ec281320c1916685cde4">00456</a>     <span class="keyword">typedef</span> V* <a class="code" href="a00105.html#ce674ab45e91ec281320c1916685cde4" title="The pointer to the Value.">Pointer</a>;
<a name="l00457"></a>00457 
<a name="l00461"></a><a class="code" href="a00105.html#6c35e250a4b90f4074e7dd1208408f89">00461</a>     <span class="keyword">typedef</span> D <a class="code" href="a00105.html#6c35e250a4b90f4074e7dd1208408f89" title="The type of the difference between two positions.">DifferenceType</a>;
<a name="l00462"></a>00462     
<a name="l00466"></a><a class="code" href="a00105.html#ff1b505e7e7894e94d662a6dbf729045">00466</a>     <span class="keyword">typedef</span> R <a class="code" href="a00105.html#ff1b505e7e7894e94d662a6dbf729045" title="The type of the reference to the values accessed.">Reference</a>;
<a name="l00467"></a>00467     
<a name="l00469"></a><a class="code" href="a00105.html#5a3fc902583e9fa92887acdc6cd77df1">00469</a>     <a class="code" href="a00105.html#ff1b505e7e7894e94d662a6dbf729045" title="The type of the reference to the values accessed.">Reference</a> <a class="code" href="a00105.html#5a3fc902583e9fa92887acdc6cd77df1" title="Dereferencing operator.">operator*</a>()<span class="keyword"> const</span>
<a name="l00470"></a>00470 <span class="keyword">    </span>{
<a name="l00471"></a>00471       <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">DerivedType</a> const*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;dereference();
<a name="l00472"></a>00472     }
<a name="l00473"></a>00473 
<a name="l00474"></a>00474     <a class="code" href="a00105.html#ce674ab45e91ec281320c1916685cde4" title="The pointer to the Value.">Pointer</a> operator-&gt;()<span class="keyword"> const</span>
<a name="l00475"></a>00475 <span class="keyword">    </span>{
<a name="l00476"></a>00476       <span class="keywordflow">return</span> &amp;(<span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="a00105.html#c79014d9986cecb8e8434889be331d3e" title="The type of derived iterator.">DerivedType</a> *<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;dereference());
<a name="l00477"></a>00477     }
<a name="l00478"></a>00478 
<a name="l00484"></a><a class="code" href="a00105.html#820c6b40e1766f689339c164898ea944">00484</a>     <a class="code" href="a00105.html#ff1b505e7e7894e94d662a6dbf729045" title="The type of the reference to the values accessed.">Reference</a> <a class="code" href="a00105.html#820c6b40e1766f689339c164898ea944" title="Get the element n positions from the current one.">operator[]</a>(<a class="code" href="a00105.html#6c35e250a4b90f4074e7dd1208408f89" title="The type of the difference between two positions.">DifferenceType</a> n)<span class="keyword"> const</span>
<a name="l00485"></a>00485 <span class="keyword">    </span>{
<a name="l00486"></a>00486       <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">DerivedType</a> *<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;elementAt(n);
<a name="l00487"></a>00487     }
<a name="l00488"></a>00488 
<a name="l00490"></a><a class="code" href="a00105.html#8b8b50ed74141416e6f5f82bca30e7b7">00490</a>     <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">DerivedType</a>&amp; <a class="code" href="a00105.html#8b8b50ed74141416e6f5f82bca30e7b7" title="Preincrement operator.">operator++</a>()
<a name="l00491"></a>00491     {
<a name="l00492"></a>00492       <span class="keyword">static_cast&lt;</span><a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">DerivedType</a> *<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;increment();
<a name="l00493"></a>00493       <span class="keywordflow">return</span> *<span class="keyword">static_cast&lt;</span><a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">DerivedType</a> *<span class="keyword">&gt;</span>(<span class="keyword">this</span>);
<a name="l00494"></a>00494     }
<a name="l00495"></a>00495 
<a name="l00497"></a><a class="code" href="a00105.html#de0700830b6d8e4174c719190bdda166">00497</a>     <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">DerivedType</a> <a class="code" href="a00105.html#8b8b50ed74141416e6f5f82bca30e7b7" title="Preincrement operator.">operator++</a>(<span class="keywordtype">int</span>)
<a name="l00498"></a>00498     {
<a name="l00499"></a>00499       <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">DerivedType</a> tmp(static_cast&lt;DerivedType const&amp;&gt;(*<span class="keyword">this</span>));
<a name="l00500"></a>00500       this-&gt;<a class="code" href="a00105.html#8b8b50ed74141416e6f5f82bca30e7b7" title="Preincrement operator.">operator++</a>();
<a name="l00501"></a>00501       <span class="keywordflow">return</span> tmp;
<a name="l00502"></a>00502     }
<a name="l00503"></a>00503 
<a name="l00504"></a>00504     <a class="code" href="a00105.html#c79014d9986cecb8e8434889be331d3e" title="The type of derived iterator.">DerivedType</a>&amp; operator+=(<a class="code" href="a00105.html#6c35e250a4b90f4074e7dd1208408f89" title="The type of the difference between two positions.">DifferenceType</a> n)
<a name="l00505"></a>00505     {
<a name="l00506"></a>00506       <span class="keyword">static_cast&lt;</span><a class="code" href="a00105.html#c79014d9986cecb8e8434889be331d3e" title="The type of derived iterator.">DerivedType</a> *<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;advance(n);
<a name="l00507"></a>00507       <span class="keywordflow">return</span> *<span class="keyword">static_cast&lt;</span><a class="code" href="a00105.html#c79014d9986cecb8e8434889be331d3e" title="The type of derived iterator.">DerivedType</a> *<span class="keyword">&gt;</span>(<span class="keyword">this</span>);
<a name="l00508"></a>00508     }
<a name="l00509"></a>00509      
<a name="l00510"></a>00510     <a class="code" href="a00105.html#c79014d9986cecb8e8434889be331d3e" title="The type of derived iterator.">DerivedType</a> operator+(<a class="code" href="a00105.html#6c35e250a4b90f4074e7dd1208408f89" title="The type of the difference between two positions.">DifferenceType</a> n)
<a name="l00511"></a>00511     {
<a name="l00512"></a>00512       <a class="code" href="a00105.html#c79014d9986cecb8e8434889be331d3e" title="The type of derived iterator.">DerivedType</a> tmp(static_cast&lt;DerivedType const&amp;&gt;(*<span class="keyword">this</span>));
<a name="l00513"></a>00513       tmp.advance(n);
<a name="l00514"></a>00514       <span class="keywordflow">return</span> tmp;
<a name="l00515"></a>00515     }
<a name="l00516"></a>00516 
<a name="l00517"></a>00517 
<a name="l00519"></a><a class="code" href="a00105.html#36fe4780ac9cd96c4530391a23e5163f">00519</a>     <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">DerivedType</a>&amp; <a class="code" href="a00105.html#36fe4780ac9cd96c4530391a23e5163f" title="Predecrement operator.">operator--</a>()
<a name="l00520"></a>00520     {
<a name="l00521"></a>00521       <span class="keyword">static_cast&lt;</span><a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">DerivedType</a> *<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;decrement();
<a name="l00522"></a>00522       <span class="keywordflow">return</span> *<span class="keyword">static_cast&lt;</span><a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">DerivedType</a> *<span class="keyword">&gt;</span>(<span class="keyword">this</span>);
<a name="l00523"></a>00523     }
<a name="l00524"></a>00524 
<a name="l00526"></a><a class="code" href="a00105.html#250cf00aa31543f2e4943d440cff0810">00526</a>     <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">DerivedType</a> <a class="code" href="a00105.html#36fe4780ac9cd96c4530391a23e5163f" title="Predecrement operator.">operator--</a>(<span class="keywordtype">int</span>)
<a name="l00527"></a>00527     {
<a name="l00528"></a>00528       <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">DerivedType</a> tmp(static_cast&lt;DerivedType const&amp;&gt;(*<span class="keyword">this</span>));
<a name="l00529"></a>00529       this-&gt;<a class="code" href="a00105.html#36fe4780ac9cd96c4530391a23e5163f" title="Predecrement operator.">operator--</a>();
<a name="l00530"></a>00530       <span class="keywordflow">return</span> tmp;
<a name="l00531"></a>00531     }
<a name="l00532"></a>00532 
<a name="l00533"></a>00533     <a class="code" href="a00105.html#c79014d9986cecb8e8434889be331d3e" title="The type of derived iterator.">DerivedType</a>&amp; operator-=(<a class="code" href="a00105.html#6c35e250a4b90f4074e7dd1208408f89" title="The type of the difference between two positions.">DifferenceType</a> n)
<a name="l00534"></a>00534     {
<a name="l00535"></a>00535       <span class="keyword">static_cast&lt;</span><a class="code" href="a00105.html#c79014d9986cecb8e8434889be331d3e" title="The type of derived iterator.">DerivedType</a> *<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;advance(-n);
<a name="l00536"></a>00536       <span class="keywordflow">return</span> *<span class="keyword">static_cast&lt;</span><a class="code" href="a00105.html#c79014d9986cecb8e8434889be331d3e" title="The type of derived iterator.">DerivedType</a> *<span class="keyword">&gt;</span>(<span class="keyword">this</span>);
<a name="l00537"></a>00537     }
<a name="l00538"></a>00538     
<a name="l00539"></a>00539     <a class="code" href="a00105.html#c79014d9986cecb8e8434889be331d3e" title="The type of derived iterator.">DerivedType</a> operator-(<a class="code" href="a00105.html#6c35e250a4b90f4074e7dd1208408f89" title="The type of the difference between two positions.">DifferenceType</a> n)
<a name="l00540"></a>00540     {
<a name="l00541"></a>00541       <a class="code" href="a00105.html#c79014d9986cecb8e8434889be331d3e" title="The type of derived iterator.">DerivedType</a> tmp(static_cast&lt;DerivedType const&amp;&gt;(*<span class="keyword">this</span>));
<a name="l00542"></a>00542       tmp.advance(-n);
<a name="l00543"></a>00543       <span class="keywordflow">return</span> tmp;
<a name="l00544"></a>00544     }
<a name="l00545"></a>00545 
<a name="l00546"></a>00546     
<a name="l00547"></a>00547   };
<a name="l00548"></a>00548 
<a name="l00559"></a>00559   <span class="keyword">template</span>&lt;<span class="keyword">class </span>T1, <span class="keyword">class </span>V1, <span class="keyword">class </span>R1, <span class="keyword">class </span>D,
<a name="l00560"></a>00560            <span class="keyword">class </span>T2, <span class="keyword">class </span>V2, <span class="keyword">class </span>R2&gt;
<a name="l00561"></a>00561   <span class="keyword">inline</span> <span class="keyword">typename</span> EnableIfInterOperable&lt;T1,T2,bool&gt;::Type
<a name="l00562"></a><a class="code" href="a00198.html#g27f37ec045571a0aba6fb30272d743eb">00562</a>   <a class="code" href="a00191.html#g57bf4ce9229d1105a6fee2c58bd2ef3c" title="Equality comparison operator for tuples.">operator==</a>(<span class="keyword">const</span> <a class="code" href="a00105.html" title="Base class for stl conformant forward iterators.">RandomAccessIteratorFacade&lt;T1,V1,R1,D&gt;</a>&amp; lhs,
<a name="l00563"></a>00563              <span class="keyword">const</span> <a class="code" href="a00105.html" title="Base class for stl conformant forward iterators.">RandomAccessIteratorFacade&lt;T2,V2,R2,D&gt;</a>&amp; rhs)
<a name="l00564"></a>00564   {
<a name="l00565"></a>00565     <span class="keywordflow">if</span>(<a class="code" href="a00028.html" title="Checks wether a type is derived from another.">Conversion&lt;T2,T1&gt;::exists</a>)
<a name="l00566"></a>00566       <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>T1&amp;<span class="keyword">&gt;</span>(lhs).equals(static_cast&lt;const T2&amp;&gt;(rhs));
<a name="l00567"></a>00567     <span class="keywordflow">else</span>
<a name="l00568"></a>00568       <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>T2&amp;<span class="keyword">&gt;</span>(rhs).equals(static_cast&lt;const T1&amp;&gt;(lhs));
<a name="l00569"></a>00569   }
<a name="l00570"></a>00570 
<a name="l00581"></a>00581   <span class="keyword">template</span>&lt;<span class="keyword">class </span>T1, <span class="keyword">class </span>V1, <span class="keyword">class </span>R1, <span class="keyword">class </span>D,
<a name="l00582"></a>00582            <span class="keyword">class </span>T2, <span class="keyword">class </span>V2, <span class="keyword">class </span>R2&gt;
<a name="l00583"></a>00583   <span class="keyword">inline</span> <span class="keyword">typename</span> EnableIfInterOperable&lt;T1,T2,bool&gt;::Type
<a name="l00584"></a><a class="code" href="a00198.html#gf0050caf9677b317bde008a062dcdf4e">00584</a>   <a class="code" href="a00191.html#g67f33244a7dcb098c9c924301ac70833" title="Inequality comparison operator for tuples.">operator!=</a>(<span class="keyword">const</span> <a class="code" href="a00105.html" title="Base class for stl conformant forward iterators.">RandomAccessIteratorFacade&lt;T1,V1,R1,D&gt;</a>&amp; lhs,
<a name="l00585"></a>00585              <span class="keyword">const</span> <a class="code" href="a00105.html" title="Base class for stl conformant forward iterators.">RandomAccessIteratorFacade&lt;T2,V2,R2,D&gt;</a>&amp; rhs)
<a name="l00586"></a>00586   {
<a name="l00587"></a>00587     <span class="keywordflow">if</span>(<a class="code" href="a00028.html" title="Checks wether a type is derived from another.">Conversion&lt;T2,T1&gt;::exists</a>)
<a name="l00588"></a>00588       <span class="keywordflow">return</span> !<span class="keyword">static_cast&lt;</span><span class="keyword">const </span>T1&amp;<span class="keyword">&gt;</span>(lhs).equals(static_cast&lt;const T2&amp;&gt;(rhs));
<a name="l00589"></a>00589     <span class="keywordflow">else</span>
<a name="l00590"></a>00590       <span class="keywordflow">return</span> !<span class="keyword">static_cast&lt;</span><span class="keyword">const </span>T2&amp;<span class="keyword">&gt;</span>(rhs).equals(static_cast&lt;const T1&amp;&gt;(lhs));
<a name="l00591"></a>00591   }
<a name="l00592"></a>00592 
<a name="l00603"></a>00603   <span class="keyword">template</span>&lt;<span class="keyword">class </span>T1, <span class="keyword">class </span>V1, <span class="keyword">class </span>R1, <span class="keyword">class </span>D,
<a name="l00604"></a>00604            <span class="keyword">class </span>T2, <span class="keyword">class </span>V2, <span class="keyword">class </span>R2&gt;
<a name="l00605"></a>00605   <span class="keyword">inline</span> <span class="keyword">typename</span> EnableIfInterOperable&lt;T1,T2,bool&gt;::Type
<a name="l00606"></a><a class="code" href="a00198.html#g28ed08f4239b654384959affc7f9cde5">00606</a>   operator&lt;(const RandomAccessIteratorFacade&lt;T1,V1,R1,D&gt;&amp; lhs,
<a name="l00607"></a>00607              <span class="keyword">const</span> <a class="code" href="a00105.html" title="Base class for stl conformant forward iterators.">RandomAccessIteratorFacade&lt;T2,V2,R2,D&gt;</a>&amp; rhs)
<a name="l00608"></a>00608   {
<a name="l00609"></a>00609     <span class="keywordflow">if</span>(<a class="code" href="a00028.html" title="Checks wether a type is derived from another.">Conversion&lt;T2,T1&gt;::exists</a>)
<a name="l00610"></a>00610       <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>T1&amp;<span class="keyword">&gt;</span>(lhs).distanceTo(static_cast&lt;const T2&amp;&gt;(rhs))&gt;0;
<a name="l00611"></a>00611     <span class="keywordflow">else</span>
<a name="l00612"></a>00612       <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>T2&amp;<span class="keyword">&gt;</span>(rhs).distanceTo(static_cast&lt;const T1&amp;&gt;(lhs))&lt;0;
<a name="l00613"></a>00613   }
<a name="l00614"></a>00614 
<a name="l00615"></a>00615   
<a name="l00626"></a>00626   <span class="keyword">template</span>&lt;<span class="keyword">class </span>T1, <span class="keyword">class </span>V1, <span class="keyword">class </span>R1, <span class="keyword">class </span>D,
<a name="l00627"></a>00627            <span class="keyword">class </span>T2, <span class="keyword">class </span>V2, <span class="keyword">class </span>R2&gt;
<a name="l00628"></a>00628   <span class="keyword">inline</span> <span class="keyword">typename</span> EnableIfInterOperable&lt;T1,T2,bool&gt;::Type
<a name="l00629"></a><a class="code" href="a00198.html#g2692db21be773e6af851126973758198">00629</a>   operator&lt;=(const RandomAccessIteratorFacade&lt;T1,V1,R1,D&gt;&amp; lhs,
<a name="l00630"></a>00630              <span class="keyword">const</span> <a class="code" href="a00105.html" title="Base class for stl conformant forward iterators.">RandomAccessIteratorFacade&lt;T2,V2,R2,D&gt;</a>&amp; rhs)
<a name="l00631"></a>00631   {
<a name="l00632"></a>00632     <span class="keywordflow">if</span>(<a class="code" href="a00028.html" title="Checks wether a type is derived from another.">Conversion&lt;T2,T1&gt;::exists</a>)
<a name="l00633"></a>00633       <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>T1&amp;<span class="keyword">&gt;</span>(lhs).distanceTo(static_cast&lt;const T2&amp;&gt;(rhs))&gt;=0;
<a name="l00634"></a>00634     <span class="keywordflow">else</span>
<a name="l00635"></a>00635       <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>T2&amp;<span class="keyword">&gt;</span>(rhs).distanceTo(static_cast&lt;const T1&amp;&gt;(lhs))&lt;=0;
<a name="l00636"></a>00636   }
<a name="l00637"></a>00637 
<a name="l00638"></a>00638 
<a name="l00649"></a>00649   <span class="keyword">template</span>&lt;<span class="keyword">class </span>T1, <span class="keyword">class </span>V1, <span class="keyword">class </span>R1, <span class="keyword">class </span>D,
<a name="l00650"></a>00650            <span class="keyword">class </span>T2, <span class="keyword">class </span>V2, <span class="keyword">class </span>R2&gt;
<a name="l00651"></a>00651   <span class="keyword">inline</span> <span class="keyword">typename</span> EnableIfInterOperable&lt;T1,T2,bool&gt;::Type
<a name="l00652"></a><a class="code" href="a00198.html#g4cbf39bc45b01c73292aa19a19e96a56">00652</a>   <a class="code" href="a00198.html#g4cbf39bc45b01c73292aa19a19e96a56" title="Comparison operator.">operator&gt;</a>(<span class="keyword">const</span> <a class="code" href="a00105.html" title="Base class for stl conformant forward iterators.">RandomAccessIteratorFacade&lt;T1,V1,R1,D&gt;</a>&amp; lhs,
<a name="l00653"></a>00653              <span class="keyword">const</span> <a class="code" href="a00105.html" title="Base class for stl conformant forward iterators.">RandomAccessIteratorFacade&lt;T2,V2,R2,D&gt;</a>&amp; rhs)
<a name="l00654"></a>00654   {
<a name="l00655"></a>00655     <span class="keywordflow">if</span>(<a class="code" href="a00028.html" title="Checks wether a type is derived from another.">Conversion&lt;T2,T1&gt;::exists</a>)
<a name="l00656"></a>00656       <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>T1&amp;<span class="keyword">&gt;</span>(lhs).distanceTo(static_cast&lt;const T2&amp;&gt;(rhs))&lt;0;
<a name="l00657"></a>00657     <span class="keywordflow">else</span>
<a name="l00658"></a>00658       <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>T2&amp;<span class="keyword">&gt;</span>(rhs).distanceTo(static_cast&lt;const T1&amp;&gt;(lhs))&gt;0;
<a name="l00659"></a>00659   }
<a name="l00660"></a>00660 
<a name="l00671"></a>00671   <span class="keyword">template</span>&lt;<span class="keyword">class </span>T1, <span class="keyword">class </span>V1, <span class="keyword">class </span>R1, <span class="keyword">class </span>D,
<a name="l00672"></a>00672            <span class="keyword">class </span>T2, <span class="keyword">class </span>V2, <span class="keyword">class </span>R2&gt;
<a name="l00673"></a>00673   <span class="keyword">inline</span> <span class="keyword">typename</span> EnableIfInterOperable&lt;T1,T2,bool&gt;::Type
<a name="l00674"></a><a class="code" href="a00198.html#geb9de751f8083dadd06a4ed5a7b8be12">00674</a>   <a class="code" href="a00198.html#geb9de751f8083dadd06a4ed5a7b8be12" title="Comparison operator.">operator&gt;=</a>(<span class="keyword">const</span> <a class="code" href="a00105.html" title="Base class for stl conformant forward iterators.">RandomAccessIteratorFacade&lt;T1,V1,R1,D&gt;</a>&amp; lhs,
<a name="l00675"></a>00675              <span class="keyword">const</span> <a class="code" href="a00105.html" title="Base class for stl conformant forward iterators.">RandomAccessIteratorFacade&lt;T2,V2,R2,D&gt;</a>&amp; rhs)
<a name="l00676"></a>00676   {
<a name="l00677"></a>00677     <span class="keywordflow">if</span>(<a class="code" href="a00028.html" title="Checks wether a type is derived from another.">Conversion&lt;T2,T1&gt;::exists</a>)
<a name="l00678"></a>00678       <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>T1&amp;<span class="keyword">&gt;</span>(lhs).distanceTo(static_cast&lt;const T2&amp;&gt;(rhs))&lt;=0;
<a name="l00679"></a>00679     <span class="keywordflow">else</span>
<a name="l00680"></a>00680       <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>T2&amp;<span class="keyword">&gt;</span>(rhs).distanceTo(static_cast&lt;const T1&amp;&gt;(lhs))&gt;=0;
<a name="l00681"></a>00681   }
<a name="l00682"></a>00682 
<a name="l00693"></a>00693   <span class="keyword">template</span>&lt;<span class="keyword">class </span>T1, <span class="keyword">class </span>V1, <span class="keyword">class </span>R1, <span class="keyword">class </span>D,
<a name="l00694"></a>00694            <span class="keyword">class </span>T2, <span class="keyword">class </span>V2, <span class="keyword">class </span>R2&gt;
<a name="l00695"></a>00695   <span class="keyword">inline</span> <span class="keyword">typename</span> EnableIfInterOperable&lt;T1,T2,D&gt;::Type
<a name="l00696"></a><a class="code" href="a00198.html#g3f9af23d01448f19280b87dab8bca5ca">00696</a>   <a class="code" href="a00198.html#g3f9af23d01448f19280b87dab8bca5ca" title="Calculates the difference between two pointers.">operator-</a>(<span class="keyword">const</span> <a class="code" href="a00105.html" title="Base class for stl conformant forward iterators.">RandomAccessIteratorFacade&lt;T1,V1,R1,D&gt;</a>&amp; lhs,
<a name="l00697"></a>00697              <span class="keyword">const</span> <a class="code" href="a00105.html" title="Base class for stl conformant forward iterators.">RandomAccessIteratorFacade&lt;T2,V2,R2,D&gt;</a>&amp; rhs)
<a name="l00698"></a>00698   {
<a name="l00699"></a>00699     <span class="keywordflow">if</span>(<a class="code" href="a00028.html" title="Checks wether a type is derived from another.">Conversion&lt;T2,T1&gt;::exists</a>)
<a name="l00700"></a>00700       <span class="keywordflow">return</span> -<span class="keyword">static_cast&lt;</span><span class="keyword">const </span>T1&amp;<span class="keyword">&gt;</span>(lhs).distanceTo(static_cast&lt;const T2&amp;&gt;(rhs));
<a name="l00701"></a>00701     <span class="keywordflow">else</span>
<a name="l00702"></a>00702       <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>T2&amp;<span class="keyword">&gt;</span>(rhs).distanceTo(static_cast&lt;const T1&amp;&gt;(lhs));
<a name="l00703"></a>00703   }
<a name="l00704"></a>00704 
<a name="l00706"></a>00706 }       
<a name="l00707"></a>00707 <span class="preprocessor">#endif </span>
</pre></div></div>
</div> <!-- end doxygen -->
</div> <!-- end main -->
<div class="foot">

<p class="foot">
  Generated on 6 Nov 2008 with <a
  href="http://www.doxygen.org/">Doxygen</a> (ver 1.5.6)  
  [<a href="doxygen.log">logfile</a>].
</p>

</div>

</body>
</html>
