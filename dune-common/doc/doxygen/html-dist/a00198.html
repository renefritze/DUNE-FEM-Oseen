<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN""http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>dune-common: Iterator facades (dune-common )</title>
  <link rel="stylesheet" type="text/css" href="./dune-doxy.css">
  <link rel="stylesheet" type="text/css" href="./tabs.css">
</head>
<div class="main">
<div class="doxygen">
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Iterator facades<br>
<small>
[<a class="el" href="a00191.html">Common</a>]</small>
</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Iterator facades for writing stl conformant iterators. 
<p>
With using these facades writing iterators for arbitrary containers becomes much less cumbersome as only few functions have to be implemented. All other functions needed by the stl are provided by the facades using the Barton-Nackman trick (also known as curiously recurring template pattern).<p>
The following example illustrates how a random access iterator might be written:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">    #include&lt;dune/common/iteratorfacades.hh&gt;</span>
    
    ...
    
    <span class="keyword">template</span>&lt;<span class="keyword">class</span> C, <span class="keyword">class</span> T&gt;
    <span class="keyword">class </span>TestIterator : <span class="keyword">public</span> Dune::BidirectionalIteratorFacade&lt;TestIterator&lt;C,T&gt;,T, T&amp;, int&gt;
    {
      <span class="keyword">friend</span> <span class="keyword">class </span>TestIterator&lt;typename remove_const&lt;C&gt;::type, typename remove_const&lt;T&gt;::type &gt;;
      friend class TestIterator&lt;const typename remove_const&lt;C&gt;::type, const typename remove_const&lt;T&gt;::type &gt;;
    
    <span class="keyword">public</span>:
    
      <span class="comment">// Constructors needed by the facade iterators.</span>
      TestIterator(): container_(0), position_(0)
      { }
    
      TestIterator(C&amp; cont, <span class="keywordtype">int</span> pos)
        : container_(&amp;cont), position_(pos)
      {}

      TestIterator(<span class="keyword">const</span> TestIterator&lt;<span class="keyword">typename</span> remove_const&lt;C&gt;::type, <span class="keyword">typename</span> remove_const&lt;T&gt;::type &gt;&amp; other)
        : container_(other.container_), position_(other.position_)
      {}
    
    
      TestIterator(<span class="keyword">const</span> TestIterator&lt;<span class="keyword">const</span> <span class="keyword">typename</span> remove_const&lt;C&gt;::type, <span class="keyword">const</span> <span class="keyword">typename</span> remove_const&lt;T&gt;::type &gt;&amp; other)
        : container_(other.container_), position_(other.position_)
      {}
    
      <span class="comment">// Methods needed by the forward iterator</span>
      <span class="keywordtype">bool</span> equals(<span class="keyword">const</span> TestIterator&lt;<span class="keyword">typename</span> remove_const&lt;C&gt;::type,<span class="keyword">typename</span> remove_const&lt;T&gt;::type&gt;&amp; other)<span class="keyword"> const</span>
<span class="keyword">      </span>{
        <span class="keywordflow">return</span> position_ == other.position_ &amp;&amp; container_ == other.container_;
      }
    
    
      <span class="keywordtype">bool</span> equals(<span class="keyword">const</span> TestIterator&lt;<span class="keyword">const</span> <span class="keyword">typename</span> remove_const&lt;C&gt;::type,<span class="keyword">const</span> <span class="keyword">typename</span> remove_const&lt;T&gt;::type&gt;&amp; other)<span class="keyword"> const</span>
<span class="keyword">      </span>{
        <span class="keywordflow">return</span> position_ == other.position_ &amp;&amp; container_ == other.container_;
      }
  
      T&amp; dereference()<span class="keyword"> const</span>
<span class="keyword">      </span>{
        <span class="keywordflow">return</span> container_-&gt;values_[position_];
      }
    
      <span class="keywordtype">void</span> increment()
      {
        ++position_;
      }
      
      <span class="comment">// Additional function needed by BidirectionalIterator</span>
      <span class="keywordtype">void</span> decrement()
     {
        --position_;
      }
      
      <span class="comment">// Additional function needed by RandomAccessIterator</span>
      T&amp; elementAt(<span class="keywordtype">int</span> i)<span class="keyword">const</span>
<span class="keyword">      </span>{
        <span class="keywordflow">return</span> container_-&gt;operator[](position_+i);
      }
      
      <span class="keywordtype">void</span> advance(<span class="keywordtype">int</span> n)
      {
        position_=position_+n;
      }

      std::ptrdiff_t distanceTo(TestIterator&lt;<span class="keyword">const</span> <span class="keyword">typename</span> remove_const&lt;C&gt;::type,<span class="keyword">const</span> <span class="keyword">typename</span> remove_const&lt;T&gt;::type&gt; other)<span class="keyword"> const</span>
<span class="keyword">      </span>{
        assert(other.container_==container_);
        <span class="keywordflow">return</span> other.position_ - position_;
      }
      
      std::ptrdiff_t distanceTo(TestIterator&lt;<span class="keyword">const</span> <span class="keyword">typename</span> remove_const&lt;C&gt;::type, <span class="keyword">typename</span> remove_const&lt;T&gt;::type&gt; other)<span class="keyword"> const</span>
<span class="keyword">      </span>{
        assert(other.container_==container_);
        <span class="keywordflow">return</span> other.position_ - position_;
      }
    <span class="keyword">private</span>:
      C *container_;
      <span class="keywordtype">size_t</span> position_;
    };
</pre></div> See dune/common/test/iteratorbase.hh for details. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Modules</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html">GenericIterator</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generic Iterator class for writing stl conformant iterators for any Container class with operator[]. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html">Dune::ForwardIteratorFacade&lt; T, V, R, D &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for stl conformant forward iterators.  <a href="a00061.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html">Dune::BidirectionalIteratorFacade&lt; T, V, R, D &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Facade class for stl conformant bidirectional iterators.  <a href="a00012.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00105.html">Dune::RandomAccessIteratorFacade&lt; T, V, R, D &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for stl conformant forward iterators.  <a href="a00105.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T1, class V1, class R1, class D, class T2, class V2, class R2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">EnableIfInterOperable&lt; T1, T2, <br>
bool &gt;::Type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00198.html#g08dcc3a032ab4adc1f2639f319019053">Dune::operator==</a> (const ForwardIteratorFacade&lt; T1, V1, R1, D &gt; &amp;lhs, const ForwardIteratorFacade&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for equality.  <a href="#g08dcc3a032ab4adc1f2639f319019053"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T1, class V1, class R1, class D, class T2, class V2, class R2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">EnableIfInterOperable&lt; T1, T2, <br>
bool &gt;::Type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00198.html#g5453af083101aa4ecf51ca7662e67188">Dune::operator!=</a> (const ForwardIteratorFacade&lt; T1, V1, R1, D &gt; &amp;lhs, const ForwardIteratorFacade&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for inequality.  <a href="#g5453af083101aa4ecf51ca7662e67188"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T1, class V1, class R1, class D, class T2, class V2, class R2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">EnableIfInterOperable&lt; T1, T2, <br>
bool &gt;::Type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00198.html#gdce22b78ea7f319666399f373b4dbd1c">Dune::operator==</a> (const BidirectionalIteratorFacade&lt; T1, V1, R1, D &gt; &amp;lhs, const BidirectionalIteratorFacade&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for equality.  <a href="#gdce22b78ea7f319666399f373b4dbd1c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T1, class V1, class R1, class D, class T2, class V2, class R2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">EnableIfInterOperable&lt; T1, T2, <br>
bool &gt;::Type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00198.html#ga66c921d994583f94286a4392ac6524d">Dune::operator!=</a> (const BidirectionalIteratorFacade&lt; T1, V1, R1, D &gt; &amp;lhs, const BidirectionalIteratorFacade&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for inequality.  <a href="#ga66c921d994583f94286a4392ac6524d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T1, class V1, class R1, class D, class T2, class V2, class R2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">EnableIfInterOperable&lt; T1, T2, <br>
bool &gt;::Type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00198.html#g27f37ec045571a0aba6fb30272d743eb">Dune::operator==</a> (const RandomAccessIteratorFacade&lt; T1, V1, R1, D &gt; &amp;lhs, const RandomAccessIteratorFacade&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for equality.  <a href="#g27f37ec045571a0aba6fb30272d743eb"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T1, class V1, class R1, class D, class T2, class V2, class R2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">EnableIfInterOperable&lt; T1, T2, <br>
bool &gt;::Type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00198.html#gf0050caf9677b317bde008a062dcdf4e">Dune::operator!=</a> (const RandomAccessIteratorFacade&lt; T1, V1, R1, D &gt; &amp;lhs, const RandomAccessIteratorFacade&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for inequality.  <a href="#gf0050caf9677b317bde008a062dcdf4e"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T1, class V1, class R1, class D, class T2, class V2, class R2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">EnableIfInterOperable&lt; T1, T2, <br>
bool &gt;::Type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00198.html#g28ed08f4239b654384959affc7f9cde5">Dune::operator&lt;</a> (const RandomAccessIteratorFacade&lt; T1, V1, R1, D &gt; &amp;lhs, const RandomAccessIteratorFacade&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comparison operator.  <a href="#g28ed08f4239b654384959affc7f9cde5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T1, class V1, class R1, class D, class T2, class V2, class R2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">EnableIfInterOperable&lt; T1, T2, <br>
bool &gt;::Type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00198.html#g2692db21be773e6af851126973758198">Dune::operator&lt;=</a> (const RandomAccessIteratorFacade&lt; T1, V1, R1, D &gt; &amp;lhs, const RandomAccessIteratorFacade&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comparison operator.  <a href="#g2692db21be773e6af851126973758198"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T1, class V1, class R1, class D, class T2, class V2, class R2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">EnableIfInterOperable&lt; T1, T2, <br>
bool &gt;::Type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00198.html#g4cbf39bc45b01c73292aa19a19e96a56">Dune::operator&gt;</a> (const RandomAccessIteratorFacade&lt; T1, V1, R1, D &gt; &amp;lhs, const RandomAccessIteratorFacade&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comparison operator.  <a href="#g4cbf39bc45b01c73292aa19a19e96a56"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T1, class V1, class R1, class D, class T2, class V2, class R2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">EnableIfInterOperable&lt; T1, T2, <br>
bool &gt;::Type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00198.html#geb9de751f8083dadd06a4ed5a7b8be12">Dune::operator&gt;=</a> (const RandomAccessIteratorFacade&lt; T1, V1, R1, D &gt; &amp;lhs, const RandomAccessIteratorFacade&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Comparison operator.  <a href="#geb9de751f8083dadd06a4ed5a7b8be12"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T1, class V1, class R1, class D, class T2, class V2, class R2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">EnableIfInterOperable&lt; T1, T2, <br>
D &gt;::Type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00198.html#g3f9af23d01448f19280b87dab8bca5ca">Dune::operator-</a> (const RandomAccessIteratorFacade&lt; T1, V1, R1, D &gt; &amp;lhs, const RandomAccessIteratorFacade&lt; T2, V2, R2, D &gt; &amp;rhs)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates the difference between two pointers.  <a href="#g3f9af23d01448f19280b87dab8bca5ca"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="gf0050caf9677b317bde008a062dcdf4e"></a><!-- doxytag: member="Dune::operator!=" ref="gf0050caf9677b317bde008a062dcdf4e" args="(const RandomAccessIteratorFacade&lt; T1, V1, R1, D &gt; &amp;lhs, const RandomAccessIteratorFacade&lt; T2, V2, R2, D &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class V1, class R1, class D, class T2, class V2, class R2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EnableIfInterOperable&lt;T1,T2,bool&gt;::Type Dune::operator!=           </td>
          <td>(</td>
          <td class="paramtype">const RandomAccessIteratorFacade&lt; T1, V1, R1, D &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RandomAccessIteratorFacade&lt; T2, V2, R2, D &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks for inequality. 
<p>
This operation is only defined if either D2 is convertible to D1 or vice versa. If that is not the case the compiler will report an error as EnableIfInterOperable&lt;D1,D2,bool&gt;::Type is not defined. 
</div>
</div><p>
<a class="anchor" name="ga66c921d994583f94286a4392ac6524d"></a><!-- doxytag: member="Dune::operator!=" ref="ga66c921d994583f94286a4392ac6524d" args="(const BidirectionalIteratorFacade&lt; T1, V1, R1, D &gt; &amp;lhs, const BidirectionalIteratorFacade&lt; T2, V2, R2, D &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class V1, class R1, class D, class T2, class V2, class R2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EnableIfInterOperable&lt;T1,T2,bool&gt;::Type Dune::operator!=           </td>
          <td>(</td>
          <td class="paramtype">const BidirectionalIteratorFacade&lt; T1, V1, R1, D &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BidirectionalIteratorFacade&lt; T2, V2, R2, D &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks for inequality. 
<p>
This operation is only defined if either D2 is convertible to D1 or vice versa. If that is not the case the compiler will report an error as EnableIfInterOperable&lt;D1,D2,bool&gt;::Type is not defined. 
</div>
</div><p>
<a class="anchor" name="g5453af083101aa4ecf51ca7662e67188"></a><!-- doxytag: member="Dune::operator!=" ref="g5453af083101aa4ecf51ca7662e67188" args="(const ForwardIteratorFacade&lt; T1, V1, R1, D &gt; &amp;lhs, const ForwardIteratorFacade&lt; T2, V2, R2, D &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class V1, class R1, class D, class T2, class V2, class R2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EnableIfInterOperable&lt;T1,T2,bool&gt;::Type Dune::operator!=           </td>
          <td>(</td>
          <td class="paramtype">const ForwardIteratorFacade&lt; T1, V1, R1, D &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIteratorFacade&lt; T2, V2, R2, D &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks for inequality. 
<p>
This operation is only defined if either D2 is convertible to D1 or vice versa. If that is not the case the compiler will report an error as EnableIfInterOperable&lt;D1,D2,bool&gt;::Type is not defined. 
</div>
</div><p>
<a class="anchor" name="g3f9af23d01448f19280b87dab8bca5ca"></a><!-- doxytag: member="Dune::operator-" ref="g3f9af23d01448f19280b87dab8bca5ca" args="(const RandomAccessIteratorFacade&lt; T1, V1, R1, D &gt; &amp;lhs, const RandomAccessIteratorFacade&lt; T2, V2, R2, D &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class V1, class R1, class D, class T2, class V2, class R2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EnableIfInterOperable&lt;T1,T2,D&gt;::Type Dune::operator-           </td>
          <td>(</td>
          <td class="paramtype">const RandomAccessIteratorFacade&lt; T1, V1, R1, D &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RandomAccessIteratorFacade&lt; T2, V2, R2, D &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculates the difference between two pointers. 
<p>
This operation is only defined if either D2 is convertible to D1 or vice versa. If that is not the case the compiler will report an error as EnableIfInterOperable&lt;D1,D2,bool&gt;::Type is not defined. 
</div>
</div><p>
<a class="anchor" name="g28ed08f4239b654384959affc7f9cde5"></a><!-- doxytag: member="Dune::operator&lt;" ref="g28ed08f4239b654384959affc7f9cde5" args="(const RandomAccessIteratorFacade&lt; T1, V1, R1, D &gt; &amp;lhs, const RandomAccessIteratorFacade&lt; T2, V2, R2, D &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class V1, class R1, class D, class T2, class V2, class R2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EnableIfInterOperable&lt;T1,T2,bool&gt;::Type Dune::operator&lt;           </td>
          <td>(</td>
          <td class="paramtype">const RandomAccessIteratorFacade&lt; T1, V1, R1, D &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RandomAccessIteratorFacade&lt; T2, V2, R2, D &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Comparison operator. 
<p>
This operation is only defined if either D2 is convertible to D1 or vice versa. If that is not the case the compiler will report an error as EnableIfInterOperable&lt;D1,D2,bool&gt;::Type is not defined. 
</div>
</div><p>
<a class="anchor" name="g2692db21be773e6af851126973758198"></a><!-- doxytag: member="Dune::operator&lt;=" ref="g2692db21be773e6af851126973758198" args="(const RandomAccessIteratorFacade&lt; T1, V1, R1, D &gt; &amp;lhs, const RandomAccessIteratorFacade&lt; T2, V2, R2, D &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class V1, class R1, class D, class T2, class V2, class R2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EnableIfInterOperable&lt;T1,T2,bool&gt;::Type Dune::operator&lt;=           </td>
          <td>(</td>
          <td class="paramtype">const RandomAccessIteratorFacade&lt; T1, V1, R1, D &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RandomAccessIteratorFacade&lt; T2, V2, R2, D &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Comparison operator. 
<p>
This operation is only defined if either D2 is convertible to D1 or vice versa. If that is not the case the compiler will report an error as EnableIfInterOperable&lt;D1,D2,bool&gt;::Type is not defined. 
</div>
</div><p>
<a class="anchor" name="g27f37ec045571a0aba6fb30272d743eb"></a><!-- doxytag: member="Dune::operator==" ref="g27f37ec045571a0aba6fb30272d743eb" args="(const RandomAccessIteratorFacade&lt; T1, V1, R1, D &gt; &amp;lhs, const RandomAccessIteratorFacade&lt; T2, V2, R2, D &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class V1, class R1, class D, class T2, class V2, class R2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EnableIfInterOperable&lt;T1,T2,bool&gt;::Type Dune::operator==           </td>
          <td>(</td>
          <td class="paramtype">const RandomAccessIteratorFacade&lt; T1, V1, R1, D &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RandomAccessIteratorFacade&lt; T2, V2, R2, D &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks for equality. 
<p>
This operation is only defined if either D2 is convertible to D1 or vice versa. If that is not the case the compiler will report an error as EnableIfInterOperable&lt;D1,D2,bool&gt;::Type is not defined. 
</div>
</div><p>
<a class="anchor" name="gdce22b78ea7f319666399f373b4dbd1c"></a><!-- doxytag: member="Dune::operator==" ref="gdce22b78ea7f319666399f373b4dbd1c" args="(const BidirectionalIteratorFacade&lt; T1, V1, R1, D &gt; &amp;lhs, const BidirectionalIteratorFacade&lt; T2, V2, R2, D &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class V1, class R1, class D, class T2, class V2, class R2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EnableIfInterOperable&lt;T1,T2,bool&gt;::Type Dune::operator==           </td>
          <td>(</td>
          <td class="paramtype">const BidirectionalIteratorFacade&lt; T1, V1, R1, D &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BidirectionalIteratorFacade&lt; T2, V2, R2, D &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks for equality. 
<p>
This operation is only defined if either D2 is convertible to D1 or vice versa. If that is not the case the compiler will report an error as EnableIfInterOperable&lt;D1,D2,bool&gt;::Type is not defined. 
</div>
</div><p>
<a class="anchor" name="g08dcc3a032ab4adc1f2639f319019053"></a><!-- doxytag: member="Dune::operator==" ref="g08dcc3a032ab4adc1f2639f319019053" args="(const ForwardIteratorFacade&lt; T1, V1, R1, D &gt; &amp;lhs, const ForwardIteratorFacade&lt; T2, V2, R2, D &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class V1, class R1, class D, class T2, class V2, class R2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EnableIfInterOperable&lt;T1,T2,bool&gt;::Type Dune::operator==           </td>
          <td>(</td>
          <td class="paramtype">const ForwardIteratorFacade&lt; T1, V1, R1, D &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIteratorFacade&lt; T2, V2, R2, D &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks for equality. 
<p>
This operation is only defined if either D2 is convertible to D1 or vice versa. If that is not the case the compiler will report an error as EnableIfInterOperable&lt;D1,D2,bool&gt;::Type is not defined. 
</div>
</div><p>
<a class="anchor" name="g4cbf39bc45b01c73292aa19a19e96a56"></a><!-- doxytag: member="Dune::operator&gt;" ref="g4cbf39bc45b01c73292aa19a19e96a56" args="(const RandomAccessIteratorFacade&lt; T1, V1, R1, D &gt; &amp;lhs, const RandomAccessIteratorFacade&lt; T2, V2, R2, D &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class V1, class R1, class D, class T2, class V2, class R2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EnableIfInterOperable&lt;T1,T2,bool&gt;::Type Dune::operator&gt;           </td>
          <td>(</td>
          <td class="paramtype">const RandomAccessIteratorFacade&lt; T1, V1, R1, D &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RandomAccessIteratorFacade&lt; T2, V2, R2, D &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Comparison operator. 
<p>
This operation is only defined if either D2 is convertible to D1 or vice versa. If that is not the case the compiler will report an error as EnableIfInterOperable&lt;D1,D2,bool&gt;::Type is not defined. 
</div>
</div><p>
<a class="anchor" name="geb9de751f8083dadd06a4ed5a7b8be12"></a><!-- doxytag: member="Dune::operator&gt;=" ref="geb9de751f8083dadd06a4ed5a7b8be12" args="(const RandomAccessIteratorFacade&lt; T1, V1, R1, D &gt; &amp;lhs, const RandomAccessIteratorFacade&lt; T2, V2, R2, D &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class V1, class R1, class D, class T2, class V2, class R2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EnableIfInterOperable&lt;T1,T2,bool&gt;::Type Dune::operator&gt;=           </td>
          <td>(</td>
          <td class="paramtype">const RandomAccessIteratorFacade&lt; T1, V1, R1, D &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RandomAccessIteratorFacade&lt; T2, V2, R2, D &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Comparison operator. 
<p>
This operation is only defined if either D2 is convertible to D1 or vice versa. If that is not the case the compiler will report an error as EnableIfInterOperable&lt;D1,D2,bool&gt;::Type is not defined. 
</div>
</div><p>
</div>
</div> <!-- end doxygen -->
</div> <!-- end main -->
<div class="foot">

<p class="foot">
  Generated on 6 Nov 2008 with <a
  href="http://www.doxygen.org/">Doxygen</a> (ver 1.5.6)  
  [<a href="doxygen.log">logfile</a>].
</p>

</div>

</body>
</html>
