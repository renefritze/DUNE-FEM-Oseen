<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN""http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>dune-common: fmatrix.hh Source File (dune-common )</title>
  <link rel="stylesheet" type="text/css" href="./dune-doxy.css">
  <link rel="stylesheet" type="text/css" href="./tabs.css">
</head>
<div class="main">
<div class="doxygen">
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_2ca904c6ce82cf2d3dcac8fdc6f434f6.html">common</a>
  </div>
</div>
<div class="contents">
<h1>fmatrix.hh</h1><a href="a00154.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// $Id: fmatrix.hh 5077 2008-02-06 14:05:09Z robertk $</span>
<a name="l00002"></a>00002 <span class="preprocessor">#ifndef DUNE_FMATRIX_HH</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span><span class="preprocessor">#define DUNE_FMATRIX_HH</span>
<a name="l00004"></a>00004 <span class="preprocessor"></span>
<a name="l00005"></a>00005 <span class="preprocessor">#include&lt;cmath&gt;</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include&lt;cstddef&gt;</span>
<a name="l00007"></a>00007 <span class="preprocessor">#include&lt;complex&gt;</span>
<a name="l00008"></a>00008 <span class="preprocessor">#include&lt;iostream&gt;</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include "<a class="code" href="a00149.html" title="A few common exception classes.">exceptions.hh</a>"</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include "<a class="code" href="a00155.html" title="This file implements a vector constructed from a given type representing a field...">fvector.hh</a>"</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include "precision.hh"</span>
<a name="l00012"></a>00012 
<a name="l00013"></a>00013 <span class="keyword">namespace </span>Dune {
<a name="l00014"></a>00014    
<a name="l00026"></a>00026   <span class="keyword">template</span>&lt;<span class="keyword">class</span> K, <span class="keywordtype">int</span> n, <span class="keywordtype">int</span> m&gt; <span class="keyword">class </span>FieldMatrix;
<a name="l00027"></a>00027   
<a name="l00029"></a><a class="code" href="a00056.html">00029</a>   <span class="keyword">class </span><a class="code" href="a00056.html" title="Error thrown if operations of a FieldMatrix fail.">FMatrixError</a> : <span class="keyword">public</span> <a class="code" href="a00044.html" title="Base class for Dune-Exceptions.">Exception</a> {};
<a name="l00030"></a>00030 
<a name="l00031"></a>00031   <span class="comment">// conjugate komplex does nothing for non-complex types</span>
<a name="l00032"></a>00032   <span class="keyword">template</span>&lt;<span class="keyword">class</span> K&gt;
<a name="l00033"></a>00033   <span class="keyword">inline</span> K fm_ck (<span class="keyword">const</span> K&amp; k)
<a name="l00034"></a>00034   {
<a name="l00035"></a>00035         <span class="keywordflow">return</span> k;
<a name="l00036"></a>00036   }
<a name="l00037"></a>00037 
<a name="l00038"></a>00038   <span class="comment">// conjugate komplex</span>
<a name="l00039"></a>00039   <span class="keyword">template</span>&lt;<span class="keyword">class</span> K&gt;
<a name="l00040"></a>00040   <span class="keyword">inline</span> std::complex&lt;K&gt; fm_ck (<span class="keyword">const</span> std::complex&lt;K&gt;&amp; c)
<a name="l00041"></a>00041   {
<a name="l00042"></a>00042         <span class="keywordflow">return</span> std::complex&lt;K&gt;(c.real(),-c.imag());
<a name="l00043"></a>00043   }
<a name="l00044"></a>00044 
<a name="l00053"></a>00053 <span class="preprocessor">#ifdef DUNE_EXPRESSIONTEMPLATES</span>
<a name="l00054"></a>00054 <span class="preprocessor"></span>  <span class="keyword">template</span>&lt;<span class="keyword">class</span> K, <span class="keywordtype">int</span> n, <span class="keywordtype">int</span> m&gt;
<a name="l00055"></a>00055   <span class="keyword">class </span>FieldMatrix : ExprTmpl::Matrix&lt; FieldMatrix&lt;K,n,m&gt; &gt;
<a name="l00056"></a>00056 #else
<a name="l00057"></a>00057   template&lt;class K, int n, int m&gt;
<a name="l00058"></a><a class="code" href="a00049.html">00058</a>   class <a class="code" href="a00049.html" title="A dense n x m matrix.">FieldMatrix</a>
<a name="l00059"></a>00059 #endif
<a name="l00060"></a>00060   {
<a name="l00061"></a>00061   <span class="keyword">public</span>:
<a name="l00062"></a>00062         <span class="comment">// standard constructor and everything is sufficient ...</span>
<a name="l00063"></a>00063 
<a name="l00064"></a>00064         <span class="comment">//===== type definitions and constants</span>
<a name="l00065"></a>00065 
<a name="l00067"></a><a class="code" href="a00049.html#e44d02894ed68d20d10511802daaa852">00067</a>         <span class="keyword">typedef</span> K <a class="code" href="a00049.html#e44d02894ed68d20d10511802daaa852" title="export the type representing the field">field_type</a>;
<a name="l00068"></a>00068 
<a name="l00070"></a><a class="code" href="a00049.html#397dc3a4ce3c2b1d0edaa06ff7cd68eb">00070</a>         <span class="keyword">typedef</span> K <a class="code" href="a00049.html#397dc3a4ce3c2b1d0edaa06ff7cd68eb" title="export the type representing the components">block_type</a>;
<a name="l00071"></a>00071     
<a name="l00073"></a><a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488">00073</a>     <span class="keyword">typedef</span> std::size_t <a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a>;
<a name="l00074"></a>00074     
<a name="l00076"></a>00076         <span class="keyword">enum</span> {
<a name="l00078"></a><a class="code" href="a00049.html#c7472b000c727d23d3d6734ae5bfd1a9f4584b51c048d0d20ba5bfb75855d114">00078</a>           <a class="code" href="a00049.html#c7472b000c727d23d3d6734ae5bfd1a9f4584b51c048d0d20ba5bfb75855d114" title="The number of block levels we contain. This is 1.">blocklevel</a> = 1
<a name="l00079"></a>00079         };
<a name="l00080"></a>00080 
<a name="l00082"></a><a class="code" href="a00049.html#f47453a03570ee649a70eacadec9c72b">00082</a>         <span class="keyword">typedef</span> <a class="code" href="a00051.html" title="Construct a vector space out of a tensor product of fields.">FieldVector&lt;K,m&gt;</a> <a class="code" href="a00051.html">row_type</a>; 
<a name="l00083"></a>00083 
<a name="l00085"></a>00085         <span class="keyword">enum</span> {
<a name="l00087"></a><a class="code" href="a00049.html#a6f7c6e923c8c1fb7879d934b60038fe540968b6fbabc35bc23f2034d0b3c717">00087</a>           <a class="code" href="a00049.html#a6f7c6e923c8c1fb7879d934b60038fe540968b6fbabc35bc23f2034d0b3c717" title="The number of rows.">rows</a> = n, 
<a name="l00089"></a><a class="code" href="a00049.html#a6f7c6e923c8c1fb7879d934b60038fe37549d479e9082ffb6bb67c17f39cc53">00089</a>           <a class="code" href="a00049.html#a6f7c6e923c8c1fb7879d934b60038fe37549d479e9082ffb6bb67c17f39cc53" title="The number of columns.">cols</a> = m
<a name="l00090"></a>00090         };
<a name="l00091"></a>00091 
<a name="l00092"></a>00092         <span class="comment">//===== constructors</span>
<a name="l00095"></a><a class="code" href="a00049.html#6bd9d90d8b75d368630a7ea8da41cd82">00095</a> <span class="comment"></span>        <a class="code" href="a00049.html#6bd9d90d8b75d368630a7ea8da41cd82" title="Default constructor.">FieldMatrix</a> () {}
<a name="l00096"></a>00096 
<a name="l00099"></a><a class="code" href="a00049.html#cdf4d16f1026dd4ff32f271ed260f22b">00099</a>         <a class="code" href="a00049.html#6bd9d90d8b75d368630a7ea8da41cd82" title="Default constructor.">FieldMatrix</a> (<span class="keyword">const</span> K&amp; k)
<a name="l00100"></a>00100         {
<a name="l00101"></a>00101           <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> i=0; i&lt;n; i++) p[i] = k;
<a name="l00102"></a>00102         }
<a name="l00103"></a>00103 
<a name="l00104"></a>00104         <span class="comment">//===== random access interface to rows of the matrix</span>
<a name="l00105"></a>00105 
<a name="l00107"></a><a class="code" href="a00049.html#51a72ac893f34ef9cd102330928e775d">00107</a>         <a class="code" href="a00051.html">row_type</a>&amp; <a class="code" href="a00049.html#51a72ac893f34ef9cd102330928e775d" title="random access to the rows">operator[] </a>(<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> i)
<a name="l00108"></a>00108         {
<a name="l00109"></a>00109 <span class="preprocessor">#ifdef DUNE_FMatrix_WITH_CHECKING</span>
<a name="l00110"></a>00110 <span class="preprocessor"></span>          <span class="keywordflow">if</span> (i&lt;0 || i&gt;=n) <a class="code" href="a00149.html#d7fce127d6eaabe773adbc409514f21e">DUNE_THROW</a>(<a class="code" href="a00056.html" title="Error thrown if operations of a FieldMatrix fail.">FMatrixError</a>,<span class="stringliteral">"index out of range"</span>);
<a name="l00111"></a>00111 <span class="preprocessor">#endif</span>
<a name="l00112"></a>00112 <span class="preprocessor"></span>          <span class="keywordflow">return</span> p[i];
<a name="l00113"></a>00113         }
<a name="l00114"></a>00114 
<a name="l00116"></a><a class="code" href="a00049.html#15e2bf9685376b4fc22f911b59c3336d">00116</a>         <span class="keyword">const</span> <a class="code" href="a00051.html">row_type</a>&amp; <a class="code" href="a00049.html#51a72ac893f34ef9cd102330928e775d" title="random access to the rows">operator[] </a>(<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> i)<span class="keyword"> const</span>
<a name="l00117"></a>00117 <span class="keyword">        </span>{
<a name="l00118"></a>00118 <span class="preprocessor">#ifdef DUNE_FMatrix_WITH_CHECKING</span>
<a name="l00119"></a>00119 <span class="preprocessor"></span>          <span class="keywordflow">if</span> (i&lt;0 || i&gt;=n) <a class="code" href="a00149.html#d7fce127d6eaabe773adbc409514f21e">DUNE_THROW</a>(<a class="code" href="a00056.html" title="Error thrown if operations of a FieldMatrix fail.">FMatrixError</a>,<span class="stringliteral">"index out of range"</span>);
<a name="l00120"></a>00120 <span class="preprocessor">#endif</span>
<a name="l00121"></a>00121 <span class="preprocessor"></span>          <span class="keywordflow">return</span> p[i];
<a name="l00122"></a>00122         }
<a name="l00123"></a>00123 
<a name="l00124"></a>00124 
<a name="l00125"></a>00125         <span class="comment">//===== iterator interface to rows of the matrix</span>
<a name="l00127"></a><a class="code" href="a00049.html#285402785c6ecaaff417e920348e62cb">00127</a> <span class="comment"></span>    <span class="keyword">typedef</span> <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">FieldIterator&lt;FieldMatrix&lt;K,n,m&gt;</a>,<a class="code" href="a00051.html">row_type</a>&gt; <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">Iterator</a>;
<a name="l00129"></a><a class="code" href="a00049.html#5cf9edb15750ffab3d70ec780b6cd783">00129</a>     <span class="keyword">typedef</span> <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">Iterator</a> <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">iterator</a>;
<a name="l00131"></a><a class="code" href="a00049.html#4ceea11e86658a46f70941911a1e8f8a">00131</a>         <span class="keyword">typedef</span> <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">Iterator</a> <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">RowIterator</a>;
<a name="l00133"></a><a class="code" href="a00049.html#dab79de300a87fc91547fa0a3f37b763">00133</a>         <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">row_type::Iterator</a> <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">ColIterator</a>;
<a name="l00134"></a>00134 
<a name="l00136"></a><a class="code" href="a00049.html#5481d3cfaa65a5f58b0d00db72adb7a7">00136</a>         <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">Iterator</a> <a class="code" href="a00049.html#5481d3cfaa65a5f58b0d00db72adb7a7" title="begin iterator">begin</a> ()
<a name="l00137"></a>00137         {
<a name="l00138"></a>00138           <span class="keywordflow">return</span> <a class="code" href="a00049.html#285402785c6ecaaff417e920348e62cb" title="Iterator class for sequential access.">Iterator</a>(*<span class="keyword">this</span>,0);
<a name="l00139"></a>00139         }
<a name="l00140"></a>00140           
<a name="l00142"></a><a class="code" href="a00049.html#5c448d47b189ba94c2aeb59da37ee983">00142</a>         <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">Iterator</a> <a class="code" href="a00049.html#5c448d47b189ba94c2aeb59da37ee983" title="end iterator">end</a> ()
<a name="l00143"></a>00143         {
<a name="l00144"></a>00144           <span class="keywordflow">return</span> <a class="code" href="a00049.html#285402785c6ecaaff417e920348e62cb" title="Iterator class for sequential access.">Iterator</a>(*<span class="keyword">this</span>,n);
<a name="l00145"></a>00145         }
<a name="l00146"></a>00146 
<a name="l00148"></a><a class="code" href="a00049.html#f63a2c138a786abc3e968fc015b5b101">00148</a>         <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">Iterator</a> <a class="code" href="a00049.html#f63a2c138a786abc3e968fc015b5b101" title="begin iterator">rbegin</a> ()
<a name="l00149"></a>00149         {
<a name="l00150"></a>00150           <span class="keywordflow">return</span> <a class="code" href="a00049.html#285402785c6ecaaff417e920348e62cb" title="Iterator class for sequential access.">Iterator</a>(*<span class="keyword">this</span>,n-1);
<a name="l00151"></a>00151         }
<a name="l00152"></a>00152           
<a name="l00154"></a><a class="code" href="a00049.html#a503e0add6207004b3f37c79ba6d5e8a">00154</a>         <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">Iterator</a> <a class="code" href="a00049.html#a503e0add6207004b3f37c79ba6d5e8a" title="end iterator">rend</a> ()
<a name="l00155"></a>00155         {
<a name="l00156"></a>00156           <span class="keywordflow">return</span> <a class="code" href="a00049.html#285402785c6ecaaff417e920348e62cb" title="Iterator class for sequential access.">Iterator</a>(*<span class="keyword">this</span>,-1);
<a name="l00157"></a>00157         }
<a name="l00158"></a>00158 
<a name="l00160"></a><a class="code" href="a00049.html#691f5be0179e3a24622e29ce606da27e">00160</a>     <span class="keyword">typedef</span> <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">FieldIterator&lt;const FieldMatrix&lt;K,n,m&gt;</a>,<span class="keyword">const</span> <a class="code" href="a00051.html">row_type</a>&gt; <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">ConstIterator</a>;
<a name="l00162"></a><a class="code" href="a00049.html#3bc0a56f87a17e5b7d2734e7ef767f02">00162</a>     <span class="keyword">typedef</span> <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">ConstIterator</a> <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">const_iterator</a>;
<a name="l00164"></a><a class="code" href="a00049.html#03e4ff8ba58d7571192f9f902da18879">00164</a>         <span class="keyword">typedef</span> <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">ConstIterator</a> <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">ConstRowIterator</a>;
<a name="l00166"></a><a class="code" href="a00049.html#22f11bfc2fa68fbdbd893edfc5b6869d">00166</a>         <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">row_type::ConstIterator</a> <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">ConstColIterator</a>;
<a name="l00167"></a>00167 
<a name="l00169"></a><a class="code" href="a00049.html#f2f2310e023a43534684af5fbb16b8d6">00169</a>         <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">ConstIterator</a> <a class="code" href="a00049.html#5481d3cfaa65a5f58b0d00db72adb7a7" title="begin iterator">begin</a> ()<span class="keyword"> const</span>
<a name="l00170"></a>00170 <span class="keyword">        </span>{
<a name="l00171"></a>00171           <span class="keywordflow">return</span> <a class="code" href="a00049.html#691f5be0179e3a24622e29ce606da27e" title="Iterator class for sequential access.">ConstIterator</a>(*<span class="keyword">this</span>,0);
<a name="l00172"></a>00172         }
<a name="l00173"></a>00173           
<a name="l00175"></a><a class="code" href="a00049.html#5ba64d3cb3a4602bf4cb1c1cd08de863">00175</a>         <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">ConstIterator</a> <a class="code" href="a00049.html#5c448d47b189ba94c2aeb59da37ee983" title="end iterator">end</a> ()<span class="keyword"> const</span>
<a name="l00176"></a>00176 <span class="keyword">        </span>{
<a name="l00177"></a>00177           <span class="keywordflow">return</span> <a class="code" href="a00049.html#691f5be0179e3a24622e29ce606da27e" title="Iterator class for sequential access.">ConstIterator</a>(*<span class="keyword">this</span>,n);
<a name="l00178"></a>00178         }
<a name="l00179"></a>00179 
<a name="l00181"></a><a class="code" href="a00049.html#2fd45a333f11d6d4bd77dacd7241a9fd">00181</a>         <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">ConstIterator</a> <a class="code" href="a00049.html#f63a2c138a786abc3e968fc015b5b101" title="begin iterator">rbegin</a> ()<span class="keyword"> const</span>
<a name="l00182"></a>00182 <span class="keyword">        </span>{
<a name="l00183"></a>00183           <span class="keywordflow">return</span> <a class="code" href="a00049.html#691f5be0179e3a24622e29ce606da27e" title="Iterator class for sequential access.">ConstIterator</a>(*<span class="keyword">this</span>,n-1);
<a name="l00184"></a>00184         }
<a name="l00185"></a>00185           
<a name="l00187"></a><a class="code" href="a00049.html#d6d8a17a67f6c78b6d3577623377e688">00187</a>         <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">ConstIterator</a> <a class="code" href="a00049.html#a503e0add6207004b3f37c79ba6d5e8a" title="end iterator">rend</a> ()<span class="keyword"> const</span>
<a name="l00188"></a>00188 <span class="keyword">        </span>{
<a name="l00189"></a>00189           <span class="keywordflow">return</span> <a class="code" href="a00049.html#691f5be0179e3a24622e29ce606da27e" title="Iterator class for sequential access.">ConstIterator</a>(*<span class="keyword">this</span>,-1);
<a name="l00190"></a>00190         }
<a name="l00191"></a>00191 
<a name="l00192"></a>00192         <span class="comment">//===== assignment from scalar</span>
<a name="l00193"></a>00193         <a class="code" href="a00049.html" title="A dense n x m matrix.">FieldMatrix</a>&amp; operator= (<span class="keyword">const</span> K&amp; k)
<a name="l00194"></a>00194         {
<a name="l00195"></a>00195             <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> i=0; i&lt;n; i++)
<a name="l00196"></a>00196                 p[i] = k;
<a name="l00197"></a>00197           <span class="keywordflow">return</span> *<span class="keyword">this</span>;   
<a name="l00198"></a>00198         }
<a name="l00199"></a>00199 
<a name="l00200"></a>00200         <span class="comment">//===== vector space arithmetic</span>
<a name="l00201"></a>00201 
<a name="l00203"></a><a class="code" href="a00049.html#7287c994bac08964d6700b1f209ccf17">00203</a>         <a class="code" href="a00049.html" title="A dense n x m matrix.">FieldMatrix</a>&amp; <a class="code" href="a00049.html#7287c994bac08964d6700b1f209ccf17" title="vector space addition">operator+= </a>(<span class="keyword">const</span> <a class="code" href="a00049.html" title="A dense n x m matrix.">FieldMatrix</a>&amp; y)
<a name="l00204"></a>00204         {
<a name="l00205"></a>00205             <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> i=0; i&lt;n; i++)
<a name="l00206"></a>00206                 p[i] += y.<a class="code" href="a00049.html#dcbb03e6bc2fa49aaec3568581d7d290">p</a>[i];
<a name="l00207"></a>00207           <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00208"></a>00208         }
<a name="l00209"></a>00209 
<a name="l00211"></a><a class="code" href="a00049.html#f459b420d50b679e5391231ec7f3e8a6">00211</a>         <a class="code" href="a00049.html" title="A dense n x m matrix.">FieldMatrix</a>&amp; <a class="code" href="a00049.html#f459b420d50b679e5391231ec7f3e8a6" title="vector space subtraction">operator-= </a>(<span class="keyword">const</span> <a class="code" href="a00049.html" title="A dense n x m matrix.">FieldMatrix</a>&amp; y)
<a name="l00212"></a>00212         {
<a name="l00213"></a>00213             <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> i=0; i&lt;n; i++)
<a name="l00214"></a>00214                 p[i] -= y.<a class="code" href="a00049.html#dcbb03e6bc2fa49aaec3568581d7d290">p</a>[i];
<a name="l00215"></a>00215           <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00216"></a>00216         }
<a name="l00217"></a>00217 
<a name="l00219"></a><a class="code" href="a00049.html#9859ccea37cee4b4da555db9bae7937a">00219</a>         <a class="code" href="a00049.html" title="A dense n x m matrix.">FieldMatrix</a>&amp; <a class="code" href="a00049.html#9859ccea37cee4b4da555db9bae7937a" title="vector space multiplication with scalar">operator*= </a>(<span class="keyword">const</span> K&amp; k)
<a name="l00220"></a>00220         {
<a name="l00221"></a>00221             <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> i=0; i&lt;n; i++)
<a name="l00222"></a>00222                 p[i] *= k;
<a name="l00223"></a>00223           <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00224"></a>00224         }
<a name="l00225"></a>00225 
<a name="l00227"></a><a class="code" href="a00049.html#87f37af6f9daf845934534d3f0c3f1a6">00227</a>         <a class="code" href="a00049.html" title="A dense n x m matrix.">FieldMatrix</a>&amp; <a class="code" href="a00049.html#87f37af6f9daf845934534d3f0c3f1a6" title="vector space division by scalar">operator/= </a>(<span class="keyword">const</span> K&amp; k)
<a name="l00228"></a>00228         {
<a name="l00229"></a>00229             <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> i=0; i&lt;n; i++)
<a name="l00230"></a>00230                 p[i] /= k;
<a name="l00231"></a>00231           <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00232"></a>00232         }
<a name="l00233"></a>00233 
<a name="l00234"></a>00234         <span class="comment">//===== linear maps</span>
<a name="l00235"></a>00235    
<a name="l00237"></a>00237         <span class="keyword">template</span>&lt;<span class="keyword">class</span> X, <span class="keyword">class</span> Y&gt;
<a name="l00238"></a><a class="code" href="a00049.html#a9997d627619a505219311ca3cd250f6">00238</a>         <span class="keywordtype">void</span> <a class="code" href="a00049.html#a9997d627619a505219311ca3cd250f6" title="y = A x">mv</a> (<span class="keyword">const</span> X&amp; x, Y&amp; y)<span class="keyword"> const</span>
<a name="l00239"></a>00239 <span class="keyword">        </span>{
<a name="l00240"></a>00240 <span class="preprocessor">#ifdef DUNE_FMatrix_WITH_CHECKING</span>
<a name="l00241"></a>00241 <span class="preprocessor"></span>          <span class="keywordflow">if</span> (x.N()!=<a class="code" href="a00049.html#a0e0e890e1d0c3e969feb6aee8f59920" title="number of blocks in column direction">M</a>()) <a class="code" href="a00149.html#d7fce127d6eaabe773adbc409514f21e">DUNE_THROW</a>(<a class="code" href="a00056.html" title="Error thrown if operations of a FieldMatrix fail.">FMatrixError</a>,<span class="stringliteral">"index out of range"</span>);
<a name="l00242"></a>00242           <span class="keywordflow">if</span> (y.N()!=<a class="code" href="a00049.html#941900e6156fe500135851254a120a36" title="number of blocks in row direction">N</a>()) <a class="code" href="a00149.html#d7fce127d6eaabe773adbc409514f21e">DUNE_THROW</a>(<a class="code" href="a00056.html" title="Error thrown if operations of a FieldMatrix fail.">FMatrixError</a>,<span class="stringliteral">"index out of range"</span>);
<a name="l00243"></a>00243 <span class="preprocessor">#endif</span>
<a name="l00244"></a>00244 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> i=0; i&lt;n; ++i)
<a name="l00245"></a>00245     {
<a name="l00246"></a>00246       y[i] = 0;
<a name="l00247"></a>00247       <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> j=0; j&lt;m; j++)
<a name="l00248"></a>00248         y[i] += (*<span class="keyword">this</span>)[i][j] * x[j];
<a name="l00249"></a>00249     }
<a name="l00250"></a>00250         }
<a name="l00251"></a>00251 
<a name="l00253"></a>00253         <span class="keyword">template</span>&lt;<span class="keyword">class</span> X, <span class="keyword">class</span> Y&gt;
<a name="l00254"></a><a class="code" href="a00049.html#8ea9030e3d162d81a17032d65c7bd6b4">00254</a>         <span class="keywordtype">void</span> <a class="code" href="a00049.html#8ea9030e3d162d81a17032d65c7bd6b4" title="y += A x">umv</a> (<span class="keyword">const</span> X&amp; x, Y&amp; y)<span class="keyword"> const</span>
<a name="l00255"></a>00255 <span class="keyword">        </span>{
<a name="l00256"></a>00256 <span class="preprocessor">#ifdef DUNE_FMatrix_WITH_CHECKING</span>
<a name="l00257"></a>00257 <span class="preprocessor"></span>          <span class="keywordflow">if</span> (x.N()!=<a class="code" href="a00049.html#a0e0e890e1d0c3e969feb6aee8f59920" title="number of blocks in column direction">M</a>()) <a class="code" href="a00149.html#d7fce127d6eaabe773adbc409514f21e">DUNE_THROW</a>(<a class="code" href="a00056.html" title="Error thrown if operations of a FieldMatrix fail.">FMatrixError</a>,<span class="stringliteral">"index out of range"</span>);
<a name="l00258"></a>00258           <span class="keywordflow">if</span> (y.N()!=<a class="code" href="a00049.html#941900e6156fe500135851254a120a36" title="number of blocks in row direction">N</a>()) <a class="code" href="a00149.html#d7fce127d6eaabe773adbc409514f21e">DUNE_THROW</a>(<a class="code" href="a00056.html" title="Error thrown if operations of a FieldMatrix fail.">FMatrixError</a>,<span class="stringliteral">"index out of range"</span>);
<a name="l00259"></a>00259 <span class="preprocessor">#endif</span>
<a name="l00260"></a>00260 <span class="preprocessor"></span>          <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> i=0; i&lt;n; i++)
<a name="l00261"></a>00261               <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> j=0; j&lt;m; j++)
<a name="l00262"></a>00262                   y[i] += (*<span class="keyword">this</span>)[i][j] * x[j];
<a name="l00263"></a>00263         }
<a name="l00264"></a>00264 
<a name="l00266"></a>00266         <span class="keyword">template</span>&lt;<span class="keyword">class</span> X, <span class="keyword">class</span> Y&gt;
<a name="l00267"></a><a class="code" href="a00049.html#e4e67e1e97f604bf9b3df4c592f4bcd6">00267</a>         <span class="keywordtype">void</span> <a class="code" href="a00049.html#e4e67e1e97f604bf9b3df4c592f4bcd6" title="y += A^T x">umtv</a> (<span class="keyword">const</span> X&amp; x, Y&amp; y)<span class="keyword"> const</span>
<a name="l00268"></a>00268 <span class="keyword">        </span>{
<a name="l00269"></a>00269 <span class="preprocessor">#ifdef DUNE_FMatrix_WITH_CHECKING</span>
<a name="l00270"></a>00270 <span class="preprocessor"></span>          <span class="keywordflow">if</span> (x.N()!=<a class="code" href="a00049.html#941900e6156fe500135851254a120a36" title="number of blocks in row direction">N</a>()) <a class="code" href="a00149.html#d7fce127d6eaabe773adbc409514f21e">DUNE_THROW</a>(<a class="code" href="a00056.html" title="Error thrown if operations of a FieldMatrix fail.">FMatrixError</a>,<span class="stringliteral">"index out of range"</span>);
<a name="l00271"></a>00271           <span class="keywordflow">if</span> (y.N()!=<a class="code" href="a00049.html#a0e0e890e1d0c3e969feb6aee8f59920" title="number of blocks in column direction">M</a>()) <a class="code" href="a00149.html#d7fce127d6eaabe773adbc409514f21e">DUNE_THROW</a>(<a class="code" href="a00056.html" title="Error thrown if operations of a FieldMatrix fail.">FMatrixError</a>,<span class="stringliteral">"index out of range"</span>);
<a name="l00272"></a>00272 <span class="preprocessor">#endif</span>
<a name="l00273"></a>00273 <span class="preprocessor"></span>          
<a name="l00274"></a>00274           <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> i=0; i&lt;n; i++)
<a name="l00275"></a>00275                   <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> j=0; j&lt;m; j++)
<a name="l00276"></a>00276                         y[j] += p[i][j]*x[i];
<a name="l00277"></a>00277         }
<a name="l00278"></a>00278 
<a name="l00280"></a>00280         <span class="keyword">template</span>&lt;<span class="keyword">class</span> X, <span class="keyword">class</span> Y&gt;
<a name="l00281"></a><a class="code" href="a00049.html#badf8447b192951a0106cd122652362e">00281</a>         <span class="keywordtype">void</span> <a class="code" href="a00049.html#badf8447b192951a0106cd122652362e" title="y += A^H x">umhv</a> (<span class="keyword">const</span> X&amp; x, Y&amp; y)<span class="keyword"> const</span>
<a name="l00282"></a>00282 <span class="keyword">        </span>{
<a name="l00283"></a>00283 <span class="preprocessor">#ifdef DUNE_FMatrix_WITH_CHECKING</span>
<a name="l00284"></a>00284 <span class="preprocessor"></span>          <span class="keywordflow">if</span> (x.N()!=<a class="code" href="a00049.html#941900e6156fe500135851254a120a36" title="number of blocks in row direction">N</a>()) <a class="code" href="a00149.html#d7fce127d6eaabe773adbc409514f21e">DUNE_THROW</a>(<a class="code" href="a00056.html" title="Error thrown if operations of a FieldMatrix fail.">FMatrixError</a>,<span class="stringliteral">"index out of range"</span>);
<a name="l00285"></a>00285           <span class="keywordflow">if</span> (y.N()!=<a class="code" href="a00049.html#a0e0e890e1d0c3e969feb6aee8f59920" title="number of blocks in column direction">M</a>()) <a class="code" href="a00149.html#d7fce127d6eaabe773adbc409514f21e">DUNE_THROW</a>(<a class="code" href="a00056.html" title="Error thrown if operations of a FieldMatrix fail.">FMatrixError</a>,<span class="stringliteral">"index out of range"</span>);
<a name="l00286"></a>00286 <span class="preprocessor">#endif</span>
<a name="l00287"></a>00287 <span class="preprocessor"></span>          
<a name="l00288"></a>00288           <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> i=0; i&lt;n; i++)
<a name="l00289"></a>00289                   <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> j=0; j&lt;m; j++)
<a name="l00290"></a>00290                         y[j] += fm_ck(p[i][j])*x[i];
<a name="l00291"></a>00291         }
<a name="l00292"></a>00292 
<a name="l00294"></a>00294         <span class="keyword">template</span>&lt;<span class="keyword">class</span> X, <span class="keyword">class</span> Y&gt;
<a name="l00295"></a><a class="code" href="a00049.html#48c472b85ff2a483150858b0198aacb0">00295</a>         <span class="keywordtype">void</span> <a class="code" href="a00049.html#48c472b85ff2a483150858b0198aacb0" title="y -= A x">mmv</a> (<span class="keyword">const</span> X&amp; x, Y&amp; y)<span class="keyword"> const</span>
<a name="l00296"></a>00296 <span class="keyword">        </span>{
<a name="l00297"></a>00297 <span class="preprocessor">#ifdef DUNE_FMatrix_WITH_CHECKING</span>
<a name="l00298"></a>00298 <span class="preprocessor"></span>          <span class="keywordflow">if</span> (x.N()!=<a class="code" href="a00049.html#a0e0e890e1d0c3e969feb6aee8f59920" title="number of blocks in column direction">M</a>()) <a class="code" href="a00149.html#d7fce127d6eaabe773adbc409514f21e">DUNE_THROW</a>(<a class="code" href="a00056.html" title="Error thrown if operations of a FieldMatrix fail.">FMatrixError</a>,<span class="stringliteral">"index out of range"</span>);
<a name="l00299"></a>00299           <span class="keywordflow">if</span> (y.N()!=<a class="code" href="a00049.html#941900e6156fe500135851254a120a36" title="number of blocks in row direction">N</a>()) <a class="code" href="a00149.html#d7fce127d6eaabe773adbc409514f21e">DUNE_THROW</a>(<a class="code" href="a00056.html" title="Error thrown if operations of a FieldMatrix fail.">FMatrixError</a>,<span class="stringliteral">"index out of range"</span>);
<a name="l00300"></a>00300 <span class="preprocessor">#endif</span>
<a name="l00301"></a>00301 <span class="preprocessor"></span>          <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> i=0; i&lt;n; i++)
<a name="l00302"></a>00302               <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> j=0; j&lt;m; j++)
<a name="l00303"></a>00303                   y[i] -= (*<span class="keyword">this</span>)[i][j] * x[j];
<a name="l00304"></a>00304         }
<a name="l00305"></a>00305 
<a name="l00307"></a>00307         <span class="keyword">template</span>&lt;<span class="keyword">class</span> X, <span class="keyword">class</span> Y&gt;
<a name="l00308"></a><a class="code" href="a00049.html#f39c8b7f29c4906d6609cce344899967">00308</a>         <span class="keywordtype">void</span> <a class="code" href="a00049.html#f39c8b7f29c4906d6609cce344899967" title="y -= A^T x">mmtv</a> (<span class="keyword">const</span> X&amp; x, Y&amp; y)<span class="keyword"> const</span>
<a name="l00309"></a>00309 <span class="keyword">        </span>{
<a name="l00310"></a>00310 <span class="preprocessor">#ifdef DUNE_FMatrix_WITH_CHECKING</span>
<a name="l00311"></a>00311 <span class="preprocessor"></span>          <span class="keywordflow">if</span> (x.N()!=<a class="code" href="a00049.html#941900e6156fe500135851254a120a36" title="number of blocks in row direction">N</a>()) <a class="code" href="a00149.html#d7fce127d6eaabe773adbc409514f21e">DUNE_THROW</a>(<a class="code" href="a00056.html" title="Error thrown if operations of a FieldMatrix fail.">FMatrixError</a>,<span class="stringliteral">"index out of range"</span>);
<a name="l00312"></a>00312           <span class="keywordflow">if</span> (y.N()!=<a class="code" href="a00049.html#a0e0e890e1d0c3e969feb6aee8f59920" title="number of blocks in column direction">M</a>()) <a class="code" href="a00149.html#d7fce127d6eaabe773adbc409514f21e">DUNE_THROW</a>(<a class="code" href="a00056.html" title="Error thrown if operations of a FieldMatrix fail.">FMatrixError</a>,<span class="stringliteral">"index out of range"</span>);
<a name="l00313"></a>00313 <span class="preprocessor">#endif</span>
<a name="l00314"></a>00314 <span class="preprocessor"></span>          
<a name="l00315"></a>00315           <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> i=0; i&lt;n; i++)
<a name="l00316"></a>00316                   <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> j=0; j&lt;m; j++)
<a name="l00317"></a>00317                         y[j] -= p[i][j]*x[i];
<a name="l00318"></a>00318         }
<a name="l00319"></a>00319 
<a name="l00321"></a>00321         <span class="keyword">template</span>&lt;<span class="keyword">class</span> X, <span class="keyword">class</span> Y&gt;
<a name="l00322"></a><a class="code" href="a00049.html#9338e26719ffdcf0fef455990f0dbf26">00322</a>         <span class="keywordtype">void</span> <a class="code" href="a00049.html#9338e26719ffdcf0fef455990f0dbf26" title="y -= A^H x">mmhv</a> (<span class="keyword">const</span> X&amp; x, Y&amp; y)<span class="keyword"> const</span>
<a name="l00323"></a>00323 <span class="keyword">        </span>{
<a name="l00324"></a>00324 <span class="preprocessor">#ifdef DUNE_FMatrix_WITH_CHECKING</span>
<a name="l00325"></a>00325 <span class="preprocessor"></span>          <span class="keywordflow">if</span> (x.N()!=<a class="code" href="a00049.html#941900e6156fe500135851254a120a36" title="number of blocks in row direction">N</a>()) <a class="code" href="a00149.html#d7fce127d6eaabe773adbc409514f21e">DUNE_THROW</a>(<a class="code" href="a00056.html" title="Error thrown if operations of a FieldMatrix fail.">FMatrixError</a>,<span class="stringliteral">"index out of range"</span>);
<a name="l00326"></a>00326           <span class="keywordflow">if</span> (y.N()!=<a class="code" href="a00049.html#a0e0e890e1d0c3e969feb6aee8f59920" title="number of blocks in column direction">M</a>()) <a class="code" href="a00149.html#d7fce127d6eaabe773adbc409514f21e">DUNE_THROW</a>(<a class="code" href="a00056.html" title="Error thrown if operations of a FieldMatrix fail.">FMatrixError</a>,<span class="stringliteral">"index out of range"</span>);
<a name="l00327"></a>00327 <span class="preprocessor">#endif</span>
<a name="l00328"></a>00328 <span class="preprocessor"></span>          
<a name="l00329"></a>00329           <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> i=0; i&lt;n; i++)
<a name="l00330"></a>00330                   <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> j=0; j&lt;m; j++)
<a name="l00331"></a>00331                         y[j] -= fm_ck(p[i][j])*x[i];
<a name="l00332"></a>00332         }
<a name="l00333"></a>00333 
<a name="l00335"></a>00335         <span class="keyword">template</span>&lt;<span class="keyword">class</span> X, <span class="keyword">class</span> Y&gt;
<a name="l00336"></a><a class="code" href="a00049.html#ce3a60b70497473477ba34bf9e687c63">00336</a>         <span class="keywordtype">void</span> <a class="code" href="a00049.html#ce3a60b70497473477ba34bf9e687c63" title="y += alpha A x">usmv</a> (<span class="keyword">const</span> K&amp; alpha, <span class="keyword">const</span> X&amp; x, Y&amp; y)<span class="keyword"> const</span>
<a name="l00337"></a>00337 <span class="keyword">        </span>{
<a name="l00338"></a>00338 <span class="preprocessor">#ifdef DUNE_FMatrix_WITH_CHECKING</span>
<a name="l00339"></a>00339 <span class="preprocessor"></span>          <span class="keywordflow">if</span> (x.N()!=<a class="code" href="a00049.html#a0e0e890e1d0c3e969feb6aee8f59920" title="number of blocks in column direction">M</a>()) <a class="code" href="a00149.html#d7fce127d6eaabe773adbc409514f21e">DUNE_THROW</a>(<a class="code" href="a00056.html" title="Error thrown if operations of a FieldMatrix fail.">FMatrixError</a>,<span class="stringliteral">"index out of range"</span>);
<a name="l00340"></a>00340           <span class="keywordflow">if</span> (y.N()!=<a class="code" href="a00049.html#941900e6156fe500135851254a120a36" title="number of blocks in row direction">N</a>()) <a class="code" href="a00149.html#d7fce127d6eaabe773adbc409514f21e">DUNE_THROW</a>(<a class="code" href="a00056.html" title="Error thrown if operations of a FieldMatrix fail.">FMatrixError</a>,<span class="stringliteral">"index out of range"</span>);
<a name="l00341"></a>00341 <span class="preprocessor">#endif</span>
<a name="l00342"></a>00342 <span class="preprocessor"></span>          <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> i=0; i&lt;n; i++)
<a name="l00343"></a>00343               <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> j=0; j&lt;m; j++)
<a name="l00344"></a>00344                   y[i] += alpha * (*<span class="keyword">this</span>)[i][j] * x[j];
<a name="l00345"></a>00345         }
<a name="l00346"></a>00346 
<a name="l00348"></a>00348         <span class="keyword">template</span>&lt;<span class="keyword">class</span> X, <span class="keyword">class</span> Y&gt;
<a name="l00349"></a><a class="code" href="a00049.html#3a0d80d941c3ce751380f6598a02b062">00349</a>         <span class="keywordtype">void</span> <a class="code" href="a00049.html#3a0d80d941c3ce751380f6598a02b062" title="y += alpha A^T x">usmtv</a> (<span class="keyword">const</span> K&amp; alpha, <span class="keyword">const</span> X&amp; x, Y&amp; y)<span class="keyword"> const</span>
<a name="l00350"></a>00350 <span class="keyword">        </span>{
<a name="l00351"></a>00351 <span class="preprocessor">#ifdef DUNE_FMatrix_WITH_CHECKING</span>
<a name="l00352"></a>00352 <span class="preprocessor"></span>          <span class="keywordflow">if</span> (x.N()!=<a class="code" href="a00049.html#941900e6156fe500135851254a120a36" title="number of blocks in row direction">N</a>()) <a class="code" href="a00149.html#d7fce127d6eaabe773adbc409514f21e">DUNE_THROW</a>(<a class="code" href="a00056.html" title="Error thrown if operations of a FieldMatrix fail.">FMatrixError</a>,<span class="stringliteral">"index out of range"</span>);
<a name="l00353"></a>00353           <span class="keywordflow">if</span> (y.N()!=<a class="code" href="a00049.html#a0e0e890e1d0c3e969feb6aee8f59920" title="number of blocks in column direction">M</a>()) <a class="code" href="a00149.html#d7fce127d6eaabe773adbc409514f21e">DUNE_THROW</a>(<a class="code" href="a00056.html" title="Error thrown if operations of a FieldMatrix fail.">FMatrixError</a>,<span class="stringliteral">"index out of range"</span>);
<a name="l00354"></a>00354 <span class="preprocessor">#endif</span>
<a name="l00355"></a>00355 <span class="preprocessor"></span>          
<a name="l00356"></a>00356           <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> i=0; i&lt;n; i++)
<a name="l00357"></a>00357                   <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> j=0; j&lt;m; j++)
<a name="l00358"></a>00358                         y[j] += alpha*p[i][j]*x[i];
<a name="l00359"></a>00359         }
<a name="l00360"></a>00360 
<a name="l00362"></a>00362         <span class="keyword">template</span>&lt;<span class="keyword">class</span> X, <span class="keyword">class</span> Y&gt;
<a name="l00363"></a><a class="code" href="a00049.html#bdb4ab12589199718b7fc277c5159dd4">00363</a>         <span class="keywordtype">void</span> <a class="code" href="a00049.html#bdb4ab12589199718b7fc277c5159dd4" title="y += alpha A^H x">usmhv</a> (<span class="keyword">const</span> K&amp; alpha, <span class="keyword">const</span> X&amp; x, Y&amp; y)<span class="keyword"> const</span>
<a name="l00364"></a>00364 <span class="keyword">        </span>{
<a name="l00365"></a>00365 <span class="preprocessor">#ifdef DUNE_FMatrix_WITH_CHECKING</span>
<a name="l00366"></a>00366 <span class="preprocessor"></span>          <span class="keywordflow">if</span> (x.N()!=<a class="code" href="a00049.html#941900e6156fe500135851254a120a36" title="number of blocks in row direction">N</a>()) <a class="code" href="a00149.html#d7fce127d6eaabe773adbc409514f21e">DUNE_THROW</a>(<a class="code" href="a00056.html" title="Error thrown if operations of a FieldMatrix fail.">FMatrixError</a>,<span class="stringliteral">"index out of range"</span>);
<a name="l00367"></a>00367           <span class="keywordflow">if</span> (y.N()!=<a class="code" href="a00049.html#a0e0e890e1d0c3e969feb6aee8f59920" title="number of blocks in column direction">M</a>()) <a class="code" href="a00149.html#d7fce127d6eaabe773adbc409514f21e">DUNE_THROW</a>(<a class="code" href="a00056.html" title="Error thrown if operations of a FieldMatrix fail.">FMatrixError</a>,<span class="stringliteral">"index out of range"</span>);
<a name="l00368"></a>00368 <span class="preprocessor">#endif</span>
<a name="l00369"></a>00369 <span class="preprocessor"></span>          
<a name="l00370"></a>00370           <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> i=0; i&lt;n; i++)
<a name="l00371"></a>00371                   <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> j=0; j&lt;m; j++)
<a name="l00372"></a>00372                         y[j] += alpha*fm_ck(p[i][j])*x[i];
<a name="l00373"></a>00373         }
<a name="l00374"></a>00374 
<a name="l00375"></a>00375         <span class="comment">//===== norms</span>
<a name="l00376"></a>00376 
<a name="l00378"></a><a class="code" href="a00049.html#eb3615e70b2e925a5fff65166afe4d66">00378</a>     <span class="keywordtype">double</span> <a class="code" href="a00049.html#eb3615e70b2e925a5fff65166afe4d66" title="frobenius norm: sqrt(sum over squared values of entries)">frobenius_norm</a> ()<span class="keyword"> const</span>
<a name="l00379"></a>00379 <span class="keyword">        </span>{
<a name="l00380"></a>00380           <span class="keywordtype">double</span> sum=0;
<a name="l00381"></a>00381           <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> i=0; i&lt;n; ++i) sum += p[i].two_norm2();
<a name="l00382"></a>00382           <span class="keywordflow">return</span> sqrt(sum);
<a name="l00383"></a>00383         }
<a name="l00384"></a>00384 
<a name="l00386"></a><a class="code" href="a00049.html#f96cb7bf71509ecfeec9253f947ec4d4">00386</a>     <span class="keywordtype">double</span> <a class="code" href="a00049.html#f96cb7bf71509ecfeec9253f947ec4d4" title="square of frobenius norm, need for block recursion">frobenius_norm2</a> ()<span class="keyword"> const</span>
<a name="l00387"></a>00387 <span class="keyword">        </span>{
<a name="l00388"></a>00388           <span class="keywordtype">double</span> sum=0;
<a name="l00389"></a>00389           <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> i=0; i&lt;n; ++i) sum += p[i].two_norm2();
<a name="l00390"></a>00390           <span class="keywordflow">return</span> sum;
<a name="l00391"></a>00391         }
<a name="l00392"></a>00392 
<a name="l00394"></a><a class="code" href="a00049.html#6aba1dbce59b3ddcc0868d4c85d8e239">00394</a>     <span class="keywordtype">double</span> <a class="code" href="a00049.html#6aba1dbce59b3ddcc0868d4c85d8e239" title="infinity norm (row sum norm, how to generalize for blocks?)">infinity_norm</a> ()<span class="keyword"> const</span>
<a name="l00395"></a>00395 <span class="keyword">        </span>{
<a name="l00396"></a>00396           <span class="keywordtype">double</span> max=0;
<a name="l00397"></a>00397           <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> i=0; i&lt;n; ++i) max = std::max(max,p[i].one_norm());
<a name="l00398"></a>00398           <span class="keywordflow">return</span> max;
<a name="l00399"></a>00399         }
<a name="l00400"></a>00400 
<a name="l00402"></a><a class="code" href="a00049.html#fd5a8db651a110e03131ce44beac5c44">00402</a>         <span class="keywordtype">double</span> <a class="code" href="a00049.html#fd5a8db651a110e03131ce44beac5c44" title="simplified infinity norm (uses Manhattan norm for complex values)">infinity_norm_real</a> ()<span class="keyword"> const</span>
<a name="l00403"></a>00403 <span class="keyword">        </span>{
<a name="l00404"></a>00404           <span class="keywordtype">double</span> max=0;
<a name="l00405"></a>00405           <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> i=0; i&lt;n; ++i) max = std::max(max,p[i].one_norm_real());
<a name="l00406"></a>00406           <span class="keywordflow">return</span> max;
<a name="l00407"></a>00407         }
<a name="l00408"></a>00408 
<a name="l00409"></a>00409         <span class="comment">//===== solve</span>
<a name="l00410"></a>00410 
<a name="l00415"></a>00415         <span class="keyword">template</span>&lt;<span class="keyword">class</span> V&gt;
<a name="l00416"></a>00416         <span class="keywordtype">void</span> <a class="code" href="a00196.html#ge2481be02c7113bdbfe0e0cae8958e16" title="Solve system A x = b.">solve</a> (V&amp; x, <span class="keyword">const</span> V&amp; b) <span class="keyword">const</span>;
<a name="l00417"></a>00417 
<a name="l00422"></a>00422       <span class="keywordtype">void</span> <a class="code" href="a00196.html#gc8853f30836b392861a22fe17ff88896" title="Compute inverse.">invert</a>();
<a name="l00423"></a>00423 
<a name="l00425"></a>00425       K <a class="code" href="a00196.html#g57d6ac617a0520301a2b284d02596c95" title="calculates the determinant of this matrix">determinant</a> () <span class="keyword">const</span>;
<a name="l00426"></a>00426 
<a name="l00428"></a><a class="code" href="a00049.html#a3c9dd1a03bcfeec4f303f6b0edb7538">00428</a>         <a class="code" href="a00049.html" title="A dense n x m matrix.">FieldMatrix</a>&amp; <a class="code" href="a00049.html#a3c9dd1a03bcfeec4f303f6b0edb7538" title="Multiplies M from the left to this matrix.">leftmultiply</a> (<span class="keyword">const</span> <a class="code" href="a00049.html" title="A dense n x m matrix.">FieldMatrix&lt;K,n,n&gt;</a>&amp; <a class="code" href="a00049.html#a0e0e890e1d0c3e969feb6aee8f59920" title="number of blocks in column direction">M</a>)
<a name="l00429"></a>00429         {
<a name="l00430"></a>00430             <a class="code" href="a00049.html" title="A dense n x m matrix.">FieldMatrix&lt;K,n,m&gt;</a> C(*<span class="keyword">this</span>);
<a name="l00431"></a>00431             
<a name="l00432"></a>00432             <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> i=0; i&lt;n; i++)
<a name="l00433"></a>00433                 <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> j=0; j&lt;m; j++) {
<a name="l00434"></a>00434                     (*this)[i][j] = 0;
<a name="l00435"></a>00435                     <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> k=0; k&lt;n; k++)
<a name="l00436"></a>00436                         (*<span class="keyword">this</span>)[i][j] += M[i][k]*C[k][j];
<a name="l00437"></a>00437                 }
<a name="l00438"></a>00438 
<a name="l00439"></a>00439           <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00440"></a>00440         }
<a name="l00441"></a>00441 
<a name="l00443"></a><a class="code" href="a00049.html#3447bb52706dd385391f238df4c20a49">00443</a>         <a class="code" href="a00049.html" title="A dense n x m matrix.">FieldMatrix</a>&amp; <a class="code" href="a00049.html#3447bb52706dd385391f238df4c20a49" title="Multiplies M from the right to this matrix.">rightmultiply</a> (<span class="keyword">const</span> <a class="code" href="a00049.html" title="A dense n x m matrix.">FieldMatrix&lt;K,m,m&gt;</a>&amp; <a class="code" href="a00049.html#a0e0e890e1d0c3e969feb6aee8f59920" title="number of blocks in column direction">M</a>)
<a name="l00444"></a>00444         {
<a name="l00445"></a>00445             <a class="code" href="a00049.html" title="A dense n x m matrix.">FieldMatrix&lt;K,n,m&gt;</a> C(*<span class="keyword">this</span>);
<a name="l00446"></a>00446 
<a name="l00447"></a>00447             <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> i=0; i&lt;n; i++)
<a name="l00448"></a>00448                 <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> j=0; j&lt;m; j++) {
<a name="l00449"></a>00449                     (*this)[i][j] = 0;
<a name="l00450"></a>00450                     <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> k=0; k&lt;m; k++)
<a name="l00451"></a>00451                         (*<span class="keyword">this</span>)[i][j] += C[i][k]*M[k][j];
<a name="l00452"></a>00452                 }
<a name="l00453"></a>00453             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00454"></a>00454         }
<a name="l00455"></a>00455 
<a name="l00456"></a>00456 
<a name="l00457"></a>00457         <span class="comment">//===== sizes</span>
<a name="l00458"></a>00458 
<a name="l00460"></a><a class="code" href="a00049.html#941900e6156fe500135851254a120a36">00460</a>         <a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> <a class="code" href="a00049.html#941900e6156fe500135851254a120a36" title="number of blocks in row direction">N</a> ()<span class="keyword"> const</span>
<a name="l00461"></a>00461 <span class="keyword">        </span>{
<a name="l00462"></a>00462           <span class="keywordflow">return</span> n;
<a name="l00463"></a>00463         }
<a name="l00464"></a>00464 
<a name="l00466"></a><a class="code" href="a00049.html#a0e0e890e1d0c3e969feb6aee8f59920">00466</a>         <a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> <a class="code" href="a00049.html#a0e0e890e1d0c3e969feb6aee8f59920" title="number of blocks in column direction">M</a> ()<span class="keyword"> const</span>
<a name="l00467"></a>00467 <span class="keyword">        </span>{
<a name="l00468"></a>00468           <span class="keywordflow">return</span> m;
<a name="l00469"></a>00469         }
<a name="l00470"></a>00470 
<a name="l00472"></a><a class="code" href="a00049.html#76e5a7418471de94d322455fe19c8956">00472</a>         <a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> <a class="code" href="a00049.html#6bb1547b901c30dc0e879e8a1793fc0c" title="dimension of the destination vector space">rowdim</a> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> r)<span class="keyword"> const</span>
<a name="l00473"></a>00473 <span class="keyword">        </span>{
<a name="l00474"></a>00474           <span class="keywordflow">return</span> 1;
<a name="l00475"></a>00475         }
<a name="l00476"></a>00476 
<a name="l00478"></a><a class="code" href="a00049.html#a88209ff18890c5e9d630cb04ef87953">00478</a>         <a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> <a class="code" href="a00049.html#964d86febe4b06f485917811ebc427c4" title="dimension of the source vector space">coldim</a> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> c)<span class="keyword"> const</span>
<a name="l00479"></a>00479 <span class="keyword">        </span>{
<a name="l00480"></a>00480           <span class="keywordflow">return</span> 1;
<a name="l00481"></a>00481         }
<a name="l00482"></a>00482 
<a name="l00484"></a><a class="code" href="a00049.html#6bb1547b901c30dc0e879e8a1793fc0c">00484</a>         <a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> <a class="code" href="a00049.html#6bb1547b901c30dc0e879e8a1793fc0c" title="dimension of the destination vector space">rowdim</a> ()<span class="keyword"> const</span>
<a name="l00485"></a>00485 <span class="keyword">        </span>{
<a name="l00486"></a>00486           <span class="keywordflow">return</span> n;
<a name="l00487"></a>00487         }
<a name="l00488"></a>00488 
<a name="l00490"></a><a class="code" href="a00049.html#964d86febe4b06f485917811ebc427c4">00490</a>         <a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> <a class="code" href="a00049.html#964d86febe4b06f485917811ebc427c4" title="dimension of the source vector space">coldim</a> ()<span class="keyword"> const</span>
<a name="l00491"></a>00491 <span class="keyword">        </span>{
<a name="l00492"></a>00492           <span class="keywordflow">return</span> m;
<a name="l00493"></a>00493         }
<a name="l00494"></a>00494 
<a name="l00495"></a>00495         <span class="comment">//===== query</span>
<a name="l00496"></a>00496         
<a name="l00498"></a><a class="code" href="a00049.html#ce8327b8f523b95598f07e1720cd0da4">00498</a>         <span class="keywordtype">bool</span> <a class="code" href="a00049.html#ce8327b8f523b95598f07e1720cd0da4" title="return true when (i,j) is in pattern">exists</a> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> i, <a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> j)<span class="keyword"> const</span>
<a name="l00499"></a>00499 <span class="keyword">        </span>{
<a name="l00500"></a>00500 <span class="preprocessor">#ifdef DUNE_FMatrix_WITH_CHECKING</span>
<a name="l00501"></a>00501 <span class="preprocessor"></span>          <span class="keywordflow">if</span> (i&lt;0 || i&gt;=n) <a class="code" href="a00149.html#d7fce127d6eaabe773adbc409514f21e">DUNE_THROW</a>(<a class="code" href="a00056.html" title="Error thrown if operations of a FieldMatrix fail.">FMatrixError</a>,<span class="stringliteral">"row index out of range"</span>);
<a name="l00502"></a>00502           <span class="keywordflow">if</span> (j&lt;0 || j&gt;=m) <a class="code" href="a00149.html#d7fce127d6eaabe773adbc409514f21e">DUNE_THROW</a>(<a class="code" href="a00056.html" title="Error thrown if operations of a FieldMatrix fail.">FMatrixError</a>,<span class="stringliteral">"column index out of range"</span>);
<a name="l00503"></a>00503 <span class="preprocessor">#endif</span>
<a name="l00504"></a>00504 <span class="preprocessor"></span>          <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00505"></a>00505         }
<a name="l00506"></a>00506 
<a name="l00507"></a>00507         <span class="comment">//===== conversion operator</span>
<a name="l00508"></a>00508 
<a name="l00510"></a><a class="code" href="a00049.html#bbac90a15b07e58520ccf8dcbf1b8a2f">00510</a>       <span class="keyword">friend</span> std::ostream&amp; operator&lt;&lt; (std::ostream&amp; s, const FieldMatrix&lt;K,n,m&gt;&amp; a)
<a name="l00511"></a>00511       {
<a name="l00512"></a>00512           <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> i=0; i&lt;n; i++)
<a name="l00513"></a>00513               s &lt;&lt; a.p[i] &lt;&lt; std::endl;
<a name="l00514"></a>00514           <span class="keywordflow">return</span> s;
<a name="l00515"></a>00515       }
<a name="l00516"></a>00516 
<a name="l00517"></a>00517   <span class="keyword">private</span>:
<a name="l00518"></a>00518         <span class="comment">// the data, very simply a built in array with row-wise ordering</span>
<a name="l00519"></a>00519         <a class="code" href="a00049.html#f47453a03570ee649a70eacadec9c72b" title="Each row is implemented by a field vector.">row_type</a> p[(n &gt; 0) ? n : 1]; 
<a name="l00520"></a>00520 
<a name="l00521"></a>00521     <span class="keyword">struct </span>ElimPivot
<a name="l00522"></a>00522     {
<a name="l00523"></a>00523       ElimPivot(<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> pivot[n]);
<a name="l00524"></a>00524       
<a name="l00525"></a>00525       <span class="keywordtype">void</span> swap(<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j);
<a name="l00526"></a>00526       
<a name="l00527"></a>00527       <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00528"></a>00528       <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> T&amp;, <span class="keywordtype">int</span> k, <span class="keywordtype">int</span> i)
<a name="l00529"></a>00529       {}
<a name="l00530"></a>00530       
<a name="l00531"></a>00531       <a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a>* pivot_;
<a name="l00532"></a>00532     };
<a name="l00533"></a>00533 
<a name="l00534"></a>00534     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> V&gt;
<a name="l00535"></a>00535     <span class="keyword">struct </span>Elim
<a name="l00536"></a>00536     {
<a name="l00537"></a>00537       Elim(V&amp; rhs);
<a name="l00538"></a>00538       
<a name="l00539"></a>00539       <span class="keywordtype">void</span> swap(<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j);
<a name="l00540"></a>00540       
<a name="l00541"></a>00541       <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <span class="keyword">typename</span> V::field_type&amp; factor, <span class="keywordtype">int</span> k, <span class="keywordtype">int</span> i);
<a name="l00542"></a>00542 
<a name="l00543"></a>00543       V* rhs_;
<a name="l00544"></a>00544     };
<a name="l00545"></a>00545     
<a name="l00546"></a>00546     <span class="keyword">template</span>&lt;<span class="keyword">class</span> Func&gt;
<a name="l00547"></a>00547     <span class="keywordtype">void</span> luDecomposition(FieldMatrix&lt;K,n,n&gt;&amp; A, Func func) <span class="keyword">const</span>;
<a name="l00548"></a>00548   };
<a name="l00549"></a>00549 
<a name="l00550"></a>00550   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keywordtype">int</span> n, <span class="keywordtype">int</span> m&gt;
<a name="l00551"></a>00551   FieldMatrix&lt;K,n,m&gt;::ElimPivot::ElimPivot(size_type pivot[n])
<a name="l00552"></a>00552     : pivot_(pivot)
<a name="l00553"></a>00553   {
<a name="l00554"></a>00554     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i &lt; n; ++i) pivot[i]=i;
<a name="l00555"></a>00555   }
<a name="l00556"></a>00556 
<a name="l00557"></a>00557   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keywordtype">int</span> n, <span class="keywordtype">int</span> m&gt;
<a name="l00558"></a>00558   <span class="keywordtype">void</span> FieldMatrix&lt;K,n,m&gt;::ElimPivot::swap(<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j)
<a name="l00559"></a>00559   {
<a name="l00560"></a>00560     pivot_[i]=j;
<a name="l00561"></a>00561   }
<a name="l00562"></a>00562   
<a name="l00563"></a>00563   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keywordtype">int</span> n, <span class="keywordtype">int</span> m&gt;
<a name="l00564"></a>00564   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> V&gt;
<a name="l00565"></a>00565   FieldMatrix&lt;K,n,m&gt;::Elim&lt;V&gt;::Elim(V&amp; rhs)
<a name="l00566"></a>00566     : rhs_(&amp;rhs)
<a name="l00567"></a>00567   {}
<a name="l00568"></a>00568   
<a name="l00569"></a>00569    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keywordtype">int</span> n, <span class="keywordtype">int</span> m&gt;
<a name="l00570"></a>00570    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> V&gt;
<a name="l00571"></a>00571    <span class="keywordtype">void</span> FieldMatrix&lt;K,n,m&gt;::Elim&lt;V&gt;::swap(<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j)
<a name="l00572"></a>00572    {
<a name="l00573"></a>00573      std::swap((*rhs_)[i], (*rhs_)[j]);
<a name="l00574"></a>00574    }
<a name="l00575"></a>00575 
<a name="l00576"></a>00576   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keywordtype">int</span> n, <span class="keywordtype">int</span> m&gt;
<a name="l00577"></a>00577   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> V&gt;
<a name="l00578"></a>00578   <span class="keywordtype">void</span> FieldMatrix&lt;K,n,m&gt;::
<a name="l00579"></a>00579   Elim&lt;V&gt;::operator()(<span class="keyword">const</span> <span class="keyword">typename</span> V::field_type&amp; factor, <span class="keywordtype">int</span> k, <span class="keywordtype">int</span> i)
<a name="l00580"></a>00580   {
<a name="l00581"></a>00581     (*rhs_)[k] -= factor*(*rhs_)[i];
<a name="l00582"></a>00582   }
<a name="l00583"></a>00583   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keywordtype">int</span> n, <span class="keywordtype">int</span> m&gt;
<a name="l00584"></a>00584   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func&gt;
<a name="l00585"></a>00585   <span class="keyword">inline</span> <span class="keywordtype">void</span> FieldMatrix&lt;K,n,m&gt;::luDecomposition(FieldMatrix&lt;K,n,n&gt;&amp; A, Func func)<span class="keyword"> const</span>
<a name="l00586"></a>00586 <span class="keyword">  </span>{
<a name="l00587"></a>00587     <span class="keywordtype">double</span> norm=A.infinity_norm_real(); <span class="comment">// for relative thresholds</span>
<a name="l00588"></a>00588     <span class="keywordtype">double</span> pivthres = std::max(FMatrixPrecision&lt;&gt;::absolute_limit(),norm*FMatrixPrecision&lt;&gt;::pivoting_limit());
<a name="l00589"></a>00589     <span class="keywordtype">double</span> singthres = std::max(FMatrixPrecision&lt;&gt;::absolute_limit(),norm*FMatrixPrecision&lt;&gt;::singular_limit());
<a name="l00590"></a>00590   
<a name="l00591"></a>00591     <span class="comment">// LU decomposition of A in A</span>
<a name="l00592"></a>00592     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;n; i++)  <span class="comment">// loop over all rows</span>
<a name="l00593"></a>00593       {
<a name="l00594"></a>00594         <span class="keywordtype">double</span> pivmax=fvmeta_absreal(A[i][i]);
<a name="l00595"></a>00595       
<a name="l00596"></a>00596         <span class="comment">// pivoting ?</span>
<a name="l00597"></a>00597         <span class="keywordflow">if</span> (pivmax&lt;pivthres)
<a name="l00598"></a>00598           {
<a name="l00599"></a>00599             <span class="comment">// compute maximum of column</span>
<a name="l00600"></a>00600             <span class="keywordtype">int</span> imax=i; <span class="keywordtype">double</span> abs;
<a name="l00601"></a>00601             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=i+1; k&lt;n; k++)
<a name="l00602"></a>00602               <span class="keywordflow">if</span> ((abs=fvmeta_absreal(A[k][i]))&gt;pivmax)
<a name="l00603"></a>00603                 {
<a name="l00604"></a>00604                   pivmax = abs; imax = k;
<a name="l00605"></a>00605                 }
<a name="l00606"></a>00606             <span class="comment">// swap rows</span>
<a name="l00607"></a>00607             <span class="keywordflow">if</span> (imax!=i){
<a name="l00608"></a>00608               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;n; j++)
<a name="l00609"></a>00609                 std::swap(A[i][j],A[imax][j]);
<a name="l00610"></a>00610               func.swap(i, imax); <span class="comment">// swap the pivot or rhs</span>
<a name="l00611"></a>00611             }
<a name="l00612"></a>00612           }
<a name="l00613"></a>00613         
<a name="l00614"></a>00614         <span class="comment">// singular ?</span>
<a name="l00615"></a>00615         <span class="keywordflow">if</span> (pivmax&lt;singthres)
<a name="l00616"></a>00616           <a class="code" href="a00149.html#d7fce127d6eaabe773adbc409514f21e">DUNE_THROW</a>(FMatrixError,<span class="stringliteral">"matrix is singular"</span>);                  
<a name="l00617"></a>00617         
<a name="l00618"></a>00618         <span class="comment">// eliminate</span>
<a name="l00619"></a>00619         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=i+1; k&lt;n; k++)
<a name="l00620"></a>00620           {
<a name="l00621"></a>00621             K factor = A[k][i]/A[i][i];
<a name="l00622"></a>00622             A[k][i] = factor;
<a name="l00623"></a>00623             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=i+1; j&lt;n; j++)
<a name="l00624"></a>00624               A[k][j] -= factor*A[i][j];
<a name="l00625"></a>00625             func(factor, k, i);
<a name="l00626"></a>00626           }
<a name="l00627"></a>00627       }
<a name="l00628"></a>00628   }
<a name="l00629"></a>00629 
<a name="l00630"></a>00630     <span class="keyword">template</span> &lt;<span class="keyword">class</span> K, <span class="keywordtype">int</span> n, <span class="keywordtype">int</span> m&gt;
<a name="l00631"></a>00631     <span class="keyword">template</span> &lt;<span class="keyword">class</span> V&gt;
<a name="l00632"></a><a class="code" href="a00196.html#ge2481be02c7113bdbfe0e0cae8958e16">00632</a>     <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="a00049.html" title="A dense n x m matrix.">FieldMatrix&lt;K,n,m&gt;::solve</a>(V&amp; x, <span class="keyword">const</span> V&amp; b)<span class="keyword"> const</span>
<a name="l00633"></a>00633 <span class="keyword">    </span>{
<a name="l00634"></a>00634         <span class="comment">// never mind those ifs, because they get optimized away</span>
<a name="l00635"></a>00635         <span class="keywordflow">if</span> (n!=m)
<a name="l00636"></a>00636             <a class="code" href="a00149.html#d7fce127d6eaabe773adbc409514f21e">DUNE_THROW</a>(<a class="code" href="a00056.html" title="Error thrown if operations of a FieldMatrix fail.">FMatrixError</a>, <span class="stringliteral">"Can't solve for a "</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">"x"</span> &lt;&lt; m &lt;&lt; <span class="stringliteral">" matrix!"</span>);
<a name="l00637"></a>00637 
<a name="l00638"></a>00638         <span class="comment">// no need to implement the case 1x1, because the whole matrix class is</span>
<a name="l00639"></a>00639         <span class="comment">// specialized for this</span>
<a name="l00640"></a>00640         
<a name="l00641"></a>00641         <span class="keywordflow">if</span> (n==2) {
<a name="l00642"></a>00642             
<a name="l00643"></a>00643 <span class="preprocessor">#ifdef DUNE_FMatrix_WITH_CHECKING</span>
<a name="l00644"></a>00644 <span class="preprocessor"></span>            K detinv = p[0][0]*p[1][1]-p[0][1]*p[1][0];
<a name="l00645"></a>00645             <span class="keywordflow">if</span> (fvmeta_absreal(detinv)&lt;<a class="code" href="a00057.html" title="Precisions for calculations with FieldMatrix and FieldVector.">FMatrixPrecision&lt;&gt;::absolute_limit</a>())
<a name="l00646"></a>00646                 <a class="code" href="a00149.html#d7fce127d6eaabe773adbc409514f21e">DUNE_THROW</a>(<a class="code" href="a00056.html" title="Error thrown if operations of a FieldMatrix fail.">FMatrixError</a>,<span class="stringliteral">"matrix is singular"</span>);
<a name="l00647"></a>00647             detinv = 1/detinv;
<a name="l00648"></a>00648 <span class="preprocessor">#else</span>
<a name="l00649"></a>00649 <span class="preprocessor"></span>            K detinv = 1.0/(p[0][0]*p[1][1]-p[0][1]*p[1][0]);
<a name="l00650"></a>00650 <span class="preprocessor">#endif</span>
<a name="l00651"></a>00651 <span class="preprocessor"></span>            
<a name="l00652"></a>00652             x[0] = detinv*(p[1][1]*b[0]-p[0][1]*b[1]);
<a name="l00653"></a>00653             x[1] = detinv*(p[0][0]*b[1]-p[1][0]*b[0]);
<a name="l00654"></a>00654 
<a name="l00655"></a>00655         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (n==3) {
<a name="l00656"></a>00656 
<a name="l00657"></a>00657             K d = <a class="code" href="a00196.html#g57d6ac617a0520301a2b284d02596c95" title="calculates the determinant of this matrix">determinant</a>();
<a name="l00658"></a>00658 <span class="preprocessor">#ifdef DUNE_FMatrix_WITH_CHECKING</span>
<a name="l00659"></a>00659 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (fvmeta_absreal(d)&lt;<a class="code" href="a00057.html" title="Precisions for calculations with FieldMatrix and FieldVector.">FMatrixPrecision&lt;&gt;::absolute_limit</a>())
<a name="l00660"></a>00660                 <a class="code" href="a00149.html#d7fce127d6eaabe773adbc409514f21e">DUNE_THROW</a>(<a class="code" href="a00056.html" title="Error thrown if operations of a FieldMatrix fail.">FMatrixError</a>,<span class="stringliteral">"matrix is singular"</span>);
<a name="l00661"></a>00661 <span class="preprocessor">#endif</span>
<a name="l00662"></a>00662 <span class="preprocessor"></span>
<a name="l00663"></a>00663             x[0] = (b[0]*p[1][1]*p[2][2] - b[0]*p[2][1]*p[1][2]
<a name="l00664"></a>00664                     - b[1] *p[0][1]*p[2][2] + b[1]*p[2][1]*p[0][2]
<a name="l00665"></a>00665                     + b[2] *p[0][1]*p[1][2] - b[2]*p[1][1]*p[0][2]) / d;
<a name="l00666"></a>00666 
<a name="l00667"></a>00667             x[1] = (p[0][0]*b[1]*p[2][2] - p[0][0]*b[2]*p[1][2]
<a name="l00668"></a>00668                     - p[1][0] *b[0]*p[2][2] + p[1][0]*b[2]*p[0][2]
<a name="l00669"></a>00669                     + p[2][0] *b[0]*p[1][2] - p[2][0]*b[1]*p[0][2]) / d;
<a name="l00670"></a>00670 
<a name="l00671"></a>00671             x[2] = (p[0][0]*p[1][1]*b[2] - p[0][0]*p[2][1]*b[1]
<a name="l00672"></a>00672                     - p[1][0] *p[0][1]*b[2] + p[1][0]*p[2][1]*b[0]
<a name="l00673"></a>00673                     + p[2][0] *p[0][1]*b[1] - p[2][0]*p[1][1]*b[0]) / d;
<a name="l00674"></a>00674 
<a name="l00675"></a>00675         } <span class="keywordflow">else</span> {
<a name="l00676"></a>00676 
<a name="l00677"></a>00677           V&amp; rhs = x; <span class="comment">// use x to store rhs</span>
<a name="l00678"></a>00678           rhs = b; <span class="comment">// copy data</span>
<a name="l00679"></a>00679           Elim&lt;V&gt; elim(rhs);
<a name="l00680"></a>00680           <a class="code" href="a00049.html" title="A dense n x m matrix.">FieldMatrix&lt;K,n,n&gt;</a> A(*<span class="keyword">this</span>);
<a name="l00681"></a>00681           
<a name="l00682"></a>00682           luDecomposition(A, elim);
<a name="l00683"></a>00683           
<a name="l00684"></a>00684           <span class="comment">// backsolve</span>
<a name="l00685"></a>00685           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=n-1; i&gt;=0; i--){
<a name="l00686"></a>00686             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=i+1; j&lt;n; j++)
<a name="l00687"></a>00687               rhs[i] -= A[i][j]*x[j];
<a name="l00688"></a>00688             x[i] = rhs[i]/A[i][i];
<a name="l00689"></a>00689           }
<a name="l00690"></a>00690         }       
<a name="l00691"></a>00691     }
<a name="l00692"></a>00692 
<a name="l00693"></a>00693     <span class="keyword">template</span> &lt;<span class="keyword">class</span> K, <span class="keywordtype">int</span> n, <span class="keywordtype">int</span> m&gt;
<a name="l00694"></a><a class="code" href="a00196.html#gc8853f30836b392861a22fe17ff88896">00694</a>     <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="a00049.html" title="A dense n x m matrix.">FieldMatrix&lt;K,n,m&gt;::invert</a>()
<a name="l00695"></a>00695     {
<a name="l00696"></a>00696         <span class="comment">// never mind those ifs, because they get optimized away</span>
<a name="l00697"></a>00697         <span class="keywordflow">if</span> (n!=m)
<a name="l00698"></a>00698             <a class="code" href="a00149.html#d7fce127d6eaabe773adbc409514f21e">DUNE_THROW</a>(<a class="code" href="a00056.html" title="Error thrown if operations of a FieldMatrix fail.">FMatrixError</a>, <span class="stringliteral">"Can't invert a "</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">"x"</span> &lt;&lt; m &lt;&lt; <span class="stringliteral">" matrix!"</span>);
<a name="l00699"></a>00699 
<a name="l00700"></a>00700         <span class="comment">// no need to implement the case 1x1, because the whole matrix class is</span>
<a name="l00701"></a>00701         <span class="comment">// specialized for this</span>
<a name="l00702"></a>00702 
<a name="l00703"></a>00703         <span class="keywordflow">if</span> (n==2) {
<a name="l00704"></a>00704 
<a name="l00705"></a>00705             K detinv = p[0][0]*p[1][1]-p[0][1]*p[1][0];
<a name="l00706"></a>00706 <span class="preprocessor">#ifdef DUNE_FMatrix_WITH_CHECKING</span>
<a name="l00707"></a>00707 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (fvmeta_absreal(detinv)&lt;<a class="code" href="a00057.html" title="Precisions for calculations with FieldMatrix and FieldVector.">FMatrixPrecision&lt;&gt;::absolute_limit</a>())
<a name="l00708"></a>00708                 <a class="code" href="a00149.html#d7fce127d6eaabe773adbc409514f21e">DUNE_THROW</a>(<a class="code" href="a00056.html" title="Error thrown if operations of a FieldMatrix fail.">FMatrixError</a>,<span class="stringliteral">"matrix is singular"</span>);            
<a name="l00709"></a>00709 <span class="preprocessor">#endif</span>
<a name="l00710"></a>00710 <span class="preprocessor"></span>            detinv = 1/detinv;
<a name="l00711"></a>00711 
<a name="l00712"></a>00712             K temp=p[0][0];
<a name="l00713"></a>00713             p[0][0] =  p[1][1]*detinv;
<a name="l00714"></a>00714             p[0][1] = -p[0][1]*detinv;
<a name="l00715"></a>00715             p[1][0] = -p[1][0]*detinv;
<a name="l00716"></a>00716             p[1][1] =  temp*detinv;
<a name="l00717"></a>00717 
<a name="l00718"></a>00718         } <span class="keywordflow">else</span> {
<a name="l00719"></a>00719 
<a name="l00720"></a>00720             <a class="code" href="a00049.html" title="A dense n x m matrix.">FieldMatrix&lt;K,n,n&gt;</a> A(*<span class="keyword">this</span>);
<a name="l00721"></a>00721             <a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> pivot[n];
<a name="l00722"></a>00722             luDecomposition(A, ElimPivot(pivot));
<a name="l00723"></a>00723             <a class="code" href="a00049.html" title="A dense n x m matrix.">FieldMatrix&lt;K,n,m&gt;</a>&amp; L=A;
<a name="l00724"></a>00724             <a class="code" href="a00049.html" title="A dense n x m matrix.">FieldMatrix&lt;K,n,m&gt;</a>&amp; U=A;
<a name="l00725"></a>00725             
<a name="l00726"></a>00726             <span class="comment">// initialize inverse</span>
<a name="l00727"></a>00727             *<span class="keyword">this</span>=0;
<a name="l00728"></a>00728             
<a name="l00729"></a>00729             <span class="keywordflow">for</span>(<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> i=0; i&lt;n; ++i)
<a name="l00730"></a>00730               p[i][i]=1;
<a name="l00731"></a>00731             
<a name="l00732"></a>00732             <span class="comment">// L Y = I; multiple right hand sides</span>
<a name="l00733"></a>00733             <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> i=0; i&lt;n; i++){
<a name="l00734"></a>00734               <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> j=0; j&lt;i; j++)
<a name="l00735"></a>00735                 <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> k=0; k&lt;n; k++)
<a name="l00736"></a>00736                   p[i][k] -= L[i][j]*p[j][k];
<a name="l00737"></a>00737             }
<a name="l00738"></a>00738   
<a name="l00739"></a>00739             <span class="comment">// U A^{-1} = Y</span>
<a name="l00740"></a>00740             <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> i=n; i&gt;0;){
<a name="l00741"></a>00741               --i;
<a name="l00742"></a>00742               <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> k=0; k&lt;n; k++){
<a name="l00743"></a>00743                 <span class="keywordflow">for</span> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> j=i+1; j&lt;n; j++)
<a name="l00744"></a>00744                   p[i][k] -= U[i][j]*p[j][k];
<a name="l00745"></a>00745                 p[i][k] /= U[i][i];
<a name="l00746"></a>00746               }
<a name="l00747"></a>00747             }
<a name="l00748"></a>00748 
<a name="l00749"></a>00749             <span class="keywordflow">for</span>(<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> i=n; i&gt;0; ){
<a name="l00750"></a>00750               --i;
<a name="l00751"></a>00751               <span class="keywordflow">if</span>(i!=pivot[i])
<a name="l00752"></a>00752                 <span class="keywordflow">for</span>(<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> j=0; j&lt;n; ++j)
<a name="l00753"></a>00753                   std::swap(p[j][pivot[i]], p[j][i]);
<a name="l00754"></a>00754             }
<a name="l00755"></a>00755         }
<a name="l00756"></a>00756     }
<a name="l00757"></a>00757 
<a name="l00758"></a>00758     <span class="comment">// implementation of the determinant </span>
<a name="l00759"></a>00759     <span class="keyword">template</span> &lt;<span class="keyword">class</span> K, <span class="keywordtype">int</span> n, <span class="keywordtype">int</span> m&gt;
<a name="l00760"></a><a class="code" href="a00196.html#g57d6ac617a0520301a2b284d02596c95">00760</a>     <span class="keyword">inline</span> K <a class="code" href="a00049.html" title="A dense n x m matrix.">FieldMatrix&lt;K,n,m&gt;::determinant</a>()<span class="keyword"> const</span>
<a name="l00761"></a>00761 <span class="keyword">    </span>{
<a name="l00762"></a>00762         <span class="comment">// never mind those ifs, because they get optimized away</span>
<a name="l00763"></a>00763         <span class="keywordflow">if</span> (n!=m)
<a name="l00764"></a>00764             <a class="code" href="a00149.html#d7fce127d6eaabe773adbc409514f21e">DUNE_THROW</a>(<a class="code" href="a00056.html" title="Error thrown if operations of a FieldMatrix fail.">FMatrixError</a>, <span class="stringliteral">"There is no determinant for a "</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">"x"</span> &lt;&lt; m &lt;&lt; <span class="stringliteral">" matrix!"</span>);
<a name="l00765"></a>00765 
<a name="l00766"></a>00766         <span class="comment">// no need to implement the case 1x1, because the whole matrix class is</span>
<a name="l00767"></a>00767         <span class="comment">// specialized for this</span>
<a name="l00768"></a>00768 
<a name="l00769"></a>00769         <span class="keywordflow">if</span> (n==2)
<a name="l00770"></a>00770             <span class="keywordflow">return</span> p[0][0]*p[1][1] - p[0][1]*p[1][0]; 
<a name="l00771"></a>00771 
<a name="l00772"></a>00772         <span class="keywordflow">if</span> (n==3) {
<a name="l00773"></a>00773              <span class="comment">// code generated by maple </span>
<a name="l00774"></a>00774             K t4  = p[0][0] * p[1][1];
<a name="l00775"></a>00775             K t6  = p[0][0] * p[1][2];
<a name="l00776"></a>00776             K t8  = p[0][1] * p[1][0];
<a name="l00777"></a>00777             K t10 = p[0][2] * p[1][0];
<a name="l00778"></a>00778             K t12 = p[0][1] * p[2][0];
<a name="l00779"></a>00779             K t14 = p[0][2] * p[2][0];
<a name="l00780"></a>00780         
<a name="l00781"></a>00781             <span class="keywordflow">return</span> (t4*p[2][2]-t6*p[2][1]-t8*p[2][2]+
<a name="l00782"></a>00782                     t10*p[2][1]+t12*p[1][2]-t14*p[1][1]);
<a name="l00783"></a>00783 
<a name="l00784"></a>00784         }
<a name="l00785"></a>00785         
<a name="l00786"></a>00786         <a class="code" href="a00149.html#d7fce127d6eaabe773adbc409514f21e">DUNE_THROW</a>(<a class="code" href="a00056.html" title="Error thrown if operations of a FieldMatrix fail.">FMatrixError</a>, <span class="stringliteral">"No implementation of determinantMatrix "</span>
<a name="l00787"></a>00787                    &lt;&lt; <span class="stringliteral">"for FieldMatrix&lt;"</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">","</span> &lt;&lt; m &lt;&lt; <span class="stringliteral">"&gt; !"</span>);
<a name="l00788"></a>00788 
<a name="l00789"></a>00789     }
<a name="l00790"></a>00790 
<a name="l00791"></a>00791 
<a name="l00794"></a>00794   <span class="keyword">template</span>&lt;<span class="keyword">class</span> K&gt;
<a name="l00795"></a><a class="code" href="a00050.html">00795</a>   <span class="keyword">class </span><a class="code" href="a00049.html" title="A dense n x m matrix.">FieldMatrix</a>&lt;K,1,1&gt;
<a name="l00796"></a>00796   {
<a name="l00797"></a>00797   <span class="keyword">public</span>:
<a name="l00798"></a>00798         <span class="comment">// standard constructor and everything is sufficient ...</span>
<a name="l00799"></a>00799 
<a name="l00800"></a>00800         <span class="comment">//===== type definitions and constants</span>
<a name="l00801"></a>00801 
<a name="l00803"></a><a class="code" href="a00050.html#697403c593f336ab4052dfcd1bcf56ca">00803</a>         <span class="keyword">typedef</span> K <a class="code" href="a00049.html#e44d02894ed68d20d10511802daaa852" title="export the type representing the field">field_type</a>;
<a name="l00804"></a>00804 
<a name="l00806"></a><a class="code" href="a00050.html#465d9d35eecc0b8232268a069c9748e8">00806</a>         <span class="keyword">typedef</span> K <a class="code" href="a00049.html#397dc3a4ce3c2b1d0edaa06ff7cd68eb" title="export the type representing the components">block_type</a>;
<a name="l00807"></a>00807 
<a name="l00809"></a><a class="code" href="a00050.html#05d2ebda121776eb635a2d94a4194bbb">00809</a>     <span class="keyword">typedef</span> std::size_t <a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a>;
<a name="l00810"></a>00810     
<a name="l00812"></a>00812         <span class="keyword">enum</span> {
<a name="l00815"></a><a class="code" href="a00050.html#733d24ccaee63f151986102e10ad643bd49c307ae3bee284f3e6c74fb2d3df52">00815</a>           <a class="code" href="a00049.html#c7472b000c727d23d3d6734ae5bfd1a9f4584b51c048d0d20ba5bfb75855d114" title="The number of block levels we contain. This is 1.">blocklevel</a> = 1
<a name="l00816"></a>00816         };
<a name="l00817"></a>00817 
<a name="l00819"></a><a class="code" href="a00050.html#91760c0af851af9077f69db20c70f209">00819</a>         <span class="keyword">typedef</span> <a class="code" href="a00051.html" title="Construct a vector space out of a tensor product of fields.">FieldVector&lt;K,1&gt;</a> <a class="code" href="a00052.html">row_type</a>; 
<a name="l00820"></a>00820 
<a name="l00822"></a>00822         <span class="keyword">enum</span> {
<a name="l00825"></a><a class="code" href="a00050.html#6ec726fe19a6ce5f8f21e4ecd66a9999daea0eab30411401d755a4c3b5e8c4c2">00825</a>           <a class="code" href="a00049.html#a6f7c6e923c8c1fb7879d934b60038fe540968b6fbabc35bc23f2034d0b3c717" title="The number of rows.">rows</a> = 1,
<a name="l00826"></a>00826       n = 1,
<a name="l00829"></a><a class="code" href="a00050.html#6ec726fe19a6ce5f8f21e4ecd66a9999338b913cd8a2860534a4f643107b785f">00829</a>           <a class="code" href="a00049.html#a6f7c6e923c8c1fb7879d934b60038fe37549d479e9082ffb6bb67c17f39cc53" title="The number of columns.">cols</a> = 1,
<a name="l00830"></a>00830       m = 1
<a name="l00831"></a>00831         };
<a name="l00832"></a>00832 
<a name="l00833"></a>00833         <span class="comment">//===== constructors</span>
<a name="l00836"></a><a class="code" href="a00050.html#30d61115bb24f74a44aa841f38d73fb2">00836</a> <span class="comment"></span>        <a class="code" href="a00049.html#6bd9d90d8b75d368630a7ea8da41cd82" title="Default constructor.">FieldMatrix</a> () {}
<a name="l00837"></a>00837 
<a name="l00840"></a><a class="code" href="a00050.html#02656d4706191bc5737b2d576487bd5f">00840</a>         <a class="code" href="a00049.html#6bd9d90d8b75d368630a7ea8da41cd82" title="Default constructor.">FieldMatrix</a> (<span class="keyword">const</span> K&amp; k)
<a name="l00841"></a>00841         {
<a name="l00842"></a>00842             a = k;
<a name="l00843"></a>00843         }
<a name="l00844"></a>00844 
<a name="l00845"></a>00845         <span class="comment">//===== random access interface to rows of the matrix</span>
<a name="l00846"></a>00846 
<a name="l00848"></a><a class="code" href="a00050.html#9f4a0a46ee6d16d5b514e190ef81f286">00848</a>         <a class="code" href="a00052.html">row_type</a>&amp; <a class="code" href="a00049.html#51a72ac893f34ef9cd102330928e775d" title="random access to the rows">operator[] </a>(<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> i)
<a name="l00849"></a>00849         {
<a name="l00850"></a>00850 <span class="preprocessor">#ifdef DUNE_FMatrix_WITH_CHECKING</span>
<a name="l00851"></a>00851 <span class="preprocessor"></span>          <span class="keywordflow">if</span> (i&lt;0 || i&gt;=n) <a class="code" href="a00149.html#d7fce127d6eaabe773adbc409514f21e">DUNE_THROW</a>(<a class="code" href="a00056.html" title="Error thrown if operations of a FieldMatrix fail.">FMatrixError</a>,<span class="stringliteral">"index out of range"</span>);
<a name="l00852"></a>00852 <span class="preprocessor">#endif</span>
<a name="l00853"></a>00853 <span class="preprocessor"></span>          <span class="keywordflow">return</span> a;
<a name="l00854"></a>00854         }
<a name="l00855"></a>00855 
<a name="l00857"></a><a class="code" href="a00050.html#83140ed37a5299fb21600fcd12eecfff">00857</a>         <span class="keyword">const</span> <a class="code" href="a00052.html">row_type</a>&amp; <a class="code" href="a00049.html#51a72ac893f34ef9cd102330928e775d" title="random access to the rows">operator[] </a>(<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> i)<span class="keyword"> const</span>
<a name="l00858"></a>00858 <span class="keyword">        </span>{
<a name="l00859"></a>00859 <span class="preprocessor">#ifdef DUNE_FMatrix_WITH_CHECKING</span>
<a name="l00860"></a>00860 <span class="preprocessor"></span>          <span class="keywordflow">if</span> (i&lt;0 || i&gt;=n) <a class="code" href="a00149.html#d7fce127d6eaabe773adbc409514f21e">DUNE_THROW</a>(<a class="code" href="a00056.html" title="Error thrown if operations of a FieldMatrix fail.">FMatrixError</a>,<span class="stringliteral">"index out of range"</span>);
<a name="l00861"></a>00861 <span class="preprocessor">#endif</span>
<a name="l00862"></a>00862 <span class="preprocessor"></span>          <span class="keywordflow">return</span> a;
<a name="l00863"></a>00863         }
<a name="l00864"></a>00864 
<a name="l00865"></a>00865         <span class="comment">//===== iterator interface to rows of the matrix</span>
<a name="l00867"></a><a class="code" href="a00050.html#8c8e2153aac51f962b8dbe1e55c3c313">00867</a> <span class="comment"></span>    <span class="keyword">typedef</span> <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">FieldIterator&lt;FieldMatrix&lt;K,n,m&gt;</a>,<a class="code" href="a00052.html">row_type</a>&gt; <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">Iterator</a>;
<a name="l00869"></a><a class="code" href="a00050.html#7c3e5b52e2074d2ce0f92f788b6ea993">00869</a>     <span class="keyword">typedef</span> <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">Iterator</a> <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">iterator</a>;
<a name="l00871"></a><a class="code" href="a00050.html#bf065ba2af584547320079b4bc22fef8">00871</a>         <span class="keyword">typedef</span> <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">Iterator</a> <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">RowIterator</a>;
<a name="l00873"></a><a class="code" href="a00050.html#ced2b6fa9bb0efa0730182f7eaa2331a">00873</a>         <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">row_type::Iterator</a> <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">ColIterator</a>;
<a name="l00874"></a>00874 
<a name="l00876"></a><a class="code" href="a00050.html#e12f63623009a9d5790dac5719bced73">00876</a>         <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">Iterator</a> <a class="code" href="a00049.html#5481d3cfaa65a5f58b0d00db72adb7a7" title="begin iterator">begin</a> ()
<a name="l00877"></a>00877         {
<a name="l00878"></a>00878           <span class="keywordflow">return</span> <a class="code" href="a00049.html#285402785c6ecaaff417e920348e62cb" title="Iterator class for sequential access.">Iterator</a>(*<span class="keyword">this</span>,0);
<a name="l00879"></a>00879         }
<a name="l00880"></a>00880           
<a name="l00882"></a><a class="code" href="a00050.html#b9aad23cba606d0b76f9d75027b882cb">00882</a>         <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">Iterator</a> <a class="code" href="a00049.html#5c448d47b189ba94c2aeb59da37ee983" title="end iterator">end</a> ()
<a name="l00883"></a>00883         {
<a name="l00884"></a>00884           <span class="keywordflow">return</span> <a class="code" href="a00049.html#285402785c6ecaaff417e920348e62cb" title="Iterator class for sequential access.">Iterator</a>(*<span class="keyword">this</span>,n);
<a name="l00885"></a>00885         }
<a name="l00886"></a>00886 
<a name="l00888"></a><a class="code" href="a00050.html#a30438112d4a3df408a66c117543616f">00888</a>         <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">Iterator</a> <a class="code" href="a00049.html#f63a2c138a786abc3e968fc015b5b101" title="begin iterator">rbegin</a> ()
<a name="l00889"></a>00889         {
<a name="l00890"></a>00890           <span class="keywordflow">return</span> <a class="code" href="a00049.html#285402785c6ecaaff417e920348e62cb" title="Iterator class for sequential access.">Iterator</a>(*<span class="keyword">this</span>,n-1);
<a name="l00891"></a>00891         }
<a name="l00892"></a>00892           
<a name="l00894"></a><a class="code" href="a00050.html#855629c399268dd63e6b3cba4b25ed06">00894</a>         <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">Iterator</a> <a class="code" href="a00049.html#a503e0add6207004b3f37c79ba6d5e8a" title="end iterator">rend</a> ()
<a name="l00895"></a>00895         {
<a name="l00896"></a>00896           <span class="keywordflow">return</span> <a class="code" href="a00049.html#285402785c6ecaaff417e920348e62cb" title="Iterator class for sequential access.">Iterator</a>(*<span class="keyword">this</span>,-1);
<a name="l00897"></a>00897         }
<a name="l00898"></a>00898 
<a name="l00900"></a><a class="code" href="a00050.html#1dcb05c2958132d83275ced6ac578ee5">00900</a>     <span class="keyword">typedef</span> <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">FieldIterator&lt;const FieldMatrix&lt;K,n,m&gt;</a>,<span class="keyword">const</span> <a class="code" href="a00052.html">row_type</a>&gt; <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">ConstIterator</a>;
<a name="l00902"></a><a class="code" href="a00050.html#87cbb0bb54ada19b3c77847ab1483e6b">00902</a>     <span class="keyword">typedef</span> <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">ConstIterator</a> <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">const_iterator</a>;
<a name="l00904"></a><a class="code" href="a00050.html#143f3f8f6e8aaa207c4fa49c2313f0cf">00904</a>         <span class="keyword">typedef</span> <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">ConstIterator</a> <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">ConstRowIterator</a>;
<a name="l00906"></a><a class="code" href="a00050.html#9fc269b20ffe62cee0b61afe1bb2ee28">00906</a>         <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">row_type::ConstIterator</a> <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">ConstColIterator</a>;
<a name="l00907"></a>00907 
<a name="l00909"></a><a class="code" href="a00050.html#44e36ff4bc1cbe903acf08feb8bf9946">00909</a>         <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">ConstIterator</a> <a class="code" href="a00049.html#5481d3cfaa65a5f58b0d00db72adb7a7" title="begin iterator">begin</a> ()<span class="keyword"> const</span>
<a name="l00910"></a>00910 <span class="keyword">        </span>{
<a name="l00911"></a>00911           <span class="keywordflow">return</span> <a class="code" href="a00049.html#691f5be0179e3a24622e29ce606da27e" title="Iterator class for sequential access.">ConstIterator</a>(*<span class="keyword">this</span>,0);
<a name="l00912"></a>00912         }
<a name="l00913"></a>00913           
<a name="l00915"></a><a class="code" href="a00050.html#9020c92c829188c286ede48c0efb9f80">00915</a>         <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">ConstIterator</a> <a class="code" href="a00049.html#5c448d47b189ba94c2aeb59da37ee983" title="end iterator">end</a> ()<span class="keyword"> const</span>
<a name="l00916"></a>00916 <span class="keyword">        </span>{
<a name="l00917"></a>00917           <span class="keywordflow">return</span> <a class="code" href="a00049.html#691f5be0179e3a24622e29ce606da27e" title="Iterator class for sequential access.">ConstIterator</a>(*<span class="keyword">this</span>,n);
<a name="l00918"></a>00918         }
<a name="l00919"></a>00919 
<a name="l00921"></a><a class="code" href="a00050.html#a0fe2b1721a97af41076cf0cd9b79fd1">00921</a>         <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">ConstIterator</a> <a class="code" href="a00049.html#f63a2c138a786abc3e968fc015b5b101" title="begin iterator">rbegin</a> ()<span class="keyword"> const</span>
<a name="l00922"></a>00922 <span class="keyword">        </span>{
<a name="l00923"></a>00923           <span class="keywordflow">return</span> <a class="code" href="a00049.html#691f5be0179e3a24622e29ce606da27e" title="Iterator class for sequential access.">ConstIterator</a>(*<span class="keyword">this</span>,n-1);
<a name="l00924"></a>00924         }
<a name="l00925"></a>00925           
<a name="l00927"></a><a class="code" href="a00050.html#e7af793e541cc5f8eb17e5de8ca0ae71">00927</a>         <a class="code" href="a00048.html" title="Iterator class for sequential access to FieldVector and FieldMatrix.">ConstIterator</a> <a class="code" href="a00049.html#a503e0add6207004b3f37c79ba6d5e8a" title="end iterator">rend</a> ()<span class="keyword"> const</span>
<a name="l00928"></a>00928 <span class="keyword">        </span>{
<a name="l00929"></a>00929           <span class="keywordflow">return</span> <a class="code" href="a00049.html#691f5be0179e3a24622e29ce606da27e" title="Iterator class for sequential access.">ConstIterator</a>(*<span class="keyword">this</span>,-1);
<a name="l00930"></a>00930         }
<a name="l00931"></a>00931 
<a name="l00932"></a>00932         <span class="comment">//===== assignment from scalar</span>
<a name="l00933"></a>00933 
<a name="l00934"></a>00934         <a class="code" href="a00049.html" title="A dense n x m matrix.">FieldMatrix</a>&amp; operator= (<span class="keyword">const</span> K&amp; k)
<a name="l00935"></a>00935         {
<a name="l00936"></a>00936           a[0] = k;
<a name="l00937"></a>00937           <span class="keywordflow">return</span> *<span class="keyword">this</span>;   
<a name="l00938"></a>00938         }
<a name="l00939"></a>00939 
<a name="l00940"></a>00940         <span class="comment">//===== vector space arithmetic</span>
<a name="l00941"></a>00941 
<a name="l00943"></a><a class="code" href="a00050.html#96360358ae8af584d094e15fbec9aeb3">00943</a>         <a class="code" href="a00049.html" title="A dense n x m matrix.">FieldMatrix</a>&amp; <a class="code" href="a00049.html#7287c994bac08964d6700b1f209ccf17" title="vector space addition">operator+= </a>(<span class="keyword">const</span> K&amp; y)
<a name="l00944"></a>00944         {
<a name="l00945"></a>00945           a[0] += y;
<a name="l00946"></a>00946           <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00947"></a>00947         }
<a name="l00948"></a>00948 
<a name="l00950"></a><a class="code" href="a00050.html#b4538113f6251e9dabd3f2ad58089127">00950</a>         <a class="code" href="a00049.html" title="A dense n x m matrix.">FieldMatrix</a>&amp; <a class="code" href="a00049.html#f459b420d50b679e5391231ec7f3e8a6" title="vector space subtraction">operator-= </a>(<span class="keyword">const</span> K&amp; y)
<a name="l00951"></a>00951         {
<a name="l00952"></a>00952           a[0] -= y;
<a name="l00953"></a>00953           <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00954"></a>00954         }
<a name="l00955"></a>00955 
<a name="l00957"></a><a class="code" href="a00050.html#9083b0ecfdf703abeac3ae9e2dede998">00957</a>         <a class="code" href="a00049.html" title="A dense n x m matrix.">FieldMatrix</a>&amp; <a class="code" href="a00049.html#9859ccea37cee4b4da555db9bae7937a" title="vector space multiplication with scalar">operator*= </a>(<span class="keyword">const</span> K&amp; k)
<a name="l00958"></a>00958         {
<a name="l00959"></a>00959           a[0] *= k;
<a name="l00960"></a>00960           <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00961"></a>00961         }
<a name="l00962"></a>00962 
<a name="l00964"></a><a class="code" href="a00050.html#1b0237fda9155bc0f6b69356aef9631e">00964</a>         <a class="code" href="a00049.html" title="A dense n x m matrix.">FieldMatrix</a>&amp; <a class="code" href="a00049.html#87f37af6f9daf845934534d3f0c3f1a6" title="vector space division by scalar">operator/= </a>(<span class="keyword">const</span> K&amp; k)
<a name="l00965"></a>00965         {
<a name="l00966"></a>00966           a[0] /= k;
<a name="l00967"></a>00967           <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00968"></a>00968         }
<a name="l00969"></a>00969 
<a name="l00970"></a>00970         <span class="comment">//===== linear maps</span>
<a name="l00971"></a>00971    
<a name="l00973"></a><a class="code" href="a00050.html#504a8a6dd6bfede43ef240ccb76aa400">00973</a>         <span class="keywordtype">void</span> <a class="code" href="a00049.html#a9997d627619a505219311ca3cd250f6" title="y = A x">mv</a> (<span class="keyword">const</span> <a class="code" href="a00051.html" title="Construct a vector space out of a tensor product of fields.">FieldVector&lt;K,1&gt;</a>&amp; x, <a class="code" href="a00051.html" title="Construct a vector space out of a tensor product of fields.">FieldVector&lt;K,1&gt;</a>&amp; y)<span class="keyword"> const</span>
<a name="l00974"></a>00974 <span class="keyword">        </span>{
<a name="l00975"></a>00975           y.<a class="code" href="a00051.html#3bcfe5b7596ba91682d3bcf4eb3bcccd">p</a> = a[0] * x.<a class="code" href="a00051.html#3bcfe5b7596ba91682d3bcf4eb3bcccd">p</a>;
<a name="l00976"></a>00976         }
<a name="l00977"></a>00977 
<a name="l00979"></a><a class="code" href="a00050.html#661803049d4878e3d263f050686fd921">00979</a>         <span class="keywordtype">void</span> <a class="code" href="a00049.html#8ea9030e3d162d81a17032d65c7bd6b4" title="y += A x">umv</a> (<span class="keyword">const</span> <a class="code" href="a00051.html" title="Construct a vector space out of a tensor product of fields.">FieldVector&lt;K,1&gt;</a>&amp; x, <a class="code" href="a00051.html" title="Construct a vector space out of a tensor product of fields.">FieldVector&lt;K,1&gt;</a>&amp; y)<span class="keyword"> const</span>
<a name="l00980"></a>00980 <span class="keyword">        </span>{
<a name="l00981"></a>00981           y.<a class="code" href="a00051.html#3bcfe5b7596ba91682d3bcf4eb3bcccd">p</a> += a[0] * x.<a class="code" href="a00051.html#3bcfe5b7596ba91682d3bcf4eb3bcccd">p</a>;
<a name="l00982"></a>00982         }
<a name="l00983"></a>00983 
<a name="l00985"></a><a class="code" href="a00050.html#ef7314acf125a4f69ba2f90cebb13179">00985</a>         <span class="keywordtype">void</span> <a class="code" href="a00049.html#e4e67e1e97f604bf9b3df4c592f4bcd6" title="y += A^T x">umtv</a> (<span class="keyword">const</span> <a class="code" href="a00051.html" title="Construct a vector space out of a tensor product of fields.">FieldVector&lt;K,1&gt;</a>&amp; x, <a class="code" href="a00051.html" title="Construct a vector space out of a tensor product of fields.">FieldVector&lt;K,1&gt;</a>&amp; y)<span class="keyword"> const</span>
<a name="l00986"></a>00986 <span class="keyword">        </span>{
<a name="l00987"></a>00987           y.<a class="code" href="a00051.html#3bcfe5b7596ba91682d3bcf4eb3bcccd">p</a> += a[0] * x.<a class="code" href="a00051.html#3bcfe5b7596ba91682d3bcf4eb3bcccd">p</a>;
<a name="l00988"></a>00988         }
<a name="l00989"></a>00989 
<a name="l00991"></a><a class="code" href="a00050.html#b698ef911ae02386c59334e292a00b83">00991</a>         <span class="keywordtype">void</span> <a class="code" href="a00049.html#badf8447b192951a0106cd122652362e" title="y += A^H x">umhv</a> (<span class="keyword">const</span> <a class="code" href="a00051.html" title="Construct a vector space out of a tensor product of fields.">FieldVector&lt;K,1&gt;</a>&amp; x, <a class="code" href="a00051.html" title="Construct a vector space out of a tensor product of fields.">FieldVector&lt;K,1&gt;</a>&amp; y)<span class="keyword"> const</span>
<a name="l00992"></a>00992 <span class="keyword">        </span>{
<a name="l00993"></a>00993           y.<a class="code" href="a00051.html#3bcfe5b7596ba91682d3bcf4eb3bcccd">p</a> += fm_ck(a[0]) * x.<a class="code" href="a00051.html#3bcfe5b7596ba91682d3bcf4eb3bcccd">p</a>;
<a name="l00994"></a>00994         }
<a name="l00995"></a>00995 
<a name="l00997"></a><a class="code" href="a00050.html#20e6c09002ffc4bd02c27d47c0b0dc02">00997</a>         <span class="keywordtype">void</span> <a class="code" href="a00049.html#48c472b85ff2a483150858b0198aacb0" title="y -= A x">mmv</a> (<span class="keyword">const</span> <a class="code" href="a00051.html" title="Construct a vector space out of a tensor product of fields.">FieldVector&lt;K,1&gt;</a>&amp; x, <a class="code" href="a00051.html" title="Construct a vector space out of a tensor product of fields.">FieldVector&lt;K,1&gt;</a>&amp; y)<span class="keyword"> const</span>
<a name="l00998"></a>00998 <span class="keyword">        </span>{
<a name="l00999"></a>00999           y.<a class="code" href="a00051.html#3bcfe5b7596ba91682d3bcf4eb3bcccd">p</a> -= a[0] * x.<a class="code" href="a00051.html#3bcfe5b7596ba91682d3bcf4eb3bcccd">p</a>;
<a name="l01000"></a>01000         }
<a name="l01001"></a>01001 
<a name="l01003"></a><a class="code" href="a00050.html#55c3266244ad422afbe9262d08122441">01003</a>         <span class="keywordtype">void</span> <a class="code" href="a00049.html#f39c8b7f29c4906d6609cce344899967" title="y -= A^T x">mmtv</a> (<span class="keyword">const</span> <a class="code" href="a00051.html" title="Construct a vector space out of a tensor product of fields.">FieldVector&lt;K,1&gt;</a>&amp; x, <a class="code" href="a00051.html" title="Construct a vector space out of a tensor product of fields.">FieldVector&lt;K,1&gt;</a>&amp; y)<span class="keyword"> const</span>
<a name="l01004"></a>01004 <span class="keyword">        </span>{
<a name="l01005"></a>01005           y.<a class="code" href="a00051.html#3bcfe5b7596ba91682d3bcf4eb3bcccd">p</a> -= a[0] * x.<a class="code" href="a00051.html#3bcfe5b7596ba91682d3bcf4eb3bcccd">p</a>;
<a name="l01006"></a>01006         }
<a name="l01007"></a>01007 
<a name="l01009"></a><a class="code" href="a00050.html#b1a3ab7e86d0c96f33a01b057ed6441a">01009</a>         <span class="keywordtype">void</span> <a class="code" href="a00049.html#9338e26719ffdcf0fef455990f0dbf26" title="y -= A^H x">mmhv</a> (<span class="keyword">const</span> <a class="code" href="a00051.html" title="Construct a vector space out of a tensor product of fields.">FieldVector&lt;K,1&gt;</a>&amp; x, <a class="code" href="a00051.html" title="Construct a vector space out of a tensor product of fields.">FieldVector&lt;K,1&gt;</a>&amp; y)<span class="keyword"> const</span>
<a name="l01010"></a>01010 <span class="keyword">        </span>{
<a name="l01011"></a>01011           y.<a class="code" href="a00051.html#3bcfe5b7596ba91682d3bcf4eb3bcccd">p</a> -= fm_ck(a[0]) * x.<a class="code" href="a00051.html#3bcfe5b7596ba91682d3bcf4eb3bcccd">p</a>;
<a name="l01012"></a>01012         }
<a name="l01013"></a>01013 
<a name="l01015"></a><a class="code" href="a00050.html#ae661db09847e8196c005978ab3d43fa">01015</a>         <span class="keywordtype">void</span> <a class="code" href="a00049.html#ce3a60b70497473477ba34bf9e687c63" title="y += alpha A x">usmv</a> (<span class="keyword">const</span> K&amp; alpha, <span class="keyword">const</span> <a class="code" href="a00051.html" title="Construct a vector space out of a tensor product of fields.">FieldVector&lt;K,1&gt;</a>&amp; x, <a class="code" href="a00051.html" title="Construct a vector space out of a tensor product of fields.">FieldVector&lt;K,1&gt;</a>&amp; y)<span class="keyword"> const</span>
<a name="l01016"></a>01016 <span class="keyword">        </span>{
<a name="l01017"></a>01017           y.<a class="code" href="a00051.html#3bcfe5b7596ba91682d3bcf4eb3bcccd">p</a> += alpha * a[0] * x.<a class="code" href="a00051.html#3bcfe5b7596ba91682d3bcf4eb3bcccd">p</a>;
<a name="l01018"></a>01018         }
<a name="l01019"></a>01019 
<a name="l01021"></a><a class="code" href="a00050.html#431c81806af19f28e845cc60fa6b3456">01021</a>         <span class="keywordtype">void</span> <a class="code" href="a00049.html#3a0d80d941c3ce751380f6598a02b062" title="y += alpha A^T x">usmtv</a> (<span class="keyword">const</span> K&amp; alpha, <span class="keyword">const</span> <a class="code" href="a00051.html" title="Construct a vector space out of a tensor product of fields.">FieldVector&lt;K,1&gt;</a>&amp; x, <a class="code" href="a00051.html" title="Construct a vector space out of a tensor product of fields.">FieldVector&lt;K,1&gt;</a>&amp; y)<span class="keyword"> const</span>
<a name="l01022"></a>01022 <span class="keyword">        </span>{
<a name="l01023"></a>01023           y.<a class="code" href="a00051.html#3bcfe5b7596ba91682d3bcf4eb3bcccd">p</a> += alpha * a[0] * x.<a class="code" href="a00051.html#3bcfe5b7596ba91682d3bcf4eb3bcccd">p</a>;
<a name="l01024"></a>01024         }
<a name="l01025"></a>01025 
<a name="l01027"></a><a class="code" href="a00050.html#4ba8dc1bbd59839ff226559494ef9444">01027</a>         <span class="keywordtype">void</span> <a class="code" href="a00049.html#bdb4ab12589199718b7fc277c5159dd4" title="y += alpha A^H x">usmhv</a> (<span class="keyword">const</span> K&amp; alpha, <span class="keyword">const</span> <a class="code" href="a00051.html" title="Construct a vector space out of a tensor product of fields.">FieldVector&lt;K,1&gt;</a>&amp; x, <a class="code" href="a00051.html" title="Construct a vector space out of a tensor product of fields.">FieldVector&lt;K,1&gt;</a>&amp; y)<span class="keyword"> const</span>
<a name="l01028"></a>01028 <span class="keyword">        </span>{
<a name="l01029"></a>01029           y.<a class="code" href="a00051.html#3bcfe5b7596ba91682d3bcf4eb3bcccd">p</a> += alpha * fm_ck(a[0]) * x.<a class="code" href="a00051.html#3bcfe5b7596ba91682d3bcf4eb3bcccd">p</a>;
<a name="l01030"></a>01030         }
<a name="l01031"></a>01031 
<a name="l01032"></a>01032         <span class="comment">//===== norms</span>
<a name="l01033"></a>01033 
<a name="l01035"></a><a class="code" href="a00050.html#a8867f6ba3ab616848a06c0d55bbd545">01035</a>     <span class="keywordtype">double</span> <a class="code" href="a00049.html#eb3615e70b2e925a5fff65166afe4d66" title="frobenius norm: sqrt(sum over squared values of entries)">frobenius_norm</a> ()<span class="keyword"> const</span>
<a name="l01036"></a>01036 <span class="keyword">        </span>{
<a name="l01037"></a>01037           <span class="keywordflow">return</span> sqrt(fvmeta_abs2(a[0]));
<a name="l01038"></a>01038         }
<a name="l01039"></a>01039 
<a name="l01041"></a><a class="code" href="a00050.html#66e7d679716c5f13fffbc5626eb50bda">01041</a>     <span class="keywordtype">double</span> <a class="code" href="a00049.html#f96cb7bf71509ecfeec9253f947ec4d4" title="square of frobenius norm, need for block recursion">frobenius_norm2</a> ()<span class="keyword"> const</span>
<a name="l01042"></a>01042 <span class="keyword">        </span>{
<a name="l01043"></a>01043           <span class="keywordflow">return</span> fvmeta_abs2(a[0]);
<a name="l01044"></a>01044         }
<a name="l01045"></a>01045 
<a name="l01047"></a><a class="code" href="a00050.html#ee5d7e25a6f5dd0abfe595d1f7b2b4ad">01047</a>     <span class="keywordtype">double</span> <a class="code" href="a00049.html#6aba1dbce59b3ddcc0868d4c85d8e239" title="infinity norm (row sum norm, how to generalize for blocks?)">infinity_norm</a> ()<span class="keyword"> const</span>
<a name="l01048"></a>01048 <span class="keyword">        </span>{
<a name="l01049"></a>01049             <span class="keywordflow">return</span> std::abs(a[0]);
<a name="l01050"></a>01050         }
<a name="l01051"></a>01051 
<a name="l01053"></a><a class="code" href="a00050.html#6d76f154b10891280e143babe7f9765c">01053</a>         <span class="keywordtype">double</span> <a class="code" href="a00049.html#fd5a8db651a110e03131ce44beac5c44" title="simplified infinity norm (uses Manhattan norm for complex values)">infinity_norm_real</a> ()<span class="keyword"> const</span>
<a name="l01054"></a>01054 <span class="keyword">        </span>{
<a name="l01055"></a>01055           <span class="keywordflow">return</span> fvmeta_abs_real(a[0]);
<a name="l01056"></a>01056         }
<a name="l01057"></a>01057 
<a name="l01058"></a>01058         <span class="comment">//===== solve</span>
<a name="l01059"></a>01059 
<a name="l01061"></a><a class="code" href="a00050.html#65e01ccabfa33698676b6c4e2745d85f">01061</a>         <span class="keywordtype">void</span> <a class="code" href="a00196.html#ge2481be02c7113bdbfe0e0cae8958e16" title="Solve system A x = b.">solve</a> (<a class="code" href="a00051.html" title="Construct a vector space out of a tensor product of fields.">FieldVector&lt;K,1&gt;</a>&amp; x, <span class="keyword">const</span> <a class="code" href="a00051.html" title="Construct a vector space out of a tensor product of fields.">FieldVector&lt;K,1&gt;</a>&amp; b)<span class="keyword"> const</span>
<a name="l01062"></a>01062 <span class="keyword">        </span>{
<a name="l01063"></a>01063 <span class="preprocessor">#ifdef DUNE_FMatrix_WITH_CHECKING</span>
<a name="l01064"></a>01064 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (fvmeta_absreal(a[0][0])&lt;<a class="code" href="a00057.html" title="Precisions for calculations with FieldMatrix and FieldVector.">FMatrixPrecision&lt;&gt;::absolute_limit</a>())
<a name="l01065"></a>01065           <a class="code" href="a00149.html#d7fce127d6eaabe773adbc409514f21e">DUNE_THROW</a>(<a class="code" href="a00056.html" title="Error thrown if operations of a FieldMatrix fail.">FMatrixError</a>,<span class="stringliteral">"matrix is singular"</span>);                  
<a name="l01066"></a>01066 <span class="preprocessor">#endif</span>
<a name="l01067"></a>01067 <span class="preprocessor"></span>          x.<a class="code" href="a00051.html#3bcfe5b7596ba91682d3bcf4eb3bcccd">p</a> = b.<a class="code" href="a00051.html#3bcfe5b7596ba91682d3bcf4eb3bcccd">p</a>/a[0];
<a name="l01068"></a>01068         }
<a name="l01069"></a>01069 
<a name="l01071"></a><a class="code" href="a00050.html#a932b619bc681e9c261e569ea6806bc8">01071</a>         <span class="keywordtype">void</span> <a class="code" href="a00196.html#gc8853f30836b392861a22fe17ff88896" title="Compute inverse.">invert</a> ()
<a name="l01072"></a>01072         {
<a name="l01073"></a>01073 <span class="preprocessor">#ifdef DUNE_FMatrix_WITH_CHECKING</span>
<a name="l01074"></a>01074 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (fvmeta_absreal(a[0][0])&lt;<a class="code" href="a00057.html" title="Precisions for calculations with FieldMatrix and FieldVector.">FMatrixPrecision&lt;&gt;::absolute_limit</a>())
<a name="l01075"></a>01075                 <a class="code" href="a00149.html#d7fce127d6eaabe773adbc409514f21e">DUNE_THROW</a>(<a class="code" href="a00056.html" title="Error thrown if operations of a FieldMatrix fail.">FMatrixError</a>,<span class="stringliteral">"matrix is singular"</span>);            
<a name="l01076"></a>01076 <span class="preprocessor">#endif</span>
<a name="l01077"></a>01077 <span class="preprocessor"></span>          a[0] = 1/a[0];
<a name="l01078"></a>01078         }
<a name="l01079"></a>01079 
<a name="l01081"></a><a class="code" href="a00050.html#9e76b8274849c36efa474819c1c871eb">01081</a>     K <a class="code" href="a00196.html#g57d6ac617a0520301a2b284d02596c95" title="calculates the determinant of this matrix">determinant</a> ()<span class="keyword"> const</span>
<a name="l01082"></a>01082 <span class="keyword">    </span>{
<a name="l01083"></a>01083       <span class="keywordflow">return</span> std::abs(a[0]);
<a name="l01084"></a>01084     }
<a name="l01085"></a>01085 
<a name="l01087"></a><a class="code" href="a00050.html#4019db367dfe46db930373f70c14d7eb">01087</a>         <a class="code" href="a00049.html" title="A dense n x m matrix.">FieldMatrix</a>&amp; <a class="code" href="a00049.html#a3c9dd1a03bcfeec4f303f6b0edb7538" title="Multiplies M from the left to this matrix.">leftmultiply</a> (<span class="keyword">const</span> <a class="code" href="a00049.html" title="A dense n x m matrix.">FieldMatrix</a>&amp; <a class="code" href="a00049.html#a0e0e890e1d0c3e969feb6aee8f59920" title="number of blocks in column direction">M</a>)
<a name="l01088"></a>01088         {
<a name="l01089"></a>01089           a[0] *= M.a[0];
<a name="l01090"></a>01090           <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01091"></a>01091         }
<a name="l01092"></a>01092 
<a name="l01094"></a><a class="code" href="a00050.html#f0f6e04c2c5a401adb0d3350a8f4f6c1">01094</a>         <a class="code" href="a00049.html" title="A dense n x m matrix.">FieldMatrix</a>&amp; <a class="code" href="a00049.html#3447bb52706dd385391f238df4c20a49" title="Multiplies M from the right to this matrix.">rightmultiply</a> (<span class="keyword">const</span> <a class="code" href="a00049.html" title="A dense n x m matrix.">FieldMatrix</a>&amp; <a class="code" href="a00049.html#a0e0e890e1d0c3e969feb6aee8f59920" title="number of blocks in column direction">M</a>)
<a name="l01095"></a>01095         {
<a name="l01096"></a>01096           a[0] *= M.a[0];
<a name="l01097"></a>01097           <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01098"></a>01098         }
<a name="l01099"></a>01099 
<a name="l01100"></a>01100 
<a name="l01101"></a>01101         <span class="comment">//===== sizes</span>
<a name="l01102"></a>01102 
<a name="l01104"></a><a class="code" href="a00050.html#da62aee05657a497002cfa576799836a">01104</a>         <a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> <a class="code" href="a00049.html#941900e6156fe500135851254a120a36" title="number of blocks in row direction">N</a> ()<span class="keyword"> const</span>
<a name="l01105"></a>01105 <span class="keyword">        </span>{
<a name="l01106"></a>01106           <span class="keywordflow">return</span> 1;
<a name="l01107"></a>01107         }
<a name="l01108"></a>01108 
<a name="l01110"></a><a class="code" href="a00050.html#76de50220c5fd941a47cd4edf1cd845b">01110</a>         <a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> <a class="code" href="a00049.html#a0e0e890e1d0c3e969feb6aee8f59920" title="number of blocks in column direction">M</a> ()<span class="keyword"> const</span>
<a name="l01111"></a>01111 <span class="keyword">        </span>{
<a name="l01112"></a>01112           <span class="keywordflow">return</span> 1;
<a name="l01113"></a>01113         }
<a name="l01114"></a>01114 
<a name="l01116"></a><a class="code" href="a00050.html#26d6d39300b6c1c2ab99de7cbc8ed33d">01116</a>         <a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> <a class="code" href="a00049.html#6bb1547b901c30dc0e879e8a1793fc0c" title="dimension of the destination vector space">rowdim</a> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> r)<span class="keyword"> const</span>
<a name="l01117"></a>01117 <span class="keyword">        </span>{
<a name="l01118"></a>01118           <span class="keywordflow">return</span> 1;
<a name="l01119"></a>01119         }
<a name="l01120"></a>01120 
<a name="l01122"></a><a class="code" href="a00050.html#1df00cf95f30805fd5abae4347efc801">01122</a>         <a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> <a class="code" href="a00049.html#964d86febe4b06f485917811ebc427c4" title="dimension of the source vector space">coldim</a> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> c)<span class="keyword"> const</span>
<a name="l01123"></a>01123 <span class="keyword">        </span>{
<a name="l01124"></a>01124           <span class="keywordflow">return</span> 1;
<a name="l01125"></a>01125         }
<a name="l01126"></a>01126 
<a name="l01128"></a><a class="code" href="a00050.html#ab338dfbfc97c667177b3cc141007c34">01128</a>         <a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> <a class="code" href="a00049.html#6bb1547b901c30dc0e879e8a1793fc0c" title="dimension of the destination vector space">rowdim</a> ()<span class="keyword"> const</span>
<a name="l01129"></a>01129 <span class="keyword">        </span>{
<a name="l01130"></a>01130           <span class="keywordflow">return</span> 1;
<a name="l01131"></a>01131         }
<a name="l01132"></a>01132 
<a name="l01134"></a><a class="code" href="a00050.html#b68631c3bd6edb6fa396830655b678a7">01134</a>         <a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> <a class="code" href="a00049.html#964d86febe4b06f485917811ebc427c4" title="dimension of the source vector space">coldim</a> ()<span class="keyword"> const</span>
<a name="l01135"></a>01135 <span class="keyword">        </span>{
<a name="l01136"></a>01136           <span class="keywordflow">return</span> 1;
<a name="l01137"></a>01137         }
<a name="l01138"></a>01138 
<a name="l01139"></a>01139         <span class="comment">//===== query</span>
<a name="l01140"></a>01140         
<a name="l01142"></a><a class="code" href="a00050.html#2d00a7de137bce66ae5cf14e965aefd2">01142</a>         <span class="keywordtype">bool</span> <a class="code" href="a00049.html#ce8327b8f523b95598f07e1720cd0da4" title="return true when (i,j) is in pattern">exists</a> (<a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> i, <a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a> j)<span class="keyword"> const </span>
<a name="l01143"></a>01143 <span class="keyword">        </span>{
<a name="l01144"></a>01144           <span class="keywordflow">return</span> i==0 &amp;&amp; j==0;
<a name="l01145"></a>01145         }
<a name="l01146"></a>01146 
<a name="l01147"></a>01147         <span class="comment">//===== conversion operator</span>
<a name="l01148"></a>01148 
<a name="l01149"></a>01149         operator K ()<span class="keyword"> const </span>{<span class="keywordflow">return</span> a[0];}
<a name="l01150"></a>01150 
<a name="l01151"></a>01151         <span class="keyword">private</span>:
<a name="l01152"></a>01152         <span class="comment">// the data, just a single row with a single scalar</span>
<a name="l01153"></a>01153     <a class="code" href="a00049.html#f47453a03570ee649a70eacadec9c72b" title="Each row is implemented by a field vector.">row_type</a> a;
<a name="l01154"></a>01154   };
<a name="l01155"></a>01155 
<a name="l01156"></a>01156 <span class="keyword">namespace </span>FMatrixHelp {
<a name="l01157"></a>01157 
<a name="l01158"></a>01158 
<a name="l01160"></a>01160 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> K&gt;
<a name="l01161"></a>01161 <span class="keyword">static</span> <span class="keyword">inline</span> K invertMatrix (<span class="keyword">const</span> FieldMatrix&lt;K,1,1&gt; &amp;matrix, FieldMatrix&lt;K,1,1&gt; &amp;inverse)
<a name="l01162"></a>01162 {
<a name="l01163"></a>01163   inverse[0][0] = 1.0/matrix[0][0];
<a name="l01164"></a>01164   <span class="keywordflow">return</span> matrix[0][0];
<a name="l01165"></a>01165 }
<a name="l01166"></a>01166 
<a name="l01168"></a>01168 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> K&gt;
<a name="l01169"></a>01169 <span class="keyword">static</span> <span class="keyword">inline</span> K invertMatrix_retTransposed (<span class="keyword">const</span> FieldMatrix&lt;K,1,1&gt; &amp;matrix, FieldMatrix&lt;K,1,1&gt; &amp;inverse)
<a name="l01170"></a>01170 {
<a name="l01171"></a>01171   <span class="keywordflow">return</span> invertMatrix(matrix,inverse); 
<a name="l01172"></a>01172 }
<a name="l01173"></a>01173 
<a name="l01174"></a>01174 
<a name="l01176"></a>01176 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> K&gt;
<a name="l01177"></a>01177 <span class="keyword">static</span> <span class="keyword">inline</span> K invertMatrix (<span class="keyword">const</span> FieldMatrix&lt;K,2,2&gt; &amp;matrix, FieldMatrix&lt;K,2,2&gt; &amp;inverse)
<a name="l01178"></a>01178 {
<a name="l01179"></a>01179   <span class="comment">// code generated by maple </span>
<a name="l01180"></a>01180   K det = (matrix[0][0]*matrix[1][1] - matrix[0][1]*matrix[1][0]);
<a name="l01181"></a>01181   K det_1 = 1.0/det;
<a name="l01182"></a>01182   inverse[0][0] =   matrix[1][1] * det_1;
<a name="l01183"></a>01183   inverse[0][1] = - matrix[0][1] * det_1;
<a name="l01184"></a>01184   inverse[1][0] = - matrix[1][0] * det_1;
<a name="l01185"></a>01185   inverse[1][1] =   matrix[0][0] * det_1;
<a name="l01186"></a>01186   <span class="keywordflow">return</span> det;
<a name="l01187"></a>01187 }
<a name="l01188"></a>01188 
<a name="l01191"></a>01191 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> K&gt;
<a name="l01192"></a>01192 <span class="keyword">static</span> <span class="keyword">inline</span> K invertMatrix_retTransposed (<span class="keyword">const</span> FieldMatrix&lt;K,2,2&gt; &amp;matrix, FieldMatrix&lt;K,2,2&gt; &amp;inverse)
<a name="l01193"></a>01193 {
<a name="l01194"></a>01194   <span class="comment">// code generated by maple </span>
<a name="l01195"></a>01195   K det = (matrix[0][0]*matrix[1][1] - matrix[0][1]*matrix[1][0]);
<a name="l01196"></a>01196   K det_1 = 1.0/det;
<a name="l01197"></a>01197   inverse[0][0] =   matrix[1][1] * det_1;
<a name="l01198"></a>01198   inverse[1][0] = - matrix[0][1] * det_1;
<a name="l01199"></a>01199   inverse[0][1] = - matrix[1][0] * det_1;
<a name="l01200"></a>01200   inverse[1][1] =   matrix[0][0] * det_1;
<a name="l01201"></a>01201   <span class="keywordflow">return</span> det;
<a name="l01202"></a>01202 }
<a name="l01203"></a>01203 
<a name="l01205"></a>01205 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> K&gt;
<a name="l01206"></a>01206 <span class="keyword">static</span> <span class="keyword">inline</span> K invertMatrix (<span class="keyword">const</span> FieldMatrix&lt;K,3,3&gt; &amp;matrix, FieldMatrix&lt;K,3,3&gt; &amp;inverse)
<a name="l01207"></a>01207 {
<a name="l01208"></a>01208   <span class="comment">// code generated by maple </span>
<a name="l01209"></a>01209   K t4  = matrix[0][0] * matrix[1][1];
<a name="l01210"></a>01210   K t6  = matrix[0][0] * matrix[1][2];
<a name="l01211"></a>01211   K t8  = matrix[0][1] * matrix[1][0];
<a name="l01212"></a>01212   K t10 = matrix[0][2] * matrix[1][0];
<a name="l01213"></a>01213   K t12 = matrix[0][1] * matrix[2][0];
<a name="l01214"></a>01214   K t14 = matrix[0][2] * matrix[2][0];
<a name="l01215"></a>01215 
<a name="l01216"></a>01216   K det = (t4*matrix[2][2]-t6*matrix[2][1]-t8*matrix[2][2]+
<a name="l01217"></a>01217            t10*matrix[2][1]+t12*matrix[1][2]-t14*matrix[1][1]);
<a name="l01218"></a>01218   K t17 = 1.0/det;
<a name="l01219"></a>01219 
<a name="l01220"></a>01220   inverse[0][0] =  (matrix[1][1] * matrix[2][2] - matrix[1][2] * matrix[2][1])*t17;
<a name="l01221"></a>01221   inverse[0][1] = -(matrix[0][1] * matrix[2][2] - matrix[0][2] * matrix[2][1])*t17;
<a name="l01222"></a>01222   inverse[0][2] =  (matrix[0][1] * matrix[1][2] - matrix[0][2] * matrix[1][1])*t17;
<a name="l01223"></a>01223   inverse[1][0] = -(matrix[1][0] * matrix[2][2] - matrix[1][2] * matrix[2][0])*t17;
<a name="l01224"></a>01224   inverse[1][1] =  (matrix[0][0] * matrix[2][2] - t14) * t17;
<a name="l01225"></a>01225   inverse[1][2] = -(t6-t10) * t17;
<a name="l01226"></a>01226   inverse[2][0] =  (matrix[1][0] * matrix[2][1] - matrix[1][1] * matrix[2][0]) * t17;
<a name="l01227"></a>01227   inverse[2][1] = -(matrix[0][0] * matrix[2][1] - t12) * t17;
<a name="l01228"></a>01228   inverse[2][2] =  (t4-t8) * t17;
<a name="l01229"></a>01229 
<a name="l01230"></a>01230   <span class="keywordflow">return</span> det;
<a name="l01231"></a>01231 }
<a name="l01232"></a>01232 
<a name="l01234"></a>01234 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> K&gt;
<a name="l01235"></a>01235 <span class="keyword">static</span> <span class="keyword">inline</span> K invertMatrix_retTransposed (<span class="keyword">const</span> FieldMatrix&lt;K,3,3&gt; &amp;matrix, FieldMatrix&lt;K,3,3&gt; &amp;inverse)
<a name="l01236"></a>01236 {
<a name="l01237"></a>01237   <span class="comment">// code generated by maple </span>
<a name="l01238"></a>01238   K t4  = matrix[0][0] * matrix[1][1];
<a name="l01239"></a>01239   K t6  = matrix[0][0] * matrix[1][2];
<a name="l01240"></a>01240   K t8  = matrix[0][1] * matrix[1][0];
<a name="l01241"></a>01241   K t10 = matrix[0][2] * matrix[1][0];
<a name="l01242"></a>01242   K t12 = matrix[0][1] * matrix[2][0];
<a name="l01243"></a>01243   K t14 = matrix[0][2] * matrix[2][0];
<a name="l01244"></a>01244 
<a name="l01245"></a>01245   K det = (t4*matrix[2][2]-t6*matrix[2][1]-t8*matrix[2][2]+
<a name="l01246"></a>01246            t10*matrix[2][1]+t12*matrix[1][2]-t14*matrix[1][1]);
<a name="l01247"></a>01247   K t17 = 1.0/det;
<a name="l01248"></a>01248 
<a name="l01249"></a>01249   inverse[0][0] =  (matrix[1][1] * matrix[2][2] - matrix[1][2] * matrix[2][1])*t17;
<a name="l01250"></a>01250   inverse[1][0] = -(matrix[0][1] * matrix[2][2] - matrix[0][2] * matrix[2][1])*t17;
<a name="l01251"></a>01251   inverse[2][0] =  (matrix[0][1] * matrix[1][2] - matrix[0][2] * matrix[1][1])*t17;
<a name="l01252"></a>01252   inverse[0][1] = -(matrix[1][0] * matrix[2][2] - matrix[1][2] * matrix[2][0])*t17;
<a name="l01253"></a>01253   inverse[1][1] =  (matrix[0][0] * matrix[2][2] - t14) * t17;
<a name="l01254"></a>01254   inverse[2][1] = -(t6-t10) * t17;
<a name="l01255"></a>01255   inverse[0][2] =  (matrix[1][0] * matrix[2][1] - matrix[1][1] * matrix[2][0]) * t17;
<a name="l01256"></a>01256   inverse[1][2] = -(matrix[0][0] * matrix[2][1] - t12) * t17;
<a name="l01257"></a>01257   inverse[2][2] =  (t4-t8) * t17;
<a name="l01258"></a>01258 
<a name="l01259"></a>01259   <span class="keywordflow">return</span> det;
<a name="l01260"></a>01260 }
<a name="l01261"></a>01261 
<a name="l01263"></a>01263 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keywordtype">int</span> rows,<span class="keywordtype">int</span> cols&gt;
<a name="l01264"></a>01264 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> multTransposedMatrix(<span class="keyword">const</span> FieldMatrix&lt;K,rows,cols&gt; &amp;matrix, FieldMatrix&lt;K,cols,cols&gt;&amp; ret)
<a name="l01265"></a>01265 {
<a name="l01266"></a>01266   <span class="keyword">typedef</span> <span class="keyword">typename</span> FieldMatrix&lt;K,rows,cols&gt;::size_type <a class="code" href="a00049.html#81a1d214bb46ed20667d3d4542223488" title="The type used for the index access and size operations.">size_type</a>;
<a name="l01267"></a>01267   
<a name="l01268"></a>01268   <span class="keywordflow">for</span>(size_type i=0; i&lt;<a class="code" href="a00049.html#a6f7c6e923c8c1fb7879d934b60038fe37549d479e9082ffb6bb67c17f39cc53" title="The number of columns.">cols</a>; i++)
<a name="l01269"></a>01269     <span class="keywordflow">for</span>(size_type j=0; j&lt;cols; j++)
<a name="l01270"></a>01270       { ret[i][j]=0.0;
<a name="l01271"></a>01271         <span class="keywordflow">for</span>(size_type k=0; k&lt;<a class="code" href="a00049.html#a6f7c6e923c8c1fb7879d934b60038fe540968b6fbabc35bc23f2034d0b3c717" title="The number of rows.">rows</a>; k++)
<a name="l01272"></a>01272           ret[i][j]+=matrix[k][i]*matrix[k][j];
<a name="l01273"></a>01273       }
<a name="l01274"></a>01274 }
<a name="l01275"></a>01275 
<a name="l01277"></a>01277 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keywordtype">int</span> dim&gt;
<a name="l01278"></a>01278 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> multAssign(<span class="keyword">const</span> FieldMatrix&lt;K,dim,dim&gt; &amp;matrix, <span class="keyword">const</span> FieldVector&lt;K,dim&gt; &amp; x, FieldVector&lt;K,dim&gt; &amp; ret) 
<a name="l01279"></a>01279 {
<a name="l01280"></a>01280   <span class="keyword">typedef</span> <span class="keyword">typename</span> FieldMatrix&lt;K,dim,dim&gt;::size_type size_type;
<a name="l01281"></a>01281   
<a name="l01282"></a>01282   <span class="keywordflow">for</span>(size_type i=0; i&lt;dim; i++)
<a name="l01283"></a>01283   {
<a name="l01284"></a>01284     ret[i] = 0.0;
<a name="l01285"></a>01285     <span class="keywordflow">for</span>(size_type j=0; j&lt;dim; j++)
<a name="l01286"></a>01286     {
<a name="l01287"></a>01287       ret[i] += matrix[i][j]*x[j];
<a name="l01288"></a>01288     }
<a name="l01289"></a>01289   }
<a name="l01290"></a>01290 }
<a name="l01291"></a>01291 
<a name="l01293"></a>01293 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keywordtype">int</span> rows,<span class="keywordtype">int</span> cols&gt;
<a name="l01294"></a>01294 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> multAssign(<span class="keyword">const</span> FieldMatrix&lt;K,rows,cols&gt; &amp;matrix, <span class="keyword">const</span> FieldVector&lt;K,cols&gt; &amp; x, FieldVector&lt;K,rows&gt; &amp; ret) 
<a name="l01295"></a>01295 {
<a name="l01296"></a>01296   <span class="keyword">typedef</span> <span class="keyword">typename</span> FieldMatrix&lt;K,rows,cols&gt;::size_type size_type;
<a name="l01297"></a>01297   
<a name="l01298"></a>01298   <span class="keywordflow">for</span>(size_type i=0; i&lt;<a class="code" href="a00049.html#a6f7c6e923c8c1fb7879d934b60038fe540968b6fbabc35bc23f2034d0b3c717" title="The number of rows.">rows</a>; i++)
<a name="l01299"></a>01299   {
<a name="l01300"></a>01300     ret[i] = 0.0;
<a name="l01301"></a>01301     <span class="keywordflow">for</span>(size_type j=0; j&lt;cols; j++)
<a name="l01302"></a>01302     {
<a name="l01303"></a>01303       ret[i] += matrix[i][j]*x[j];
<a name="l01304"></a>01304     }
<a name="l01305"></a>01305   }
<a name="l01306"></a>01306 }
<a name="l01307"></a>01307 
<a name="l01309"></a>01309 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keywordtype">int</span> dim&gt;
<a name="l01310"></a>01310 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> multAssignTransposed( <span class="keyword">const</span> FieldMatrix&lt;K,dim,dim&gt; &amp;matrix, <span class="keyword">const</span> FieldVector&lt;K,dim&gt; &amp; x, FieldVector&lt;K,dim&gt; &amp; ret) 
<a name="l01311"></a>01311 {
<a name="l01312"></a>01312   <span class="keyword">typedef</span> <span class="keyword">typename</span> FieldMatrix&lt;K,dim,dim&gt;::size_type size_type;
<a name="l01313"></a>01313   
<a name="l01314"></a>01314   <span class="keywordflow">for</span>(size_type i=0; i&lt;dim; i++)
<a name="l01315"></a>01315   {
<a name="l01316"></a>01316     ret[i] = 0.0;
<a name="l01317"></a>01317     <span class="keywordflow">for</span>(size_type j=0; j&lt;dim; j++)
<a name="l01318"></a>01318     {
<a name="l01319"></a>01319       ret[i] += matrix[j][i]*x[j];
<a name="l01320"></a>01320     }
<a name="l01321"></a>01321   }
<a name="l01322"></a>01322 }
<a name="l01323"></a>01323 
<a name="l01325"></a>01325 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keywordtype">int</span> dim&gt;
<a name="l01326"></a>01326 <span class="keyword">static</span> <span class="keyword">inline</span> FieldVector&lt;K,dim&gt; mult(<span class="keyword">const</span> FieldMatrix&lt;K,dim,dim&gt; &amp;matrix, <span class="keyword">const</span> FieldVector&lt;K,dim&gt; &amp; x) 
<a name="l01327"></a>01327 {
<a name="l01328"></a>01328   FieldVector&lt;K,dim&gt; ret;
<a name="l01329"></a>01329   multAssign(matrix,x,ret);
<a name="l01330"></a>01330   <span class="keywordflow">return</span> ret; 
<a name="l01331"></a>01331 }
<a name="l01332"></a>01332 
<a name="l01333"></a>01333 
<a name="l01334"></a>01334 
<a name="l01336"></a>01336 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keywordtype">int</span> rows, <span class="keywordtype">int</span> cols&gt;
<a name="l01337"></a>01337 <span class="keyword">static</span> <span class="keyword">inline</span> FieldVector&lt;K,cols&gt; multTransposed(<span class="keyword">const</span> FieldMatrix&lt;K,rows,cols&gt; &amp;matrix, <span class="keyword">const</span> FieldVector&lt;K,rows&gt; &amp; x) 
<a name="l01338"></a>01338 {
<a name="l01339"></a>01339   FieldVector&lt;K,cols&gt; ret;
<a name="l01340"></a>01340   <span class="keyword">typedef</span> <span class="keyword">typename</span> FieldMatrix&lt;K,rows,cols&gt;::size_type size_type;
<a name="l01341"></a>01341   <span class="keywordflow">for</span>(size_type i=0; i&lt;cols; i++)
<a name="l01342"></a>01342   {
<a name="l01343"></a>01343     ret[i] = 0.0;
<a name="l01344"></a>01344     <span class="keywordflow">for</span>(size_type j=0; j&lt;rows; j++)
<a name="l01345"></a>01345     {
<a name="l01346"></a>01346       ret[i] += matrix[j][i]*x[j];
<a name="l01347"></a>01347     }
<a name="l01348"></a>01348   }
<a name="l01349"></a>01349   <span class="keywordflow">return</span> ret; 
<a name="l01350"></a>01350 }
<a name="l01351"></a>01351 
<a name="l01352"></a>01352 } <span class="comment">// end namespace FMatrixHelp </span>
<a name="l01353"></a>01353 
<a name="l01354"></a>01354 <span class="preprocessor">#ifdef DUNE_EXPRESSIONTEMPLATES</span>
<a name="l01355"></a>01355 <span class="preprocessor"></span><span class="keyword">template</span> &lt;<span class="keyword">class</span> K, <span class="keywordtype">int</span> N, <span class="keywordtype">int</span> M&gt;
<a name="l01356"></a>01356 <span class="keyword">struct </span>BlockType&lt; <a class="code" href="a00049.html#6bd9d90d8b75d368630a7ea8da41cd82" title="Default constructor.">FieldMatrix</a>&lt;K,<a class="code" href="a00049.html#941900e6156fe500135851254a120a36" title="number of blocks in row direction">N</a>,<a class="code" href="a00049.html#a0e0e890e1d0c3e969feb6aee8f59920" title="number of blocks in column direction">M</a>&gt; &gt;
<a name="l01357"></a>01357 {
<a name="l01358"></a>01358   <span class="keyword">typedef</span> K type;
<a name="l01359"></a>01359 };
<a name="l01360"></a>01360 
<a name="l01361"></a>01361 <span class="keyword">template</span> &lt;<span class="keyword">class</span> K, <span class="keywordtype">int</span> N, <span class="keywordtype">int</span> M&gt;
<a name="l01362"></a>01362 <span class="keyword">struct </span>FieldType&lt; <a class="code" href="a00049.html#6bd9d90d8b75d368630a7ea8da41cd82" title="Default constructor.">FieldMatrix</a>&lt;K,<a class="code" href="a00049.html#941900e6156fe500135851254a120a36" title="number of blocks in row direction">N</a>,<a class="code" href="a00049.html#a0e0e890e1d0c3e969feb6aee8f59920" title="number of blocks in column direction">M</a>&gt; &gt;
<a name="l01363"></a>01363 {
<a name="l01364"></a>01364   <span class="keyword">typedef</span> K type;
<a name="l01365"></a>01365 };
<a name="l01366"></a>01366 <span class="preprocessor">#endif // DUNE_EXPRESSIONTEMPLATES</span>
<a name="l01367"></a>01367 <span class="preprocessor"></span>
<a name="l01370"></a>01370 } <span class="comment">// end namespace</span>
<a name="l01371"></a>01371 
<a name="l01372"></a>01372 <span class="preprocessor">#endif</span>
</pre></div></div>
</div> <!-- end doxygen -->
</div> <!-- end main -->
<div class="foot">

<p class="foot">
  Generated on 6 Nov 2008 with <a
  href="http://www.doxygen.org/">Doxygen</a> (ver 1.5.6)  
  [<a href="doxygen.log">logfile</a>].
</p>

</div>

</body>
</html>
